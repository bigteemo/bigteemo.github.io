<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[124. Binary Tree Maximum Path Sum]]></title>
    <url>%2F2017%2F11%2F24%2F124-Binary-Tree-Maximum-Path-Sum%2F</url>
    <content type="text"><![CDATA[Given a binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. For example:Given the below binary tree,123 1 / \2 3 Return 6. 解法1： Divide &amp; Conquer O(N)对于一个node有左右两边的path,经过这一点的path可以有的情况是,往左，往右，自己，或者从左往右。如果以left或者right为顶点的maxPath为负数的话，那么包含当前点的maxPath一定不用包含负数的left或者right 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; int res = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) &#123; if (root == null) return 0; helper(root); return res; &#125; private int helper(TreeNode root) &#123; if (root == null) return 0; int left = Math.max(0, helper(root.left)); int right = Math.max(0, helper(root.right)); res = Math.max(res, left + right + root.val); return Math.max(left, right) + root.val; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[99. Recover Binary Search Tree]]></title>
    <url>%2F2017%2F11%2F23%2F99-Recover-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Note:A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? 解法1： In-order Traversal O(N)BST的很重要的性质就是对他进行in order traversal的话，得到的是一个有序数组。那么可以按照in order traversal,找到第一个node使得node.val &gt;= node.successor.val和最后一个node使得node.predecessor.val &gt;= node.val就可以了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; TreeNode first = null; TreeNode second = null; TreeNode prev = null; public void recoverTree(TreeNode root) &#123; if (root == null) return; inOrder(root); if (first == null || second == null) return; int temp = first.val; first.val = second.val; second.val = temp; return; &#125; private void inOrder(TreeNode root) &#123; if (root == null) return; inOrder(root.left); if (prev != null &amp;&amp; prev.val &gt;= root.val) &#123; if (first == null) &#123; first = prev; &#125; if (first != null) &#123; second = root; &#125; &#125; prev = root; inOrder(root.right); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[97. Interleaving String]]></title>
    <url>%2F2017%2F11%2F23%2F97-Interleaving-String%2F</url>
    <content type="text"><![CDATA[Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. For example,Given:s1 = “aabcc”,s2 = “dbbca”, When s3 = “aadbbcbcac”, return true.When s3 = “aadbbbaccc”, return false. 解法1： DP O(len_s1 * len_s2) Time and space拿到题目似乎就是用dp来做，其他没有比较好的办法可以套。那么就从小问题开始。如果一个string是空，那么s3必须和另一个string相等。如果用dp[i][j] 表示的是前i个字符和前j个字符组成的string可以是前(i+j)的interleave，那么就可以知道i+j上的字符一定要么等于s1的第i个字符或者是s2的第j个字符。同时，如果这个条件满足，则就考虑dp[i -1][j]或者dp[i][j - 1]是否为真就可以了。 123456789101112131415161718192021222324252627282930313233class Solution &#123; public boolean isInterleave(String s1, String s2, String s3) &#123; int len1 = s1.length(); int len2 = s2.length(); if (s3.length() != s1.length() + s2.length()) return false; boolean[][] dp = new boolean[len1 + 1][len2 + 1]; dp[0][0] = true; for (int col = 1; col &lt;= len2; col++) &#123; dp[0][col] = s2.substring(0, col).equals(s3.substring(0, col)); &#125; for (int row = 1; row &lt;= len1; row++) &#123; dp[row][0] = s1.substring(0, row).equals(s3.substring(0,row)); &#125; for (int i = 1; i &lt;= len1; i++) &#123; for (int j = 1; j &lt;= len2; j++) &#123; int len = i + j; if (s3.charAt(len - 1) == s1.charAt(i - 1) &amp;&amp; dp[i - 1][j]) &#123; dp[i][j] = true; &#125; if (s3.charAt(len - 1) == s2.charAt(j - 1) &amp;&amp; dp[i][j - 1]) &#123; dp[i][j] = true; &#125; &#125; &#125; return dp[len1][len2]; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[87. Scramble String]]></title>
    <url>%2F2017%2F11%2F23%2F87-Scramble-String%2F</url>
    <content type="text"><![CDATA[Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. Below is one possible representation of s1 = “great”:1234567 great / \ gr eat / \ / \g r e at / \ a t To scramble the string, we may choose any non-leaf node and swap its two children. For example, if we choose the node “gr” and swap its two children, it produces a scrambled string “rgeat”.1234567 rgeat / \ rg eat / \ / \r g e at / \ a t We say that “rgeat” is a scrambled string of “great”. Similarly, if we continue to swap the children of nodes “eat” and “at”, it produces a scrambled string “rgtae”.1234567 rgtae / \ rg tae / \ / \r g ta e / \ t a We say that “rgtae” is a scrambled string of “great”. Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1. 解法1： 递归 O(2^n)尝试每一个可能的split point，然后查看对于某一个切口i,可能可以分成的４个substring是否是scramble string.时间复杂度是O(2^N) 123456789101112131415161718192021222324252627282930313233class Solution &#123; public boolean isScramble(String s1, String s2) &#123; if (s1.equals(s2)) &#123; return true; &#125; if (s1.length() != s2.length()) &#123; return false; &#125; int[] chars = new int[256]; for (int i = 0; i &lt; s1.length(); i++) &#123; chars[(int)s1.charAt(i)]++; chars[(int)s2.charAt(i)]--; &#125; for (int i = 0; i &lt; 256; i++) &#123; if (chars[i] != 0) return false; &#125; for (int i = 1; i &lt; s1.length(); i++) &#123; if (isScramble(s1.substring(0, i), s2.substring(0, i)) &amp;&amp; isScramble(s1.substring(i), s2.substring(i))) return true; if (isScramble(s1.substring(0, i), s2.substring(s2.length() - i)) &amp;&amp; isScramble(s1.substring(i), s2.substring(0, s2.length() - i))) return true; &#125; return false; &#125;&#125; 解法２: DP参考了[这篇][1]帖子的解法， 可以用dp的思想，dp是一个bottom up的想法。用一个dp[i][j][k]表示两个string分别从i和j开始，长度为k + 1的两个子串是否为scramble string 1234567891011121314151617181920212223242526272829303132public boolean isScramble(String s1, String s2) &#123; int len = s1.length(); if (len != s2.length()) return false; if (s1.equals(s2)) return true; // a table of matches // T[i][j][k] = true iff s2.substring(j,j+k+1) is a scambled string of s1.substring(i,i+k+1) boolean[][][] scrambled = new boolean[len][len][len]; for (int i=0; i &lt; len; ++i) &#123; for (int j=0; j &lt; len; ++j) &#123; scrambled[i][j][0] = (s1.charAt(i) == s2.charAt(j)); &#125; &#125; // dynamically fill up the table for (int k=1; k &lt; len; ++k) &#123; // k: length for (int i=0; i &lt; len - k; ++i) &#123; // i: index in s1 for (int j=0; j &lt; len - k; ++j) &#123; // j: index in s2 scrambled[i][j][k] = false; for (int p=0; p &lt; k; ++p) &#123; // p: split into [0..p] and [p+1..k] if ((scrambled[i][j][p] &amp;&amp; scrambled[i+p+1][j+p+1][k-p-1]) || (scrambled[i][j+k-p][p] &amp;&amp; scrambled[i+p+1][j][k-p-1])) &#123; scrambled[i][j][k] = true; break; &#125; &#125; &#125; &#125; &#125; return scrambled[0][0][len-1]; &#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[52. N-Queens II]]></title>
    <url>%2F2017%2F11%2F23%2F52-N-Queens-II%2F</url>
    <content type="text"><![CDATA[Follow up for N-Queens problem. Now, instead outputting board configurations, return the total number of distinct solutions. 解法1： DFS这题比要print所有的解法的一个可以优化的地方是，只需要不停的每行fill的同时check是否是valid,如果是就继续往下填。在看是否是合法的时候用三个数组或者是set来保存当前fill的状态。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; int count = 0; public int totalNQueens(int n) &#123; Set&lt;Integer&gt; cols = new HashSet&lt;&gt;(); Set&lt;Integer&gt; rightDiag = new HashSet&lt;&gt;(); Set&lt;Integer&gt; leftDiag = new HashSet&lt;&gt;(); solve(0, cols, rightDiag, leftDiag, n); return count; &#125; private void solve(int row, Set&lt;Integer&gt; cols, Set&lt;Integer&gt; rightDiag, Set&lt;Integer&gt; leftDiag, int n) &#123; if (row == n) &#123; count++; return; &#125; /* Fill in each row And check if it is valid */ for (int i = 0; i &lt; n; i++) &#123; if (cols.contains(i)) continue; if (rightDiag.contains(row - i)) continue; if (leftDiag.contains(row + i)) continue; cols.add(i); rightDiag.add(row - i); leftDiag.add(row + i); solve(row + 1, cols, rightDiag, leftDiag, n); cols.remove(i); leftDiag.remove(row + i); rightDiag.remove(row - i); &#125; return; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51. N-Queens]]></title>
    <url>%2F2017%2F11%2F23%2F51-N-Queens%2F</url>
    <content type="text"><![CDATA[The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively. For example,There exist two distinct solutions to the 4-queens puzzle:1234567891011[ [&quot;.Q..&quot;, // Solution 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // Solution 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]] 解法1： DFS, O(N^N )每一行有Ｎ个位置可以尝试，一共有Ｎ个行，不同的摆放方法是N^N要注意的是在存储一个特定的摆放时，一个list就能解决问题。每一个元素对应的是每一行的列的位置。比较直接的DFS的解法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Solution &#123; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; board = new ArrayList&lt;&gt;(); dfs(res, board, n); return res; &#125; /* Create a board from the configuration */ private List&lt;String&gt; draw(List&lt;Integer&gt; board) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); int n = board.size(); for (int i = 0; i &lt; board.size(); i++) &#123; char[] chs = new char[n]; Arrays.fill(chs, '.'); chs[board.get(i)] = 'Q'; res.add(new String(chs)); &#125; return res; &#125; /* Check if a board is valid */ private boolean isValid(List&lt;Integer&gt; board) &#123; if (board.size() == 0) &#123; return true; &#125; for (int i = 0; i &lt; board.size() - 1; i++) &#123; for (int j = i + 1; j &lt; board.size(); j++) &#123; if (board.get(i) == board.get(j)) return false; if (i + board.get(i) == j + board.get(j)) return false; if (j - i == board.get(j) - board.get(i)) return false; &#125; &#125; return true; &#125; private void dfs(List&lt;List&lt;String&gt;&gt; res, List&lt;Integer&gt; board, int n) &#123; if (!isValid(board)) &#123; return; &#125; if (board.size() == n) &#123; List&lt;String&gt; solution = draw(board); res.add(solution); return; &#125; for (int i = 0; i &lt; n; i++) &#123; if (board.contains(i)) &#123; continue; &#125; board.add(i); dfs(res, board, n); board.remove(board.size() - 1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[37. Sudoku Solver]]></title>
    <url>%2F2017%2F11%2F23%2F37-Sudoku-Solver%2F</url>
    <content type="text"><![CDATA[Write a program to solve a Sudoku puzzle by filling the empty cells. Empty cells are indicated by the character ‘.’. You may assume that there will be only one unique solution. A sudoku puzzle… …and its solution numbers marked in red. 解法1： DFS, O(9^N)N是空格子的总数就是一个比较直接的dfs的题。对于每一个空格子尝试从１到９，然后检查是否是valid，如果是则继续，如果不是就填回原来的数字。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public void solveSudoku(char[][] board) &#123; if (board == null || board.length == 0 || board[0] == null || board[0].length == 0) &#123; return; &#125; solve(board); &#125; private boolean solve(char[][] board) &#123; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[0].length; j++) &#123; if (board[i][j] == '.') &#123; // fill up 1 to 9 for (char ch = '1'; ch &lt;= '9'; ch++) &#123; if (isValid(board, i, j, ch)) &#123; board[i][j] = ch; boolean next = solve(board); if (next) &#123; return true; &#125; else &#123; board[i][j] = '.'; &#125; &#125; &#125; return false; &#125; &#125; &#125; return true; &#125; private boolean isValid(char[][] board, int row, int col, char ch) &#123; for (int i = 0; i &lt; 9; i++) &#123; if (board[i][col] != '.' &amp;&amp; board[i][col] == ch) return false; if (board[row][i] != '.' &amp;&amp; board[row][i] == ch) return false; // check the small matrix int matrixRow = (row / 3) * 3 + i / 3; int matrixCol = (col / 3) * 3 + i % 3; if (board[matrixRow][matrixCol] != '.' &amp;&amp; board[matrixRow][matrixCol] == ch) return false; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[460. LFU Cache]]></title>
    <url>%2F2017%2F11%2F19%2F460-LFU-Cache%2F</url>
    <content type="text"><![CDATA[Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted. Follow up:Could you do both operations in O(1) time complexity? Example:123456789101112LFUCache cache = new LFUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.get(3); // returns 3.cache.put(4, 4); // evicts key 1.cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 解法1：12]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[76. Minimum Window Substring]]></title>
    <url>%2F2017%2F11%2F15%2F76-Minimum-Window-Substring%2F</url>
    <content type="text"><![CDATA[Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). For example,S = “ADOBECODEBANC”T = “ABC”Minimum window is “BANC”. Note:If there is no such window in S that covers all characters in T, return the empty string “”. If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S. 解法1： Sliding Window直接用Sliding Window的模板来做。维护一个map来存每一个字符出现的次数,用一个指针start记录substring的左边界然后遍历就可以了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; public String minWindow(String s, String t) &#123; // sliding window problem if (t == null || t.length() == 0) &#123; return ""; &#125; if (s == null || s.length() == 0) &#123; return ""; &#125; // Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (char ch : t.toCharArray()) &#123; map.put(ch, map.getOrDefault(ch, 0) + 1); &#125; int count = t.length(); int start = 0; int minLen = Integer.MAX_VALUE; String res = ""; for (int i = 0; i &lt; s.length(); i++) &#123; char ch = s.charAt(i); if (map.containsKey(ch)) &#123; map.put(ch, map.get(ch) - 1); // decrease by one if (map.get(ch) &gt;= 0) &#123; count--; &#125; while (count == 0) &#123; // update result string int len = i - start + 1; if (len &lt; minLen) &#123; minLen = len; res = s.substring(start, i + 1); &#125; char temp = s.charAt(start); if (map.containsKey(temp)) &#123; map.put(temp, map.get(temp) + 1); if (map.get(temp) &gt; 0) &#123; count++; &#125; &#125; start++; // move start &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[65. Valid Number]]></title>
    <url>%2F2017%2F11%2F15%2F65-Valid-Number%2F</url>
    <content type="text"><![CDATA[Validate if a given string is numeric. Some examples:“0” =&gt; true“ 0.1 “ =&gt; true“abc” =&gt; false“1 a” =&gt; false“2e10” =&gt; trueNote: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. Update (2015-02-10):The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition. 解法1： DFA第一次遇到可以用DFA(finite automata)做的题，终于学到的理论知识也有可以用的地方了。用dfa做的时候的点在于首先要换出图，然后识别出valid的state,最后判断一下是否落在state中就可以了。实现起来比较简单。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public boolean isNumber(String s) &#123; if (s == null || s.length() == 0 || s.trim().length() == 0) &#123; return false; &#125; s = s.trim(); int state = 1; boolean hasNum = false; for (int i = 0; i &lt; s.length(); i++) &#123; char ch = s.charAt(i); if (Character.isDigit(ch)) &#123; hasNum = true; if (state &lt;= 3) &#123; state = 3; &#125; else if (state &lt;= 5) &#123; state = 5; &#125; else if (state &lt;= 8) &#123; state = 8; &#125; &#125; else if (ch == '.') &#123; if (state &lt; 3) state = 4; else if (state == 3) state = 5; else return false; &#125; else if (ch == 'e') &#123; if (state == 3) state = 6; else if (state == 5) state = 6; else return false; &#125; else if (ch == '+' || ch == '-') &#123; if (state == 1) state = 2; else if (state == 6) state = 7; else return false; &#125; else &#123; return false; &#125; &#125; return state == 3 || state == 5 || state == 8; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[32. Longest Valid Parentheses]]></title>
    <url>%2F2017%2F11%2F15%2F32-Longest-Valid-Parentheses%2F</url>
    <content type="text"><![CDATA[Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring. For “(()”, the longest valid parentheses substring is “()”, which has length = 2. Another example is “)()())”, where the longest valid parentheses substring is “()()”, which has length = 4. 解法1： DP用一个array,dp[i]表示的是0 … i子串里lvp。首先如果要valid,那么最后一个字符一定是). 这就是说我们只需要在看到)的时候判断一下当前最长的子串。那么可以得到如下的推算公式。如果i字符是(，那么如果i-1是(,则代表有一个valid的子串，dp[i] = dp[i - 2] + 2如果i字符是)，那么先要看i - 1位置的最长子串，然后看这个子串的前一个字符是否是(，如果是那么我们又凑满了一个valid的子串。dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2 123456789101112131415161718class Solution &#123; public int longestValidParentheses(String s) &#123; int res = 0; int[] dp = new int[s.length()]; for (int i = 1; i &lt; s.length(); i++) &#123; if (s.charAt(i) == ')') &#123; if (s.charAt(i - 1) == '(') &#123; dp[i] = (i &gt;= 2 ? dp[i - 2] : 0) + 2; &#125; else if (i &gt; dp[i - 1] &amp;&amp; s.charAt(i - dp[i - 1] - 1) == '(') &#123; dp[i] = dp[i - 1] + (i - dp[i - 1] &gt;= 2 ? dp[i - dp[i - 1] - 2]: 0) + 2; &#125; &#125; res = Math.max(res, dp[i]); &#125; return res; &#125;&#125; 解法２: Stack123456789101112131415161718192021222324252627282930class Solution &#123; public int longestValidParentheses(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int start = -1; int res = 0; for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == '(') &#123; stack.push(i); &#125; else &#123; if (!stack.isEmpty()) &#123; stack.pop(); if (stack.isEmpty()) &#123; res = Math.max(res, i - start); &#125; else &#123; res = Math.max(res, i - stack.peek()); &#125; &#125; else &#123; start = i; // because if a string starts with ) it will never become valid &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[30. Substring with Concatenation of All Words]]></title>
    <url>%2F2017%2F11%2F13%2F30-Substring-with-Concatenation-of-All-Words%2F</url>
    <content type="text"><![CDATA[You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. For example, given:s: “barfoothefoobarman”words: [“foo”, “bar”] You should return the indices: [0,9].(order does not matter). 解法1： HashMap ＋ 一次遍历 用HashMap记录每一个word出现的次数，然后对每一个起始点进行遍历。复杂度应该是O(NL), N是字符串的长度，L是字符串数组的个数。12345678910111213141516171819202122232425262728class Solution &#123; public static List&lt;Integer&gt; findSubstring(String S, String[] L) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if (S == null || L == null || L.length == 0) return res; int len = L[0].length(); // length of each word Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); // map for L for (String w : L) map.put(w, map.containsKey(w) ? map.get(w) + 1 : 1); for (int i = 0; i &lt;= S.length() - len * L.length; i++) &#123; Map&lt;String, Integer&gt; copy = new HashMap&lt;String, Integer&gt;(map); for (int j = 0; j &lt; L.length; j++) &#123; // checkc if match String str = S.substring(i + j*len, i + j*len + len); // next word if (copy.containsKey(str)) &#123; // is in remaining words int count = copy.get(str); if (count == 1) copy.remove(str); else copy.put(str, count - 1); if (copy.isEmpty()) &#123; // matches res.add(i); break; &#125; &#125; else break; // not in L &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[25. Reverse Nodes in k-Group]]></title>
    <url>%2F2017%2F11%2F13%2F25-Reverse-Nodes-in-k-Group%2F</url>
    <content type="text"><![CDATA[Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. You may not alter the values in the nodes, only nodes itself may be changed. Only constant memory is allowed. For example,Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5 For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5 For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 解法1： O(N)考点是基本的linkedlist操作，每次找出一个要反转的subList的头的前一个node和他的尾巴node,反转了之后再把新subList接回原来的list就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; if (head == null) return null; if (k &lt;= 1) return head; ListNode dummy = new ListNode(0); dummy.next = head; ListNode tail = dummy; while (tail != null &amp;&amp; tail.next != null) &#123; int count = 0; // first find the end of the sub list ListNode subHead = tail; while (tail != null &amp;&amp; count &lt; k) &#123; ++count; tail = tail.next; &#125; // tail point to the end of the subList if (tail == null) break; ListNode next = tail.next; tail.next = null; ListNode subRealHead = subHead.next; ListNode temp = reverse(subRealHead); subHead.next = temp; // connect the new head to front subRealHead.next = next; // connect the new tail to end tail = subRealHead; // set tail to be the last element in the current subList &#125; return dummy.next; &#125; private ListNode reverse(ListNode head) &#123; ListNode prev = null; while (head != null) &#123; ListNode next = head.next; head.next = prev; prev = head; head = next; &#125; return prev; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23. Merge k Sorted List]]></title>
    <url>%2F2017%2F11%2F13%2F23-Merge-k-Sorted-List%2F</url>
    <content type="text"><![CDATA[Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 解法1： PriorityQueue, O(NlogM)M是queue的长度，N是所有node的总数。一个简单的PriorityQueue的应用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length == 0) &#123; return null; &#125; ListNode dummy = new ListNode(0); ListNode tail = dummy; Queue&lt;ListNode&gt; queue = new PriorityQueue&lt;&gt;((a,b) -&gt; a.val - b.val); for (int i = 0; i &lt; lists.length; i++) &#123; if (lists[i] != null) &#123; queue.offer(lists[i]); &#125; &#125; while (!queue.isEmpty()) &#123; ListNode next = queue.poll(); tail.next = next; tail = tail.next; // add another node if exist if (next.next != null) &#123; queue.offer(next.next); &#125; &#125; return dummy.next; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10. Regular Expression Matching]]></title>
    <url>%2F2017%2F11%2F13%2F10-Regular-Expression-Matching%2F</url>
    <content type="text"><![CDATA[Implement regular expression matching with support for ‘.’ and ‘*’.12345678910111213141516&apos;.&apos; Matches any single character.&apos;*&apos; Matches zero or more of the preceding element.The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch(&quot;aa&quot;,&quot;a&quot;) → falseisMatch(&quot;aa&quot;,&quot;aa&quot;) → trueisMatch(&quot;aaa&quot;,&quot;aa&quot;) → falseisMatch(&quot;aa&quot;, &quot;a*&quot;) → trueisMatch(&quot;aa&quot;, &quot;.*&quot;) → trueisMatch(&quot;ab&quot;, &quot;.*&quot;) → trueisMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → true 解法1： DP O(MN)这题一开始拿到没想到可以用DP。如果从基础的递归开始思考的话会比较容易一点往dp的方向上想。而dp的状态方程也不太好想。参考了YouTube上的这个视频,讲的还是比较清楚的。首先，dp[i][j]表示的是前i个字符和前j个字符是否能match。那么如果s[i] == p[j]，又或者当前的pattern是”.”, 则可以轻松得出dp[i][j] = dp[i - 1][j - 1]如果是,那么就稍微麻烦一点。这里可以考虑的是两种情况：一个是不match前面的字符，这种情况下可以得到dp[i][j] = dp[i][j - 2]另外一个是match一个或者多个前面的字符，但是这种情况需要满足s[i] = p[j - 1].那么怎么表示match呢？可以的做法就是把当前s的位置的字符删除，变成s[i - 1]再和p[i]尝试match.举一个例子：aa 和a*。 如果在match第二个a的时候，可以退化成比较a和a*。而这个结果已经有了。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public boolean isMatch(String s, String p) &#123; if (s == null &amp;&amp; p == null) return true; if (s == null || p == null) return false; if (s.length() == 0 &amp;&amp; p.length() == 0) return true; int m = s.length(); int n = p.length(); boolean[][] dp = new boolean[m + 1][n + 1]; dp[0][0] = true; for (int i = 2; i &lt;= n; i++) &#123; if (p.charAt(i - 1) == '*') &#123; dp[0][i] = dp[0][i - 2]; &#125; &#125; for (int i = 1; i &lt;=m ; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (p.charAt(j - 1) == '.' || (p.charAt(j - 1) == s.charAt(i - 1))) &#123; dp[i][j] = dp[i - 1][j - 1]; &#125; else if (p.charAt(j - 1) == '*') &#123; dp[i][j] = dp[i][j - 2]; // zero match of the previous value if (p.charAt(j - 2) == '.' || p.charAt(j - 2) == s.charAt(i - 1)) &#123; dp[i][j] |= dp[i - 1][j]; &#125; &#125; else &#123; dp[i][j] = false; &#125; &#125; &#125; return dp[m][n]; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[393. UTF-8 Validation]]></title>
    <url>%2F2017%2F11%2F11%2F393-UTF-8-Validation%2F</url>
    <content type="text"><![CDATA[A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules: For 1-byte character, the first bit is a 0, followed by its unicode code.For n-bytes character, the first n-bits are all one’s, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.This is how the UTF-8 encoding would work:1234567Char. number range | UTF-8 octet sequence (hexadecimal) | (binary)--------------------+---------------------------------------------0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx Given an array of integers representing the data, return whether it is a valid utf-8 encoding. Note:The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data. Example 1:1234data = [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.Return true.It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character. Example 2:123456data = [235, 140, 4], which represented the octet sequence: 11101011 10001100 00000100.Return false.The first 3 bits are all one&apos;s and the 4th bit is 0 means it is a 3-bytes character.The next byte is a continuation byte which starts with 10 and that&apos;s correct.But the second continuation byte does not start with 10, so it is invalid. 解法1：按照规则来。用一个变量存储当前还需要几个连续的以10开头的byte。要注意的是在设置mask的时候，需要用0B11100000去判断最初的两个数字是否是11 1234567891011121314151617181920public class Solution &#123; public boolean validUtf8(int[] data) &#123; int varCharLeft = 0; for (int b: data) &#123; if (varCharLeft == 0) &#123; // 要差一位来判断到底有几个1在数字里面，不然不知道到底是有几位。 // 判断到3的原因是unicode最多是4个byte if ((b &amp; 0b10000000) == 0) varCharLeft = 0; else if ((b &amp; 0b11100000) == 0b11000000) varCharLeft = 1; else if ((b &amp; 0b11110000) == 0b11100000) varCharLeft = 2; else if ((b &amp; 0b11111000) == 0b11110000) varCharLeft = 3; else return false; &#125; else &#123; if ((b &amp; 0b11000000) != 0b10000000) return false; varCharLeft--; &#125; &#125; return varCharLeft==0; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[392. Is Subsequence]]></title>
    <url>%2F2017%2F11%2F11%2F392-Is-Subsequence%2F</url>
    <content type="text"><![CDATA[Given a string s and a string t, check if s is subsequence of t. You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (&lt;=100). A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ace” is a subsequence of “abcde” while “aec” is not). Example 1:s = “abc”, t = “ahbgdc” Return true. Example 2:s = “axc”, t = “ahbgdc” Return false. Follow up:If there are lots of incoming S, say S1, S2, … , Sk where k &gt;= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code? 解法1： Two pointers O(M + N)一个指针扫描t，一个指针扫描s。当两个指向的字符相同的时候就把s的指针前进，如果s到了t的末尾，那么就返回true。 123456789101112131415161718192021222324class Solution &#123; public boolean isSubsequence(String s, String t) &#123; if (s == null || s.length() == 0) &#123; return true; &#125; if (t == null || t.length() == 0) &#123; return false; &#125; int j = 0; for (int i = 0; i &lt; t.length(); i++)&#123; if (t.charAt(i) == s.charAt(j)) &#123; j++; if (j == s.length()) &#123; return true; &#125; &#125; &#125; return false; &#125;&#125; Follow up如果是要不停的处理不同的s的话，一般情况下可以对t进行一些预处理。首先用O(N)的办法得出每一个字符在t中出现的位置，用一个Map]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[390. Elimination Game]]></title>
    <url>%2F2017%2F11%2F11%2F390-Elimination-Game%2F</url>
    <content type="text"><![CDATA[There is a list of sorted integers from 1 to n. Starting from left to right, remove the first number and every other number afterward until you reach the end of the list. Repeat the previous step again, but this time from right to left, remove the right most number and every other number from the remaining numbers. We keep repeating the steps again, alternating left to right and right to left, until a single number remains. Find the last number that remains starting with a list of length n. Example:123456789Input:n = 9,1 2 3 4 5 6 7 8 92 4 6 82 66Output:6 解法1： Recursion观察可以发现，对于[1,2,3,4,5,6,7,8,9] 这个数组，第一遍从左到右去掉之后得到的是[2,4,6,8],这个时候需要从右往左。那么她的结果也就是可以看成是两倍的right(1,2,3,4)。同理，这个(1,2,3,4)又可以看成是从左到右的(1,2),不过这里要区分一下奇数和偶数的情况。1234567891011121314151617181920class Solution &#123; public int lastRemaining(int n) &#123; return left2Right(n); &#125; private int left2Right(int n) &#123; if (n &lt;= 2) return n; return 2 * right2Left(n / 2); &#125; private int right2Left(int n) &#123; if (n &lt;= 2) return 1; // differentiate between odd and even cases if (n % 2 == 1) &#123; return 2 * left2Right(n / 2); &#125; else &#123; return 2 * left2Right(n / 2) - 1; &#125; &#125;&#125; 解法2： Iteration TLE也可以用约瑟夫环的类似的解法取去模拟删除的过程。不过大数据的时候就TLE了123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public int lastRemaining(int n) &#123; if (n &lt;= 2) return n; LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); for (int i = 1; i &lt;= n; i++) &#123; list.add(i); &#125; ListIterator&lt;Integer&gt; iterator = list.listIterator(); boolean left2Right = true; iterator.next(); // starting from the starting point while (list.size() &gt; 1) &#123; iterator.remove(); if (left2Right) &#123; if (iterator.hasNext()) &#123; iterator.next(); if (iterator.hasNext()) &#123; iterator.next(); &#125; else &#123; left2Right = false; iterator.previous(); &#125; &#125; else &#123; left2Right = false; iterator.previous(); &#125; &#125; else &#123; if (iterator.hasPrevious()) &#123; iterator.previous(); if (iterator.hasPrevious()) &#123; iterator.previous(); &#125; else &#123; left2Right = true; iterator.next(); &#125; &#125; else &#123; left2Right = true; iterator.next(); &#125; &#125; &#125; return list.get(0); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[388. Longest Absolute File Path]]></title>
    <url>%2F2017%2F11%2F11%2F388-Longest-Absolute-File-Path%2F</url>
    <content type="text"><![CDATA[Suppose we abstract our file system by a string in the following manner: The string “dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext” represents:1234dir subdir1 subdir2 file.ext The directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext. The string “dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext” represents:1234567dir subdir1 file1.ext subsubdir1 subdir2 subsubdir2 file2.ext The directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext. We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is “dir/subdir2/subsubdir2/file2.ext”, and its length is 32 (not including the double quotes). Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0. Note:The name of a file contains at least a . and an extension.The name of a directory or sub-directory will not contain a ..Time complexity required: O(n) where n is the size of the input string. Notice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png. 解法1： HashMap基本的思路是先把string按照\n分割，然后按照题意，对于每一个子字符串，他的\t的数量就代表他的层数。这样的话可以从左往右扫描一遍，遇到一个新的level就存下当前的路径长度，不过如果当前是文件的话则从map中读取当前的level长度然后加上文件名长度就可以了。每次存level的时候实际可以存上真实level+1，代表的是如果下一个文件的level是x，那么直接从map中读取x就是对应的path长度。初始化的时候要放入map.put(0,0) 123456789101112131415161718class Solution &#123; public int lengthLongestPath(String input) &#123; int res = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); // record the length at each level map.put(0, 0); for (String element : input.split("\n")) &#123; int level = element.lastIndexOf("\t") + 1; element = element.substring(level); if (element.contains(".")) &#123; res = Math.max(res, map.get(level) + element.length()); &#125; else &#123; map.put(level + 1, map.get(level) + element.length() + 1); &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[385. Mini Parser]]></title>
    <url>%2F2017%2F11%2F11%2F385-Mini-Parser%2F</url>
    <content type="text"><![CDATA[Given a nested list of integers represented as a string, implement a parser to deserialize it. Each element is either an integer, or a list – whose elements may also be integers or other lists. Note: You may assume that the string is well-formed: String is non-empty.String does not contain white spaces.String contains only digits 0-9, [, - ,, ].Example 1:123Given s = &quot;324&quot;,You should return a NestedInteger object which contains a single integer 324. Example 2:123456789Given s = &quot;[123,[456,[789]]]&quot;,Return a NestedInteger object containing a nested list with 2 elements:1. An integer containing value 123.2. A nested list containing two elements: i. An integer containing value 456. ii. A nested list with one element: a. An integer containing value 789. 解法1： Stack O(N)用一个stack来存储每一个当前的nestedInteger。用一个variable存储指针使得他指向当前要parse的数字的开始位置。每次看到一个,或者是]的时候就表示当前的nestedInteger结束了，所以需要把当前的数字放入nestedInteger。如果是]，如果当前的stack不为空，那么就说明这个integer属于另一个integer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * public interface NestedInteger &#123; * // Constructor initializes an empty nested list. * public NestedInteger(); * * // Constructor initializes a single integer. * public NestedInteger(int value); * * // @return true if this NestedInteger holds a single integer, rather than a nested list. * public boolean isInteger(); * * // @return the single integer that this NestedInteger holds, if it holds a single integer * // Return null if this NestedInteger holds a nested list * public Integer getInteger(); * * // Set this NestedInteger to hold a single integer. * public void setInteger(int value); * * // Set this NestedInteger to hold a nested list and adds a nested integer to it. * public void add(NestedInteger ni); * * // @return the nested list that this NestedInteger holds, if it holds a nested list * // Return null if this NestedInteger holds a single integer * public List&lt;NestedInteger&gt; getList(); * &#125; */class Solution &#123; public NestedInteger deserialize(String s) &#123; if (s == null || s.length() == 0) &#123; return new NestedInteger(); &#125; if (s.charAt(0) != '[') return new NestedInteger(Integer.parseInt(s)); Stack&lt;NestedInteger&gt; stack = new Stack&lt;&gt;(); int start = 1; for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) =='[') &#123; // start of a new NestedInteger stack.push(new NestedInteger()); start = i + 1; &#125; else if (s.charAt(i) == ',' || s.charAt(i) == ']') &#123; if (start &lt; i) &#123; NestedInteger top = stack.peek(); top.add(new NestedInteger(Integer.parseInt(s.substring(start, i)))); &#125; start = i + 1; if (s.charAt(i) == ']') &#123; if (stack.size() &gt; 1) &#123; NestedInteger child = stack.pop(); NestedInteger parent = stack.peek(); parent.add(child); &#125; &#125; &#125; &#125; return stack.pop(); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[384. Shuffle an Array]]></title>
    <url>%2F2017%2F11%2F06%2F384-Shuffle-an-Array%2F</url>
    <content type="text"><![CDATA[解法1： O(N), Fisher-Yates Algorithm参看这个geeksforgeeks的文章12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; int[] data = null; int[] backup = null; Random random; public Solution(int[] nums) &#123; data = nums; backup = Arrays.copyOf(data, data.length); random = new Random(System.currentTimeMillis()); &#125; /** Resets the array to its original configuration and return it. */ public int[] reset() &#123; data = Arrays.copyOf(backup, backup.length); return data; &#125; /** Returns a random shuffling of the array. */ public int[] shuffle() &#123; for (int i = data.length - 1; i &gt; 0; i--) &#123; int pick = random.nextInt(i + 1); swap(i, pick); &#125; return data; &#125; private void swap(int i, int j) &#123; int temp = data[i]; data[i] = data[j]; data[j] = temp; &#125;&#125;/** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(nums); * int[] param_1 = obj.reset(); * int[] param_2 = obj.shuffle(); */]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[382. Linked List Random Node]]></title>
    <url>%2F2017%2F11%2F06%2F382-Linked-List-Random-Node%2F</url>
    <content type="text"><![CDATA[Given a singly linked list, return a random node’s value from the linked list. Each node must have the same probability of being chosen. Follow up:What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space? Example:12345678// Init a singly linked list [1,2,3].ListNode head = new ListNode(1);head.next = new ListNode(2);head.next.next = new ListNode(3);Solution solution = new Solution(head);// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.solution.getRandom(); 解法1： Reservoir Sampling是reservoir sampling的直接应用。从discussion上看来的比较好懂的解释：12345678Start...When we read the first node head, if the stream ListNode stops here, we can just return the head.val. The possibility is 1/1.When we read the second node, we can decide if we replace the result r or not. The possibility is 1/2. So we just generate a random number between 0 and 1, and check if it is equal to 1. If it is 1, replace r as the value of the current node, otherwise we don&apos;t touch r, so its value is still the value of head.When we read the third node, now the result r is one of value in the head or second node. We just decide if we replace the value of r as the value of current node(third node). The possibility of replacing it is 1/3, namely the possibility of we don&apos;t touch r is 2/3. So we just generate a random number between 0 ~ 2, and if the result is 2 we replace r.We can continue to do like this until the end of stream ListNode. 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; /** @param head The linked list's head. Note that the head is guaranteed to be not null, so it contains at least one node. */ ListNode head = null; Random random = null; public Solution(ListNode head) &#123; this.head = head; random = new Random(System.currentTimeMillis()); &#125; /** Returns a random node's value. */ public int getRandom() &#123; // k = 1 int res = head.val; ListNode ptr = head.next; for (int i = 1; ptr != null; i++) &#123; if (random.nextInt(i + 1) == i) &#123; res = ptr.val; &#125; ptr = ptr.next; &#125; return res; &#125;&#125;/** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(head); * int param_1 = obj.getRandom(); */]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[372. Super Pow]]></title>
    <url>%2F2017%2F11%2F06%2F372-Super-Pow%2F</url>
    <content type="text"><![CDATA[Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array. Example1:1234a = 2b = [3]Result: 8 Example2:1234a = 2b = [1,0]Result: 1024 解法1： 二分分割参考了这篇解答1,主要的思想还是做二分分割。用到的性质是1(ab)%x = (a%x)*(b%x) % x 然后判断下是否是偶数或者奇数。这里需要记忆一个高精度除法的计算方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; public static int DIV = 1337; public void divide(int[] b, int divisor) &#123; int temp = 0; for (int i = 0; i &lt; b.length; i++) &#123; b[i] += temp * 10; temp = b[i] % divisor; b[i] /= divisor; &#125; &#125; public boolean isZero(int[] b) &#123; for (int i = 0; i &lt; b.length; i++) &#123; if (b[i] != 0) &#123; return false; &#125; &#125; return true; &#125; public int superPow(int a, int[] b) &#123; if (isZero(b)) &#123; return 1; &#125; a %= Solution.DIV; // take a % first boolean isEven = false; if (b[b.length - 1] % 2 == 0) &#123; isEven = true; &#125; divide(b, 2); int sub = superPow(a, b); sub %= Solution.DIV; sub *= sub; sub %= Solution.DIV; if (!isEven) &#123; sub *= a; sub %= Solution.DIV; &#125; return sub; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[353. Design Snake Game]]></title>
    <url>%2F2017%2F11%2F06%2F353-Design-Snake-Game%2F</url>
    <content type="text"><![CDATA[Design a Snake game that is played on a device with screen size = width x height. Play the game online if you are not familiar with the game. The snake is initially positioned at the top left corner (0,0) with length = 1 unit. You are given a list of food’s positions in row-column order. When a snake eats the food, its length and the game’s score both increase by 1. Each food appears one by one on the screen. For example, the second food will not appear until the first food was eaten by the snake. When a food does appear on the screen, it is guaranteed that it will not appear on a block occupied by the snake. Example:1234567891011121314151617181920212223242526272829303132333435Given width = 3, height = 2, and food = [[1,2],[0,1]].Snake snake = new Snake(width, height, food);Initially the snake appears at position (0,0) and the food at (1,2).|S| | || | |F|snake.move(&quot;R&quot;); -&gt; Returns 0| |S| || | |F|snake.move(&quot;D&quot;); -&gt; Returns 0| | | || |S|F|snake.move(&quot;R&quot;); -&gt; Returns 1 (Snake eats the first food and right after that, the second food appears at (0,1) )| |F| || |S|S|snake.move(&quot;U&quot;); -&gt; Returns 1| |F|S|| | |S|snake.move(&quot;L&quot;); -&gt; Returns 2 (Snake eats the second food)| |S|S|| | |S|snake.move(&quot;U&quot;); -&gt; Returns -1 (Game over because snake collides with border) 解法1： Deque + HashMap设计题在于选用合适的数据结构来完成要求的feature。用一个hashmap存每一个snake的位置是便于查询是否头咬到了身体用deque来表示一个snake，方便从头从尾巴更新。每次移动的时候先要把tail移除，然后判断是否溢出，是否咬到了身体。然后再判断是否吃到了果实，如果是那么再把tail给放回去。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495class SnakeGame &#123; /** Initialize your data structure here. @param width - screen width @param height - screen height @param food - A list of food positions E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the second is at [1,0]. */ Deque&lt;Integer&gt; snake; Set&lt;Integer&gt; snakeBody; int width; int height; int[][] food; int score; int foodIndex; public SnakeGame(int width, int height, int[][] food) &#123; this.snake = new LinkedList&lt;Integer&gt;(); this.snakeBody = new HashSet&lt;&gt;(); this.width = width; this.height = height; this.food = food; this.score = 0; this.foodIndex = 0; snake.offerFirst(0); snakeBody.add(0); &#125; /** Moves the snake. @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down @return The game's score after the move. Return -1 if game over. Game over when snake crosses the screen boundary or bites its body. */ public int move(String direction) &#123; if (score == -1) &#123; return score; &#125; int head = snake.peekFirst(); int row = head / width; int col = head % width; switch (direction) &#123; case "U": row--; break; case "D": row++; break; case "L": col--; break; case "R": col++; break; &#125; // remove tail from snake int tail = snake.peekLast(); snake.removeLast(); snakeBody.remove(tail); // check if snake is out of boundary if (row &lt; 0 || row &gt;= height || col &lt; 0 || col &gt;= width) &#123; score = -1; return score; &#125; int newHead = row * width + col; if (snakeBody.contains(newHead)) &#123; score = -1; return score; &#125; // check if the tail needs to be added back if (foodIndex &lt; food.length) &#123; int[] currentFood = food[foodIndex]; if (row == currentFood[0] &amp;&amp; col == currentFood[1]) &#123; snake.offerLast(tail); snakeBody.add(tail); foodIndex++; score++; &#125; &#125; // add new head into snake snake.offerFirst(newHead); snakeBody.add(newHead); return score; &#125;&#125;/** * Your SnakeGame object will be instantiated and called as such: * SnakeGame obj = new SnakeGame(width, height, food); * int param_1 = obj.move(direction); */]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[714. Best Time to Buy and Sell Stock with Transaction Fee]]></title>
    <url>%2F2017%2F11%2F05%2F714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee%2F</url>
    <content type="text"><![CDATA[Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.) Return the maximum profit you can make. Example 1:12345678Input: prices = [1, 3, 2, 8, 4, 9], fee = 2Output: 8Explanation: The maximum profit can be achieved by:Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8. Note:1230 &lt; prices.length &lt;= 50000.0 &lt; prices[i] &lt; 50000.0 &lt;= fee &lt; 50000. 解法1： Two DP process这一系列题的推广解法非常的简洁也非常的好懂。这是一种互为影响的dp系列。一般用两个dp array解决。一个array代表在时间i不持有股票的最大值，另一个代表在时间i持有股票的最大值。那么可以得到这样的关系withStock[i] = Math.max(withStock[i - 1], withoutStock[i - 1] - price)这里表示在时间i如果买了股票的话资金池就需要减掉pricewithoutStock[i] = Math.max(withoutStock[i - 1], withStock[i - 1] + price)这里只是加入了fee，那么我们可以把它放在sell的时候或者是buy的时候就可以了。最后最大的值一定是withoutStock[i] 123456789101112131415161718class Solution &#123; public int maxProfit(int[] prices, int fee) &#123; if (prices == null || prices.length == 0) &#123; return 0; &#125; long tik0 = 0, tik1 = Integer.MIN_VALUE; for (int price : prices) &#123; long tik0_old = tik0; tik0 = Math.max(tik0, tik1 + price - fee); tik1 = Math.max(tik1, tik0_old - price); &#125; return (int)tik0; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[669. Trim a Binary Search Tree]]></title>
    <url>%2F2017%2F11%2F05%2F669-Trim-a-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R &gt;= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree. Example 1:123456789101112Input: 1 / \ 0 2 L = 1 R = 2Output: 1 \ 2 Example 2:1234567891011121314151617Input: 3 / \ 0 4 \ 2 / 1 L = 1 R = 3Output: 3 / 2 / 解法1： Recursion应用BST的性质，如果当前是一个leaf并且不在[L,R]范围内，那么就返回null。如果不是leaf并且leaf的value在范围内，那么就对左右子树各trim如果不是leaf而不在范围内，那么就either对左子数或者右子数trim就可以了。 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode trimBST(TreeNode root, int L, int R) &#123; if (root == null) return null; if (root.left == null &amp;&amp; root.right == null) &#123; if (root.val &gt;= L &amp;&amp; root.val &lt;= R) &#123; return root; &#125; else &#123; return null; &#125; &#125; int val = root.val; if (val &gt;= L &amp;&amp; val &lt;= R) &#123; root.left = trimBST(root.left, L, R); root.right = trimBST(root.right, L, R); return root; &#125; else if (val &lt; L) &#123; return trimBST(root.right, L, R); &#125; else &#123; // val &gt; R return trimBST(root.left, L, R); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[547. Friend Circles]]></title>
    <url>%2F2017%2F11%2F05%2F547-Friend-Circles%2F</url>
    <content type="text"><![CDATA[There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends. Given a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students. Example 1:1234567Input:[[1,1,0], [1,1,0], [0,0,1]]Output: 2Explanation:The 0th and 1st students are direct friends, so they are in a friend circle.The 2nd student himself is in a friend circle. So return 2. Example 2:1234567Input:[[1,1,0], [1,1,1], [0,1,1]]Output: 1Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends,so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1. Note:N is in range [1,200].M[i][i] = 1 for all students.If M[i][j] = 1, then M[j][i] = 1. 解法1： DFS这里因为已经有一个矩阵代表了graph连接的情况，所以我们不需要另外建图了。对于每一个node，dfs一下把所有连通的地方都设为visited。在外面循环的时候，每次看到一个没有被visited过得就是一个新的group12345678910111213141516171819202122232425262728class Solution &#123; public int findCircleNum(int[][] M) &#123; if (M == null || M.length == 0 || M[0] == null || M[0].length == 0) &#123; return 0; &#125; int n = M.length; boolean[] visited = new boolean[n]; int res = 0; for (int i = 0; i &lt; n; i++) &#123; if (!visited[i]) &#123; res++; dfs(M, visited, i); &#125; &#125; return res; &#125; private void dfs(int[][] M, boolean[] visited, int id) &#123; visited[id] = true; for (int i = 0; i &lt; M.length; i++) &#123; if (visited[i] || M[i][id] == 0) continue; dfs(M, visited, i); &#125; &#125;&#125; 解法2: Union Find比较典型的Union Find解法。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int findCircleNum(int[][] M) &#123; if (M == null || M.length == 0 || M[0] == null || M[0].length == 0) &#123; return 0; &#125; int n = M.length; int[] roots = new int[n]; for (int i = 0; i &lt; n; i++) &#123; roots[i] = i; &#125; // loop through M to union for (int i = 0; i &lt; n - 1; i++) &#123; for (int j = i + 1 ; j &lt; n; j++) &#123; if (M[i][j] == 1) &#123; int root_left = find(roots, i); int root_right = find(roots, j); roots[root_right] = root_left; &#125; &#125; &#125; int res = 0; for (int i = 0; i &lt; n; i++) &#123; if (roots[i] == i) &#123; res++; &#125; &#125; return res; &#125; private int find(int[] nums, int i) &#123; while (i != nums[i]) &#123; i = nums[nums[i]]; &#125; return i; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[443. String Compression]]></title>
    <url>%2F2017%2F11%2F05%2F443-String-Compression%2F</url>
    <content type="text"><![CDATA[Given an array of characters, compress it in-place. The length after compression must always be smaller than or equal to the original array. Every element of the array should be a character (not int) of length 1. After you are done modifying the input array in-place, return the new length of the array. Follow up:1Could you solve it using only O(1) extra space? Example 1:12345678Input:[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]Output:Return 6, and the first 6 characters of the input array should be: [&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]Explanation:&quot;aa&quot; is replaced by &quot;a2&quot;. &quot;bb&quot; is replaced by &quot;b2&quot;. &quot;ccc&quot; is replaced by &quot;c3&quot;. Example 2:12345678Input:[&quot;a&quot;]Output:Return 1, and the first 1 characters of the input array should be: [&quot;a&quot;]Explanation:Nothing is replaced. Example 3:123456789Input:[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;]Output:Return 4, and the first 4 characters of the input array should be: [&quot;a&quot;,&quot;b&quot;,&quot;1&quot;,&quot;2&quot;].Explanation:Since the character &quot;a&quot; does not repeat, it is not compressed. &quot;bbbbbbbbbbbb&quot; is replaced by &quot;b12&quot;.Notice each digit has it&apos;s own entry in the array. Note:All characters have an ASCII value in [35, 126].1 &lt;= len(chars) &lt;= 1000. 解法1： in-placeinplace的解法就是用一个pos记录当前需要插入的位置。用一个变量last记录上一个字符，用count记录那个字符重复的次数。如果当前字符和last一样则更新count，否则的话就写入到array中。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public int compress(char[] chars) &#123; if (chars == null || chars.length == 0) &#123; return 0; &#125; if (chars.length == 1) return 1; int pos = 0; char last = chars[0]; int count = 1; for (int i = 1; i &lt; chars.length; i++) &#123; char current = chars[i]; if (current == last) &#123; count++; &#125; else &#123; chars[pos++] = last; if (count &gt; 1) &#123; String digit = Integer.toString(count); for (char d : digit.toCharArray()) &#123; chars[pos++] = d; &#125; &#125; count = 1; last = current; &#125; &#125; chars[pos++] = chars[chars.length - 1]; if (count &gt; 1) &#123; String digit = Integer.toString(count); for (char d : digit.toCharArray()) &#123; chars[pos++] = d; &#125; &#125; return pos; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[297. Serialize and Deserialize Binary Tree]]></title>
    <url>%2F2017%2F11%2F05%2F297-Serialize-and-Deserialize-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. For example, you may serialize the following tree 1 / \ 2 3 / \ 4 5as “[1,2,3,null,null,4,5]”, just the same as how LeetCode OJ serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless. 解法1： Preorder + Queue先用Preorder构造serialization，在deserialize的时候用一个queue存放所有的node的string。如果是“#”那么直接返回null，否则就知道当前的是一个node，然后分别递归剩下的，得到root.left和root.right的值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Codec &#123; // Encodes a tree to a single string. public String serialize(TreeNode root) &#123; List&lt;String&gt; temp = new ArrayList&lt;&gt;(); helper(root, temp); // join them using , StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; temp.size() - 1; i++) &#123; sb.append(temp.get(i) + ","); &#125; sb.append(temp.get(temp.size() - 1)); return sb.toString(); &#125; private void helper(TreeNode root, List&lt;String&gt; sb) &#123; if (root == null) &#123; sb.add("#"); return; &#125; sb.add(Integer.toString(root.val)); helper(root.left, sb); helper(root.right, sb); &#125; // [1,2,#,#,3,4,#,#,5,#,#] // Decodes your encoded data to tree. public TreeNode deserialize(String data) &#123; if (data == null || data.length() == 0) &#123; return null; &#125; String[] comp = data.split(","); Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); for (String c : comp) &#123; queue.offer(c); &#125; return deserialize(queue); &#125; private TreeNode deserialize(Queue&lt;String&gt; queue) &#123; if (queue.isEmpty()) &#123; return null; &#125; String rootVal = queue.poll(); if (rootVal.equals("#")) &#123; return null; &#125; TreeNode root = new TreeNode(Integer.parseInt(rootVal)); root.left = deserialize(queue); root.right = deserialize(queue); return root; &#125;&#125;// Your Codec object will be instantiated and called as such:// Codec codec = new Codec();// codec.deserialize(codec.serialize(root));]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[386. Lexicographical Numbers]]></title>
    <url>%2F2017%2F11%2F05%2F386-Lexicographical-Numbers%2F</url>
    <content type="text"><![CDATA[Given an integer n, return 1 - n in lexicographical order. For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9]. Please optimize your algorithm to use less time and space. The input size may be as large as 5,000,000. 解法1： DFS观察规律的话，其实是从每一个数字往下画一个树。对于X，下面的数字就是x*10 + i, i从0到9为止。而X的范围是1到9。这样的话就很容易写出来DFS的程序了。123456789101112131415161718192021222324class Solution &#123; public List&lt;Integer&gt; lexicalOrder(int n) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int i = 1; i &lt; 10; i++) &#123; helper(res, i, n); &#125; return res; &#125; private void helper(List&lt;Integer&gt; res, int current, int n) &#123; if (current &gt; n) &#123; return; &#125; else &#123; res.add(current); for (int i = 0; i &lt; 10; i++) &#123; if (current * 10 + i &gt; n) &#123; return; &#125; helper(res, current * 10 + i, n); &#125; &#125; &#125;&#125; 解法2： Ietration也有iteration的做法，这个方法的核心就是对于每一个数字，要找出对应的下一个数字。第二个和第三个if语句里面解决的是对于499下一个数字的问题，应该是5而不是500，所以这种情况下要把末尾的9去掉，然后再把结果+1123456789101112131415161718192021class Solution &#123; public List&lt;Integer&gt; lexicalOrder(int n) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); int current = 1; for (int i = 1; i &lt;= n; i++) &#123; res.add(current); if (current * 10 &lt;= n) &#123; current *= 10; &#125; else if (current % 10 != 9 &amp;&amp; current + 1 &lt;= n) &#123; current++; &#125; else &#123; while ((current / 10) % 10 == 9) &#123; current /= 10; &#125; current = current / 10 + 1; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7. Reverse Integer]]></title>
    <url>%2F2017%2F11%2F05%2F7-Reverse-Integer%2F</url>
    <content type="text"><![CDATA[Given a 32-bit signed integer, reverse digits of an integer. Example 1:12Input: 123Output: 321 Example 2:12Input: -123Output: -321 Example 3:12Input: 120Output: 21 Note:Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. 解法1：这里用到了其中一种判断是否overflow的办法，就是先存下变化之前的数，然后变化之后做相同的操作看看是否和原来的数字一致。如果不相等则说明这个操作overflow了。 1234567891011121314151617181920class Solution &#123; public int reverse(int x) &#123; int res = 0; while ( x != 0) &#123; int newRes = res; int digit = x % 10; newRes = res * 10 + digit; if ((newRes - digit) / 10 != res) &#123; // overflow return 0; &#125; res = newRes; x /= 10; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[138. Copy List With Random Pointer]]></title>
    <url>%2F2017%2F11%2F05%2F138-Copy-List-With-Random-Pointer%2F</url>
    <content type="text"><![CDATA[A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. 解法1： HashMap12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list with a random pointer. * class RandomListNode &#123; * int label; * RandomListNode next, random; * RandomListNode(int x) &#123; this.label = x; &#125; * &#125;; */public class Solution &#123; public RandomListNode copyRandomList(RandomListNode head) &#123; if (head == null) &#123; return head; &#125; Map&lt;RandomListNode, RandomListNode&gt; map = new HashMap&lt;&gt;(); RandomListNode oldHead = head; while (head != null) &#123; RandomListNode copy = new RandomListNode(head.label); map.put(head, copy); head = head.next; &#125; head = oldHead; while (head != null) &#123; map.get(head).random = map.get(head.random); if (head.next != null) &#123; map.get(head).next = map.get(head.next); &#125; head = head.next; &#125; return map.get(oldHead); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[373. Find K Pairs with Smallest Sums]]></title>
    <url>%2F2017%2F10%2F23%2F373-Find-K-Pairs-with-Smallest-Sums%2F</url>
    <content type="text"><![CDATA[You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k. Define a pair (u,v) which consists of one element from the first array and one element from the second array. Find the k pairs (u1,v1),(u2,v2) …(uk,vk) with the smallest sums. Example 1:123456Given nums1 = [1,7,11], nums2 = [2,4,6], k = 3Return: [1,2],[1,4],[1,6]The first 3 pairs are returned from the sequence:[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] Example 2:123456Given nums1 = [1,1,2], nums2 = [1,2,3], k = 2Return: [1,1],[1,1]The first 2 pairs are returned from the sequence:[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] Example 3:123456Given nums1 = [1,2], nums2 = [3], k = 3Return: [1,3],[2,3]All possible pairs are returned from the sequence:[1,3],[2,3] 解法1：discussion中的解法。要用到sorted这个条件可以简化不少程序。由于两个都是sorted，那么第一个array中任何一个数字和第二个数组搭配时，最小的和一定是和第二个数组的第一个元素的配搭。这样我们可以先把这个组合加入heap中，每次poll出来的时候就把对应的第二个数组的配搭往上挪一个。 12345678910111213141516171819202122class Solution &#123; public List&lt;int[]&gt; kSmallestPairs(int[] nums1, int[] nums2, int k) &#123; List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;int[]&gt;((a,b) -&gt; (a[0] + a[1] - b[0] - b[1])); if (nums1.length == 0 || nums2.length == 0 || k == 0) &#123; return res; &#125; for (int i = 0; i &lt; nums1.length; i++) &#123; queue.offer(new int[]&#123;nums1[i], nums2[0], 0&#125;); &#125; while (k-- &gt; 0 &amp;&amp; !queue.isEmpty()) &#123; int[] cur = queue.poll(); res.add(new int[]&#123;cur[0], cur[1]&#125;); int ptr = cur[2]; if (ptr == nums2.length - 1) continue; queue.offer(new int[]&#123;cur[0], nums2[ptr + 1], ptr + 1&#125;); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[365. Water and Jug Problem]]></title>
    <url>%2F2017%2F10%2F23%2F365-Water-and-Jug-Problem%2F</url>
    <content type="text"><![CDATA[You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs. If z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end. Operations allowed: Fill any of the jugs completely with water.Empty any of the jugs.Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.Example 1: (From the famous “Die Hard” example)12Input: x = 3, y = 5, z = 4Output: True Example 2:12Input: x = 2, y = 6, z = 5Output: False 解法1：这里实际是一个数学定理，稍微看一下就可以了。1234567891011121314151617181920class Solution &#123; public boolean canMeasureWater(int x, int y, int z) &#123; if (x + y &lt; z) return false; if (x == z || y == z || x + y == z) return true; return z % gcd(x, y) == 0; &#125; private int gcd(int a, int b) &#123; while (b != 0) &#123; int temp = b; b = a % b; a = temp; &#125; return a; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[355. Design Twitter]]></title>
    <url>%2F2017%2F10%2F23%2F355-Design-Twitter%2F</url>
    <content type="text"><![CDATA[Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user’s news feed. Your design should support the following methods: postTweet(userId, tweetId): Compose a new tweet.getNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user’s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.follow(followerId, followeeId): Follower follows a followee.unfollow(followerId, followeeId): Follower unfollows a followee.Example:123456789101112131415161718192021222324Twitter twitter = new Twitter();// User 1 posts a new tweet (id = 5).twitter.postTweet(1, 5);// User 1&apos;s news feed should return a list with 1 tweet id -&gt; [5].twitter.getNewsFeed(1);// User 1 follows user 2.twitter.follow(1, 2);// User 2 posts a new tweet (id = 6).twitter.postTweet(2, 6);// User 1&apos;s news feed should return a list with 2 tweet ids -&gt; [6, 5].// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.twitter.getNewsFeed(1);// User 1 unfollows user 2.twitter.unfollow(1, 2);// User 1&apos;s news feed should return a list with 1 tweet id -&gt; [5],// since user 1 is no longer following user 2.twitter.getNewsFeed(1); 解法1： Heap用OOD设计的方法解这题比较清楚明白。在设计getNewsFeed的时候，用一个priorityQueue来把每一个follow的user的tweet的head放入堆中，按照时间顺序出堆入堆。每出一个就把当前指向的tweet的下一个推入堆中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121class Twitter &#123; /** Initialize your data structure here. */ class Tweet &#123; int id; int time; Tweet next; public Tweet(int id) &#123; this.id = id; this.time = timeStamp++; next = null; &#125; &#125;; class User &#123; int id; Set&lt;Integer&gt; followed; Tweet tweets; public User(int id) &#123; this.id = id; followed = new HashSet&lt;&gt;(); tweets = null; follow(id); &#125; public void post(int tweetId) &#123; Tweet tweet = new Tweet(tweetId); tweet.next = tweets; tweets = tweet; &#125; public void follow(int id) &#123; if (!followed.contains(id)) &#123; followed.add(id); &#125; &#125; public void unfollow(int id) &#123; if (followed.contains(id)) &#123; followed.remove(id); &#125; &#125; &#125;; int timeStamp = 0; Map&lt;Integer, User&gt; userTable; public Twitter() &#123; userTable = new HashMap&lt;&gt;(); &#125; /** Compose a new tweet. */ public void postTweet(int userId, int tweetId) &#123; if (!userTable.containsKey(userId)) &#123; userTable.put(userId, new User(userId)); &#125; User user = userTable.get(userId); user.post(tweetId); &#125; /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */ public List&lt;Integer&gt; getNewsFeed(int userId) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if (!userTable.containsKey(userId)) &#123; return res; &#125; User user = userTable.get(userId); Set&lt;Integer&gt; followed = user.followed; PriorityQueue&lt;Tweet&gt; queue = new PriorityQueue&lt;&gt;((a,b) -&gt; b.time - a.time); for (Integer temp : followed) &#123; User followed_user = userTable.get(temp); if (followed_user.tweets != null) &#123; queue.offer(followed_user.tweets); &#125; &#125; int n = 0; while (!queue.isEmpty() &amp;&amp; n &lt; 10) &#123; Tweet tweet = queue.poll(); res.add(tweet.id); n++; if (tweet.next != null) &#123; queue.offer(tweet.next); &#125; &#125; return res; &#125; /** Follower follows a followee. If the operation is invalid, it should be a no-op. */ public void follow(int followerId, int followeeId) &#123; if (!userTable.containsKey(followerId)) &#123; userTable.put(followerId, new User(followerId)); &#125; if (!userTable.containsKey(followeeId)) &#123; userTable.put(followeeId, new User(followeeId)); &#125; userTable.get(followerId).follow(followeeId); &#125; /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */ public void unfollow(int followerId, int followeeId) &#123; if (!userTable.containsKey(followerId) || followerId == followeeId) &#123; return; &#125; userTable.get(followerId).unfollow(followeeId); &#125;&#125;/** * Your Twitter object will be instantiated and called as such: * Twitter obj = new Twitter(); * obj.postTweet(userId,tweetId); * List&lt;Integer&gt; param_2 = obj.getNewsFeed(userId); * obj.follow(followerId,followeeId); * obj.unfollow(followerId,followeeId); */]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>OOD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[348. Design Tic-Tac-Toe]]></title>
    <url>%2F2017%2F10%2F19%2F348-Design-Tic-Tac-Toe%2F</url>
    <content type="text"><![CDATA[Design a Tic-tac-toe game that is played between two players on a n x n grid. You may assume the following rules: A move is guaranteed to be valid and is placed on an empty block.Once a winning condition is reached, no more moves is allowed.A player who succeeds in placing n of their marks in a horizontal, vertical, or diagonal row wins the game.Example:Given n = 3, assume that player 1 is “X” and player 2 is “O” in the board.123456789101112131415161718192021222324252627282930313233343536TicTacToe toe = new TicTacToe(3);toe.move(0, 0, 1); -&gt; Returns 0 (no one wins)|X| | || | | | // Player 1 makes a move at (0, 0).| | | |toe.move(0, 2, 2); -&gt; Returns 0 (no one wins)|X| |O|| | | | // Player 2 makes a move at (0, 2).| | | |toe.move(2, 2, 1); -&gt; Returns 0 (no one wins)|X| |O|| | | | // Player 1 makes a move at (2, 2).| | |X|toe.move(1, 1, 2); -&gt; Returns 0 (no one wins)|X| |O|| |O| | // Player 2 makes a move at (1, 1).| | |X|toe.move(2, 0, 1); -&gt; Returns 0 (no one wins)|X| |O|| |O| | // Player 1 makes a move at (2, 0).|X| |X|toe.move(1, 0, 2); -&gt; Returns 0 (no one wins)|X| |O||O|O| | // Player 2 makes a move at (1, 0).|X| |X|toe.move(2, 1, 1); -&gt; Returns 1 (player 1 wins)|X| |O||O|O| | // Player 1 makes a move at (2, 1).|X|X|X| Follow up:Could you do better than O(n2) per move() operation? 解法1： O(N) move基本的思路就是每次move之后，检查行，列，对角线是否满足胜利条件，如果满足就返回。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class TicTacToe &#123; /** Initialize your data structure here. */ int[][] board = null; int n; public TicTacToe(int n) &#123; board = new int[n][n]; this.n = n; &#125; /** Player &#123;player&#125; makes a move at (&#123;row&#125;, &#123;col&#125;). @param row The row of the board. @param col The column of the board. @param player The player, can be either 1 or 2. @return The current winning condition, can be either: 0: No one wins. 1: Player 1 wins. 2: Player 2 wins. */ public int move(int row, int col, int player) &#123; board[row][col] = player; if (isWin(row, col, player)) return player; return 0; &#125; private boolean isWin(int row, int col, int player) &#123; // check row boolean win = true; for (int i = 0; i &lt; n; i++) &#123; if (board[row][i] != player) &#123; win = false; break; &#125; &#125; if (win) return true; win = true; // check col for (int i = 0; i &lt; n; i++) &#123; if (board[i][col] != player) &#123; win = false; break; &#125; &#125; if (win) return true; // check diagonal if (row == col) &#123; win = true; for (int i = 0; i &lt; n; i++) &#123; if (board[i][i] != player) &#123; win = false; break; &#125; &#125; &#125; if (win) return true; if (row + col == n - 1) &#123; win = true; for (int i = 0; i &lt; n; i++) &#123; if (board[i][n - 1 - i] != player) &#123; win = false; break; &#125; &#125; &#125; if (win) return true; return false; &#125;&#125;/** * Your TicTacToe object will be instantiated and called as such: * TicTacToe obj = new TicTacToe(n); * int param_1 = obj.move(row,col,player); */ 解法2： O(1) move实际上这题可以做到o(1)的复杂度。用+1和-1表示每一个方向两个选手的落子情况。那么如果一个行都被其中一个选手占领，他的绝对值就一定和行数相等。由此 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class TicTacToe &#123; private int[] rows; private int[] cols; private int diagonal; private int antiDiagonal; /** Initialize your data structure here. */ public TicTacToe(int n) &#123; rows = new int[n]; cols = new int[n]; &#125; /** Player &#123;player&#125; makes a move at (&#123;row&#125;, &#123;col&#125;). @param row The row of the board. @param col The column of the board. @param player The player, can be either 1 or 2. @return The current winning condition, can be either: 0: No one wins. 1: Player 1 wins. 2: Player 2 wins. */ public int move(int row, int col, int player) &#123; int toAdd = player == 1 ? 1 : -1; rows[row] += toAdd; cols[col] += toAdd; if (row == col) &#123; diagonal += toAdd; &#125; if (col == (cols.length - row - 1)) &#123; antiDiagonal += toAdd; &#125; int size = rows.length; if (Math.abs(rows[row]) == size || Math.abs(cols[col]) == size || Math.abs(diagonal) == size || Math.abs(antiDiagonal) == size) &#123; return player; &#125; return 0; &#125;&#125;/** * Your TicTacToe object will be instantiated and called as such: * TicTacToe obj = new TicTacToe(n); * int param_1 = obj.move(row,col,player); */]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[334. Increasing Triplet Subsequence]]></title>
    <url>%2F2017%2F10%2F19%2F334-Increasing-Triplet-Subsequence%2F</url>
    <content type="text"><![CDATA[Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array. Formally the function should:Return true if there exists i, j, ksuch that arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤ n-1 else return false.Your algorithm should run in O(n) time complexity and O(1) space complexity. Examples:Given [1, 2, 3, 4, 5],return true. Given [5, 4, 3, 2, 1],return false. 解法1： O(N)类似于一个贪心的算法，我们可以设两个变量，这两个变量的条件就是a &lt; b,同时a，b要尽可能的小，这样在后续的扫描中如果发现有一个数字比a，b都大我们就找到了答案。 1234567891011121314151617class Solution &#123; public boolean increasingTriplet(int[] nums) &#123; if (nums == null || nums.length &lt; 3) &#123; return false; &#125; int small = Integer.MAX_VALUE, big = Integer.MAX_VALUE; for (int num : nums) &#123; if (num &lt;= small) small = num; else if (num &lt;= big) big = num; else return true; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[325. Maximum Size Subarray Sum Equals k]]></title>
    <url>%2F2017%2F10%2F19%2F325-Maximum-Size-Subarray-Sum-Equals-k%2F</url>
    <content type="text"><![CDATA[Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn’t one, return 0 instead. Note:The sum of the entire nums array is guaranteed to fit within the 32-bit signed integer range. Example 1:Given nums = [1, -1, 5, -2, 3], k = 3,return 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longest) Example 2:Given nums = [-2, -1, 2, 1], k = 1,return 2. (because the subarray [-1, 2] sums to 1 and is the longest) Follow Up:Can you do it in O(n) time? 解法1： O(N) HashMap用一个hashmap存储每一个子串sum当前出现过的最早的位置（因为只要求最长的一段，所以只需要保存这个就可以了）。然后对于每一个新球出来的sum，看是否存在sum - k存在在map中，如果存在则更新结果。要注意的是还要考虑当前的sum是否正好为k。 1234567891011121314151617181920212223class Solution &#123; public int maxSubArrayLen(int[] nums, int k) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int sum = 0; int res = 0; for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; if (sum == k) res = i + 1; else if (map.containsKey(sum - k)) &#123; res = Math.max(res, i - map.get(sum - k)); &#125; if (!map.containsKey(sum)) &#123; map.put(sum, i); &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[324. Wiggle Sort II]]></title>
    <url>%2F2017%2F10%2F19%2F324-Wiggle-Sort-II%2F</url>
    <content type="text"><![CDATA[Given an unsorted array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]…. Example:(1) Given nums = [1, 5, 1, 1, 6, 4], one possible answer is [1, 4, 1, 5, 1, 6].(2) Given nums = [1, 3, 2, 2, 3, 1], one possible answer is [2, 3, 1, 3, 1, 2]. Note:You may assume all input has valid answer. Follow Up:Can you do it in O(n) time and/or in-place with O(1) extra space? 解法1： O(NlogN)比较基本的解法就是先排序，然后就可以重新建一个数组，从前半部分去一个然后后半部分取一个交替进行。要注意的是，因为array可能有重复的数字出现，所以不能从两边往当中，这样最后可能会碰到两个数字一样，比如[4,5,5,6]。这是需要注意的。 123456789101112131415161718192021222324class Solution &#123; public void wiggleSort(int[] nums) &#123; if (nums == null || nums.length &lt;= 1) &#123; return; &#125; Arrays.sort(nums); int left = (nums.length - 1) / 2; int right = nums.length - 1; int[] temp = new int[nums.length]; for (int i = 0; i &lt; nums.length; i++) &#123; temp[i] = (i % 2 == 0) ? nums[left--] : nums[right--]; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; nums[i] = temp[i]; &#125; return; &#125;&#125; Follow up: O(N), virtual indexing这个还没看懂。。。]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[146. LRU Cache]]></title>
    <url>%2F2017%2F10%2F11%2F146-LRU-Cache%2F</url>
    <content type="text"><![CDATA[Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. Follow up:Could you do both operations in O(1) time complexity? Example:1234567891011LRUCache cache = new LRUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 解法1： HashMap + DequeO(1)的put和get，hashmap应该是逃不了的。问题是还要维护每一个value的access的时间的先后顺序，一般的解法给出来的办法是用一个deque，最近access过的东西放在deque的最后面，而head就存放将要被删除的value。那么自己要实现的deque的操作就是move_to_head还有一个是remove_from_head，写的时候别忘了当capacity满了之后，需要从deque和hashmap两个地方都删除掉才行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class LRUCache &#123; class Node &#123; int key; int val; Node prev; Node next; public Node(int key, int val) &#123; this.key = key; this.val = val; this.prev = null; this.next = null; &#125; &#125;; private int capacity; private HashMap&lt;Integer, Node&gt; map = new HashMap&lt;&gt;(); private Node head = new Node(-1, -1); private Node tail = new Node(-1, -1); public LRUCache(int capacity) &#123; this.capacity = capacity; head.next = tail; tail.prev = head; &#125; public int get(int key) &#123; if (!map.containsKey(key)) &#123; return -1; &#125; Node node = map.get(key); // Remove from the list node.prev.next = node.next; node.next.prev = node.prev; // move to tail move_to_tail(node); return node.val; &#125; public void put(int key, int value) &#123; if (get(key) != -1) &#123; map.get(key).val = value; return; &#125; if (map.size() == capacity) &#123; map.remove(head.next.key); remove_from_head(); &#125; Node target = new Node(key, value); map.put(key, target); move_to_tail(target); &#125; private void move_to_tail(Node node) &#123; node.prev = tail.prev; tail.prev = node; node.prev.next = node; node.next = tail; &#125; private void remove_from_head() &#123; head.next = head.next.next; head.next.prev = head; &#125;&#125;/** * Your LRUCache object will be instantiated and called as such: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[313. Super Ugly Number]]></title>
    <url>%2F2017%2F10%2F05%2F313-Super-Ugly-Number%2F</url>
    <content type="text"><![CDATA[Write a program to find the nth super ugly number. Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. For example, [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32] is the sequence of the first 12 super ugly numbers given primes = [2, 7, 13, 19] of size 4. Note:(1) 1 is a super ugly number for any given primes.(2) The given numbers in primes are in ascending order.(3) 0 &lt; k ≤ 100, 0 &lt; n ≤ 106, 0 &lt; primes[i] &lt; 1000.(4) The nth super ugly number is guaranteed to fit in a 32-bit signed integer. 解法1：和Ugly Number II的解法一样，只是这里要用一个数组来维护每一个对应的primes相乘的ugly number的位置。要注意这里用到的去重的方法是一旦当前的ugly number确定了就把可能产生的小于等于他的所有备选答案跳过（也就是对应的和prime相乘的index要++) 123456789101112131415161718192021class Solution &#123; public int nthSuperUglyNumber(int n, int[] primes) &#123; int[] ugly = new int[n]; int[] idx = new int[primes.length]; ugly[0] = 1; for (int i = 1; i &lt; n; i++) &#123; //find next ugly[i] = Integer.MAX_VALUE; for (int j = 0; j &lt; primes.length; j++) ugly[i] = Math.min(ugly[i], primes[j] * ugly[idx[j]]); //slip duplicate for (int j = 0; j &lt; primes.length; j++) &#123; while (primes[j] * ugly[idx[j]] &lt;= ugly[i]) idx[j]++; &#125; &#125; return ugly[n - 1]; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[307. Range Sum Query - Mutable]]></title>
    <url>%2F2017%2F10%2F05%2F307-Range-Sum-Query-Mutable%2F</url>
    <content type="text"><![CDATA[Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. The update(i, val) function modifies nums by updating the element at index i to val.Example:12345Given nums = [1, 3, 5]sumRange(0, 2) -&gt; 9update(1, 2)sumRange(0, 2) -&gt; 8 Note:The array is only modifiable by the update function.You may assume the number of calls to update and sumRange function is distributed evenly. 解法1： Segment TreeSegment Tree的直接应用。Segment Tree 的node需要记录range的start，end以及对应的sum。tree需要有一个node作为root。tree提供如下几个基本的method：1build，update，sumRange 每一个函数基本都是通过recursion实现的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798class NumArray &#123; class SegmentTreeNode &#123; int start; int end; int val; SegmentTreeNode left; SegmentTreeNode right; public SegmentTreeNode(int start, int end, int val) &#123; this.start = start; this.end = end; this.val = val; left = null; right = null; &#125; &#125;; class SegmentTree &#123; SegmentTreeNode root; public SegmentTree(int[] nums) &#123; root = build(nums, 0, nums.length - 1); &#125; public SegmentTreeNode build(int[] nums, int start, int end) &#123; if (start &gt; end) return null; if (start == end) &#123; return new SegmentTreeNode(start, end, nums[start]); &#125; int mid = start + (end - start) / 2; SegmentTreeNode left = build(nums, start, mid); SegmentTreeNode right = build(nums, mid + 1, end); int val = (left == null ? 0 : left.val ) + (right == null ? 0 : right.val); SegmentTreeNode root = new SegmentTreeNode(start, end, val); root.left = left; root.right = right; return root; &#125; public void update(int i, int val) &#123; update(root, i, val); &#125; public void update(SegmentTreeNode current, int i, int val) &#123; if (current.start == i &amp;&amp; current.end == i) &#123; current.val = val; return; &#125; int mid = current.start + (current.end - current.start) / 2; if (i &lt;= mid) &#123; update(current.left, i, val); &#125; else &#123; update(current.right, i, val); &#125; current.val = current.left.val + current.right.val; return; &#125; public int sumRange(int i, int j) &#123; return sumRange(root, i, j); &#125; public int sumRange(SegmentTreeNode current, int i, int j) &#123; if (current.start &gt;= i &amp;&amp; current.end &lt;= j) return current.val; int mid = current.start + (current.end - current.start) / 2; if (j &lt;= mid) &#123; return sumRange(current.left, i, j); &#125; else if (i &gt; mid) &#123; return sumRange(current.right, i, j); &#125; else &#123; return sumRange(current.left, i, mid) + sumRange(current.right, mid + 1, j); &#125; &#125; &#125; SegmentTree tree; public NumArray(int[] nums) &#123; tree = new SegmentTree(nums); &#125; public void update(int i, int val) &#123; tree.update(i, val); &#125; public int sumRange(int i, int j) &#123; return tree.sumRange(i, j); &#125;&#125;/** * Your NumArray object will be instantiated and called as such: * NumArray obj = new NumArray(nums); * obj.update(i,val); * int param_2 = obj.sumRange(i,j); */]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Segment Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[306. Additive Number]]></title>
    <url>%2F2017%2F10%2F05%2F306-Additive-Number%2F</url>
    <content type="text"><![CDATA[Additive number is a string whose digits can form additive sequence. A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two. For example:“112358” is an additive number because the digits can form an additive sequence: 1, 1, 2, 3, 5, 8. 1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8“199100199” is also an additive number, the additive sequence is: 1, 99, 100, 199.1 + 99 = 100, 99 + 100 = 199Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid. Given a string containing only digits ‘0’-‘9’, write a function to determine if it’s an additive number. 解法1： Recursion思想比较简单，就是不停的尝试两个可能的number，然后看是否可以满足additive number的条件。用recursion就可以解决。要注意的是，第一个i的循环只需要到(n - 1) / 2就可以了，因为两个数相加最少也会和较长的数长度相等。假设第二个数字到位置j，那么第三个数字（两个数字之和的长度）就是n - j, n - j要满足的条件也就是j要满足的条件。 123456789101112131415161718192021222324252627282930313233class Solution &#123; public boolean isAdditiveNumber(String num) &#123; if (num == null || num.length() == 0) &#123; return false; &#125; int n = num.length(); for (int i = 1; i &lt;= (n - 1) / 2; i++) &#123; if (num.charAt(0) == '0' &amp;&amp; i &gt; 1) return false; for (int j = i + 1; n - j &gt;= Math.max(i, j - i); j++) &#123; if (num.charAt(i) == '0' &amp;&amp; j - i &gt; 1) break; long first = Long.parseLong(num.substring(0, i)); long second = Long.parseLong(num.substring(i, j)); String rest = num.substring(j); if (helper(rest, first, second)) return true; &#125; &#125; return false; &#125; public boolean helper(String num, long first, long second) &#123; if (num.length() == 0) return true; Long sum = first + second; String s = sum.toString(); if (!num.startsWith(s)) return false; return helper(num.substring(s.length()), second, sum); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15. 3Sum]]></title>
    <url>%2F2017%2F09%2F30%2F15-3Sum%2F</url>
    <content type="text"><![CDATA[Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets.1234567For example, given array S = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 解法1： Backtracking典型的backtracking + 去重的问题。主要的容易错的地方是怎么去重，当确定了其中一个数字的位置i之后，在变动left和right时，每当找到一个满足条件的解都要跳过之后所有和left或者right指向的相同的数字。12345678910111213141516171819202122232425262728293031323334class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (nums == null || nums.length == 0) &#123; return res; &#125; Arrays.sort(nums); for (int i = 0; i &lt; nums.length - 2; i++) &#123; if (i != 0 &amp;&amp; nums[i] == nums[i -1]) continue; int left = i + 1, right = nums.length - 1; while (left &lt; right) &#123; if (nums[i] + nums[left] + nums[right] == 0) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); temp.add(nums[i]); temp.add(nums[left]); temp.add(nums[right]); res.add(temp); left++; right--; while (left &lt; right &amp;&amp; nums[left - 1] == nums[left]) left++; while (left &lt; right &amp;&amp; nums[right + 1] == nums[right]) right--; &#125; else if (nums[i] + nums[left] + nums[right] &lt; 0) &#123; left++; &#125; else &#123; right--; &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[286. Walls and Gates]]></title>
    <url>%2F2017%2F09%2F28%2F286-Walls-and-Gates%2F</url>
    <content type="text"><![CDATA[You are given a m x n 2D grid initialized with these three possible values. -1 - A wall or an obstacle.0 - A gate.INF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF. For example, given the 2D grid:1234INF -1 0 INFINF INF INF -1INF -1 INF -1 0 -1 INF INF After running your function, the 2D grid should be:12343 -1 0 12 2 1 -11 -1 2 -10 -1 3 4 解法1： DFS这题也是变换了一下思路。要找每一个room对应的最近的gate，那么反过来可以从每一个gate出发，更新每一个他可以够着的room的距离。用DFS就可以解决了。 lang: java1234567891011121314151617181920212223242526272829class Solution &#123; public void wallsAndGates(int[][] rooms) &#123; if (rooms == null || rooms.length == 0 || rooms[0] == null || rooms[0].length == 0) &#123; return; &#125; int n = rooms.length; int m = rooms[0].length; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (rooms[i][j] == 0) &#123; dfs(rooms, i, j, 0); &#125; &#125; &#125; &#125; private void dfs(int[][] rooms, int i, int j, int d) &#123; if (i &lt; 0 || i &gt;= rooms.length || j &lt; 0 || j &gt;= rooms[0].length || rooms[i][j] &lt; d) return; rooms[i][j] = d; dfs(rooms, i + 1, j, d + 1); dfs(rooms, i - 1, j , d + 1); dfs(rooms, i, j + 1, d + 1); dfs(rooms, i, j - 1, d + 1); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[267. Palindrome Permutation II]]></title>
    <url>%2F2017%2F09%2F27%2F267-Palindrome-Permutation-II%2F</url>
    <content type="text"><![CDATA[解法1：此题看起来就是用backtracking，但是如果直接用会TLE。首先观察，如果一个字符串出现奇数次的字符的个数&gt;1，那一定不能组成回文串。所以奇数个次数的字符最多一个。并且如果有的话最中间的一定是他。所以偶数回文串可以分成前后两段，奇数回文串可以分成前中后三段。我们把所有的字符出现的次数/2，加上中段和reverse过的前段就可以得到一个回文串。那么问题就转变成了求/2过后的子串的所有的permutation。具体的解法如下 lang: java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Solution &#123; public List&lt;String&gt; generatePalindromes(String s) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); if (s == null || s.length() == 0) &#123; return res; &#125; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (char c : s.toCharArray()) &#123; map.put(c, map.getOrDefault(c, 0) + 1); &#125; int odd = 0; for (char key : map.keySet()) &#123; if (map.get(key) % 2 != 0) &#123; odd++; &#125; &#125; if (odd &gt; 1) return res; String mid = &quot;&quot;; // Create the to-be-appended string StringBuilder sb = new StringBuilder(); for (char key : map.keySet()) &#123; for (int i = 0; i &lt; map.get(key) / 2; i++) &#123; sb.append(key); &#125; if (map.get(key) % 2 != 0) &#123; mid = Character.toString(key); &#125; &#125; // Generate permutations for the sb.toStirng() List&lt;String&gt; perm = new ArrayList&lt;&gt;(); boolean[] visited = new boolean[sb.length()]; String template = sb.toString(); char[] temparray = template.toCharArray(); Arrays.sort(temparray); helper(new String(temparray), &quot;&quot;, perm, visited); for (String temp : perm) &#123; res.add(temp + mid + (new StringBuilder(temp)).reverse().toString()); &#125; return res; &#125; private void helper(String s, String current, List&lt;String&gt; res, boolean[] visited) &#123; if (current.length() == s.length()) &#123; res.add(current); return; &#125; for (int i = 0; i &lt; s.length(); i++) &#123; if (!visited[i]) &#123; if (i != 0 &amp;&amp; s.charAt(i) == s.charAt(i - 1) &amp;&amp; !visited[i - 1]) continue; visited[i] = true; helper(s, current + s.charAt(i), res, visited); visited[i] = false; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[362. Design Hit Counter]]></title>
    <url>%2F2017%2F09%2F27%2F362-Design-Hit-Counter%2F</url>
    <content type="text"><![CDATA[Design a hit counter which counts the number of hits received in the past 5 minutes. Each function accepts a timestamp parameter (in seconds granularity) and you may assume that calls are being made to the system in chronological order (ie, the timestamp is monotonically increasing). You may assume that the earliest timestamp starts at 1. It is possible that several hits arrive roughly at the same time. Example:HitCounter counter = new HitCounter(); // hit at timestamp 1.counter.hit(1); // hit at timestamp 2.counter.hit(2); // hit at timestamp 3.counter.hit(3); // get hits at timestamp 4, should return 3.counter.getHits(4); // hit at timestamp 300.counter.hit(300); // get hits at timestamp 300, should return 4.counter.getHits(300); // get hits at timestamp 301, should return 3.counter.getHits(301);Follow up:What if the number of hits per second could be very large? Does your design scale? 解法1： Deque用一个deque来记录5分钟以内的hit。而当查询gitHit的时候，把deque前面的超出范围的node全部弹出就可以了。如果getHit比较少的话，可以在hit的函数里放上弹出的操作。class HitCounter { /** Initialize your data structure here. */ Deque&lt;Integer&gt; deque; public HitCounter() { deque = new LinkedList&lt;&gt;(); } /** Record a hit. @param timestamp - The current timestamp (in seconds granularity). */ public void hit(int timestamp) { deque.offerLast(timestamp); } /** Return the number of hits in the past 5 minutes. @param timestamp - The current timestamp (in seconds granularity). */ public int getHits(int timestamp) { while (!deque.isEmpty() &amp;&amp; timestamp - deque.peekFirst() &gt;= 300) { deque.pollFirst(); } return deque.size(); } } /** Your HitCounter object will be instantiated and called as such: HitCounter obj = new HitCounter(); obj.hit(timestamp); int param_2 = obj.getHits(timestamp);*/ lang: java12]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[360. Sort Transformed Array]]></title>
    <url>%2F2017%2F09%2F26%2F360-Sort-Transformed-Array%2F</url>
    <content type="text"><![CDATA[Given a sorted array of integers nums and integer values a, b and c. Apply a function of the form f(x) = ax2 + bx + c to each element x in the array. The returned array must be in sorted order. Expected time complexity: O(n) Example:1234567nums = [-4, -2, 2, 4], a = 1, b = 3, c = 5,Result: [3, 9, 15, 33]nums = [-4, -2, 2, 4], a = -1, b = 3, c = 5Result: [-23, -5, 1, 7] 解法1： Two pointers + Math如果a是正数，那么在边缘的x所对应的数字是最大的，而最小值在中间。如果a是负数，那么在边缘的x所对应的数字是最小的，最大值在中间。可以改变要写入的位置来精简代码。 lang: java12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int[] sortTransformedArray(int[] nums, int a, int b, int c) &#123; int n = nums.length; int[] res = new int[n]; int i = 0, j = n - 1; int index = a &gt;= 0 ? n - 1 : 0; while (i &lt;= j) &#123; int left = calc(nums[i], a, b, c); int right = calc(nums[j], a, b, c); if (a &gt;= 0) &#123; if (left &gt;= right) &#123; res[index--] = left; i++; &#125; else &#123; res[index--] = right; j--; &#125; &#125; else &#123; if (left &gt;= right) &#123; res[index++] = right; j--; &#125; else &#123; res[index++] = left; i++; &#125; &#125; &#125; return res; &#125; private int calc(int num, int a, int b, int c) &#123; return a * num * num + b * num + c; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[260. Single Number III]]></title>
    <url>%2F2017%2F09%2F26%2F260-Single-Number-III%2F</url>
    <content type="text"><![CDATA[Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. For example: Given nums = [1, 2, 1, 3, 2, 5], return [3, 5]. Note:The order of the result is not important. So in the above example, [5, 3] is also correct.Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity? 解法1： Bit Manipulation这题挺好的。思维很巧妙。首先还是要用XOR， 如果我们先把所有数字XOR一遍，那么结果就是A ^ B. 其中A，B就是我们要找的两个数。而这个结果一定不是0.那么如果我们随便找一个setbit， 就可以把原来的数组分成这个bit被set和不被set的两组。要求的数一定分别在这两组里面。对每一组分别求XOR就可以得到要求的结果。其中求一个number的一个bit可以用一个小技巧1number &amp; (-number) 可以得到rightmost setbitlang: java12345678910111213141516171819202122232425class Solution &#123; public int[] singleNumber(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return new int[0]; &#125; int[] res = new int[2]; int xor = 0; for (int num : nums) &#123; xor ^= num; &#125; int setBit = xor &amp; (-xor); for (int num : nums) &#123; if ( (num &amp; setBit) == 0) &#123; res[0] ^= num; &#125; else &#123; res[1] ^= num; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[254. Factor Combinations]]></title>
    <url>%2F2017%2F09%2F26%2F254-Factor-Combinations%2F</url>
    <content type="text"><![CDATA[Numbers can be regarded as product of its factors. For example,128 = 2 x 2 x 2; = 2 x 4. Write a function that takes an integer n and return all possible combinations of its factors. Note:You may assume that n is always positive.Factors should be greater than 1 and less than n.Examples:input: 1output:1[] input: 37output:1[] input: 12output:12345[ [2, 6], [2, 2, 3], [3, 4]] input: 32output:12345678[ [2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8]] 解法1： Backtrackinglang: java123456789101112131415161718192021222324252627282930313233class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; getFactors(int n) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; current = new ArrayList&lt;&gt;(); if (n &lt;= 2) return res; helper(n, 2, current, res); return res; &#125; private void helper(int n, int start, List&lt;Integer&gt; current, List&lt;List&lt;Integer&gt;&gt; res) &#123; if (n &lt;= 0) &#123; return; &#125; if (n == 1) &#123; if (current.size() &gt; 1) &#123; res.add(new ArrayList&lt;Integer&gt;(current)); return; &#125; &#125; for (int i = start; i &lt;= n; i++) &#123; if (n % i == 0) &#123; current.add(i); helper(n / i, i, current, res); current.remove(current.size() - 1); &#125; &#125; return; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[253. Meeting Rooms II]]></title>
    <url>%2F2017%2F09%2F26%2F253-Meeting-Rooms-II%2F</url>
    <content type="text"><![CDATA[Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],…] (si &lt; ei), find the minimum number of conference rooms required. For example,Given [[0, 30],[5, 10],[15, 20]],return 2 解法1： Sweep Line / 扫描线扫描线的基础题。基本的思路是把所有的线段的两个断点都归类并且排序，然后碰到起点就+1，碰到终点就-1，按照时间的顺序遍历，相当于有一根线在从左面扫到右面。实际在写code的时候可以有不同的写法，第一种是用了一种比较少用的数据结构，TreeMap。这个hashmap存储的是对于每一个时间点的计数，不同的是，对于起点计数+1，对于终点计数-1， 表现的就是如果一个会议结束了当前的room就释放出来不需要了，所以自然需要的room的个数-1。然后需要按照时间顺序遍历每一个时间点，把所有的room的变化加和，在加和的过程中保留下遇见过的最大值）。TreeMap的key是按照natural order排序的，所以很适合这个问题。 lang: java1234567891011121314151617181920212223242526272829303132333435/** * Definition for an interval. * public class Interval &#123; * int start; * int end; * Interval() &#123; start = 0; end = 0; &#125; * Interval(int s, int e) &#123; start = s; end = e; &#125; * &#125; */class Solution &#123; public int minMeetingRooms(Interval[] intervals) &#123; if (intervals == null || intervals.length == 0) &#123; return 0; &#125; // Map&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;(); // Treat start and end as the natural time point // Takes O(logN) for each operation for (Interval it : intervals) &#123; map.put(it.start, map.getOrDefault(it.start, 0) + 1); map.put(it.end, map.getOrDefault(it.end, 0) - 1); &#125; int rooms = 0; int res = 0; for (int timePoint : map.keySet()) &#123; // timePoint is sorted in ascending order rooms += map.get(timePoint); res = Math.max(res, rooms); &#125; return res; &#125;&#125; 解法2： Sorting Array同样的思路，不同的写法。也可以维护两个数组，start, end. 把对应的时间点放进去进行排序。然后用两个指针指向两个数组，当start &lt; end的时候需要的room+1， 反之则room-1. 然后在更新的过程中统计出现过的最大的room的个数。lang: java1234567891011121314151617181920212223242526272829303132333435/** * Definition for an interval. * public class Interval &#123; * int start; * int end; * Interval() &#123; start = 0; end = 0; &#125; * Interval(int s, int e) &#123; start = s; end = e; &#125; * &#125; */class Solution &#123; public int minMeetingRooms(Interval[] intervals) &#123; int n = intervals.length; int[] start = new int[n]; int[] end = new int[n]; for (int i = 0; i &lt; intervals.length; i++) &#123; start[i] = intervals[i].start; end[i] = intervals[i].end; &#125; Arrays.sort(start); Arrays.sort(end); int endptr = 0; int res = 0; for (int i = 0; i &lt; n; i++) &#123; if (start[i] &lt; end[endptr]) &#123; res++; &#125; else &#123; endptr++; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>扫描线</tag>
        <tag>TreeMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[251. Flatten 2D Vector]]></title>
    <url>%2F2017%2F09%2F26%2F251-Flatten-2D-Vector%2F</url>
    <content type="text"><![CDATA[Implement an iterator to flatten a 2d vector. For example,Given 2d vector = [ [1,2], [3], [4,5,6]]By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,2,3,4,5,6]. Follow up:As an added challenge, try to code it using only iterators in C++ or iterators in Java. 解法1： Non-Iterator, List + Pointer用一个list来存储原来的数据。同时维护两个指针，一个指向当前的子list，另一个指向该list中的位置。在hasNext函数中，判断是否还有数据查看elemenPointer是不是在list尾巴，同时检查是否还有下一个list。 lang: java12345678910111213141516171819202122232425262728293031323334public class Vector2D implements Iterator&lt;Integer&gt; &#123; List&lt;List&lt;Integer&gt;&gt; data; int listPos; int elemPos; public Vector2D(List&lt;List&lt;Integer&gt;&gt; vec2d) &#123; this.data = vec2d; listPos = 0; elemPos = 0; &#125; @Override public Integer next() &#123; return data.get(listPos).get(elemPos++); &#125; @Override public boolean hasNext() &#123; while (listPos &lt; data.size()) &#123; if (elemPos &lt; data.get(listPos).size()) &#123; return true; &#125; else &#123; listPos++; elemPos = 0; &#125; &#125; return false; &#125;&#125;/** * Your Vector2D object will be instantiated and called as such: * Vector2D i = new Vector2D(vec2d); * while (i.hasNext()) v[f()] = i.next(); */ 解法2： Iterator用一个queue来存储每一个list对应的iterator。同时维护一个iterator指向当前的iterator。hasNext就需要判断当前是否还有iterator同时这个iterator是否有下一个元素。 lang: java1234567891011121314151617181920212223242526272829303132333435public class Vector2D implements Iterator&lt;Integer&gt; &#123; Queue&lt;Iterator&lt;Integer&gt;&gt; queue; Iterator&lt;Integer&gt; current = null; public Vector2D(List&lt;List&lt;Integer&gt;&gt; vec2d) &#123; queue = new LinkedList&lt;&gt;(); for (List&lt;Integer&gt; list : vec2d) &#123; queue.offer(list.iterator()); &#125; current = queue.poll(); &#125; @Override public Integer next() &#123; return current.next(); &#125; @Override public boolean hasNext() &#123; while (current == null || !current.hasNext()) &#123; if (!queue.isEmpty()) &#123; current = queue.poll(); &#125; else &#123; return false; &#125; &#125; return true; &#125;&#125;/** * Your Vector2D object will be instantiated and called as such: * Vector2D i = new Vector2D(vec2d); * while (i.hasNext()) v[f()] = i.next(); */]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[249. Group Shifted Strings]]></title>
    <url>%2F2017%2F09%2F26%2F249-Group-Shifted-Strings%2F</url>
    <content type="text"><![CDATA[Given a string, we can “shift” each of its letter to its successive letter, for example: “abc” -&gt; “bcd”. We can keep “shifting” which forms the sequence:1&quot;abc&quot; -&gt; &quot;bcd&quot; -&gt; ... -&gt; &quot;xyz&quot; Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence. For example, given: [“abc”, “bcd”, “acef”, “xyz”, “az”, “ba”, “a”, “z”],A solution is:123456[ [&quot;abc&quot;,&quot;bcd&quot;,&quot;xyz&quot;], [&quot;az&quot;,&quot;ba&quot;], [&quot;acef&quot;], [&quot;a&quot;,&quot;z&quot;]] 解法1： HashMap基本的思路是要构造一个hash function，使得属于一个sequence的字符串可以group到一起。一个思路是把每一个字符转换成对于与第一个字符的位置。这里要处理的是负数的情况，比如ba,az，这里用到的trick是用(diff + 26) % 26 来转换成正整数。同时要注意的是需要分隔开不同的数字，因为对于012不能区分是0-12还是0-1-2.lang: java1234567891011121314151617181920212223242526272829303132class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupStrings(String[] strings) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); if (strings == null || strings.length == 0) &#123; return res; &#125; // Design a hash function Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (String str : strings) &#123; // construct the hash key StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; str.length(); i++) &#123; sb.append(Integer.toString((str.charAt(i) - str.charAt(0) + 26) % 26)); sb.append(&quot;.&quot;); &#125; String key = sb.toString(); if (!map.containsKey(key)) &#123; map.put(key, new ArrayList&lt;String&gt;()); &#125; map.get(key).add(str); &#125; for (String key : map.keySet()) &#123; res.add(map.get(key)); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[247. Strobogrammatic Number II]]></title>
    <url>%2F2017%2F09%2F26%2F247-Strobogrammatic-Number-II%2F</url>
    <content type="text"><![CDATA[A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Find all strobogrammatic numbers that are of length = n. For example,Given n = 2, return [“11”,”69”,”88”,”96”]. 解法1： Recursion承接I的思路，当数字长度大于1的时候，都需要配对存在。要注意的是00配对只可能存在内层中，所以在递归的时候需要用一个变量记录原来n的长度。这样当不是最外层的时候就可以把0加上了。 lang: java1234567891011121314151617181920212223class Solution &#123; public List&lt;String&gt; findStrobogrammatic(int n) &#123; return helper(n, n); &#125; private List&lt;String&gt; helper(int n, int m) &#123; if (n == 0) return new ArrayList&lt;String&gt;(Arrays.asList(&quot;&quot;)); if (n == 1) return new ArrayList&lt;String&gt;(Arrays.asList(&quot;0&quot;,&quot;1&quot;,&quot;8&quot;)); List&lt;String&gt; next = helper(n - 2, m); List&lt;String&gt; res = new ArrayList&lt;&gt;(); for (String str : next) &#123; if (n != m) res.add(&quot;0&quot; + str + &quot;0&quot;); res.add(&quot;1&quot; + str + &quot;1&quot;); res.add(&quot;6&quot; + str + &quot;9&quot;); res.add(&quot;8&quot; + str + &quot;8&quot;); res.add(&quot;9&quot; + str + &quot;6&quot;); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[241. Different Ways to Add Parentheses]]></title>
    <url>%2F2017%2F09%2F23%2F241-Different-Ways-to-Add-Parentheses%2F</url>
    <content type="text"><![CDATA[Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *. Example 112345Input: &quot;2-1-1&quot;.((2-1)-1) = 0(2-(1-1)) = 2Output: [0, 2] Example 212345678Input: &quot;2*3-4*5&quot;(2*(3-(4*5))) = -34((2*3)-(4*5)) = -14((2*(3-4))*5) = -10(2*((3-4)*5)) = -10(((2*3)-4)*5) = 10Output: [-34, -14, -10, -10, 10] 解法1：用Divide &amp; Conquer的思想，按照每一个运算符号分成左右两边。每边计算一下结果然后按照运算符号结合起来。当只有数字的时候所生成的res一定为空，这个时候就把数字加入res即可。 lang: java123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public List&lt;Integer&gt; diffWaysToCompute(String input) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; input.length(); i++) &#123; if (input.charAt(i) == &apos;+&apos; || input.charAt(i) == &apos;-&apos; || input.charAt(i) == &apos;*&apos;) &#123; String left = input.substring(0, i); String right = input.substring(i + 1); List&lt;Integer&gt; leftRes = diffWaysToCompute(left); List&lt;Integer&gt; rightRes = diffWaysToCompute(right); for (int l : leftRes) &#123; for (int r : rightRes) &#123; switch (input.charAt(i)) &#123; case &apos;+&apos; : res.add(l + r); break; case &apos;-&apos;: res.add(l - r); break; case &apos;*&apos;: res.add( l * r); break; &#125; &#125; &#125; &#125; &#125; if (res.size() == 0) &#123; res.add(Integer.parseInt(input)); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[223. Rectangle Area]]></title>
    <url>%2F2017%2F09%2F22%2F223-Rectangle-Area%2F</url>
    <content type="text"><![CDATA[Find the total area covered by two rectilinear rectangles in a 2D plane. Each rectangle is defined by its bottom left corner and top right corner as shown in the figure. Assume that the total area is never beyond the maximum possible value of int. 解法1：lang: java123456789101112131415161718192021222324252627class Solution &#123; public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) &#123; int left = (C - A) * (D - B); int right = (G - E) * (H - F); // on the left or right side if (E &gt;= C || G &lt;= A) &#123; return left + right; &#125; // above or below if (F &gt;= D || H &lt;= B ) &#123; return left + right; &#125; // overlap int ldx = Math.max(A, E); int ldy = Math.max(B, F); int rux = Math.min(C, G); int ruy = Math.min(D, H); int cross = (rux - ldx) * (ruy - ldy); return left + right - cross; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[220. Contains Duplicate III]]></title>
    <url>%2F2017%2F09%2F22%2F220-Contains-Duplicate-III%2F</url>
    <content type="text"><![CDATA[Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k. 解法1： TreeSet, O(nlog(k, n))这里用到一个比较特殊的数据结构treeset。实际上这是一个self-balancing binary search tree, 他的基本操作都是O(logN)的。而且他还有两个额外的功能很有用set.ceiling(T)和set.floor(T)ceiling返回的是大于等于T的最小的元素，而floor返回的是小于等于T的最大元素。那么我们维护一个大小为k的set，这样就满足了一个条件。那第二个条件满足的条件就是对于每一个num，找出他的ceiling和floor，看是否在范围内即可。lang: java1234567891011121314151617181920212223242526class Solution &#123; public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123; if (nums == null || nums.length == 0) &#123; return false; &#125; TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int current = nums[i]; Integer ceiling = set.ceiling(current); Integer floor = set.floor(current); if (ceiling != null &amp;&amp; ceiling &lt;= current + t) &#123; return true; &#125; if (floor != null &amp;&amp; current &lt;= floor + t) &#123; return true; &#125; set.add(current); if (set.size() &gt; k) &#123; set.remove(nums[i - k]); &#125; &#125; return false; &#125;&#125; 解法2： O(N) using Bucketlang: java1234567891011121314151617181920212223242526272829303132333435class Solution &#123; private long getBucketId(long num, long w) &#123; return num &lt; 0 ? (num + 1) / w - 1 : num / w; &#125; public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123; if (t &lt; 0 ) return false; if (nums == null || nums.length == 0) &#123; return false; &#125; long w = (long)t + 1; Map&lt;Long, Long&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; long id = getBucketId((long)nums[i], w); if (map.containsKey(id)) &#123; return true; &#125; if (map.containsKey(id - 1) &amp;&amp; Math.abs(map.get(id - 1) - nums[i]) &lt; w) &#123; return true; &#125; if (map.containsKey(id + 1) &amp;&amp; Math.abs(map.get(id + 1) - nums[i]) &lt; w) &#123; return true; &#125; map.put(id, (long)nums[i]); if (i &gt;= k) &#123; map.remove(getBucketId(nums[i - k], w)); &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>TreeSet</tag>
        <tag>Buckets</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[137. Single Number II]]></title>
    <url>%2F2017%2F09%2F18%2F137-Single-Number-II%2F</url>
    <content type="text"><![CDATA[Given an array of integers, every element appears three times except for one, which appears exactly once. Find that single one. Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 解法1： O(N) Time + O(1) Space主要的思路是对于每一位（32中的一位），如果一个数字出现三次的话，该位出现次数为1.如果统计每一个位数上的出现次数，再对3取余，那么剩下的每一个位子上的1就是只出现一次的数。这个思想也可以递推到其他的出现频率题上。 lang: java123456789101112131415161718192021222324class Solution &#123; public int singleNumber(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int ans = 0; for (int i = 0; i &lt; 32; i++) &#123; int count = 0; for (int num : nums) &#123; if (((num &gt;&gt; i) &amp; 1) == 1) &#123; count++; &#125; &#125; count = count % 3; if (count != 0) &#123; ans |= (1 &lt;&lt; i); &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[134. Gas Station]]></title>
    <url>%2F2017%2F09%2F18%2F134-Gas-Station%2F</url>
    <content type="text"><![CDATA[There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1. Note:The solution is guaranteed to be unique. 解法1： Greedylang: java12345678910111213141516171819202122232425class Solution &#123; public int canCompleteCircuit(int[] gas, int[] cost) &#123; if (gas == null || gas.length == 0 || cost == null || cost.length == 0) &#123; return -1; &#125; int sum = 0, total = 0, pos = -1; for (int i = 0; i &lt; gas.length; i++) &#123; sum += gas[i] - cost[i]; total += sum; if (sum &lt; 0) &#123; pos = i; sum = 0; // reset sum to be zero &#125; &#125; if (total &lt; 0) &#123; return -1; &#125; return pos + 1; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Greddy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[130. Surrounded Regions]]></title>
    <url>%2F2017%2F09%2F18%2F130-Surrounded-Regions%2F</url>
    <content type="text"><![CDATA[Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’. A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region. For example,1234X X X XX O O XX X O XX O X X After running your function, the board should be:1234X X X XX X X XX X X XX O X X 解法1: DFS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Solution &#123; int[][] ds = new int[][]&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;; public void solve(char[][] board) &#123; if (board == null || board.length == 0 || board[0] == null || board[0].length == 0) &#123; return; &#125; int row = board.length; int col = board[0].length; for (int i = 0; i &lt; row; i++) &#123; if (board[i][0] == &apos;O&apos;) &#123; dfs(board, i, 0); &#125; if (board[i][col - 1] == &apos;O&apos;) &#123; dfs(board, i, col - 1); &#125; &#125; for (int j = 0; j &lt; col; j++) &#123; if (board[0][j] == &apos;O&apos;) &#123; dfs(board, 0, j); &#125; if (board[row - 1][j] == &apos;O&apos;) &#123; dfs(board, row - 1, j); &#125; &#125; // Need to convert all &apos;M&apos; into &apos;O&apos; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; if (board[i][j] == &apos;O&apos;) &#123; board[i][j] = &apos;X&apos;; &#125; else if (board[i][j] == &apos;M&apos;) &#123; board[i][j] = &apos;O&apos;; &#125; &#125; &#125; &#125;// private void dfs(char[][] board, int i, int j) &#123;// board[i][j] = &apos;M&apos;;// for (int[] d : ds) &#123;// int x = i + d[0];// int y = j + d[1];// if (x &gt;= 0 &amp;&amp; x &lt; board.length &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; board[0].length &amp;&amp; board[x][y] == &apos;O&apos;) &#123;// dfs(board, x, y);// &#125;// &#125;// &#125; private void dfs(char[][] board, int i, int j) &#123; if (i &lt; 0 || i &gt; board.length - 1 || j &lt;0 || j &gt; board[0].length - 1) return; if (board[i][j] == &apos;O&apos;) board[i][j] = &apos;M&apos;; if (i &gt; 1 &amp;&amp; board[i-1][j] == &apos;O&apos;) dfs(board, i-1, j); if (i &lt; board.length - 2 &amp;&amp; board[i+1][j] == &apos;O&apos;) dfs(board, i+1, j); if (j &gt; 1 &amp;&amp; board[i][j-1] == &apos;O&apos;) dfs(board, i, j-1); if (j &lt; board[i].length - 2 &amp;&amp; board[i][j+1] == &apos;O&apos; ) dfs(board, i, j+1); &#125;&#125; 解法2: BFS这题DFS的解法非常容易出现stack overflow。 主要的原因是在判断对那个方向进行DFS的时候如果不避免边界上的点的话就会overflow，所以我们要跳过那些边界的点而只看纵深的点。如果用BFS的话情况会好不少，不过要写对也不容易。基本思路也是对于边界上的O点，使用BFS把所有相通的都标注一下。不过在进行BFS的时候，每一个新的点push进queue的时候，立即把他标注成M，这样可以减少push的点。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution &#123; int[][] directions = new int[][]&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;; public void solve(char[][] board) &#123; if (board == null || board.length == 0 || board[0] == null || board[0].length == 0) &#123; return; &#125; int m = board.length; int n = board[0].length; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; m; i++) &#123; if (board[i][0] == 'O') &#123; bfs(board, i, 0); &#125; if (board[i][n - 1] == 'O') &#123; bfs(board, i, n - 1); &#125; &#125; for (int j = 0; j &lt; n; j++) &#123; if (board[0][j] == 'O') &#123; bfs(board, 0, j); &#125; if (board[m - 1][j] == 'O') &#123; bfs(board, m - 1, j); &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (board[i][j] == 'O')&#123; board[i][j] = 'X'; &#125; else if (board[i][j] == 'M') &#123; board[i][j] = 'O'; &#125; &#125; &#125; &#125; private void bfs(char[][] board, int i, int j) &#123; int m = board.length; int n = board[0].length; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.offer(i * n + j); board[i][j] = 'M'; while (!queue.isEmpty()) &#123; int temp = queue.poll(); int row = temp / n; int col = temp % n; for (int[] dir : directions) &#123; int x = row + dir[0]; int y = col + dir[1]; if (x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; board[x][y] == 'O') &#123; queue.offer(x * n + y); board[x][y] = 'M'; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>DFS</tag>
        <tag>Union Find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题型总结: 滑动窗口 Sliding Window]]></title>
    <url>%2F2017%2F09%2F10%2FAlgorithm-Summary-Sliding-Window%2F</url>
    <content type="text"><![CDATA[基本思路滑动窗口的问题可以解决一系列，有两个字符串，找一个字符串存在另一个字符串的某种性质的问题。可以解决的问题参考同名tag. 这里只是列举一下模板 1234567891011121314151617181920212223242526272829303132333435363738394041&#125;int SlidingWindow(String s, String p) &#123; // 先建立一个map来存储p中的每一个字符出现的次数,etc Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (char ch: p.toCharArray()) &#123; map.put(ch, ...) &#125; // 然后用两个左右指针，右指针遍历字符串s。同时需要维护一个变量count, // 这个变量的作用在于知晓需要找的性质是否找到之类的问题。 int start = 0, end = 0, count = 0; while (end &lt; s.length()) &#123; char right = s.charAt(end); // 更新map中对应的数值, 同时需要更新count // count更新的条件取决于不同的题目。比如可以是所有的字符都出现过了。 if (map.containsKey(right)) &#123; // ... if (map.get(right) == 0) count--; &#125; // 查看寻找的条件是否已达到 while (count == 0) &#123; // 更新要求的答案 // 更新count start++; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>题型总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[294. Flip Game II]]></title>
    <url>%2F2017%2F08%2F17%2F2017-08-17-294-Flip-Game-II%2F</url>
    <content type="text"><![CDATA[You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two consecutive “++” into “–”. The game ends when a person can no longer make a move and therefore the other person will be the winner. Write a function to determine if the starting player can guarantee a win. For example, given s = “++++”, return true. The starting player can guarantee a win by flipping the middle “++” to become “+–+”. Follow up:Derive your algorithm’s runtime complexity. 解法1：DFS O(N!!)每次尝试一个可以flip的位置，然后进行下一轮，如果下一轮的人不能获胜，则证明first player可以赢。Time Complexity 按照这个人说的：1For the time complexity, here is what I thought, let&apos;s say the length of the input string s is n, there are at most n - 1 ways to replace &quot;++&quot; to &quot;--&quot; (imagine s is all &quot;+++...&quot;), once we replace one &quot;++&quot;, there are at most (n - 2) - 1 ways to do the replacement, it&apos;s a little bit like solving the N-Queens problem, the time complexity is (n - 1) x (n - 3) x (n - 5) x ..., so it&apos;s O(n!!), double factorial. C++1 Java1 解法2： DP参考这篇：https://leetcode.com/problems/flip-game-ii/discuss/]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[379. Design Phone Directory]]></title>
    <url>%2F2017%2F08%2F17%2F2017-08-17-379-Design-Phone-Directory%2F</url>
    <content type="text"><![CDATA[Design a Phone Directory which supports the following operations: get: Provide a number which is not assigned to anyone.check: Check if a number is available or not.release: Recycle or release a number.Example:1234567891011121314151617181920212223// Init a phone directory containing a total of 3 numbers: 0, 1, and 2.PhoneDirectory directory = new PhoneDirectory(3);// It can return any available phone number. Here we assume it returns 0.directory.get();// Assume it returns 1.directory.get();// The number 2 is available, so return true.directory.check(2);// It returns 2, the only number that is left.directory.get();// The number 2 is no longer available, so return false.directory.check(2);// Release number 2 back to the pool.directory.release(2);// Number 2 is available again, return true.directory.check(2); 解法1：用一个hashset存储号码。get的时候用directory.iterator().next()来得到下一个数字。C++1 Java1234567891011121314151617181920212223242526272829303132333435363738394041424344public class PhoneDirectory &#123; HashSet&lt;Integer&gt; directory; /** Initialize your data structure here @param maxNumbers - The maximum numbers that can be stored in the phone directory. */ public PhoneDirectory(int maxNumbers) &#123; directory = new HashSet&lt;Integer&gt;(); for (int i = 0; i &lt; maxNumbers; i++) &#123; directory.add(i); &#125; &#125; /** Provide a number which is not assigned to anyone. @return - Return an available number. Return -1 if none is available. */ public int get() &#123; if (directory.size() == 0) &#123; return -1; &#125; int key = directory.iterator().next(); directory.remove(key); return key; &#125; /** Check if a number is available or not. */ public boolean check(int number) &#123; return directory.contains(number); &#125; /** Recycle or release a number. */ public void release(int number) &#123; directory.add(number); &#125;&#125;/** * Your PhoneDirectory object will be instantiated and called as such: * PhoneDirectory obj = new PhoneDirectory(maxNumbers); * int param_1 = obj.get(); * boolean param_2 = obj.check(number); * obj.release(number); */]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[328. Odd Even Linked List]]></title>
    <url>%2F2017%2F08%2F17%2F2017-08-17-328-Odd-Even-Linked-List%2F</url>
    <content type="text"><![CDATA[You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.123Example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL,return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL. Note:The relative order inside both the even and odd groups should remain as it was in the input.The first node is considered odd, the second node even and so on … 解法1：考虑1-&gt;2-&gt;3-&gt;4这个情况，实际上只需要修改成1-&gt;3-&gt;4,2-&gt;4就可以了，然后把odd指针往下移动一格，even指针往下移动一格就可以了。C++1 Java12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode oddEvenList(ListNode head) &#123; if (head == null || head.next == null || head.next.next == null) &#123; return head; &#125; ListNode oddHead = head, evenHead = head.next; ListNode odd = oddHead, even = evenHead; while (even != null &amp;&amp; even.next != null) &#123; ListNode temp = even.next; even.next = even.next.next; // skip next odd following the current even odd.next = temp; odd = odd.next; even = even.next; &#125; // odd point to the tail of the list odd.next = evenHead; return oddHead; &#125;&#125; 另一种写法1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode oddEvenList(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode odd = new ListNode(1); ListNode even = new ListNode(2); ListNode odd_tail = odd; ListNode even_tail = even; int i = 1; while (head != null) &#123; if (i % 2 == 1) &#123; odd_tail.next = head; odd_tail = odd_tail.next; &#125; else &#123; even_tail.next = head; even_tail = even_tail.next; &#125; head = head.next; i++; &#125; odd_tail.next = even.next; even_tail.next = null; return odd.next; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[148. Sort List]]></title>
    <url>%2F2017%2F08%2F17%2F2017-08-17-148-Sort-List%2F</url>
    <content type="text"><![CDATA[Sort a linked list in O(n log n) time using constant space complexity. 解法1： Merge Sort考察了几个基本算法：linkedlist找中点linkedlist merge C++1 Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode sortList(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; // Cut into half, i.e. look for the middle point ListNode slow = head, fast = head.next; while (fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; fast = fast.next.next; &#125; // break from the middle point ListNode rightHead = slow.next; slow.next = null; // Sort on each half ListNode left = sortList(head); ListNode right = sortList(rightHead); // Merge return merge(left, right); &#125; private ListNode merge(ListNode left, ListNode right) &#123; ListNode dummy = new ListNode(0); ListNode tail = dummy; while (left != null &amp;&amp; right != null) &#123; if (left.val &lt; right.val) &#123; tail.next = left; left = left.next; &#125; else &#123; tail.next = right; right = right.next; &#125; tail = tail.next; &#125; if (left != null) &#123; tail.next = left; &#125; if (right != null) &#123; tail.next = right; &#125; return dummy.next; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[82. Remove Duplicates from Sorted List II]]></title>
    <url>%2F2017%2F08%2F17%2F2017-08-17-82-Remove-Duplicates-from-Sorted-List-II%2F</url>
    <content type="text"><![CDATA[Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. For example,Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3. 解法1：用dummy node解决。slow表示下一个插入位置。fast表示当前的元素。fast和它下一个元素相比，如果相同则跳过。最后再按照两种情况分别处理，一个是slow指向的下一个元素就是fast，也就是说fast原来指向的数值是unique的，那么slow和fast都向前移动。如果slow下一个元素和fast不同，那么需要跳过slow和fast当中的元素。C++1 Java12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if (head == null) &#123; return head; &#125; ListNode dummy = new ListNode(0); dummy.next = head; ListNode slow = dummy, fast = head; while (fast != null) &#123; while (fast.next != null &amp;&amp; fast.val == fast.next.val) &#123; fast = fast.next; &#125; if (slow.next != fast) &#123; slow.next = fast.next; fast = slow.next; &#125; else &#123; slow = slow.next; fast = fast.next; &#125; &#125; return dummy.next; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[369. Plus One Linked List]]></title>
    <url>%2F2017%2F08%2F17%2F2017-08-17-369-Plus-One-Linked-List%2F</url>
    <content type="text"><![CDATA[Given a non-negative integer represented as non-empty a singly linked list of digits, plus one to the integer. You may assume the integer do not contain any leading zero, except the number 0 itself. The digits are stored such that the most significant digit is at the head of the list. Example:12345Input:1-&gt;2-&gt;3Output:1-&gt;2-&gt;4 解法1：考察linkedlist基本功的一道题，先reverse再加1再reverseC++1 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode plusOne(ListNode head) &#123; if (head == null) &#123; return head; &#125; ListNode headReversed = reverse(head); int carry = 1; head = headReversed; ListNode prev = head; while (head != null) &#123; prev = head; int digit = (head.val + carry) % 10; carry = (head.val + carry) / 10; head.val = digit; head = head.next; &#125; if (carry != 0) &#123; ListNode temp = new ListNode(carry); prev.next = temp; &#125; // reverse back to get the desired result return reverse(headReversed); &#125; private ListNode reverse(ListNode head) &#123; ListNode prev = null; while (head != null) &#123; ListNode temp = head.next; head.next = prev; prev = head; head = temp; &#125; return prev; &#125;&#125; 解法2: Recursion此题也可以用递归的办法做。因为递归会自然的把list倒过来处理。 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode plusOne(ListNode head) &#123; int carry = dfs(head); if (carry == 0) &#123; return head; &#125; ListNode newHead = new ListNode(carry); newHead.next = head; return newHead; &#125; private int dfs(ListNode head) &#123; if (head == null) return 1; int carry = dfs(head.next); if (carry == 0) return 0; int val = head.val + 1; head.val = val % 10; return val / 10; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[142. Linked List Cycle II]]></title>
    <url>%2F2017%2F08%2F17%2F2017-08-17-142-Linked-List-Cycle-II%2F</url>
    <content type="text"><![CDATA[Given a linked list, return the node where the cycle begins. If there is no cycle, return null. Note: Do not modify the linked list. Follow up:Can you solve it without using extra space? 解法1：一个老题。快慢两个指针，等相遇的时候slow继续往前走一个然后继续前行，fast回到原点然后一次一步直到再次相遇就是他们的交点。C++1 Java123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; if (head == null) &#123; return null; &#125; ListNode slow = head, fast = head.next; while (fast != slow) &#123; if (fast == null || fast.next == null) &#123; return null; &#125; fast = fast.next.next; slow = slow.next; &#125; slow = slow.next; fast = head; while (fast != slow) &#123; fast = fast.next; slow = slow.next; &#125; return fast; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[207. Course Schedule]]></title>
    <url>%2F2017%2F08%2F17%2F2017-08-17-207-Course-Schedule%2F</url>
    <content type="text"><![CDATA[There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? For example:12, [[1,0]] There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.12, [[1,0],[0,1]] There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible. 解法1：有向图这题和Course Schedule II的解法基本一样，就是判断有向图中是否有环。基本的入度出度的解法要掌握。C++1 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Solution &#123; public boolean canFinish(int numCourses, int[][] prerequisites) &#123; if (prerequisites == null || prerequisites.length == 0) &#123; return true; &#125; // no circle in the graph + number of visited nodes == numCourses int[] ins = new int[numCourses]; Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;Integer, List&lt;Integer&gt;&gt;(); for (int[] pre : prerequisites) &#123; if (!map.containsKey(pre[1])) &#123; map.put(pre[1], new ArrayList&lt;Integer&gt;()); &#125; map.get(pre[1]).add(pre[0]); // because of no duplicate edges in the input prerequisities ins[pre[0]]++; // add the in-count for the node &#125; Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); for (int i = 0; i &lt; numCourses; i++) &#123; if (ins[i] == 0) &#123; queue.offer(i); &#125; &#125; while (!queue.isEmpty()) &#123; int root = queue.poll(); if (map.containsKey(root)) &#123; List&lt;Integer&gt; children = map.get(root); for (int child : children) &#123; ins[child] -= 1; if (ins[child] == 0) &#123; queue.offer(child); &#125; &#125; &#125; &#125; // check if there is non-zero ins for (int i = 0; i &lt; numCourses; i++) &#123; if (ins[i] != 0) &#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[210. Course Schedule II]]></title>
    <url>%2F2017%2F08%2F17%2F2017-08-17-210-Course-Schedule-II%2F</url>
    <content type="text"><![CDATA[There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. For example:12, [[1,0]] There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]14, [[1,0],[2,0],[3,1],[3,2]] There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3]. Note:The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.You may assume that there are no duplicate edges in the input prerequisites. 1234Hints:This problem is equivalent to finding the topological order in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.Topological sort could also be done via BFS. 解法1：有向图， 拓扑排序有向图的问题用入度和出度解决的比较多。这题用BFS解决，push进queue的是所有入度为0的点。如果有向图有环，则表示图中有互相依赖的课程存在。如果最后没有入度不为0的点，则说明是一个无环有向图。 C++1 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Solution &#123; public int[] findOrder(int numCourses, int[][] prerequisites) &#123; int[] res = new int[numCourses]; if (prerequisites == null || prerequisites.length == 0) &#123; for (int i = 0; i &lt; numCourses; i++) &#123; res[i] = i; &#125; return res; &#125;w // Construct the graph HashMap&lt;Integer, List&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); int[] ins = new int[numCourses]; for (int[] pre : prerequisites) &#123; if (!graph.containsKey(pre[1])) &#123; graph.put(pre[1], new ArrayList&lt;Integer&gt;()); &#125; graph.get(pre[1]).add(pre[0]); ins[pre[0]]++; &#125; Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); for (int i = 0; i &lt; numCourses; i++) &#123; if (ins[i] == 0) &#123; queue.offer(i); &#125; &#125; int pos = 0; while (!queue.isEmpty()) &#123; int root = queue.poll(); res[pos++] = root; if (graph.containsKey(root)) &#123; List&lt;Integer&gt; subs = graph.get(root); for (int sub : subs) &#123; ins[sub]--; if (ins[sub] == 0) &#123; queue.offer(sub); &#125; &#125; &#125; &#125; for (int i = 0; i &lt; numCourses; i++) &#123; if (ins[i] != 0) &#123; return new int[0]; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[542. 01 Matrix]]></title>
    <url>%2F2017%2F08%2F17%2F2017-08-17-542-01-Matrix%2F</url>
    <content type="text"><![CDATA[Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1.Example 1:Input:1230 0 00 1 00 0 0 Output:1230 0 00 1 00 0 0 Example 2:Input:1230 0 00 1 01 1 1 Output:1230 0 00 1 01 2 1 Note:The number of elements of the given matrix will not exceed 10,000.There are at least one 0 in the given matrix.The cells are adjacent in only four directions: up, down, left and right. 解法1： BFS这题和那个continental divide的题的思路有点相似的地方。要反过来想问题会变简单。题意是让我们计算每一个1距离最近的0的距离。如果反过来想，我们从每一个0出发，探查四周，如果当前距离比之前的距离要短，那么更新那个单元格的数值，同时把那个单元格加入到探查的路径中。如果距离要更长，则这一支不需要再探查了。C++1 Java12&lt;!--￼4--&gt;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[364. Nested List Weight Sum II]]></title>
    <url>%2F2017%2F08%2F17%2F2017-08-17-364-Nested-List-Weight-Sum-II%2F</url>
    <content type="text"><![CDATA[Given a nested list of integers, return the sum of all integers in the list weighted by their depth. Each element is either an integer, or a list – whose elements may also be integers or other lists. Different from the previous question where weight is increasing from root to leaf, now the weight is defined from bottom up. i.e., the leaf level integers have weight 1, and the root level integers have the largest weight. Example 1:Given the list [[1,1],2,[1,1]], return 8. (four 1’s at depth 1, one 2 at depth 2) Example 2:Given the list [1,[4,[6]]], return 17. (one 1 at depth 3, one 4 at depth 2, and one 6 at depth 1; 13 + 42 + 6*1 = 17) 解法1：一个递归的办法就可以解决。因为weight现在是从bottom到top，所以要先计算出maxdepth。这一步也需要用递归完成。然后把depth作为一个参数pass到每一层就可以了。C++1 Java1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; public int depthSumInverse(List&lt;NestedInteger&gt; nestedList) &#123; if (nestedList == null || nestedList.size() == 0) &#123; return 0; &#125; // get the max sum; int maxDepth = getMaxDepth(nestedList); return helper(nestedList, maxDepth); &#125; private int getMaxDepth(List&lt;NestedInteger&gt; nestedList) &#123; int max = 1; for (int i = 0; i &lt; nestedList.size(); i++) &#123; NestedInteger item = nestedList.get(i); if (item.isInteger()) &#123; max = Math.max(max, 1); &#125; else &#123; max = Math.max(max, getMaxDepth(item.getList()) + 1); &#125; &#125; return max; &#125; private int helper(List&lt;NestedInteger&gt; nestedList, int depth) &#123; int sum = 0; for (int i = 0; i &lt; nestedList.size(); i++) &#123; NestedInteger item = nestedList.get(i); if (item.isInteger()) &#123; sum += depth * item.getInteger(); &#125; else &#123; sum += helper(item.getList(), depth - 1); &#125; &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[417. Pacific Atlantic Water Flow]]></title>
    <url>%2F2017%2F08%2F13%2F2017-08-13-417-Pacific-Atlantic-Water-Flow%2F</url>
    <content type="text"><![CDATA[Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the “Pacific ocean” touches the left and top edges of the matrix and the “Atlantic ocean” touches the right and bottom edges. Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower. Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean. Note:The order of returned grid coordinates does not matter.Both m and n are less than 150.Example:12345678910111213Given the following 5x5 matrix: Pacific ~ ~ ~ ~ ~ ~ 1 2 2 3 (5) * ~ 3 2 3 (4) (4) * ~ 2 4 (5) 3 1 * ~ (6) (7) 1 4 5 * ~ (5) 1 1 2 4 * * * * * * AtlanticReturn:[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix). 解法1： DFS 两次也是反向思维。似乎要分别判断能flow到atlantic和pacific的cell。边界上的点是确定的，所以可以从这几个点开始。逆向思维–&gt;让水从边界开始往内陆”流”，只要海拔越来越高就可以。C++1 Java12&lt;!--￼1--&gt;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[323. Number of Connected Components in an Undirected Graph]]></title>
    <url>%2F2017%2F08%2F13%2F2017-08-13-323-Number-of-Connected-Components-in-an-Undirected-Graph%2F</url>
    <content type="text"><![CDATA[Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph. Example 1:1230 3| |1 --- 2 4 Given n = 5 and edges = [[0, 1], [1, 2], [3, 4]], return 2. Example 2:1230 4| |1 --- 2 --- 3 Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]], return 1. Note:You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges. 解法1：Union-FindC++1 Java1234567891011121314151617181920212223242526public class Solution &#123; public int countComponents(int n, int[][] edges) &#123; int[] root = new int[n]; for (int i = 0; i &lt; n; i++) &#123; root[i] = i; &#125; for (int[] edge : edges) &#123; int root1 = find(root, edge[0]); int root2 = find(root, edge[1]); if (root1 != root2) &#123; root[root1] = root2; n--; &#125; &#125; return n; &#125; private int find(int[] root, int id) &#123; while (root[id] != id) &#123; id = root[id]; &#125; return id; &#125;&#125; 解法2：DFSDFS统计visited的node的个数的一种办法是，维护visited的set，每次执行一次dfs，然后到下一个节点如果没有visit过就++count。最后count就是总的visited的分隔的group的个数。Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Solution &#123; public int countComponents(int n, int[][] edges) &#123; if (edges == null || edges.length == 0 || edges[0].length == 0) &#123; return n; &#125; int count = 0; Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;Integer, List&lt;Integer&gt;&gt;(); // store the edges for (int[] edge : edges) &#123; if (!map.containsKey(edge[0])) &#123; map.put(edge[0], new ArrayList&lt;Integer&gt;()); &#125; map.get(edge[0]).add(edge[1]); if (!map.containsKey(edge[1])) &#123; map.put(edge[1], new ArrayList&lt;Integer&gt;()); &#125; map.get(edge[1]).add(edge[0]); &#125; Set&lt;Integer&gt; visited = new HashSet&lt;Integer&gt;(); // visited nodes for (int i = 0; i &lt; n; i++) &#123; if (!visited.contains(i)) &#123; count++; dfs(visited, i, map); &#125; &#125; return count; &#125; private void dfs(Set&lt;Integer&gt; visited, int current, Map&lt;Integer, List&lt;Integer&gt;&gt; map) &#123; visited.add(current); // add to visited node list if (!map.containsKey(current)) &#123; return; &#125; List&lt;Integer&gt; list = map.get(current); for (int node : list) &#123; if (!visited.contains(node)) &#123; dfs(visited, node, map); &#125; &#125; return; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[439. Tenary Expression Parser]]></title>
    <url>%2F2017%2F08%2F13%2F2017-08-13-439-Tenary-Expression-Parser%2F</url>
    <content type="text"><![CDATA[Given a string representing arbitrarily nested ternary expressions, calculate the result of the expression. You can always assume that the given expression is valid and only consists of digits 0-9, ?, :, T and F (T and F represent True and False respectively). Note: The length of the given string is ≤ 10000.Each number will contain only one digit.The conditional expressions group right-to-left (as usual in most languages).The condition will always be either T or F. That is, the condition will never be a digit.The result of the expression will always evaluate to either a digit 0-9, T or F.Example 1:12345Input: &quot;T?2:3&quot;Output: &quot;2&quot;Explanation: If true, then result is 2; otherwise result is 3. Example 2:123456789Input: &quot;F?1:T?4:5&quot;Output: &quot;4&quot;Explanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as: &quot;(F ? 1 : (T ? 4 : 5))&quot; &quot;(F ? 1 : (T ? 4 : 5))&quot; -&gt; &quot;(F ? 1 : 4)&quot; or -&gt; &quot;(T ? 4 : 5)&quot; -&gt; &quot;4&quot; -&gt; &quot;4&quot; Example 3:123456789Input: &quot;T?T?F:5:3&quot;Output: &quot;F&quot;Explanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as: &quot;(T ? (T ? F : 5) : 3)&quot; &quot;(T ? (T ? F : 5) : 3)&quot; -&gt; &quot;(T ? F : 3)&quot; or -&gt; &quot;(T ? F : 5)&quot; -&gt; &quot;F&quot; -&gt; &quot;F&quot; 解法1： Stack打破传统思维，从后往前扫描放入stackC++1 Java1234567891011121314151617181920212223242526272829public class Solution &#123; public String parseTernary(String expression) &#123; if (expression == null || expression.length() == 0) &#123; return ""; &#125; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (int i = expression.length() - 1; i &gt;= 0; i--) &#123; char current = expression.charAt(i); if (!stack.isEmpty() &amp;&amp; stack.peek() == '?') &#123; stack.pop(); // get ride of ? char left = stack.pop(); stack.pop(); char right = stack.pop(); if (current == 'T') &#123; stack.push(left); &#125; else &#123; stack.push(right); &#125; &#125; else &#123; stack.push(current); &#125; &#125; return String.valueOf(stack.peek()); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[473. Matchsticks to Square]]></title>
    <url>%2F2017%2F08%2F13%2F2017-08-13-473-Matchsticks-to-Square%2F</url>
    <content type="text"><![CDATA[Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time. Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has. Example 1:Input: [1,1,2,2,2]Output: true Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.Example 2:Input: [3,3,3,3,4]Output: false Explanation: You cannot find a way to form a square with all the matchsticks.Note:The length sum of the given matchsticks is in the range of 0 to 10^9.The length of the given matchstick array will not exceed 15. 解法1：DFS首先，如果能摆成正方形，正方形的边长是确定的。也就是所有的数加起来/4。然后就是运行一个DFS。核心思想是，用一个数组代表每一个边长，然后尝试不同的组合，终结条件是每条边长都是target。这里有一个优化是需要先对所有火柴递减排列：原因是1Sorting the input array DESC will make the DFS process run much faster. Reason behind this is we always try to put the next matchstick in the first subset. If there is no solution, trying a longer matchstick first will get to negative conclusion earlier. Following is the updated code. Runtime is improved from more than 1000ms to around 40ms. A big improvement. 也就是说，如果一个组合不能成功拼成正方形的话，先用长的可以更快的得到false的结论，而不用多循环好多次来得到这个结论。这样运行速度就加快了。C++1 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Solution &#123; public boolean makesquare(int[] nums) &#123; if (nums == null || nums.length &lt; 4) &#123; return false; &#125; int sum = 0; for (int num : nums) &#123; sum += num; &#125; if (sum % 4 != 0) &#123; return false; &#125; int target = sum / 4; // this is the length of square Arrays.sort(nums); // sort the nums descending reverse(nums); int[] sides = new int[4]; return dfs(sides, nums, 0, target); &#125; private void reverse(int[] nums) &#123; int i = 0, j = nums.length - 1; while (i &lt; j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; i++; j--; &#125; return; &#125; private boolean dfs(int[] sides, int[] nums, int pos, int target) &#123; if (pos == nums.length) &#123; if (sides[0] == target &amp;&amp; sides[1] == target &amp;&amp; sides[2] == target) &#123; return true; &#125; return false; &#125; for (int i = 0; i &lt; 4; i++) &#123; if (sides[i] + nums[pos] &gt; target) &#123; continue; &#125; sides[i] += nums[pos]; boolean temp = dfs(sides, nums, pos + 1, target); if (temp) &#123; return true; &#125; sides[i] -= nums[pos]; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[356. Line Reflection]]></title>
    <url>%2F2017%2F08%2F13%2F2017-08-13-356-Line-Reflection%2F</url>
    <content type="text"><![CDATA[Given n points on a 2D plane, find if there is such a line parallel to y-axis that reflect the given points. Example 1:Given points = [[1,1],[-1,1]], return true. Example 2:Given points = [[1,1],[-1,-1]], return false. Follow up:Could you do better than O(n2)? 解法1：O(N) Time + O(N) Space这题的题意是对于N个给定的点，找一下是否存在一条平行与y轴的线，使得所有点都对称与此条线。那么怎么确定这条平行的线是关键。如果点都是对称存在的，那么最左面的点和最右面的点当中的线就是平行于y轴的对称线。所有其他的点都必须以此为基准。用一个set存储每一个点，并且找出最左最右两个点。找出以后，对于每一个点，检查他的对称点是否在set中。放入set的时候用到了Arrays.hashCode(int[])的function。C++1 Java1234567891011121314151617181920212223242526public class Solution &#123; public boolean isReflected(int[][] points) &#123; if (points == null || points.length == 0) &#123; return true; &#125; HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); int xmin = Integer.MAX_VALUE, xmax = Integer.MIN_VALUE; for (int[] point : points) &#123; xmin = Math.min(xmin, point[0]); xmax = Math.max(xmax, point[0]); set.add(Arrays.hashCode(point)); &#125; int sum = xmin + xmax; for (int[] point : points) &#123; if (!set.contains(Arrays.hashCode(new int[] &#123; sum - point[0], point[1]&#125;))) &#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[525. Contiguous Array]]></title>
    <url>%2F2017%2F08%2F13%2F2017-08-13-525-Contiguous-Array%2F</url>
    <content type="text"><![CDATA[Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1. Example 1:123Input: [0,1]Output: 2Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1. Example 2:123Input: [0,1,0]Output: 2Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1. Note: The length of the given binary array will not exceed 50,000. 解法1：很好的一题，用到了2sum = zero的特殊解法（用hashmap）， 也用到了变换条件使得题目变得更有利。把0变成-1的话这题的条件就变成找一个continuous array使得加和为1并且最长。加和为0很好办，看sum是否出现过，如果出现过，更新最长距离。要注意初始条件，第一个点是设成map.put(0, -1)C++1 Java123456789101112131415161718192021222324252627282930public class Solution &#123; public int findMaxLength(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] == 0) &#123; nums[i] = -1; &#125; &#125; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); map.put(0, -1); int sum = 0, max = 0; for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; if (map.containsKey(sum)) &#123; // prefix sum exists, meaning sum[i, j] = 0 =&gt; equal number of 1 and 0 (now -1) max = Math.max(max, i - map.get(sum)); &#125; else &#123; map.put(sum, i); &#125; &#125; return max; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[554. Brick Wall]]></title>
    <url>%2F2017%2F08%2F13%2F2017-08-13-554-Brick-Wall%2F</url>
    <content type="text"><![CDATA[There is a brick wall in front of you. The wall is rectangular and has several rows of bricks. The bricks have the same height but different width. You want to draw a vertical line from the top to the bottom and cross the least bricks. The brick wall is represented by a list of rows. Each row is a list of integers representing the width of each brick in this row from left to right. If your line go through the edge of a brick, then the brick is not considered as crossed. You need to find out how to draw the line to cross the least bricks and return the number of crossed bricks. You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks. Example:123456789Input:[[1,2,2,1], [3,1,2], [1,3,2], [2,4], [3,1,2], [1,3,1,1]]Output: 2Explanation: Note:The width sum of bricks in different rows are the same and won’t exceed INT_MAX.The number of bricks in each row is in range [1,10,000]. The height of wall is in range [1,10,000]. Total number of bricks of the wall won’t exceed 20,000. 解法1：自己想的很复杂，模模糊糊的有一个轮廓。答案给的很brilliant， 就是说我们yaocut的位置一定是在砖块对齐最多的位置。这个位置是most common right position of bricks要注意循环的时候是到size() - 1, 为的是避免右面的边界。C++1 Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[645. Set Mismatch]]></title>
    <url>%2F2017%2F08%2F13%2F2017-08-13-645-Set-Mismatch%2F</url>
    <content type="text"><![CDATA[The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number. Given an array nums representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array. Example 1:12Input: nums = [1,2,2,4]Output: [2,3] Note:The given array size will in the range [2, 10000].The given array’s numbers won’t have any order. 解法1：C++1 Java123456789101112131415161718192021222324252627public class Solution &#123; public int[] findErrorNums(int[] nums) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); int[] res = new int[2]; if (nums == null || nums.length == 0) &#123; return res; &#125; for (int num : nums) &#123; map.put(num, map.getOrDefault(num, 0) + 1); if (map.get(num) &gt; 1) &#123; res[0] = num; &#125; &#125; for (int i = 1; i &lt;= nums.length; i++) &#123; if (!map.containsKey(i)) &#123; res[1] = i; return res; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[347. Top K Frequent Elements]]></title>
    <url>%2F2017%2F08%2F13%2F2017-08-13-347-Top-K-Frequent-Elements%2F</url>
    <content type="text"><![CDATA[Given a non-empty array of integers, return the k most frequent elements. For example,Given [1,1,1,2,2,3] and k = 2, return [1,2]. Note:You may assume k is always valid, 1 ? k ? number of unique elements.Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size. 解法1： heap比较直接的写法就是用heap，不过还有一种bucket sort的办法似乎更快，可以做到O(N)C++1 Java有一个Java8的compare写法可以掌握一下(a,b) -&gt; a.getValue() - b.getValue() 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if (nums == null || nums.length == 0) &#123; return res; &#125; // map with keySet // [1,1,1,2,2,3] Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int num : nums) &#123; map.put(num, map.getOrDefault(num, 0) + 1); &#125; // Put each elements into priorityqueue PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; queue = new PriorityQueue&lt;&gt;((a,b) -&gt; a.getValue() - b.getValue()); for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; queue.offer(entry); if (queue.size() &gt; k) &#123; queue.poll(); // poll the smallest entry based on the frequency &#125; &#125; while (!queue.isEmpty()) &#123; res.add(queue.poll().getKey()); &#125; return res; &#125;&#125; 解法2： Bucket 思想基本的思路是，先用一个hashmap存储每一个num出现的次数。然后最大的可能出现的次数就是nums的长度，所以可以用一个数组，每一个元素是一个list，记录当前频率下的所有数字。这样以来，最后只需要从大到小的扫描一遍就可以得到答案了。 1234567891011121314151617181920212223242526public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; List&lt;Integer&gt;[] bucket = new List[nums.length + 1]; Map&lt;Integer, Integer&gt; frequencyMap = new HashMap&lt;Integer, Integer&gt;(); for (int n : nums) &#123; frequencyMap.put(n, frequencyMap.getOrDefault(n, 0) + 1); &#125; for (int key : frequencyMap.keySet()) &#123; int frequency = frequencyMap.get(key); if (bucket[frequency] == null) &#123; bucket[frequency] = new ArrayList&lt;&gt;(); &#125; bucket[frequency].add(key); &#125; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int pos = bucket.length - 1; pos &gt;= 0 &amp;&amp; res.size() &lt; k; pos--) &#123; if (bucket[pos] != null) &#123; res.addAll(bucket[pos]); &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[166. Fraction to Recurring Decimal]]></title>
    <url>%2F2017%2F08%2F13%2F2017-08-13-166-Fraction-to-Recurring-Decimal%2F</url>
    <content type="text"><![CDATA[Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. For example, Given numerator = 1, denominator = 2, return “0.5”.Given numerator = 2, denominator = 1, return “2”.Given numerator = 2, denominator = 3, return “0.(6)”.Credits: 解法1：HashMap能写成分数的一定是有理数，有理数一定是有限的或者是无限循环小数。先计算整数部分，然后看余数是否为0。如果不是零，那么把每一个数放入map中，记录他们出现的位置。然后乘以10再取余， C++1 Java1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; public String fractionToDecimal(int numerator, int denominator) &#123; if (numerator == 0) &#123; return "0"; &#125; StringBuilder sb = new StringBuilder(); sb.append(((numerator &gt; 0) ^ (denominator &gt; 0)) ? "-" : ""); long num = Math.abs((long)numerator); long den = Math.abs((long)denominator); // Get integral part sb.append(num / den); num %= den; if (num == 0) &#123; return sb.toString(); &#125; // process fraction Map&lt;Long, Integer&gt; map = new HashMap&lt;Long, Integer&gt;(); // Record the position that each digit exist sb.append("."); map.put(num, sb.length()); while (num != 0) &#123; num *= 10; sb.append(num / den); num %= den; if (map.containsKey(num)) &#123; int index = map.get(num); sb.insert(index, "("); sb.append(")"); break; // end the search &#125; else &#123; map.put(num, sb.length()); &#125; &#125; return sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[325. Maximum Size Subarray Sum Eqauls K]]></title>
    <url>%2F2017%2F08%2F13%2F2017-08-13-325-Maximum-Size-Subarray-Sum-Eqauls-K%2F</url>
    <content type="text"><![CDATA[Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn’t one, return 0 instead. Note:The sum of the entire nums array is guaranteed to fit within the 32-bit signed integer range. Example 1:Given nums = [1, -1, 5, -2, 3], k = 3,return 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longest) Example 2:Given nums = [-2, -1, 2, 1], k = 1,return 2. (because the subarray [-1, 2] sums to 1 and is the longest) Follow Up:Can you do it in O(n) time? 解法1：用prefix sum数组解决， 用一个map记录每一个accumulate sum对应的位置。然后线性扫描一遍加和数组，对于没有见过的数直接加入map，对于见过的就可以判断是否存在dp[i] - k, 注意。这题没有说是否有duplicate，实际是可能的，而我们push进map的都是第一次出现的位置，这样保证了如果找到一个解，一定是最长的一个subarray。C++1 Java12345678910111213141516171819202122232425262728293031public class Solution &#123; public int maxSubArrayLen(int[] nums, int k) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int n = nums.length; int[] dp = new int[n + 1]; for (int i = 1; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + nums[i - 1]; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); map.put(0, 0); // don't forget to put this into hashmap int max = 0; for (int i = 1; i &lt;= n; i++) &#123; int remain = dp[i] - k; if (map.containsKey(remain)) &#123; max = Math.max(max, i - map.get(remain)); &#125; if (!map.containsKey(dp[i])) &#123; map.put(dp[i], i); &#125; &#125; return max; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[244. Shortest Word Distance II]]></title>
    <url>%2F2017%2F08%2F13%2F2017-08-13-244-Shortest-Word-Distance-II%2F</url>
    <content type="text"><![CDATA[This is a follow up of Shortest Word Distance. The only difference is now you are given the list of words and your method will be called repeatedly many times with different parameters. How would you optimize it? Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list. For example,Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”]. Given word1 = “coding”, word2 = “practice”, return 3.Given word1 = “makes”, word2 = “coding”, return 1. Note:You may assume that word1 does not equal to word2, and word1 and word2 are both in the list. 解法1：先用hashmap没有疑问，之后在map中寻找最近的一对pair的时候可以用O(m+n)的复杂度解决，诀窍就是two pointers按照大小顺序移动两个pointer C++1 Java12345678910111213141516171819202122232425262728293031323334353637383940414243public class WordDistance &#123; HashMap&lt;String, List&lt;Integer&gt;&gt; map = null; public WordDistance(String[] words) &#123; map = new HashMap&lt;String, List&lt;Integer&gt;&gt;(); for (int i = 0; i &lt; words.length; i++) &#123; String word = words[i]; if (!map.containsKey(word)) &#123; map.put(word, new ArrayList&lt;Integer&gt;()); &#125; map.get(word).add(i); &#125; &#125; public int shortest(String word1, String word2) &#123; List&lt;Integer&gt; index1 = map.get(word1); List&lt;Integer&gt; index2 = map.get(word2); int res = Integer.MAX_VALUE; int i = 0, j = 0; while (i &lt; index1.size() &amp;&amp; j &lt; index2.size()) &#123; int ii = index1.get(i); int jj = index2.get(j); res = Math.min(res, Math.abs(jj - ii)); if (ii &lt; jj) &#123; i++; &#125; else &#123; j++; &#125; &#125; return res; &#125;&#125;/** * Your WordDistance object will be instantiated and called as such: * WordDistance obj = new WordDistance(words); * int param_1 = obj.shortest(word1,word2); */]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[314. Binary Tree Vertical Order Traversal]]></title>
    <url>%2F2017%2F08%2F13%2F2017-08-13-314-Binary-Tree-Vertical-Order-Traversal%2F</url>
    <content type="text"><![CDATA[Given a binary tree, return the vertical order traversal of its nodes’ values. (ie, from top to bottom, column by column). If two nodes are in the same row and column, the order should be from left to right. Examples:12345678Given binary tree [3,9,20,null,null,15,7], 3 /\ / \ 9 20 /\ / \ 15 7 return its vertical order traversal as:123456[ [9], [3,15], [20], [7]] Given binary tree [3,9,8,4,0,1,7],1234567 3 /\ / \ 9 8 /\ /\/ \/ \4 01 7 return its vertical order traversal as:1234567[ [4], [9], [3,0,1], [8], [7]] Given binary tree [3,9,8,4,0,1,7,null,null,null,2,5] (0’s right child is 2 and 1’s left child is 5),12345678910 3 /\ / \ 9 8 /\ /\/ \/ \4 01 7 /\ / \ 5 2 return its vertical order traversal as:1234567[ [4], [9,5], [3,0,1], [8,2], [7]] 解法1：一种BFS的增强用法在每次push一个node到一个queue的同时，维护另外一个queue，记录相对应的node的信息用一个hashmap记录每一个col对应的答案。然后min，max记录col的范围，之后把map里的数字再按顺序读取就可以了C++1 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; verticalOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (root == null) &#123; return res; &#125; Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); // record each column's result Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); // used for bfs search Queue&lt;Integer&gt; column = new LinkedList&lt;Integer&gt;(); // used for bfs search, update each node's column number queue.offer(root); column.offer(0); int min = 0; int max = 0; while (!queue.isEmpty()) &#123; TreeNode current = queue.poll(); int col = column.poll(); min = Math.min(col, min); max = Math.max(col, max); if (!map.containsKey(col)) &#123; map.put(col, new ArrayList&lt;Integer&gt;()); &#125; map.get(col).add(current.val); if (current.left != null) &#123; queue.offer(current.left); column.offer(col - 1); &#125; if (current.right != null) &#123; queue.offer(current.right); column.offer(col + 1); &#125; &#125; for (int i = min; i &lt;= max; i++) &#123; res.add(map.get(i)); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[50. Pow(x,n)]]></title>
    <url>%2F2017%2F08%2F13%2F2017-08-13-50-Pow-x-n%2F</url>
    <content type="text"><![CDATA[解法1：很简洁的一个写法，用了divide&amp;conquer的思想C++1 Java123456789101112131415161718public class Solution &#123; public double myPow(double x, int n) &#123; if (n == 0) &#123; return 1; &#125; double temp = myPow(x, n / 2); if (n % 2 == 0) &#123; return temp * temp; &#125; else &#123; if (n &gt; 0) &#123; return temp * temp * x; &#125; else &#123; return temp * temp / x; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[454. 4Sum II]]></title>
    <url>%2F2017%2F08%2F13%2F2017-08-13-454-4Sum-II%2F</url>
    <content type="text"><![CDATA[Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero. To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1. Example:12345678910111213Input:A = [ 1, 2]B = [-2,-1]C = [-1, 2]D = [ 0, 2]Output:2Explanation:The two tuples are:1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0 解法1: O(N^2)就是two sum的解法C++1 Java1234567891011121314151617181920212223242526272829303132public class Solution &#123; public int fourSumCount(int[] A, int[] B, int[] C, int[] D) &#123; // N^3logN if (A.length == 0) &#123; return 0; &#125; int count = 0; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); int n = A.length; // O(N^2) for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; int sum = A[i] + B[j]; map.put(sum, map.getOrDefault(sum, 0) + 1); &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; int sum = C[i] + D[j]; if (map.containsKey(0 - sum)) &#123; count += map.get(0 - sum); &#125; &#125; &#125; return count; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[275. H-Index II]]></title>
    <url>%2F2017%2F08%2F13%2F2017-08-13-275-H-Index-II%2F</url>
    <content type="text"><![CDATA[Follow up for H-Index: What if the citations array is sorted in ascending order? Could you optimize your algorithm? 解法1：C++1 Java123456789101112131415161718192021222324252627public class Solution &#123; public int hIndex(int[] citations) &#123; if (citations == null || citations.length == 0) &#123; return 0; &#125; int start = 0; int end = citations.length - 1; int n = citations.length; while (start + 1 &lt; end) &#123; int mid = start + (end - start) / 2; if (citations[mid] &gt;= n - mid) &#123; end = mid; &#125; else &#123; start = mid; &#125; &#125; if (citations[start] &gt;= n - start) &#123; return n - start; &#125; if (citations[end] &gt;= n - end) &#123; return n - end; &#125; return n - end - 1; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[378. Kth Smallest Element in a Sorted Matrix]]></title>
    <url>%2F2017%2F08%2F13%2F2017-08-13-378-Kth-Smallest-Element-in-a-Sorted-Matrix%2F</url>
    <content type="text"><![CDATA[Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. Example:12345678matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k = 8,return 13. Note:You may assume k is always valid, 1 ? k ? n2. 解法1：Heap用heap的思想，先把第一排或者第一列放入queue中，然后操作k-1次，每一次拿出一个元素，并且把他下面一行的元素也推入queue中。最后在堆顶的就是所求的答案。C++1 Java 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public int kthSmallest(int[][] matrix, int k) &#123; if (matrix.length == 0 || matrix[0].length == 0) &#123; return 0; &#125; PriorityQueue&lt;Tuple&gt; queue = new PriorityQueue&lt;&gt;(new Comparator&lt;Tuple&gt;() &#123; public int compare(Tuple left, Tuple right) &#123; return left.val - right.val; &#125; &#125;); int row = matrix.length; int col = matrix[0].length; for (int j = 0; j &lt; col; j++) &#123; queue.offer(new Tuple(0, j, matrix[0][j])); &#125; for (int count = 0; count &lt; k - 1 ; count++) &#123; Tuple temp = queue.poll(); if (temp.x == row - 1) continue; queue.offer(new Tuple(temp.x + 1, temp.y, matrix[temp.x + 1][temp.y])); &#125; return queue.poll().val; &#125; class Tuple &#123; int x; int y; int val; public Tuple(int x, int y, int val) &#123; this.x = x; this.y = y; this.val = val; &#125; &#125;;&#125; 解法2：Range version of Binary Search, Time Complexity O(NlogM)先确定最小值和最大值，知道了范围以后。找出中间点，然后统计有多少数小于他的值，如果总数小于k那么知道k个数一定在右半边。以此类推O(NlogM): N是行数，M是search range = max - min1234567891011121314151617181920212223242526272829public class Solution &#123; public int kthSmallest(int[][] matrix, int k) &#123; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123; return 0; &#125; int n = matrix.length; int low = matrix[0][0]; int high = matrix[n - 1][n - 1] + 1; // [low, high) while (low &lt; high) &#123; int mid = low + (high - low ) / 2; int count = 0, j = matrix[0].length - 1; // seach from the end of the column for (int i = 0; i &lt; matrix.length; i++) &#123; while (j &gt;= 0 &amp;&amp; matrix[i][j] &gt; mid) j--; count += (j + 1); // calcualte in this row, how many elements are smaller than mid &#125; if (count &lt; k) &#123; low = mid + 1; &#125; else &#123; high = mid; &#125; &#125; return low; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[436. Find Right Interval]]></title>
    <url>%2F2017%2F07%2F23%2F2017-07-23-436-Find-Right-Interval%2F</url>
    <content type="text"><![CDATA[Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the “right” of i. For any interval i, you need to store the minimum interval j’s index, which means that the interval j has the minimum start point to build the “right” relationship for interval i. If the interval j doesn’t exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array. Note: You may assume the interval’s end point is always bigger than its start point. You may assume none of these intervals have the same start point. Example 1:12345Input: [ [1,2] ]Output: [-1]Explanation: There is only one interval in the collection, so it outputs -1. Example 2:1234567Input: [ [3,4], [2,3], [1,2] ]Output: [-1, 0, 1]Explanation: There is no satisfied &quot;right&quot; interval for [3,4].For [2,3], the interval [3,4] has minimum-&quot;right&quot; start point;For [1,2], the interval [2,3] has minimum-&quot;right&quot; start point. Example 3:123456Input: [ [1,4], [2,3], [3,4] ]Output: [-1, 2, -1]Explanation: There is no satisfied &quot;right&quot; interval for [1,4] and [3,4].For [2,3], the interval [3,4] has minimum-&quot;right&quot; start point. 解法1：这里遇到了一种binarysearch的用法，题目要求需要返回原始的index，而又有点像binarysearch可以先用hashmap记录每一个当前的index，再对数组进行排序排好序之后得到结果了再取map中找寻原始的index。C++1 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Definition for an interval. * public class Interval &#123; * int start; * int end; * Interval() &#123; start = 0; end = 0; &#125; * Interval(int s, int e) &#123; start = s; end = e; &#125; * &#125; */public class Solution &#123; public int[] findRightInterval(Interval[] intervals) &#123; HashMap&lt;Integer, Integer&gt; startMap = new HashMap&lt;Integer, Integer&gt;(); List&lt;Integer&gt; starts = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt; intervals.length; i++) &#123; startMap.put(intervals[i].start, i); starts.add(intervals[i].start); &#125; Collections.sort(starts); // sort the array of start int[] res = new int[starts.size()]; for (int i = 0; i &lt; intervals.length; i++) &#123; int end = intervals[i].end; int temp = binarySearch(starts, end); if (temp == -1) &#123; res[i] = -1; &#125; else &#123; res[i] = startMap.get(starts.get(temp)); &#125; &#125; return res; &#125; private int binarySearch(List&lt;Integer&gt; list, int target) &#123; // find first that is larger than end int start = 0, end = list.size() - 1; while (start + 1 &lt; end) &#123; int mid = start + (end - start) / 2; if (list.get(mid) &lt; target) &#123; start = mid; &#125; else &#123; end = mid; &#125; &#125; if (list.get(start) &gt;= target) &#123; return start; &#125; if (list.get(end) &gt;= target) &#123; return end; &#125; return -1; // didn't find a start that is larger than target &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H-Index]]></title>
    <url>%2F2017%2F07%2F23%2F2017-07-23-274-H-Index%2F</url>
    <content type="text"><![CDATA[Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index. According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.” For example, given citations = [3, 0, 6, 1, 5], which means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, his h-index is 3. Note: If there are several possible values for h, the maximum one is taken as the h-index. 解法1：要注意h的范围是在[0, N]之间。只需要用一个array记录每一个数字出现的次数，对于数字大于等于N的记录在N最后从后往前，累加所有的次数，当count &gt;= i的时候说明就是我们要求的h-indexhttps://discuss.leetcode.com/topic/40765/java-bucket-sort-o-n-solution-with-detail-explanation/2C++1 Java123456789101112131415public class Solution &#123; public int hIndex(int[] citations) &#123; if (citations == null || citations.length == 0) &#123; return 0; &#125; Arrays.sort(citations); int max = 0; for (int i = 0; i &lt; citations.length; i++) &#123; int curr = Math.min(citations[i], citations.length - i); // [1,4,5] max = Math.max(max, curr); &#125; return max; &#125;&#125; 解法2： Bucket Sort的思想目标是找寻一个数i，使得比他引用次数多的paper的数量（包括和他一样的）要比i大就可以。统计每一个citation次数出现的次数，然后从大到小找到第一个满足条件的数字就可以了。 lang: java1234567891011121314151617181920212223242526272829class Solution &#123; public int hIndex(int[] citations) &#123; if (citations == null || citations.length == 0) &#123; return 0; &#125; int n = citations.length; int[] buckets = new int[n + 1]; for (int citation : citations) &#123; if (citation &gt;= n) &#123; buckets[n]++; &#125; else &#123; buckets[citation]++; &#125; &#125; // move from back to front int count = 0; for (int i = n; i &gt;= 0; i--) &#123; count += buckets[i]; if (count &gt;= i) &#123; return i; &#125; &#125; return 0; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[311. Sparse Matrix Multiplication]]></title>
    <url>%2F2017%2F07%2F23%2F2017-07-23-311-Sparse-Matrix-Multiplication%2F</url>
    <content type="text"><![CDATA[Given two sparse matrices A and B, return the result of AB. You may assume that A’s column number is equal to B’s row number. Example:123456789101112131415A = [ [ 1, 0, 0], [-1, 0, 3]]B = [ [ 7, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 1 ]] | 1 0 0 | | 7 0 0 | | 7 0 0 |AB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 | | 0 0 1 | 解法1：只要存下非0的数即可，然后遍历每一对非0的pair，看是否col=row，然后加和到对应的单元格里。C++1 Java1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; public int[][] multiply(int[][] A, int[][] B) &#123; int row_a = A.length; int col_a = A[0].length; int row_b = B.length; int col_b = B[0].length; int[][] res = new int[row_a][col_b]; // store the result // res[i][j] = sum (A[i][k] .* B[k][j]) ... HashMap&lt;Integer, Integer&gt; a = new HashMap&lt;Integer, Integer&gt;(); HashMap&lt;Integer, Integer&gt; b = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; row_a; i++) &#123; for (int j = 0; j &lt; col_a; j++) &#123; if (A[i][j] != 0) &#123; int index = i*col_a + j; a.put(index, A[i][j]); &#125; &#125; &#125; for (int i = 0; i &lt; row_b; i++) &#123; for (int j = 0; j &lt; col_b; j++) &#123; if (B[i][j] != 0) &#123; int index = i*col_b + j; b.put(index, B[i][j]); &#125; &#125; &#125; for (int index_a : a.keySet()) &#123; for (int index_b : b.keySet()) &#123; if (index_a % col_a == index_b / col_b) &#123; res[index_a / col_a][index_b % col_b] += a.get(index_a) * b.get(index_b); &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[288. Unique Word Abbreviation]]></title>
    <url>%2F2017%2F07%2F23%2F2017-07-23-288-Unique-Word-Abbreviation%2F</url>
    <content type="text"><![CDATA[An abbreviation of a word follows the form . Below are some examples of word abbreviations:123456789101112a) it --&gt; it (no abbreviation) 1b) d|o|g --&gt; d1g 1 1 1 1---5----0----5--8c) i|nternationalizatio|n --&gt; i18n 1 1---5----0d) l|ocalizatio|n --&gt; l10n Assume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary. A word’s abbreviation is unique if no other word from the dictionary has the same abbreviation. Example:12345678910111213Given dictionary = [ &quot;deer&quot;, &quot;door&quot;, &quot;cake&quot;, &quot;card&quot; ]isUnique(&quot;dear&quot;) -&gt;falseisUnique(&quot;cart&quot;) -&gt;trueisUnique(&quot;cane&quot;) -&gt;falseisUnique(&quot;make&quot;) -&gt;true 解法1：莫名其妙的一题。。C++1 Java1234567891011121314151617181920212223242526272829303132333435public class ValidWordAbbr &#123; HashMap&lt;String, Integer&gt; map = null; HashMap&lt;String, Integer&gt; countMap = null; public ValidWordAbbr(String[] dictionary) &#123; map = new HashMap&lt;&gt;(); countMap = new HashMap&lt;&gt;(); for (String str : dictionary) &#123; String abbr = getAbbr(str); map.put(abbr, map.getOrDefault(abbr, 0) + 1); countMap.put(str, countMap.getOrDefault(str, 0) + 1); &#125; &#125; private String getAbbr(String str) &#123; if (str.length() &lt;= 2) &#123; return str; &#125; return str.substring(0, 1) + Integer.toString(str.length() - 2) + str.substring(str.length() - 1, str.length()); &#125; public boolean isUnique(String word) &#123; String key = getAbbr(word); int abbrCount = map.getOrDefault(key, 0); int count = countMap.getOrDefault(word, 0); return abbrCount &lt;= count; &#125;&#125;/** * Your ValidWordAbbr object will be instantiated and called as such: * ValidWordAbbr obj = new ValidWordAbbr(dictionary); * boolean param_1 = obj.isUnique(word); */]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[623. Add One Row to Tree]]></title>
    <url>%2F2017%2F07%2F23%2F2017-07-23-623-Add-One-Row-to-Tree%2F</url>
    <content type="text"><![CDATA[Given the root of a binary tree, then value v and depth d, you need to add a row of nodes with value v at the given depth d. The root node is at depth 1. The adding rule is: given a positive integer depth d, for each NOT null tree nodes N in depth d-1, create two tree nodes with value v as N’s left subtree root and right subtree root. And N’s original left subtree should be the left subtree of the new left subtree root, its original right subtree should be the right subtree of the new right subtree root. If depth d is 1 that means there is no depth d-1 at all, then create a tree node with value v as the new root of the whole original tree, and the original tree is the new root’s left subtree. Example 1:1234567891011121314151617181920Input:A binary tree as following: 4 / \ 2 6 / \ / 3 1 5 v = 1d = 2Output: 4 / \ 1 1 / \ 2 6 / \ / 3 1 5 Example 2:1234567891011121314151617181920Input:A binary tree as following: 4 / 2 / \ 3 1 v = 1d = 3Output: 4 / 2 / \ 1 1 / \ 3 1 Note: The given d is in range [1, maximum depth of the given tree + 1]. The given binary tree has at least one tree node. 解法1：先用bfs找到要加的层的上一层。然后对每一个node加上新的node，然后把原来的left assign给left，rightassign给rightC++1 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public TreeNode addOneRow(TreeNode root, int v, int d) &#123; // do a level order traversal if (root == null) &#123; if (d == 1) &#123; return new TreeNode(v); &#125; return null; &#125; int depth = 1; if (d == 1) &#123; TreeNode root_new = new TreeNode(v); root_new.left = root; return root_new; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); // do level order traversal until reach the level right before depth while (!queue.isEmpty() &amp;&amp; depth &lt; d - 1) &#123; int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; TreeNode current = queue.poll(); if (current.left != null) &#123; queue.offer(current.left); &#125; if (current.right != null) &#123; queue.offer(current.right); &#125; &#125; depth++; &#125; // depth == d - 1 // queue contains all the nodes that is point to depth while (!queue.isEmpty()) &#123; TreeNode current = queue.poll(); TreeNode left = current.left; // original left TreeNode right = current.right; // original right TreeNode left_new = new TreeNode(v); // new left TreeNode right_new = new TreeNode(v); current.left = left_new; current.right = right_new; left_new.left = left; right_new.right = right; &#125; return root; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[582. Kill Process]]></title>
    <url>%2F2017%2F07%2F23%2F2017-07-23-582-Kill-Process%2F</url>
    <content type="text"><![CDATA[Given n processes, each process has a unique PID (process id) and its PPID (parent process id). Each process only has one parent process, but may have one or more children processes. This is just like a tree structure. Only one process has PPID that is 0, which means this process has no parent process. All the PIDs will be distinct positive integers. We use two list of integers to represent a list of processes, where the first list contains PID for each process and the second list contains the corresponding PPID. Now given the two lists, and a PID representing a process you want to kill, return a list of PIDs of processes that will be killed in the end. You should assume that when a process is killed, all its children processes will be killed. No order is required for the final answer. Example 1:123456789101112Input:pid = [1, 3, 10, 5]ppid = [3, 0, 5, 3]kill = 5Output: [5,10]Explanation: 3 / \ 1 5 / 10Kill 5 will also kill 10. Note: The given kill id is guaranteed to be one of the given PIDs. n &gt;= 1. 解法1：先把问题条件转化为一个图，然后对图做一个BFS就可以了。C++1 Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Solution &#123; public List&lt;Integer&gt; killProcess(List&lt;Integer&gt; pid, List&lt;Integer&gt; ppid, int kill) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if (pid == null || ppid == null) &#123; return res; &#125; if (pid.size() != ppid.size()) &#123; return res; &#125; // Convert to a graph HashMap&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;Integer, List&lt;Integer&gt;&gt;(); for (int i = 0; i &lt; pid.size(); i++) &#123; int child = pid.get(i); int parent = ppid.get(i); if (!map.containsKey(parent)) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(); temp.add(child); map.put(parent, temp); &#125; else &#123; map.get(parent).add(child); &#125; &#125; // do a bfs on the graph to get all childs Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); queue.offer(kill); while (!queue.isEmpty()) &#123; int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; int id = queue.poll(); res.add(id); List&lt;Integer&gt; children = map.get(id); if (children != null) &#123; // important! check if there exists children for (int c : children) &#123; queue.offer(c); &#125; &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[549. Binary Tree Longest Consecutive Sequence II]]></title>
    <url>%2F2017%2F07%2F23%2F2017-07-23-549-Binary-Tree-Longest-Consecutive-Sequence-II%2F</url>
    <content type="text"><![CDATA[Given a binary tree, you need to find the length of Longest Consecutive Path in Binary Tree. Especially, this path can be either increasing or decreasing. For example, [1,2,3,4] and [4,3,2,1] are both considered valid, but the path [1,2,4,3] is not valid. On the other hand, the path can be in the child-Parent-child order, where not necessarily be parent-child order. Example 1:123456Input: 1 / \ 2 3Output: 2Explanation: The longest consecutive path is [1, 2] or [2, 1]. Example 2:123456Input: 2 / \ 1 3Output: 3Explanation: The longest consecutive path is [1, 2, 3] or [3, 2, 1]. Note: All the values of tree nodes are in the range of [-1e7, 1e7]. 解法1：要先想想思路一个node，返回已他为起点的最长的decreasing和increasing那通过root的最长的一个path一定是increase + decrease - 1, 减1是去掉一次rootC++1 Java12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; int max = 0; public int longestConsecutive(TreeNode root) &#123; int[] temp = helper(root); return max; &#125; private int[] helper(TreeNode root) &#123; if (root == null) &#123; return new int[]&#123;0, 0&#125;; &#125; int increase = 1, decrease = 1; if (root.left != null) &#123; int[] left = helper(root.left); if (root.val == root.left.val + 1) &#123; decrease = left[1] + 1; &#125; else if (root.val == root.left.val -1) &#123; increase = left[0] + 1; &#125; &#125; if (root.right != null) &#123; int[] right = helper(root.right); if (root.val == root.right.val + 1) &#123; decrease = Math.max(decrease, right[1] + 1); &#125; else if (root.val == root.right.val -1) &#123; increase = Math.max(increase, right[0] + 1); &#125; &#125; max = Math.max(max, decrease + increase -1); return new int[]&#123;increase, decrease&#125;; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[333. Largest BST Subtree]]></title>
    <url>%2F2017%2F07%2F23%2F2017-07-23-333-Largest-BST-Subtree%2F</url>
    <content type="text"><![CDATA[Given a binary tree, find the largest subtree which is a Binary Search Tree (BST), where largest means subtree with largest number of nodes in it. Note:A subtree must include all of its descendants.Here’s an example:12345 10 / \ 5 15 / \ \1 8 7 The Largest BST Subtree in this case is the highlighted one.The return value is the subtree’s size, which is 3. Follow up:Can you figure out ways to solve it with O(n) time complexity? 解法1：C++1 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; class NodeInfo &#123; boolean isBST; int count; int max; int min; public NodeInfo (boolean isBST, int count, int max, int min) &#123; this.isBST = isBST; this.count = count; this.max = max; this.min = min; &#125; &#125;; int res = 0; // Store the final result public int largestBSTSubtree(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; NodeInfo dummy = helper(root); return res; &#125; private NodeInfo helper(TreeNode root) &#123; if (root == null) &#123; return new NodeInfo(true, 0, Integer.MIN_VALUE, Integer.MAX_VALUE); &#125; NodeInfo left = helper(root.left); NodeInfo right = helper(root.right); boolean isBST = false; if (root.val &gt; left.max &amp;&amp; root.val &lt; right.min) &#123; isBST = left.isBST &amp;&amp; right.isBST; &#125; int count = left.count + right.count + 1; if (isBST) &#123; res = Math.max(res, count); &#125; int max = Math.max(left.max, Math.max(right.max, root.val)); int min = Math.min(left.min, Math.min(right.min, root.val)); return new NodeInfo(isBST, count, max, min); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[255. Verify Preorder Sequence in Binary Search Tree]]></title>
    <url>%2F2017%2F07%2F23%2F2017-07-23-255-Verify-Preorder-Sequence-in-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[Given an array of numbers, verify whether it is the correct preorder traversal sequence of a binary search tree. You may assume each number in the sequence is unique. Follow up:Could you do it using only constant space complexity? 解法1：吃透了bst的性质就好做了：第一个数字是root，之后找出所有比他大的和所有比他小的范围。对large 和small分别做递归。要注意如果left &gt; right return trueC++1 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Solution &#123; public boolean verifyPreorder(int[] preorder) &#123; if (preorder == null || preorder.length == 0) &#123; return true; &#125; return helper(preorder, 0, preorder.length - 1); &#125; private boolean helper(int[] preorder, int left, int right) &#123; if (left &gt; right) &#123; return true; &#125; if (left == right) &#123; return true; &#125; // root is the first one int root = preorder[left]; // check [left, right] find first index that is larger than root int i = left + 1; for (;i &lt;= right; i++) &#123; if (preorder[i] &gt; root) &#123; break; &#125; &#125; if (i &gt; right) &#123; return helper(preorder, left + 1, right); &#125; if (i == right) &#123; return helper(preorder, left + 1, right - 1); &#125; // check if [i, right] has one element that is smaller than root for (int j = i; j &lt;= right; j++) &#123; if (preorder[j] &lt; root) &#123; return false; &#125; &#125; return helper(preorder, left + 1, i - 1) &amp;&amp; helper(preorder, i, right); &#125;&#125; 解法2： Stack O(N) Time + O(N) Space基本的思想是，用一个stack来维护当前的树，如果一个数字比栈顶的数字小，那么就认为是当前数的左子树，而如果比栈顶的大，那么说明是其中一个node的右字树，那么就需要把栈顶弹出，同时需要更新当前的low，之后所有的点都必须要比这个low大，如果不符合这一点就不是BST。 12345678910111213141516171819202122class Solution &#123; public boolean verifyPreorder(int[] preorder) &#123; if (preorder == null || preorder.length == 0) &#123; return true; &#125; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int lower = Integer.MIN_VALUE; for (int i = 0; i &lt; preorder.length; i++) &#123; int p = preorder[i]; if (p &lt; lower) &#123; return false; &#125; while (!stack.isEmpty() &amp;&amp; p &gt; stack.peek()) &#123; lower = stack.pop(); &#125; stack.push(p); &#125; return true; &#125;&#125; 解法3： Follow Up Stack O(N) Time + O(1) Space为了节省空间，就直接用preorder这个数组来当成stack就可以了。 lang: java1234567891011public boolean verifyPreorder(int[] preorder) &#123; int low = Integer.MIN_VALUE, i = -1; for (int p : preorder) &#123; if (p &lt; low) return false; while (i &gt;= 0 &amp;&amp; p &gt; preorder[i]) low = preorder[i--]; preorder[++i] = p; &#125; return true;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[298. Binary Tree Longest Consecutive Sequence]]></title>
    <url>%2F2017%2F07%2F23%2F2017-07-23-298-Binary-Tree-Longest-Consecutive-Sequence%2F</url>
    <content type="text"><![CDATA[Given a binary tree, find the length of the longest consecutive sequence path. The path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive path need to be from parent to child (cannot be the reverse). For example,12345671 \ 3 / \2 4 \ 5 Longest consecutive sequence path is 3-4-5, so return 3.1234567 2 \ 3 / 2 /1 Longest consecutive sequence path is 2-3,not3-2-1, so return 2. 解法1：用一个全局变量来存储答案，然后递归遍历数就可以了。C++1 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; int max = 0; public int longestConsecutive(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; helper(root, 1); return max; &#125; private void helper(TreeNode root, int count) &#123; if (root == null) &#123; max = Math.max(max, count); return; &#125; max = Math.max(max, count); if (root.left != null) &#123; if (root.left.val == root.val + 1) &#123; helper(root.left, count + 1); &#125; else &#123; helper(root.left, 1); &#125; &#125; if (root.right != null) &#123; if (root.right.val == root.val + 1) &#123; helper(root.right, count + 1); &#125; else &#123; helper(root.right, 1); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[250. Count Univalue Subtrees]]></title>
    <url>%2F2017%2F07%2F23%2F2017-07-23-250-Count-Univalue-Subtrees%2F</url>
    <content type="text"><![CDATA[Given a binary tree, count the number of uni-value subtrees. A Uni-value subtree means all nodes of the subtree have the same value. For example:Given binary tree,12345 5 / \ 1 5 / \ \5 5 5 return 4. 解法1：用Divide &amp; ConquerC++1 Java12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; int res = 0; public int countUnivalSubtrees(TreeNode root) &#123; helper(root); return res; &#125; private boolean helper(TreeNode root) &#123; if (root == null) &#123; return true; &#125; boolean left = helper(root.left); boolean right = helper(root.right); if (left &amp;&amp; right) &#123; if (root.left != null &amp;&amp; root.left.val != root.val) &#123; return false; &#125; if (root.right != null &amp;&amp; root.right.val != root.val) &#123; return false; &#125; ++res; return true; &#125; else &#123; return false; &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[285. Inorder Successor in BST]]></title>
    <url>%2F2017%2F07%2F23%2F2017-07-23-285-Inorder-Successor-in-BST%2F</url>
    <content type="text"><![CDATA[Given a binary search tree and a node in it, find the in-order successor of that node in the BST. Note: If the given node has no in-order successor in the tree, return null. 解法1： O(N) Space最直观的方法，就是先做一遍in order, 存起来，然后找出来目标node前一个node即可。C++1 Java123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public TreeNode inorderSuccessor(TreeNode root, TreeNode p) &#123; List&lt;TreeNode&gt; list = new ArrayList&lt;TreeNode&gt;(); if (root == null || p == null) &#123; return null; &#125; helper(root, list); for (int i = 0; i &lt; list.size(); i++) &#123; if (list.get(i) == p) &#123; if (i == list.size() - 1) &#123; return null; &#125; else &#123; return list.get(i + 1); &#125; &#125; &#125; return null; &#125; private void helper(TreeNode root, List&lt;TreeNode&gt; list) &#123; if (root == null) &#123; return; &#125; helper(root.left, list); list.add(root); helper(root.right, list); &#125;&#125; 解法2： O(1) Spacelang: java123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; TreeNode prev = null; TreeNode res = null; public TreeNode inorderSuccessor(TreeNode root, TreeNode p) &#123; if (root == null || p == null) &#123; return null; &#125; helper(root, p); return res; &#125; private void helper(TreeNode root, TreeNode p) &#123; if (root == null) &#123; return; &#125; helper(root.left, p); if (prev == p) &#123; res = root; prev = root; return; &#125; prev = root; helper(root.right, p); &#125;&#125; 解法3: Iterativelang: java12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode inorderSuccessor(TreeNode root, TreeNode p) &#123; if (root == null) return root; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode prev = null; while (!stack.isEmpty() || root != null) &#123; if (root != null) &#123; stack.push(root); root = root.left; &#125; else &#123; root = stack.pop(); if (prev == p) return root; prev = root; root = root.right; &#125; &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[312. Burst Balloons]]></title>
    <url>%2F2017%2F07%2F23%2F2017-07-23-312-Burst-Balloons%2F</url>
    <content type="text"><![CDATA[Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] nums[i] nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you can collect by bursting the balloons wisely. Note:(1) You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them.(2) 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100 Example: Given [3, 1, 5, 8] Return 16712 nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 解法1：C++1 Java1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public int maxCoins(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int n = nums.length; int[][] dp = new int[n][n]; // record the largest coin for a burst between [i, j] for (int len = 1; len &lt;= n; len++) &#123; for (int start = 0; start &lt;= n - len; start++) &#123; int end = start + len - 1; // dp[start][end] int max = Integer.MIN_VALUE; for (int i = start; i &lt;= end; i++) &#123; int coins = 0; coins = nums[i] * (start == 0 ? 1 : nums[start - 1]) * (end == n - 1 ? 1 : nums[end + 1]); // burst nums[i] if (i != start) &#123; coins += dp[start][i - 1]; &#125; if (i != end) &#123; coins += dp[i + 1][end]; &#125; max = Math.max(max, coins); &#125; dp[start][end] = max; &#125; &#125; return dp[0][n - 1]; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[376. Wiggle Subsequence]]></title>
    <url>%2F2017%2F07%2F23%2F2017-07-23-376-Wiggle-Subsequence%2F</url>
    <content type="text"><![CDATA[A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero. Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order. Examples:12345678910Input: [1,7,4,9,2,5]Output: 6The entire sequence is a wiggle sequence.Input: [1,17,5,10,13,15,10,5,16,8]Output: 7There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].Input: [1,2,3,4,5,6,7,8,9]Output: 2 解法1：两次dp两次dp的思想很巧妙，用up和down两个数组记录到当前位置，最后相邻的两个是up的最长wiggle sequence或者是最后相邻两个是down的最长wiggle sequence。那么只要交替更新一下每一个dp array就可以了。似乎这和minmax类的题目很类似， 比如Predict the winner，也是用两个相互影响的dp数组来完成。C++1 Java12345678910111213141516171819202122232425262728293031323334public class Solution &#123; public int wiggleMaxLength(int[] nums) &#123; if (nums == null) &#123; return 0; &#125; if (nums.length &lt;= 1) &#123; return nums.length; &#125; int n = nums.length; int[] up = new int[n]; int[] down = new int[n]; up[0] = 1; down[0] = 1; for (int i = 1; i &lt; n; i++) &#123; if (nums[i] &gt; nums[i - 1]) &#123; up[i] = down[i - 1] + 1; down[i] = down[i - 1]; &#125; else if (nums[i] &lt; nums[i - 1]) &#123; down[i] = up[i - 1] + 1; up[i] = up[i - 1]; &#125; else &#123; up[i] = up[i - 1]; down[i] = down[i - 1]; &#125; &#125; return Math.max(up[n - 1], down[n - 1]); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>MinMax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[474. Ones and Zeros]]></title>
    <url>%2F2017%2F07%2F23%2F2017-07-23-474-Ones-and-Zeros%2F</url>
    <content type="text"><![CDATA[In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue. For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s. Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once. Note: The given numbers of 0s and 1s will both not exceed 100 The size of given string array won&apos;t exceed 600. Example 1:1234Input: Array = &#123;&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, m = 5, n = 3Output: 4Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0” Example 2:1234Input: Array = &#123;&quot;10&quot;, &quot;0&quot;, &quot;1&quot;&#125;, m = 1, n = 1Output: 2Explanation: You could form &quot;10&quot;, but then you&apos;d have nothing left. Better form &quot;0&quot; and &quot;1&quot;. 解法1：这个的解释还算可以,来自于leetcode discuss:123456789101112131415161718192021The idea is to build up the solution for 0..m zeros and 0..n ones, from only knowing 1 string, 2 strings, ..., up to n strings.For example, for array = &#123;&quot;10&quot;, &quot;0&quot;, &quot;1&quot;&#125;, m = 1, n = 1. for first string &quot;10&quot;: zero = 0, one = 0 zero = 1, one = 0 zero = 0, one = 1 zero = 1, one = 1, can form &quot;10&quot; [+1] continue on the second string &quot;0&quot;, with previous knowledge of string &quot;10&quot;: zero = 0, one = 0 zero = 1, one = 0, can form &quot;0&quot; [+1] zero = 0, one = 1 zero = 1, one = 1, can form &quot;0&quot; [+1] or 1 string (&quot;10&quot;), known from previous string continue on the last string &quot;1&quot;, with previous knowledge of strings &quot;10&quot; and &quot;0&quot;: zero = 0, one = 0 zero = 1, one = 0, can&apos;t form &quot;1&quot;, but we know it can form 1 string (&quot;0&quot;) from previous set of strings zero = 0, one = 1, can form &quot;1&quot; (+1) zero = 1, one = 1, (can form &quot;1&quot; and 1 more string (&quot;0&quot;) with zero = 1, one = 0, known from previous set of strings) or (1 string (&quot;10&quot;), known from previous set of strings)Hence, at the end, we know that with zero = 1, one = 1, with string &quot;10&quot;, &quot;0&quot;, and &quot;1&quot;, the maximum number of strings we can form is 2. C++1 Java1234567891011121314151617181920212223public class Solution &#123; public static int findMaxForm(String[] strs, int m, int n) &#123; int[][] dp = new int[m + 1][n + 1]; for (String str : strs) &#123; int[] count = count(str); for (int i = m; i &gt;= count[0]; i--) &#123; for (int j = n; j &gt;= count[1]; j--) &#123; dp[i][j] = Math.max(dp[i][j], dp[i - count[0]][j - count[1]] + 1); &#125; &#125; &#125; return dp[m][n]; &#125; private static int[] count(String s) &#123; int[] result = new int[2]; char[] array = s.toCharArray(); for (int i : array) &#123; result[i - '0']++; &#125; return result; &#125;&#125; 解法2： 背包解法此题实际上是一个背包问题，背包问题的本质是：求一个最大或者最小，给定一定的限定条件。这里的限定条件是有限的0和1。背包就构建一个n维数组，dp[i][j][k]表示前i个数，用jk两个限定条件所能达到的最大结果。 lang: java123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public int findMaxForm(String[] strs, int m, int n) &#123; if (strs == null || strs.length == 0) &#123; return 0; &#125; int strn = strs.length; int[][][] dp = new int[strn + 1][m + 1][n + 1]; // dp[l][i][j] means up to first l strings, with m zeros and n ones, the max number of strings it can form // do[l][i][j] = Math.max(dp[l - 1][i - zero[l]][j - zero[l][i - ones]] + 1, dp[l - 1][i][j]）； for (int l = 1; l &lt;= strn; l++) &#123; int[] current = count(strs[l - 1]); // count current number of zeros and ones for (int i = 0; i &lt;= m; i++) &#123; for (int j = 0; j &lt;= n; j++) &#123; if (i &gt;= current[0] &amp;&amp; j &gt;= current[1]) &#123; dp[l][i][j] = Math.max(dp[l][i][j], dp[l - 1][i - current[0]][j - current[1]] + 1); &#125; dp[l][i][j] = Math.max(dp[l][i][j], dp[l - 1][i][j]); &#125; &#125; &#125; return dp[strn][m][n]; &#125; private int[] count(String str) &#123; // count number of ones and zeros in the string int[] res = new int[2]; for (int i = 0; i &lt; str.length(); i++) &#123; if (str.charAt(i) == &apos;0&apos;) &#123; res[0]++; &#125; else &#123; res[1]++; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>0-1 Knapsack</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[464. Can I Win]]></title>
    <url>%2F2017%2F07%2F23%2F2017-07-23-464-Can-I-Win%2F</url>
    <content type="text"><![CDATA[In the “100 game,” two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins. What if we change the game so that players cannot re-use integers? For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total &gt;= 100. Given an integer maxChoosableInteger and another integer desiredTotal, determine if the first player to move can force a win, assuming both players play optimally. You can always assume that maxChoosableInteger will not be larger than 20 and desiredTotal will not be larger than 300. Example12345678910111213Input:maxChoosableInteger = 10desiredTotal = 11Output:falseExplanation:No matter which integer the first player choose, the first player will lose.The first player can choose an integer from 1 up to 10.If the first player choose 1, the second player can only choose integers from 2 up to 10.The second player will win by choosing 10 and get a total = 11, which is &gt;= desiredTotal.Same with other integers chosen by the first player, the second player will always win. 解法1：当dp不太好想的时候考虑用一下memorization来减少复杂度。这题粗暴思路就是一个dfs，来判断对于一组数是否能win。那么我们可以把当前数字使用情况转变成一个key来存储起来。转成key的思路是把每一位数字如果没被用过变为0，用过了变为1.C++1 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Solution &#123; private HashMap&lt;Integer, Boolean&gt; map = new HashMap&lt;Integer, Boolean&gt;(); public boolean canIWin(int maxChoosableInteger, int desiredTotal) &#123; int sum = (1 + maxChoosableInteger) * maxChoosableInteger / 2; if (sum &lt; desiredTotal) &#123; return false; &#125; if (maxChoosableInteger &gt;= desiredTotal) &#123; return true; &#125; boolean[] used = new boolean[maxChoosableInteger + 1]; return helper(used, desiredTotal, maxChoosableInteger); &#125; private boolean helper(boolean[] used, int desiredTotal, int max) &#123; if (desiredTotal &lt;= 0) &#123; return false; &#125; int key = transform(used); if (map.containsKey(key)) &#123; return map.get(key); &#125; for (int i = 1; i &lt;= max; i++) &#123; if (!used[i]) &#123; used[i] = true; boolean sub = helper(used, desiredTotal - i, max); used[i] = false; if (!sub) &#123; map.put(key, true); return true; &#125; &#125; &#125; map.put(key, false); return false; &#125; private int transform(boolean[] used) &#123; int num = 0; for (boolean i : used) &#123; num &lt;&lt;= 1; if (i) &#123; num |= 1; &#125; &#125; return num; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[467. Unique Substrings in Wraparound String]]></title>
    <url>%2F2017%2F07%2F23%2F2017-07-23-467-Unique-Substrings-in-Wraparound-String%2F</url>
    <content type="text"><![CDATA[Consider the string s to be the infinite wraparound string of “abcdefghijklmnopqrstuvwxyz”, so s will look like this: “…zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd….”. Now we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s. Note: p consists of only lowercase English letters and the size of p might be over 10000. Example 1:1234Input: &quot;a&quot;Output: 1Explanation: Only the substring &quot;a&quot; of string &quot;a&quot; is in the string s. Example 2:123Input: &quot;cac&quot;Output: 2Explanation: There are two substrings &quot;a&quot;, &quot;c&quot; of string &quot;cac&quot; in the string s. Example 3:123Input: &quot;zab&quot;Output: 6Explanation: There are six substrings &quot;z&quot;, &quot;a&quot;, &quot;b&quot;, &quot;za&quot;, &quot;ab&quot;, &quot;zab&quot; of string &quot;zab&quot; in the string s. 解法1:又是维护一个running local optimal，然后再更新最终答案的题目。这里是把p中以每一个字符结尾的最长子串加入到hashmap中。之后再得出一个加和就可以了。C++1 Java1234567891011121314151617181920212223public class Solution &#123; public int findSubstringInWraproundString(String p) &#123; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); int maxLen = 0; for (int i = 0; i &lt; p.length(); i++) &#123; if (i &gt; 0 &amp;&amp; (p.charAt(i) - p.charAt(i -1) == 1 || p.charAt(i) - p.charAt(i - 1) == -25)) &#123; maxLen++; &#125; else &#123; maxLen = 1; &#125; map.put(p.charAt(i), Math.max(map.getOrDefault(p.charAt(i), 0), maxLen)); &#125; int sum = 0; for (char key : map.keySet()) &#123; sum += map.get(key); &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[103. Binary Tree Zigzag Level Order Traversal]]></title>
    <url>%2F2017%2F07%2F23%2F2017-07-23-103-Binary-Tree-Zigzag-Level-Order-Traversal%2F</url>
    <content type="text"><![CDATA[Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between). For example:Given binary tree [3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7 return its zigzag level order traversal as:12345[ [3], [20,9], [15,7]] 解法1：BFSBFS 然后reverse间隔行就可以了。C++1 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (root == null) &#123; return res; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); int level = 1; while (!queue.isEmpty()) &#123; int size = queue.size(); List&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt; size; i++) &#123; TreeNode current = queue.poll(); temp.add(current.val); if (current.left != null) &#123; queue.offer(current.left); &#125; if (current.right != null) &#123; queue.offer(current.right); &#125; &#125; if (level % 2 == 0) &#123; // reverse the temp for (int i = 0, j = temp.size() - 1; i &lt; j; i++, j--) &#123; int buffer = temp.get(i); temp.set(i, temp.get(j)); temp.set(j, buffer); &#125; &#125; res.add(temp); level++; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[144. Binary Tree Preorder Traversal]]></title>
    <url>%2F2017%2F07%2F23%2F2017-07-23-144-Binary-Tree-Preorder-Traversal%2F</url>
    <content type="text"><![CDATA[Given a binary tree, return the preorder traversal of its nodes’ values. For example:Given binary tree {1,#,2,3},123451 \ 2 /3 return [1,2,3]. Note: Recursive solution is trivial, could you do it iteratively? 解法1：Iterative version 用stack递归的就不写了，实在太简单。用stack的方法的关键点在于，每一条路劲在探寻最左元素的时候，要把所有的parent node都push到stack中。如果当前的路径到头了之后，从stack里pop出上一个parent，然后移步到右边。注意终止条件是需要node！= null同时stack不为空。C++1 Java123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if (root == null) &#123; return res; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); TreeNode current = root; while (current != null || !stack.isEmpty()) &#123; // push all left nodes into stack while (current != null) &#123; res.add(current.val); stack.push(current); current = current.left; &#125; if (!stack.isEmpty()) &#123; TreeNode temp = stack.pop(); current = temp.right; // move to the right cell &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[413. Arithmetic Slices]]></title>
    <url>%2F2017%2F07%2F23%2F2017-07-23-413-Arithmetic-Slices%2F</url>
    <content type="text"><![CDATA[A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, these are arithmetic sequence:1231, 3, 5, 7, 97, 7, 7, 73, -1, -5, -9 The following sequence is not arithmetic.11, 1, 2, 5, 7 A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 &lt;= P &lt; Q &lt; N. A slice (P, Q) of array A is called arithmetic if the sequence:A[P], A[p + 1], …, A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 &lt; Q. The function should return the number of arithmetic slices in the array A. Example: A = [1, 2, 3, 4] return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself. 解法1：C++1 Java1234567891011121314151617public class Solution &#123; public int numberOfArithmeticSlices(int[] A) &#123; // 找规律发现是一个fibb sequence int curr = 0, sum = 0; for (int i = 2; i &lt; A.length; i++) &#123; if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) &#123; curr += 1; sum += curr; &#125; else &#123; curr = 0; &#125; &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[392. Is Subsequence]]></title>
    <url>%2F2017%2F07%2F23%2F2017-07-23-392-Is-Subsequence%2F</url>
    <content type="text"><![CDATA[Given a string s and a string t, check if s is subsequence of t. You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (&lt;=100). A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ace” is a subsequence of “abcde” while “aec” is not). Example 1:s = “abc”, t = “ahbgdc” Return true. Example 2:s = “axc”, t = “ahbgdc” Return false. Follow up:If there are lots of incoming S, say S1, S2, … , Sk where k &gt;= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code? 解法1：O(N) 解法用两个指针一前一后的分别指向string的位置。如果两个字符相等就同前进，如果不相等，那么只前进target的指针，因为subsequence可以要求是不连续的。然后判断一下s的指针时候到尾巴了就可以了。如果t到尾巴了还没有结果，则说明答案是false。C++1 Java123456789101112131415161718192021222324public class Solution &#123; public boolean isSubsequence(String s, String t) &#123; if ((s == null &amp;&amp; t == null) || (s.length() == 0)) &#123; return true; &#125; if (s.length() &gt; t.length()) &#123; return false; &#125; int i = 0, j = 0; while (j &lt; t.length()) &#123; if (t.charAt(j) == s.charAt(i)) &#123; i++; if (i == s.length()) return true; &#125; j++; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[486. Predict the Winner]]></title>
    <url>%2F2017%2F07%2F23%2F2017-07-23-486-Predict-the-Winner%2F</url>
    <content type="text"><![CDATA[Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins. Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score. Example 1:123456Input: [1, 5, 2]Output: FalseExplanation: Initially, player 1 can choose between 1 and 2.If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2).So, final score of player 1 is 1 + 2 = 3, and player 2 is 5.Hence, player 1 will never be the winner and you need to return False. Example 2:1234Input: [1, 5, 233, 7]Output: TrueExplanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win. Note: 1 &lt;= length of the array &lt;= 20. Any scores in the given array are non-negative integers and will not exceed 10,000,000. If the scores of both players are equal, then player 1 is still the winner. 解法1：是同时维护两个dp而相互update的一类题目。用max，min分别表示对于[i,j]范围的一组数，先手的player能取到的最大和最小值。要注意： min对于[i,i]就为0max对于[i,j]的递推公式是，如果取尾巴，那么再取下一步一定是取[i, j -1]的最小值。如果取头部，那么再取一定是取[i - 1, j]的最小值。min对于[i, j]的递推公式是，当对手取了[i]或者[j]之后，剩下的矩阵取一个最大值.要注意更新矩阵的时候是按对角线更新。 C++1 Java12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public boolean PredictTheWinner(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return false; &#125; int n = nums.length; // max and min points if the array is [i, j] int[][] max = new int[n][n]; int[][] min = new int[n][n]; for (int i = 0; i &lt; n; i++) &#123; max[i][i] = nums[i]; min[i][i] = 0; // min is player gets nothing &#125; // Need to fill the dp matrix diagonally for (int diff = 1; diff &lt; n; diff++) &#123; for (int start = 0; start &lt; n - diff; start++) &#123; int end = start + diff; max[start][end] = Math.max(nums[end] + min[start][end - 1], nums[start] + min[start + 1][end]); min[start][end] = Math.min(max[start][end - 1], max[start + 1][end]); &#125; &#125; // Check which player gets higher score int sum = 0; for (int num : nums) &#123; sum += num; &#125; return max[0][n - 1] &gt;= sum - max[0][n - 1]; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>MinMax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[494. Target Sum]]></title>
    <url>%2F2017%2F07%2F23%2F2017-07-23-494-Target-Sum%2F</url>
    <content type="text"><![CDATA[You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol. Find out how many ways to assign symbols to make sum of integers equal to target S. Example 1:1234567891011Input: nums is [1, 1, 1, 1, 1], S is 3.Output: 5Explanation:-1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3There are 5 ways to assign symbols to make the sum of nums be target 3. Note: The length of the given array is positive and will not exceed 20. The sum of elements in the given array will not exceed 1000. Your output answer is guaranteed to be fitted in a 32-bit integer. 解法1：用dfs + memo的想法来解决。用一个map来记录对于一个子数组和一个相对应的和，有多少种方法可以计算出相对应的和。然后进行dfs遍历，对于每一个元素，有+和-两种办法加和到总和之中，然后再进行下一步遍历。直到遍历到数组的最后一个，只需要判断最后一个元素是否是所剩和的+/-就可。C++1 Java12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; // key will be pos and targetSum HashMap&lt;List&lt;Integer&gt;, Integer&gt; map = new HashMap&lt;&gt;(); public int findTargetSumWays(int[] nums, int S) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; return dfs(nums, 0, S); &#125; private int dfs(int[] nums, int pos, int S) &#123; List&lt;Integer&gt; key = new ArrayList&lt;Integer&gt;(Arrays.asList(pos, S)); if (map.containsKey(key)) &#123; return map.get(key); &#125; if (pos == nums.length - 1) &#123; int res = 0; if (nums[pos] == S) &#123; res++; &#125; if (nums[pos] == S * (-1)) &#123; res++; &#125; return res; &#125; int res = 0; res += dfs(nums, pos + 1, S - nums[pos]); res += dfs(nums, pos + 1, S + nums[pos]); map.put(key, res); return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[523. Continuous Subarray Sum]]></title>
    <url>%2F2017%2F07%2F23%2F2017-07-23-523-Continuous-Subarray-Sum%2F</url>
    <content type="text"><![CDATA[Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer. Example 1:123Input: [23, 2, 4, 6, 7], k=6Output: TrueExplanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6. Example 2:123Input: [23, 2, 6, 4, 7], k=6Output: TrueExplanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42. Note: The length of the array won’t exceed 10,000. You may assume the sum of all the numbers is in the range of a signed 32-bit integer. 解法1：O(N^2)Subarray Sum的题目考虑用prefix sum解决，先计算每一个prefix sum，然后再遍历每一个subarray来寻找满足条件的最大答案。C++1 Java1234567891011121314151617181920212223242526public class Solution &#123; public boolean checkSubarraySum(int[] nums, int k) &#123; if (nums == null || nums.length == 0) &#123; return false; &#125; // prefix sum int[] dp = new int[nums.length + 1]; for (int i = 1; i &lt;= nums.length; i++) &#123; dp[i] = dp[i - 1] + nums[i - 1]; &#125; // check if there is a sum - prefix that is n * k for (int i = 1; i &lt;= nums.length; i++) &#123; for (int j = 0; j &lt; i - 1; j++) &#123; int temp = dp[i] - dp[j]; if (k == 0 &amp;&amp; temp == 0) &#123; return true; &#125; else if (k != 0 &amp;&amp; temp % k == 0) &#123; return true; &#125; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[638. Shopping Offers]]></title>
    <url>%2F2017%2F07%2F23%2F2017-07-23-638-Shopping-Offers%2F</url>
    <content type="text"><![CDATA[In LeetCode Store, there are some kinds of items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price. You are given the each item’s price, a set of special offers, and the number we need to buy for each item. The job is to output the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers. Each special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer. You could use any of special offers as many times as you want. Example 1:1234567Input: [2,5], [[3,0,5],[1,2,10]], [3,2]Output: 14Explanation:There are two kinds of items, A and B. Their prices are $2 and $5 respectively.In special offer 1, you can pay $5 for 3A and 0BIn special offer 2, you can pay $10 for 1A and 2B.You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A. Example 2:1234567Input: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1]Output: 11Explanation:The price of A is $2, and $3 for B, $4 for C.You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C.You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C.You cannot add more items, though only $9 for 2A ,2B and 1C. Note: There are at most 6 kinds of items, 100 special offers. For each item, you need to buy at most 6 of them. You are not allowed to buy more items than you want, even if that would lower the overall price. 解法1：用了一个DFS + memo的做法，基本思路是去尝试每一个deal，当needs全都满足的时候更新一下最小的cost。要注意的是用一个memo table去记录已经探寻过的一种needs对应的cost。同时对每一个needs要考虑是否不用任何一个deal，就是说对于每个商品单独相加花费更少。C++1 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class Solution &#123; Map&lt;List&lt;Integer&gt;, Integer&gt; map = new HashMap&lt;&gt;(); public int shoppingOffers(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs) &#123; int res = dfs(price, special, needs); return res; &#125; private int dfs(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs) &#123; if (map.containsKey(needs)) &#123; return map.get(needs); &#125; int fulfilledStatus = fulfilled(needs); if (fulfilledStatus == 1) &#123; return 0; &#125; if (fulfilledStatus == -1) &#123; // Invalid Move; return Integer.MAX_VALUE; &#125; int min = Integer.MAX_VALUE; for (List&lt;Integer&gt; deal : special) &#123; List&lt;Integer&gt; updatedNeeds = useDeal(needs, deal); if (updatedNeeds != null) &#123; int temp = dfs(price, special, updatedNeeds); min = Math.min(min, temp + deal.get(deal.size() - 1)); &#125; &#125; // check if needs can be fulfilled with single purchases min = Math.min(min, useNoDeal(price, needs)); map.put(needs, min); return min; &#125; private int useNoDeal(List&lt;Integer&gt; price, List&lt;Integer&gt; needs) &#123; int sum = 0; for (int i = 0; i &lt; price.size(); i++) &#123; sum += price.get(i) * needs.get(i); &#125; return sum; &#125; private List&lt;Integer&gt; useDeal(List&lt;Integer&gt; needs, List&lt;Integer&gt; deal) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt; needs.size(); i++) &#123; int left = needs.get(i) - deal.get(i); if (left &lt; 0) &#123; return null; &#125; res.add(left); &#125; return res; &#125; private int fulfilled(List&lt;Integer&gt; needs) &#123; for (int need : needs) &#123; if (need &gt; 0) &#123; return 0; &#125; else if (need &lt; 0) &#123; return -1; &#125; &#125; return 1; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[361. Bomb Enemy]]></title>
    <url>%2F2017%2F07%2F17%2F2017-07-17-361-Bomb-Enemy%2F</url>
    <content type="text"><![CDATA[Given a 2D grid, each cell is either a wall ‘W’, an enemy ‘E’ or empty ‘0’ (the number zero), return the maximum enemies you can kill using one bomb.The bomb kills all the enemies in the same row and column from the planted point until it hits the wall since the wall is too strong to be destroyed.Note that you can only put the bomb at an empty cell. Example:1234567For the given grid0 E 0 0E 0 W E0 E 0 0return 3. (Placing a bomb at (1,1) kills 3 enemies) 解法1：C++1 Java123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public int maxKilledEnemies(char[][] grid) &#123; if (grid.length == 0 || grid[0].length == 0) &#123; return 0; &#125; int m = grid.length; int n = grid[0].length; int rowCount = 0; int[] colCount = new int[n]; int res = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (j == 0 || grid[i][j - 1] == 'W') &#123; rowCount = 0; for (int k = j; k &lt; n &amp;&amp; grid[i][k] != 'W';k++) &#123; rowCount += grid[i][k] == 'E' ? 1 : 0; &#125; &#125; if (i == 0 || grid[i - 1][j] == 'W') &#123; colCount[j] = 0; for (int k = i; k &lt; m &amp;&amp; grid[k][j] != 'W'; k++) &#123; colCount[j] += (grid[k][j] == 'E' ? 1 : 0); &#125; &#125; if (grid[i][j] == '0') &#123; res = Math.max(res, rowCount + colCount[j]); &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[604. Design Compressed String Iterator]]></title>
    <url>%2F2017%2F07%2F17%2F2017-07-17-604-Design-Compressed-String-Iterator%2F</url>
    <content type="text"><![CDATA[Design and implement a data structure for a compressed string iterator. It should support the following operations: next and hasNext. The given compressed string will be in the form of each letter followed by a positive integer representing the number of this letter existing in the original uncompressed string. next() - if the original string still has uncompressed characters, return the next letter; Otherwise return a white space.hasNext() - Judge whether there is any letter needs to be uncompressed. Note:Please remember to RESET your class variables declared in StringIterator, as static/class variables are persisted across multiple test cases. Please see here for more details. Example: StringIterator iterator = new StringIterator(“L1e2t1C1o1d1e1”); iterator.next(); // return ‘L’iterator.next(); // return ‘e’iterator.next(); // return ‘e’iterator.next(); // return ‘t’iterator.next(); // return ‘C’iterator.next(); // return ‘o’iterator.next(); // return ‘d’iterator.hasNext(); // return trueiterator.next(); // return ‘e’iterator.hasNext(); // return falseiterator.next(); // return ‘ ‘ 解法1：思路比较好想。用一个count记录当前字符还剩下的个数，另一个用pos记录在compressedString里面扫描到的位置。要注意的是在判断hasNext的时候要check count！=0C++1 Java123456789101112131415161718192021222324252627282930313233343536373839public class StringIterator &#123; int pos = 0; char prev = ' '; int count = 0; String data = null; public StringIterator(String compressedString) &#123; this.data = compressedString; &#125; public char next() &#123; if (!hasNext()) &#123; return ' '; &#125; if (count == 0) &#123; prev = data.charAt(pos++); int tempCount = 0; while (pos &lt; data.length() &amp;&amp; Character.isDigit(data.charAt(pos))) &#123; tempCount = tempCount * 10 + data.charAt(pos) - '0'; pos++; &#125; count = tempCount; &#125; count--; return prev; &#125; public boolean hasNext() &#123; return pos &lt; data.length() || count != 0; &#125;&#125;/** * Your StringIterator object will be instantiated and called as such: * StringIterator obj = new StringIterator(compressedString); * char param_1 = obj.next(); * boolean param_2 = obj.hasNext(); */]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[594. Longest Harmonious Subsequence]]></title>
    <url>%2F2017%2F07%2F17%2F2017-07-17-594-Longest-Harmonious-Subsequence%2F</url>
    <content type="text"><![CDATA[We define a harmonious array is an array where the difference between its maximum value and its minimum value is exactly 1. Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences. Example 1:123Input: [1,3,2,2,5,2,3,7]Output: 5Explanation: The longest harmonious subsequence is [3,2,2,2,3]. Note: The length of the input array will not exceed 20,000. 解法1：对于subsequence的题目，经常会用到two pointer，一种是从两头像中间靠拢，另一种是前后两个指针按照条件和数字的变化不停的移动。这题就属于后者。C++1 Java123456789101112131415161718192021222324252627public class Solution &#123; public int findLHS(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; Arrays.sort(nums); int res = 0; int left = 0, right = 1; while (right &lt; nums.length) &#123; if (nums[right] - nums[left] &gt; 1) &#123; left++; &#125; else if (nums[right] - nums[left] &lt; 1) &#123; right++; &#125; else &#123; right++; // update the max length of the subarray res = Math.max(res, right - left); &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[598. Range Addition II]]></title>
    <url>%2F2017%2F07%2F17%2F2017-07-17-598-Range-Addition-II%2F</url>
    <content type="text"><![CDATA[Given an m * n matrix M initialized with all 0’s and several update operations. Operations are represented by a 2D array, and each operation is represented by an array with two positive integers a and b, which means M[i][j] should be added by one for all 0 &lt;= i &lt; a and 0 &lt;= j &lt; b. You need to count and return the number of maximum integers in the matrix after performing all the operations. Example 1:123456789101112131415161718192021Input:m = 3, n = 3operations = [[2,2],[3,3]]Output: 4Explanation:Initially, M =[[0, 0, 0], [0, 0, 0], [0, 0, 0]]After performing [2,2], M =[[1, 1, 0], [1, 1, 0], [0, 0, 0]]After performing [3,3], M =[[2, 2, 1], [2, 2, 1], [1, 1, 1]]So the maximum integer in M is 2, and there are four of it in M. So return 4. Note: The range of m and n is [1,40000]. The range of a is [1,m], and the range of b is [1,n]. The range of operations size won&apos;t exceed 10,000. 解法1：思想很巧妙，拥有最大值的数组一定是执行操作最多的。操作共享的最小范围就是row和col分别的最小值。C++1 Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[599. Minimum Index Sum of Two Lists]]></title>
    <url>%2F2017%2F07%2F17%2F2017-07-17-599-Minimum-Index-Sum-of-Two-Lists%2F</url>
    <content type="text"><![CDATA[Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings. You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer. Example 1:12345Input:[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;][&quot;Piatti&quot;, &quot;The Grill at Torrey Pines&quot;, &quot;Hungry Hunter Steakhouse&quot;, &quot;Shogun&quot;]Output: [&quot;Shogun&quot;]Explanation: The only restaurant they both like is &quot;Shogun&quot;. Example 2:12345Input:[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;][&quot;KFC&quot;, &quot;Shogun&quot;, &quot;Burger King&quot;]Output: [&quot;Shogun&quot;]Explanation: The restaurant they both like and have the least index sum is &quot;Shogun&quot; with index sum 1 (0+1). Note: The length of both lists will be in the range of [1, 1000]. The length of strings in both lists will be in the range of [1, 30]. The index is starting from 0 to the list length minus 1. No duplicates in both lists. 解法1：用一个hashtable记录每一个restaurant出现的位置，当出现之前出现过的string的时候更新答案。C++1 Java12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public String[] findRestaurant(String[] list1, String[] list2) &#123; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); if (list1 == null || list2 == null || list1.length == 0 || list2.length == 0) &#123; return new String[0]; &#125; Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); for (int i = 0; i &lt; list1.length; i++) &#123; map.put(list1[i], i); &#125; int min = Integer.MAX_VALUE; for (int i = 0; i &lt; list2.length; i++) &#123; if (map.containsKey(list2[i])) &#123; int index = map.get(list2[i]); if (index + i == min) &#123; res.add(list2[i]); &#125; else if (index + i &lt; min) &#123; res.clear(); res.add(list2[i]); min = index + i; &#125; &#125; &#125; String[] array = new String[res.size()]; for (int i = 0; i &lt; res.size(); i++) &#123; array[i] = res.get(i); &#125; return array; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[213. House Robber II]]></title>
    <url>%2F2017%2F07%2F17%2F2017-07-17-213-House-Robber-II%2F</url>
    <content type="text"><![CDATA[Note: This is an extension of House Robber. After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 解法1：两次dp, 每次只考虑头或者尾之中的一个, i.e. [0, n - 1]或者[1, n].然后找出对应的最大的值就可以了C++1 Java12345678910111213141516171819202122232425262728public class Solution &#123; public int rob(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int[] dp = new int[nums.length]; dp[0] = nums[0]; // forward looking int res = dp[0]; for (int i = 1; i &lt; nums.length - 1; i++) &#123; dp[i] = Math.max(dp[i - 1], nums[i] + (i &gt;= 2 ? dp[i - 2] : 0)); res = Math.max(dp[i], res); &#125; // backward looking dp = new int[nums.length]; dp[nums.length - 1] = nums[nums.length - 1]; res = Math.max(res, dp[nums.length - 1]); for (int i = nums.length - 2; i &gt; 0; i--) &#123; dp[i] = Math.max(dp[i + 1], nums[i] + (i &lt; nums.length - 2 ? dp[i + 2] : 0)); res = Math.max(res, dp[i]); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[375. Guess Number Higher or Lower II]]></title>
    <url>%2F2017%2F07%2F17%2F2017-07-17-375-Guess-Number-Higher-or-Lower-II%2F</url>
    <content type="text"><![CDATA[We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I’ll tell you whether the number I picked is higher or lower. However, when you guess a particular number x, and you guess wrong, you pay $x. You win the game when you guess the number I picked. Example:123456789n = 10, I pick 8.First round: You guess 5, I tell you that it&apos;s higher. You pay $5.Second round: You guess 7, I tell you that it&apos;s higher. You pay $7.Third round: You guess 9, I tell you that it&apos;s lower. You pay $9.Game over. 8 is the number I picked.You end up paying $5 + $7 + $9 = $21. Given a particular n ≥ 1, find out how much money you need to have to guarantee a win. 解法1：试着去选择每一个数作为猜测的答案，然后分为左边和右边分别考虑。用一个dp记录子问题的结果，dp数组只需要按照对角线填充就可以了。C++1 Java12345678910111213141516171819202122232425262728public class Solution &#123; public int getMoneyAmount(int n) &#123; if (n &lt;= 0) &#123; return 0; &#125; if (n == 1) &#123; return 0; &#125; int[][] dp = new int[n + 1][n + 1]; // dp[i][j] is [i,j] costs // Fill the upper triangle from mid to top right // len is the count of numbers in this range for (int len = 2; len &lt;= n; len++) &#123; for (int start = 1; start &lt;= n - len + 1; start++) &#123; int temp = Integer.MAX_VALUE; for (int pivot = start; pivot &lt;= start + len - 1; pivot++) &#123; temp = Math.min(temp, pivot + Math.max(dp[start][pivot - 1], (pivot == start + len - 1 ? 0 : dp[pivot + 1][start + len - 1]))); &#125; dp[start][start + len - 1] = temp; &#125; &#125; return dp[1][n]; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[357. Count Numbers with Unique Digits]]></title>
    <url>%2F2017%2F07%2F17%2F2017-07-17-357-Count-Numbers-with-Unique-Digits%2F</url>
    <content type="text"><![CDATA[Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x &lt; 10n. Example:Given n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x &lt; 100, excluding [11,22,33,44,55,66,77,88,99]) 解法1：一个排列组合的题目，注意一位的数有10种选择，而大于一位的数第一位只有9种。用一个数组或者一个变量prev记录之前的结果简化运算。C++1 Java1234567891011121314151617181920212223242526public class Solution &#123; public int countNumbersWithUniqueDigits(int n) &#123; if (n == 0) &#123; return 1; &#125; if (n == 1) &#123; return 10; &#125; int sum = 0; int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 10; dp[2] = 81; sum += dp[1] + dp[2]; for (int i = 3; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] * (9 - i + 2); sum += dp[i]; &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[530. Minimum Absolute Difference in BST]]></title>
    <url>%2F2017%2F07%2F15%2F2017-07-15-530-Minimum-Absolute-Difference-in-BST%2F</url>
    <content type="text"><![CDATA[Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes. Example:12345678910111213Input: 1 \ 3 / 2Output:1Explanation:The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3). Note: There are at least two nodes in this BST. 解法1：in-order的traversal是一个排序过后的数组，用一个prev记录上一次访问过的node，然后相邻的比较一下。用一个global variable寄存C++1 Java1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; int min = Integer.MAX_VALUE; TreeNode prev = null; public int getMinimumDifference(TreeNode root) &#123; // bst in order traversal is a sorted array // Record the prev node and current node // Calculate the difference and compare with global min inorder(root); return min; &#125; private void inorder(TreeNode root) &#123; if (root == null) &#123; return; &#125; inorder(root.left); if (prev != null) &#123; min = Math.min(min, Math.abs(prev.val - root.val)); &#125; prev = root; inorder(root.right); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[507. Perfect Number]]></title>
    <url>%2F2017%2F07%2F15%2F2017-07-15-507-Perfect-Number%2F</url>
    <content type="text"><![CDATA[We define the Perfect Number is a positive integer that is equal to the sum of all its positive divisors except itself.Now, given an integer n, write a function that returns true when it is a perfect number and false when it is not. Example:123Input: 28Output: TrueExplanation: 28 = 1 + 2 + 4 + 7 + 14 Note: The input number n will not exceed 100,000,000. (1e8) 解法1：每一个divisor都有对应的另外一个divisor， 每次找到一个小的divisor之后对应的大的divisor就成为了新的边界，因为不会再出现比大的divisor再大的没遇见的divisor。C++1 Java12345678910111213141516171819public class Solution &#123; public boolean checkPerfectNumber(int num) &#123; int sum = 1; int i = 2; int right = num; while ( i &lt; right) &#123; if (num % i == 0) &#123; sum += i; sum += (num / i); // the other side, &#125; right = num / i; i++; &#125; return sum == num &amp;&amp; num != 1; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[543. Diameter of Binary Tree]]></title>
    <url>%2F2017%2F07%2F15%2F2017-07-15-543-Diameter-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. Example:Given a binary tree12345 1 / \ 2 3 / \ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3]. Note: The length of path between two nodes is represented by the number of edges between them. 解法1：用一个function计算每一个node的max path， 然后对每一个node更新最大的diameter，每一个node的diameter是left + right。C++1 Java123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; int diameter = 0; public int diameterOfBinaryTree(TreeNode root) &#123; int temp = helper(root); return diameter; &#125; private int helper(TreeNode root) &#123; // Use this function to calculate the longest path rooted at "root" if (root == null) &#123; return 0; &#125; if (root.left == null &amp;&amp; root.right == null) &#123; return 1; &#125; int left = helper(root.left); int right = helper(root.right); // Update the longest path diameter = Math.max(diameter, left + right); return Math.max(left, right) + 1; // Update the longest path rooted at root &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[563. Binary Tree Tilt]]></title>
    <url>%2F2017%2F07%2F15%2F2017-07-15-563-Binary-Tree-Tilt%2F</url>
    <content type="text"><![CDATA[Given a binary tree, return the tilt of the whole tree. The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0. The tilt of the whole tree is defined as the sum of all nodes’ tilt. Example:12345678910Input: 1 / \ 2 3Output: 1Explanation:Tilt of node 2 : 0Tilt of node 3 : 0Tilt of node 1 : |2-3| = 1Tilt of binary tree : 0 + 0 + 1 = 1 Note: The sum of node values in any subtree won&apos;t exceed the range of 32-bit integer. All the tilt values won&apos;t exceed the range of 32-bit integer. 解法1：对每一个node计算一个total sum,同时也计算出当前node的sum，然后再把这个sum加入到结果中就可以了。C++1 Java123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; int totalTilt = 0; public int findTilt(TreeNode root) &#123; int temp = helper(root); return totalTilt; &#125; private int helper(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; if (root.left == null &amp;&amp; root.right == null) &#123; return root.val; &#125; int left = helper(root.left); int right = helper(root.right); totalTilt += Math.abs(left - right); // update the total tilt return left + right + root.val; // return total sum &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[479. Largest Palindrome Product]]></title>
    <url>%2F2017%2F07%2F15%2F2017-07-15-479-Largest-Palindrome-Product%2F</url>
    <content type="text"><![CDATA[Find the largest palindrome made from the product of two n-digit numbers. Since the result could be very large, you should return the largest palindrome mod 1337. Example: Input: 2 Output: 987 Explanation: 99 x 91 = 9009, 9009 % 1337 = 987 Note: The range of n is [1,8]. 解法1：这题不认为是简单题。。。主要的思路是，对于一个n位的数字，最大的数字就是pow(10, n) - 1, 那么可以从这个数字开始，计算出最大的可能的乘积。这就确定了我们搜索的上边界，那么如果把这个数分成左右两半，我们可以把左面的数看成是乘积左面的上边界然后遍历他，直到左面的数小于n个数字。然后每次对左面的数减1，看是否能构造成两个满足是palindrome的数。对于拆分成左右两个数，用到了left = prod / mod 和right = prod % mod的办法，其中mod = pow(10, n)也就是说，对于2位的数，最大可能乘积为4位，那么pow(10,2) = 100，4位的 mod 100可以得到后面两位，左面同理。对于每一个left的数，构造出一个palindrome的数，然后去看是否满足这个数能被其中一个数整除（范围是[i, prod/i]),其中i从maxNumber开始。 C++1 Java123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public int largestPalindrome(int n) &#123; if (n == 1) &#123; return 9; &#125; int base = 1337; int mod = (int)Math.pow(10, n); int maxNumber = (int)Math.pow(10, n) - 1; // Start from maxNumber and traverse until a result is found long prod = (long)maxNumber * (long)maxNumber; // To split prod into left half and right half int left = (int)(prod / mod); int right = (int)(prod % mod); if (left == reverse(right)) return (int)(prod % base); left--; prod = (long)left * (long)mod + (long)reverse(left); // Traverse from left to min while (left != mod / 10) &#123; for (int i = maxNumber; i &gt; prod / i; i--) &#123; if (prod % i == 0) &#123; return (int)(prod % base); &#125; &#125; left--; prod = (long)left * (long)mod + (long)reverse(left); &#125; return (int)(prod % base); &#125; private int reverse(int n) &#123; int x = n; int res = 0; while (x != 0) &#123; res = res * 10 + (x % 10); x /= 10; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[475. Heaters]]></title>
    <url>%2F2017%2F07%2F15%2F2017-07-15-475-Heaters%2F</url>
    <content type="text"><![CDATA[Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses. Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters. So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters. Note: Numbers of houses and heaters you are given are non-negative and will not exceed 25000. Positions of houses and heaters you are given are non-negative and will not exceed 10^9. As long as a house is in the heaters&apos; warm radius range, it can be warmed. All the heaters follow your radius standard and the warm radius will the same. Example 1:123Input: [1,2,3],[2]Output: 1Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed. Example 2:123Input: [1,2,3,4],[1,4]Output: 1Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed. 解法1：Array的题目需要总结一下常见的思路。一般看到array想想：是否需要排序？可以使用双指针？是否可以dp?这题的思路是，要覆盖所有的房子，那么每一个房子要知道离他最近的heater在哪里。我们找出所有房子对应的最近的heater的距离，然后再取最大的距离就是我们所求的最小的radius。我们可以对heaters排序，然后找寻对于每一个house最近的heaters，这里有一点greedy的思想，就是如果i…j对于房子A不是最近的heater，那么对于一个排在房子A之后的房子B，他们也一定不是最近的heaters。C++1 Java123456789101112131415161718public class Solution &#123; public int findRadius(int[] houses, int[] heaters) &#123; Arrays.sort(houses); Arrays.sort(heaters); int i = 0, res = 0; for (int house: houses) &#123; while (i &lt; heaters.length - 1 &amp;&amp; Math.abs(heaters[i] - house) &gt;= Math.abs(heaters[i + 1] - house)) &#123; i++; &#125; res = Math.max(res, Math.abs(heaters[i] - house)); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[400. Nth Digit]]></title>
    <url>%2F2017%2F07%2F15%2F2017-07-15-400-Nth-Digit%2F</url>
    <content type="text"><![CDATA[Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, … Note:n is positive and will fit within the range of a 32-bit signed integer (n &lt; 231). Example 1:12345Input:3Output:3 Example 2:12345Input:11Output:0 Explanation:The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, … is a 0, which is part of the number 10. 解法1：不太喜欢这种风格的题。。。基本思路是：1 digit =&gt; 9 numbers2 digits =&gt; 90 numbers3 digits =&gt; 900 numbers以此类推。 C++1 Java12345678910111213141516171819public class Solution &#123; public int findNthDigit(int m) &#123; long n=m; // convert int to long long start=1, len=1, count=9; while(n&gt;len*count)&#123; n=n-len*count; len++; count=count*10; start=start*10; &#125; // identify the number start = start + (n-1)/len; // identify the digit return String.valueOf(start).charAt((int)((n-1)%len))-'0'; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[367. Valid Perfect Square]]></title>
    <url>%2F2017%2F07%2F15%2F2017-07-15-367-Valid-Perfect-Square%2F</url>
    <content type="text"><![CDATA[Given a positive integer num, write a function which returns True if num is a perfect square else False. Note: Do not use any built-in library function such as sqrt. Example 1:12Input: 16Returns: True Example 2:12Input: 14Returns: False 解法1：基本的binarySearch， 要用一个long来防止overflow.C++1 Java1234567891011121314151617181920212223242526public class Solution &#123; public boolean isPerfectSquare(int num) &#123; if (num &lt;= 0) &#123; return false; &#125; long start = 1, end = num; while (start + 1 &lt; end) &#123; long mid = start + (end - start) / 2; long temp = mid * mid; if (temp &lt; num) &#123; start = mid; &#125; else if (temp &gt; num) &#123; end = mid; &#125; else &#123; return true; &#125; &#125; if (end * end == num || start * start == num) &#123; return true; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[170. Two Sum III - Data structure design]]></title>
    <url>%2F2017%2F07%2F15%2F2017-07-15-170-Two-Sum-III-Data-structure-design%2F</url>
    <content type="text"><![CDATA[Design and implement a TwoSum class. It should support the following operations: add and find. add - Add the number to an internal data structure.find - Find if there exists any pair of numbers which sum is equal to the value. For example,123add(1); add(3); add(5);find(4) -&gt; truefind(7) -&gt; false 解法1：要注意一些细节。需要排除找到的数字不是自己，所以要统计每一个数字出现的次数。C++1 Java123456789101112131415161718192021222324252627282930313233public class TwoSum &#123; /** Initialize your data structure here. */ HashMap&lt;Integer, Integer&gt; map = null; public TwoSum() &#123; map = new HashMap&lt;Integer, Integer&gt;(); &#125; /** Add the number to an internal data structure.. */ public void add(int number) &#123; map.put(number, map.getOrDefault(number, 0) + 1); &#125; /** Find if there exists any pair of numbers which sum is equal to the value. */ public boolean find(int value) &#123; for (int key : map.keySet()) &#123; int target = value - key; if (target == key &amp;&amp; map.get(key) &gt; 1 ) &#123; return true; &#125; else if (target != key &amp;&amp; map.containsKey(target)) &#123; return true; &#125; &#125; return false; &#125;&#125;/** * Your TwoSum object will be instantiated and called as such: * TwoSum obj = new TwoSum(); * obj.add(number); * boolean param_2 = obj.find(value); */]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[168. Excel Sheet Column Title]]></title>
    <url>%2F2017%2F07%2F15%2F2017-07-15-168-Excel-Sheet-Column-Title%2F</url>
    <content type="text"><![CDATA[Given a positive integer, return its corresponding column title as appear in an Excel sheet. For example:12345671 -&gt; A2 -&gt; B3 -&gt; C...26 -&gt; Z27 -&gt; AA28 -&gt; AB 解法1：这题做起来有点拗，主要的点就在于那个n–同时java里面char + integer是返回一个integer，所以需要用(char)去cast一下。C++1 Java12345678910111213141516public class Solution &#123; public String convertToTitle(int n) &#123; if (n &lt;= 0) &#123; return ""; &#125; StringBuilder builder = new StringBuilder(); while (n &gt; 0) &#123; n--; // key to success! builder.append((char)('A' + n % 26)); n /= 26; &#125; return builder.reverse().toString(); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[576. Out of Boundary Paths]]></title>
    <url>%2F2017%2F07%2F13%2F2017-07-13-576-Out-of-Boundary-Paths%2F</url>
    <content type="text"><![CDATA[There is an m by n grid with a ball. Given the start coordinate (i,j) of the ball, you can move the ball to adjacent cell or cross the grid boundary in four directions (up, down, left, right). However, you can at most move N times. Find out the number of paths to move the ball out of grid boundary. The answer may be very large, return it after mod 109 + 7. Example 1: Input:m = 2, n = 2, N = 2, i = 0, j = 0Output: 6Explanation: Example 2: Input:m = 1, n = 3, N = 3, i = 0, j = 1Output: 12Explanation:Note: Once you move the ball out of boundary, you cannot move it back. The length and height of the grid is in range [1,50]. N is in range [0,50]. 解法1：比较喜欢memorization的这个解法。最直观的思路就是对于每一个位置，用递归像4个方向搜索是否能到边界之外。如果可以则返回1.而每一个节点的数值是所有方向相加。但对于每一个位置(i,j)，和一定剩余的步数k, 这个组合在搜索的过程中会出现多次，所以用一个矩阵来记录下中间结果。 C++1 Java12345678910111213141516171819202122232425262728293031323334public class Solution &#123; private int M=1000000007; public int findPaths(int m, int n, int N, int i, int j) &#123; int[][][] memo = new int[m][n][N + 1]; for (int k = 0; k &lt; m; k++) &#123; for (int l = 0; l &lt; n; l++) &#123; for (int p = 0; p &lt;= N; p++) &#123; memo[k][l][p] = -1; &#125; &#125; &#125; return helper(m, n, N, i, j, memo); &#125; private int helper(int m, int n, int N, int i, int j, int[][][] memo) &#123; if (i == m || j == n || i &lt; 0 || j &lt; 0) &#123; return 1; &#125; if (N == 0) &#123; return 0; &#125; if (memo[i][j][N] != -1) &#123; return memo[i][j][N]; &#125; memo[i][j][N] = ((helper(m, n, N - 1, i + 1, j, memo) + helper(m, n, N - 1, i - 1, j, memo))%M + (helper(m, n, N - 1, i, j + 1, memo) + helper(m, n, N - 1, i, j - 1, memo))%M)%M; return memo[i][j][N]; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15. Read N Characters Given Read4 II - Call multiple times]]></title>
    <url>%2F2017%2F07%2F13%2F2017-07-13-15-Read-N-Characters-Given-Read4-II-Call-multiple-times%2F</url>
    <content type="text"><![CDATA[The API: int read4(char *buf) reads 4 characters at a time from a file. The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file. By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file. Note:The read function may be called multiple times. 解法1：这题其实针对的是在I中的解法里的一个问题，就是多读的buf会被扔掉。这里因为要call multiple times,那么不能扔掉多读的，而是要存起来。存起来的办法就是建一个queue,先读queue里的数，如果有多的就放回到queue里。C++1 Java12345678910111213141516171819202122232425262728293031323334353637/* The read4 API is defined in the parent class Reader4. int read4(char[] buf); */public class Solution extends Reader4 &#123; /** * @param buf Destination buffer * @param n Maximum number of characters to read * @return The number of characters read */ Queue&lt;Character&gt; queue = new LinkedList&lt;&gt;(); public int read(char[] buf, int n) &#123; int i = 0; while (i &lt; n &amp;&amp; !queue.isEmpty()) &#123; buf[i++] = queue.poll(); &#125; // i points to the next inserting position while (i &lt; n) &#123; char[] buffer = new char[4]; int len = read4(buffer); if (len == 0) &#123; return i; &#125; int j = 0; for (; j &lt; len &amp;&amp; i &lt; n; j++) &#123; buf[i++] = buffer[j]; &#125; while (j &lt; len) &#123; queue.offer(buffer[j++]); &#125; &#125; return i; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[68. Text Justification]]></title>
    <url>%2F2017%2F07%2F13%2F2017-07-13-68-Text-Justification%2F</url>
    <content type="text"><![CDATA[Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ‘ ‘ when necessary so that each line has exactly L characters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left justified and no extra space is inserted between words. For example,words: [“This”, “is”, “an”, “example”, “of”, “text”, “justification.”]L: 16. Return the formatted lines as: [ “This is an”, “example of text”, “justification. “] Note: Each word is guaranteed not to exceed L in length. 解法1：此题不难，也没有什么考点，可能就是考察编程能力和细心程度把。思路大体就是先找出来每一行有哪些words,然后在分布空格。分布空格的时候要从后往前分布，保证比较均匀且较多的空格在左面。对于最后一行的处理要注意补齐空格。C++1 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class Solution &#123; public List&lt;String&gt; fullJustify(String[] words, int maxWidth) &#123; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); if (words.length == 0 || maxWidth &lt; 0) &#123; return res; &#125; int i = 0; // coding skill and detail-oriented mindset int currentLen = 0; List&lt;String&gt; line = new ArrayList&lt;String&gt;(); while (i &lt; words.length) &#123; // need to know if it is the start of a line if ((line.isEmpty() ) || currentLen + 1 + words[i].length() &lt;= maxWidth) &#123; currentLen += (line.isEmpty() ? 0 : 1 ) + words[i].length(); // add a space line.add(words[i]); i++; &#125; else &#123; // Convert current line into a string and push into res res.add(justifyLine(line, maxWidth)); line = new ArrayList&lt;String&gt;(); currentLen = 0; &#125; &#125; // treat last line if (!line.isEmpty()) &#123; String lastLine = String.join(" ", line); if (lastLine.length() &lt; maxWidth) &#123; int spaces = maxWidth - lastLine.length(); for (i = 0; i &lt; spaces; i++) &#123; lastLine += " "; &#125; &#125; res.add(lastLine); &#125; return res; &#125; private String justifyLine(List&lt;String&gt; words, int maxWidth) &#123; StringBuilder builder = new StringBuilder(); int len = 0; for (String s : words) &#123; len += s.length(); &#125; int spaces = maxWidth - len; if (words.size() == 1) &#123; builder.append(words.get(0)); for (int i = 1; i &lt;= spaces; i++) &#123; builder.append(" "); &#125; &#125; else &#123; // distribute evenly List&lt;String&gt; temp = new ArrayList&lt;String&gt;(); for (int i = words.size() - 1; i &gt; 0; i--) &#123; int average = spaces / i; temp.add(words.get(i)); for (int s = 0; s &lt; average; s++) &#123; temp.add(" "); &#125; spaces -= average; &#125; // append last word temp.add(words.get(0)); for (int i = temp.size() - 1; i &gt;= 0; i--) &#123; builder.append(temp.get(i)); &#125; &#125; return builder.toString(); &#125; &#125; 第二遍写的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596class Solution &#123; public List&lt;String&gt; fullJustify(String[] words, int maxWidth) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); if (words == null || words.length == 0 || maxWidth &lt; 0) &#123; return res; &#125; int start = 0; int len = 0; for (int i = 0; i &lt; words.length; i++) &#123; if (len == 0) len += words[i].length(); else &#123; len += (1 + words[i].length()); &#125; if (len &gt; maxWidth) &#123; // means the last step is the right interval to do a justify res.add(justify(words, start, i - 1, maxWidth, false)); start = i; len = words[i].length(); &#125; &#125; res.add(justify(words, start, words.length - 1, maxWidth, true)); return res; &#125; /* Need to concate all words between start and end */ private String justify(String[] words, int start, int end, int maxWidth, boolean lastLine) &#123; StringBuilder builder = new StringBuilder(); // left justify for the single word problem if (start == end) &#123; builder.append(words[start]); for (int i = words[start].length() + 1; i &lt;= maxWidth; i++) &#123; builder.append(" "); &#125; return builder.toString(); &#125; // Calculate the number of space between words if (lastLine) &#123; int len = 0; for (int i = start; i &lt; end; i++) &#123; builder.append(words[i]); builder.append(" "); len += words[i].length() + 1; &#125; builder.append(words[end]); len += words[end].length(); while (len &lt; maxWidth) &#123; builder.append(" "); len++; &#125; return builder.toString(); &#125; int totalLen = 0; for (int i = start; i &lt;= end; i++) &#123; totalLen += words[i].length(); &#125; int n = end - start + 1; /* Start filling the words into the sequence */ int totalSpaces = maxWidth - totalLen; Stack&lt;String&gt; stack = new Stack&lt;&gt;(); for (int i = end; i &gt; start; i--) &#123; stack.push(words[i]); int spaces = totalSpaces / (i - start); for (int j = 0; j &lt; spaces; j++) &#123; stack.push(" "); &#125; totalSpaces -= spaces; &#125; stack.push(words[start]); while (!stack.isEmpty()) &#123; builder.append(stack.pop()); &#125; return builder.toString(); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[44. Wildcard Matching]]></title>
    <url>%2F2017%2F07%2F13%2F2017-07-13-44-Wildcard-Matching%2F</url>
    <content type="text"><![CDATA[Implement wildcard pattern matching with support for ‘?’ and ‘*’. ‘?’ Matches any single character.‘*’ Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). The function prototype should be:bool isMatch(const char s, const char p) Some examples:isMatch(“aa”,”a”) ? falseisMatch(“aa”,”aa”) ? trueisMatch(“aaa”,”aa”) ? falseisMatch(“aa”, ““) ? trueisMatch(“aa”, “a“) ? trueisMatch(“ab”, “?“) ? trueisMatch(“aab”, “ca*b”) ? false 解法1：这题的关键在于对于*的处理。DP 不能过OJtwo pointers可以，关键思路是碰到＊先从match 0个字符开始，往后继续match，如果发现不match了那就试着match 1个字符，以此类推。最后要注意是否pattern还只剩＊C++1 Java1234567891011121314151617181920212223242526272829303132public class Solution &#123; public boolean isMatch(String s, String p) &#123; if (s == null &amp;&amp; p == null) return true; if (s == null || p == null) return false; int ss = 0, pp = 0, starIndex = -1, match = 0; while (ss &lt; s.length()) &#123; if (pp &lt; p.length() &amp;&amp; (s.charAt(ss) == p.charAt(pp) || p.charAt(pp) == '?')) &#123; ss++; pp++; &#125; else if (pp &lt; p.length() &amp;&amp; p.charAt(pp) == '*') &#123; starIndex = pp; match = ss; pp++; &#125; else if (starIndex != -1) &#123; pp = starIndex + 1; match++; ss = match; &#125; else &#123; return false; &#125; &#125; while (pp &lt; p.length() &amp;&amp; p.charAt(pp) == '*') &#123; pp++; &#125; return pp == p.length(); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[501. Find Mode in Binary Search Tree]]></title>
    <url>%2F2017%2F07%2F13%2F2017-07-13-501-Find-Mode-in-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST. Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than or equal to the node&apos;s key. The right subtree of a node contains only nodes with keys greater than or equal to the node&apos;s key. Both the left and right subtrees must also be binary search trees. For example:Given BST [1,null,2,2], 1 \ 2 / 2 return [2]. Note: If a tree has more than one mode, you can return them in any order. Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count). 解法1：In-order traversal这题如果要求可以用extra space 的话很简单，用一个hashmap存储每一个出现的次数就可以了。现在不能用extra space,那么根据bst的性质，一个中序遍历可以得到一个排序的数组。对于这个排序数组，我们维护一个prev表示上一个节点，如果两个节点一样，我们更新count,如果不一样，则把当前的count和max相比，如果比max大则更新max并设置count为1. C++1 Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; TreeNode prev = null; int max = 1; int count = 1; public int[] findMode(TreeNode root) &#123; int count = 0; TreeNode prev = null; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); traverse(root, res); int[] resArray = new int[res.size()]; for (int i = 0; i &lt; res.size(); i++) &#123; resArray[i] = res.get(i); &#125; return resArray; &#125; private void traverse(TreeNode root, List&lt;Integer&gt; res) &#123; if (root == null) &#123; return; &#125; traverse(root.left, res); if (prev != null) &#123; if (root.val == prev.val) &#123; count++; &#125; else &#123; count = 1; &#125; &#125; if (count &gt; max) &#123; res.clear(); max = count; res.add(root.val); &#125; else if (count == max) &#123; res.add(root.val); &#125; prev = root; traverse(root.right, res); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>In-order-traversal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[637. Average of Levels in Binary Tree]]></title>
    <url>%2F2017%2F07%2F13%2F2017-07-13-637-Average-of-Levels-in-Binary-TRee%2F</url>
    <content type="text"><![CDATA[Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array. Example 1:12345678910Input: 3 / \ 9 20 / \ 15 7Output: [3, 14.5, 11]Explanation:The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11]. Note: The range of node&apos;s value is in the range of 32-bit signed integer. 解法1：一个bfs解决问题。要注意的是当中的加和可能会overflow，要用long。C++1 Java1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123; List&lt;Double&gt; res = new ArrayList&lt;Double&gt;(); if (root == null) &#123; return res; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; int size = queue.size(); long sum = 0; for (int i = 0; i &lt; size; i++) &#123; TreeNode current = queue.poll(); sum += current.val; if (current.left != null) &#123; queue.offer(current.left); &#125; if (current.right != null) &#123; queue.offer(current.right); &#125; &#125; res.add((double)sum / size); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[368. Largest Divisible Subset]]></title>
    <url>%2F2017%2F07%2F13%2F2017-07-13-368-Largest-Divisible-Subset%2F</url>
    <content type="text"><![CDATA[Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0. If there are multiple solutions, return any subset is fine. Example 1: nums: [1,2,3] Result: [1,2] (of course, [1,3] will also be ok) Example 2: nums: [1,2,4,8] Result: [1,2,4,8] 解法1：思路是：if a &lt; b then a % b != 0 for all a , b &gt; 0所以只需要对与一个数，只要从大往小找小于他的数即可。第二步：先把数组排序，便于分析。对于排好序的数组，我们可以计算出对于每一个数字，数组中存在的可以整除他的数的最大个数。这可以用一个dp完成。统计出最大的个数的同时，如果我们维护另外一个数组，记录能被整除且sequence最长的那个数的index，就能在之后把整条链提取出来。 C++1 Java123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public List&lt;Integer&gt; largestDivisibleSubset(int[] nums) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if (nums == null || nums.length == 0) &#123; return res; &#125; Arrays.sort(nums); // sort the array first int n = nums.length; int[] dp = new int[n]; int[] index = new int[n]; // index stores the corresponding next item in the longest subsequence Arrays.fill(dp, 1); Arrays.fill(index, -1); int max = 1; int maxIndex = 0; for (int i = 1; i &lt; n; i++) &#123; for (int j = i - 1; j &gt;= 0; j--) &#123; if (nums[i] % nums[j] == 0) &#123; if (dp[j] + 1 &gt; dp[i]) &#123; dp[i] = dp[j] + 1; // update the dp array index[i] = j; &#125; &#125; &#125; if (dp[i] &gt; max) &#123; max = dp[i]; maxIndex = i; &#125; &#125; // maxIndex for (int i = maxIndex; i != -1; i = index[i]) &#123; res.add(nums[i]); &#125; return res; &#125;&#125; 这题如果改成，求最长的subset的长度，使得subset中每两个数字都能保证其中一个被整除，那么这就是一个经典的dp问题。这题的难点是在这个的基础上要求出这个subset。对于这种问题，一般可以采取的方法就是在dp的过程中记录下每一个点的optimal解法相对应的位置。这题就是这样，dp[i]记录下对于第i个点，他们之前的0到i-1个点对应的能被其整除的数字的个数，当这个个数被更新的时候，记录下其所对应的位置。当扫描结束一遍之后，我们也得到了对应于最大答案的subset中每一个点的位置。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public List&lt;Integer&gt; largestDivisibleSubset(int[] nums) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if (nums == null || nums.length == 0) &#123; return res; &#125; int n = nums.length; Arrays.sort(nums); int[] dp = new int[n]; // stores the number of longest subsequence of the array that all elements can be divisible dp[0] = 1; int[] tracks = new int[n]; Arrays.fill(tracks, -1); int max = 0; for (int i =1; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (nums[i] % nums[j] == 0) &#123; if (dp[j] + 1 &gt;= dp[i]) &#123; dp[i] = dp[j] + 1; tracks[i] = j; &#125; &#125; &#125; if (dp[i] &gt;= dp[max]) &#123; max = i; &#125; &#125; // start from i and trace back to get the list for (int i = max; i &gt;= 0; i = tracks[i]) &#123; res.add(nums[i]); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[572. Subtree of Another Tree]]></title>
    <url>%2F2017%2F07%2F13%2F2017-07-13-572-Subtree-of-Another-Tree%2F</url>
    <content type="text"><![CDATA[Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node’s descendants. The tree s could also be considered as a subtree of itself. Example 1:Given tree s:1234567891011 3 / \ 4 5 / \1 2Given tree t: 4 / \1 2 Return true, because t has the same structure and node values with a subtree of s. Example 2:Given tree s:12345678910111213 3 / \ 4 5 / \1 2 / 0Given tree t: 4 / \1 2 Return false. 解法1：很简单的一个递归算法。如果当前节点数值一样，那么先判断是否identical,如果不是，考虑left, 考虑right是否和target tree存在subset关系。 C++1 Java123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public boolean isSubtree(TreeNode s, TreeNode t) &#123; if (s == null &amp;&amp; t == null) &#123; return true; &#125; else if (s == null || t == null) &#123; return false; &#125; if (s.val == t.val) &#123; if (identical(s, t)) &#123; return true; &#125; &#125; return isSubtree(s.left, t) || isSubtree(s.right, t); &#125; private boolean identical(TreeNode s, TreeNode t) &#123; if (s == null &amp;&amp; t == null) &#123; return true; &#125; else if (s == null || t == null) &#123; return false; &#125; if (s.val != t.val) &#123; return false; &#125; return identical(s.left, t.left) &amp;&amp; identical(s.right, t.right); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[115. Distinct Subsequences]]></title>
    <url>%2F2017%2F07%2F13%2F2017-07-13-115-Distinct-Subsequences%2F</url>
    <content type="text"><![CDATA[Given a string S and a string T, count the number of distinct subsequences of S which equals T. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABCDE” while “AEC” is not). Here is an example:S = “rabbbit”, T = “rabbit” Return 3. 解法1：O(NM)dp[i][j]表示的是s[0,i]和t[0,j]的匹配答案。递推关系可以分为s[i] == t[j] 和不等的两种情况如果相等，那么既可以是包括i, 那么就是需要知道(i-1,j-1)的结果；也可以是不包括j, 那么就需要知道(i -1, j)的结果如果不相等，只要(i - 1, j)就可以了。C++1 Java12345678910111213141516171819202122232425public class Solution &#123; public int numDistinct(String s, String t) &#123; int n = s.length(); int m = t.length(); int[][] dp = new int[n + 1][m + 1]; for (int i = 0; i &lt;= n; i++) &#123; dp[i][0] = 1; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (s.charAt(i - 1) == t.charAt(j - 1)) &#123; dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; &#125; else &#123; dp[i][j] = dp[i - 1][j]; &#125; &#125; &#125; return dp[n][m]; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[377. Combination Sum IV]]></title>
    <url>%2F2017%2F07%2F13%2F2017-07-13-377-Combination-Sum-IV%2F</url>
    <content type="text"><![CDATA[Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Example:1234567891011nums = [1, 2, 3]target = 4The possible combination ways are:(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1) Note that different sequences are counted as different combinations. Therefore the output is 7. Follow up:What if negative numbers are allowed in the given array?How does it change the problem?What limitation we need to add to the question to allow negative numbers? 解法1：O(N) 解法 dp[i]表示的是target为i时一共的解法。对于如果target较大的话，可以先把nums排一下序。然后在内层循环里面当i&lt;num的时候直接break就可以了。follow up：如果负数被允许的话，解答可能是infinite。比如[-1,1]，target为1的情况。这个时候需要限制比如每个元素用几次之类的。 Java123456789101112131415161718192021public class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int n = nums.length; int[] dp = new int[target + 1]; dp[0] = 1; for (int i = 0; i &lt;= target; i++) &#123; for (int num : nums) &#123; if (i &gt;= num) &#123; dp[i] += dp[i - num]; &#125; &#125; &#125; return dp[target]; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[300. Longest Increasing Subsequence]]></title>
    <url>%2F2017%2F07%2F11%2F2017-07-11-300-Longest-Increasing-Subsequence%2F</url>
    <content type="text"><![CDATA[Given an unsorted array of integers, find the length of longest increasing subsequence. For example,Given [10, 9, 2, 5, 3, 7, 101, 18],The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity. Follow up: Could you improve it to O(n log n) time complexity? 解法1：O(N^2)经典dp, dp[i]是到第ｉ个数字的最大递增subsequence, 那么dp[i] = Max(dp[k1], dp[k2], dp[k3]…) + 1, nums[i] &gt; nums[kn] C+,1 Java123456789101112131415161718192021222324public class Solution &#123; public int lengthOfLIS(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int[] dp = new int[nums.length]; dp[0] = 1; int res = 1; for (int i = 1; i &lt; nums.length; i++) &#123; dp[i] = 1; for (int j = 0; j &lt; i; j++) &#123; if (nums[i] &gt; nums[j]) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); &#125; &#125; res = Math.max(res, dp[i]); &#125; return res; &#125;&#125; 解法2：O(NlogN)解释参考leetcode 的答案解释：1234567891011121314151617In this approach, we scan the array from left to right. We also make use of a dpdpdp array initialized with all 0&apos;s. This dpdpdp array is meant to store the increasing subsequence formed by including the currently encountered element. While traversing the numsnumsnums array, we keep on filling the dpdpdp array with the elements encountered so far. For the element corresponding to the jthj^&#123;th&#125;j​th​​ index (nums[j]nums[j]nums[j]), we determine its correct position in the dpdpdp array(say ithi^&#123;th&#125;i​th​​ index) by making use of Binary Search(which can be used since the dpdpdp array is storing increasing subsequence) and also insert it at the correct position. An important point to be noted is that for Binary Search, we consider only that portion of the dpdpdp array in which we have made the updations by inserting some elements at their correct positions(which remains always sorted). Thus, only the elements upto the ithi^&#123;th&#125;i​th​​ index in the dpdpdp array can determine the position of the current element in it. Since, the element enters its correct position(iii) in an ascending order in the dpdpdp array, the subsequence formed so far in it is surely an increasing subsequence. Whenever this position index iii becomes equal to the length of the LIS formed so far(lenlenlen), it means, we need to update the lenlenlen as len=len+1len = len + 1len=len+1.Note: dpdpdp array does not result in longest increasing subsequence, but length of dpdpdp array will give you length of LIS.Consider the example:input: [0, 8, 4, 12, 2]dp: [0]dp: [0, 8]dp: [0, 4]dp: [0, 4, 12]dp: [0 , 2, 12] which is not the longest increasing subsequence, but length of dpdpdp array results in length of Longest Increasing Subsequence. lang: java1234567891011121314151617public class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int[] dp = new int[nums.length]; int len = 0; for (int num : nums) &#123; int i = Arrays.binarySearch(dp, 0, len, num); if (i &lt; 0) &#123; i = -(i + 1); &#125; dp[i] = num; if (i == len) &#123; len++; &#125; &#125; return len; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[351. Android Unlock Patterns]]></title>
    <url>%2F2017%2F07%2F11%2F2017-07-11-351-Android-Unlock-Patterns%2F</url>
    <content type="text"><![CDATA[Given an Android 3x3 key lock screen and two integers m and n, where 1 ≤ m ≤ n ≤ 9, count the total number of unlock patterns of the Android lock screen, which consist of minimum of m keys and maximum n keys. Rules for a valid pattern: Each pattern must connect at least m keys and at most n keys. All the keys must be distinct. If the line connecting two consecutive keys in the pattern passes through any other keys, the other keys must have previously selected in the pattern. No jumps through non selected key is allowed. The order of keys used matters.Explanation: | 1 | 2 | 3 || 4 | 5 | 6 || 7 | 8 | 9 | Invalid move: 4 - 1 - 3 - 6Line 1 - 3 passes through key 2 which had not been selected in the pattern. Invalid move: 4 - 1 - 9 - 2Line 1 - 9 passes through key 5 which had not been selected in the pattern. Valid move: 2 - 4 - 1 - 3 - 6Line 1 - 3 is valid because it passes through key 2, which had been selected in the pattern Valid move: 6 - 5 - 4 - 1 - 9 - 2Line 1 - 9 is valid because it passes through key 5, which had been selected in the pattern. Example:Given m = 1, n = 1, return 9. 解法1：这题一拿到感觉是dp或者是dfs的题目。用dp想不出状态方程看来只能用dfs试一下。dfs的话最核心的思想就是每次往目标前进一步，如果成功则再继续探寻。这个问题的一部是要看上一步和当前一步是否构成一个合适的movement.一定是：１． 相邻的２． 对线的３． 不相邻但是当中的数字已经被访问过了 那么用一个数组维护访问过的数字，同时维护一个上次访问的数字和当前的数字，以便判断一个move是否合适。对于每一个数字进行dfs遍历，每前进一步就把所剩的步数－１．C++1 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Solution &#123; public int numberOfPatterns(int m, int n) &#123; int sum = 0; for (int i = m; i &lt;= n; i++) &#123; boolean[] visited = new boolean[9]; // initialize the array sum += dfs(visited, -1, i); &#125; return sum; &#125; private boolean isValidMove(boolean[] visited, int last, int current) &#123; if (visited[current]) &#123; return false; &#125; if (last == -1) &#123; // First move, always true return true; &#125; if ((last + current) % 2 == 1) &#123; return true; &#125; int row_last = last / 3; int row_current = current / 3; int col_last = last % 3; int col_current = current % 3;// if (row_last == row_current &amp;&amp; (Math.abs(col_last - col_current) == 1)) &#123;// return true;// &#125;// if (col_last == col_current &amp;&amp; (Math.abs(row_last - row_current) == 1)) &#123;// return true;// &#125; int mid = (last + current) / 2; if (mid == 4) &#123; return visited[mid]; // diagonal &#125; if (row_last != row_current &amp;&amp; col_last != col_current) &#123; return true; &#125; return visited[mid]; &#125; private int dfs(boolean[] visited, int last, int len) &#123; // last is the last visited number // len is the remaining length of required key string if (len == 0) &#123; return 1; &#125; // record the sum int sum = 0; for (int i = 0; i &lt; 9; i++) &#123; // Move from last to i if (isValidMove(visited, last, i)) &#123; visited[i] = true; sum += dfs(visited, i, len - 1); visited[i] = false; &#125; &#125; return sum; &#125;&#125; 解法2：由于可能的跳跃是有限的，可以用一个table来存储合法的跳跃path。这样可以简化很多检查一个move是否合法的code。每次DFS的时候从一个点开始，找出可能的path。同时利用对称性，1,3,7,9是一样的；2,4,6,8是一样的。5单独一个。 1234567891011121314151617181920212223242526272829303132333435363738public class Solution &#123; // cur: the current position // remain: the steps remaining int DFS(boolean vis[], int[][] skip, int cur, int remain) &#123; if(remain &lt; 0) return 0; if(remain == 0) return 1; vis[cur] = true; int rst = 0; for(int i = 1; i &lt;= 9; ++i) &#123; // If vis[i] is not visited and (two numbers are adjacent or skip number is already visited) if(!vis[i] &amp;&amp; (skip[cur][i] == 0 || (vis[skip[cur][i]]))) &#123; rst += DFS(vis, skip, i, remain - 1); &#125; &#125; vis[cur] = false; return rst; &#125; public int numberOfPatterns(int m, int n) &#123; // Skip array represents number to skip between two pairs int skip[][] = new int[10][10]; skip[1][3] = skip[3][1] = 2; skip[1][7] = skip[7][1] = 4; skip[3][9] = skip[9][3] = 6; skip[7][9] = skip[9][7] = 8; skip[1][9] = skip[9][1] = skip[2][8] = skip[8][2] = skip[3][7] = skip[7][3] = skip[4][6] = skip[6][4] = 5; boolean vis[] = new boolean[10]; int rst = 0; // DFS search each length from m to n for(int i = m; i &lt;= n; ++i) &#123; rst += DFS(vis, skip, 1, i - 1) * 4; // 1, 3, 7, 9 are symmetric rst += DFS(vis, skip, 2, i - 1) * 4; // 2, 4, 6, 8 are symmetric rst += DFS(vis, skip, 5, i - 1); // 5 &#125; return rst; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[30. Substring with Concatenation of All Words]]></title>
    <url>%2F2017%2F07%2F11%2F2017-07-11-30-Substring-with-Concatenation-of-All-Words%2F</url>
    <content type="text"><![CDATA[You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. For example, given:s: “barfoothefoobarman”words: [“foo”, “bar”] You should return the indices: [0,9].(order does not matter). 解法1：也是滑动窗口的思路，第一层循环是对于起始点的遍历。起始点可以从0到word的长度－１。之后就是一个词一个词的向右进。同时统计每一个词出现的次数。C++1 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Solution &#123; public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123;List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if (words == null || words.length == 0) &#123; return res; &#125; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); Map&lt;String, Integer&gt; currentMap = new HashMap&lt;&gt;(); for (String word : words) &#123; map.put(word, map.getOrDefault(word, 0) + 1); &#125; int len = s.length(); int N = words.length; int M = words[0].length(); for (int i = 0; i &lt; M; i++) &#123; int count = 0; int start = i; // record the start index of the substring int left = start, right = left + M; while (right &lt;= len) &#123; String current = s.substring(left, right); if (map.containsKey(current)) &#123; currentMap.put(current, currentMap.getOrDefault(current, 0) + 1); if (currentMap.get(current) &lt;= map.get(current)) count++; // find a matched word while (currentMap.get(current) &gt; map.get(current)) &#123; String temp = s.substring(start, start + M); currentMap.put(temp, currentMap.get(temp) - 1); start += M; // update the start of the substring if (currentMap.get(temp) &lt; map.get(temp)) count--; &#125; if (count == N) &#123; res.add(start); String temp = s.substring(start, start + M); currentMap.put(temp, currentMap.get(temp) - 1); count--; start += M; // update the start of the substring &#125; &#125; else &#123; count = 0; currentMap.clear(); start = right; &#125; left = right; right += M; &#125; currentMap.clear(); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[340. Longest Substring with At Most k Distinct Characters]]></title>
    <url>%2F2017%2F07%2F11%2F2017-07-11-340-Longest-Substring-with-At-Most-k-Distinct-Characters%2F</url>
    <content type="text"><![CDATA[Given a string, find the length of the longest substring T that contains at most k distinct characters. For example, Given s = “eceba” and k = 2, T is “ece” which its length is 3. 解法1：O(N)滑动窗口的解法。C++1 Java1234567891011121314151617181920212223242526272829public class Solution &#123; public int lengthOfLongestSubstringKDistinct(String s, int k) &#123; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int count = 0, start = 0, end = 0; int res = 0; while (end &lt; s.length()) &#123; char current = s.charAt(end); map.put(current, map.getOrDefault(current, 0) + 1); if (map.get(current) == 1) &#123; count++; &#125; end++; // move 1 position forward while (count &gt; k) &#123; char prev = s.charAt(start); map.put(prev, map.get(prev) - 1); if (map.get(prev) == 0) &#123; count--; &#125; start++; &#125; res = Math.max(res, end - start); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[159. Longest Substring with At Most Two Distinct Characters]]></title>
    <url>%2F2017%2F07%2F11%2F2017-07-11-159-Longest-Substring-with-At-Most-Two-Distinct-Characters%2F</url>
    <content type="text"><![CDATA[Given a string, find the length of the longest substring T that contains at most 2 distinct characters. For example, Given s = “eceba”, T is “ece” which its length is 3. 解法1：O(N)这题是sliding window的一个例题。要掌握一下模板。这题和另一题at most k distinct characters的解法一致。主要的思路就是维护一个hashmap存取每一个元素出现的次数，如果为１的话，就说明是新入的元素，总个数要＋１同时维护一个start指针来标记左面的边界，每次找到一个符合标准的答案时，更新最长的长度。C++1 Java12345678910111213141516171819202122232425262728293031public class Solution &#123; public int lengthOfLongestSubstringTwoDistinct(String s) &#123; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int count = 0, start = 0, end = 0; int res = 0; while (end &lt; s.length()) &#123; char current = s.charAt(end); map.put(current, map.getOrDefault(current, 0) + 1); if (map.get(current) == 1) &#123; // new character count++; &#125; end++; // move end 1 position forward while (count &gt; 2) &#123; char prev = s.charAt(start); map.put(prev, map.get(prev) -1 ); if (map.get(prev) == 0) &#123; // Removed one character count--; &#125; start++; &#125; res = Math.max(res, end - start); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[221. Maximal Square]]></title>
    <url>%2F2017%2F07%2F10%2F2017-07-10-221-Maximal-Square%2F</url>
    <content type="text"><![CDATA[Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area. For example, given the following matrix:12341 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0 Return 4. 解法1：诀窍在于dp[i][j] 表示以(i,j)为底的正方形的边长。dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1, if matrix[i][j] == 1,画一下图就比较清楚。C++1 Java123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public int maximalSquare(char[][] matrix) &#123; if (matrix.length == 0 || matrix[0].length == 0) &#123; return 0; &#125; int row = matrix.length; int col = matrix[0].length; int[][] dp = new int[row][col]; dp[0][0] = matrix[0][0] - '0' == 1 ? 1 : 0; int res = dp[0][0]; // record the final result for (int j = 1; j &lt; col; j++) &#123; if (matrix[0][j] - '0' == 1) &#123; dp[0][j] = 1; res = 1; &#125; &#125; for (int i = 1; i &lt; row; i++) &#123; if (matrix[i][0] - '0' == 1) &#123; dp[i][0] = 1; res = 1; &#125; &#125; for (int i = 1; i &lt; row; i++) &#123; for (int j = 1; j &lt; col; j++) &#123; if (matrix[i][j] - '0' == 0) &#123; dp[i][j] = 0; &#125; else &#123; dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]),dp[i - 1][j - 1]) + 1; &#125; res = Math.max(res, dp[i][j] * dp[i][j]); &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[264. Ugly Number II]]></title>
    <url>%2F2017%2F07%2F10%2F2017-07-10-264-Ugly-Number-II%2F</url>
    <content type="text"><![CDATA[Write a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note that 1 is typically treated as an ugly number, and n does not exceed 1690. 解法1：C++1 Java12345678910111213141516171819202122232425public class Solution &#123; public int nthUglyNumber(int n) &#123; int[] dp = new int[n]; dp[0] = 1; int i = 0, j = 0, k = 0; int d1 = 2, d2 = 3, d3 = 5; int count = 1; for (int p = 1; p &lt; n; p++) &#123; int res = Math.min(Math.min(d1, d2), d3); dp[p] = res; if (d1 == res) &#123; d1 = 2 * dp[++i]; &#125; if (d2 == res) &#123; d2 = 3 * dp[++j]; &#125; if (d3 == res) &#123; d3 = 5 * dp[++k]; &#125; &#125; return dp[n - 1]; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[256. Paint House]]></title>
    <url>%2F2017%2F07%2F10%2F2017-07-10-256-Paint-House%2F</url>
    <content type="text"><![CDATA[There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on… Find the minimum cost to paint all houses. Note:All costs are positive integers. 解法1：O(N*K) TimeN是房子的数量，K是房子的颜色数。经典dp, dp[i][j] 表示前i个房子的最小cost,当第i个房子涂得颜色是j。C++1 Java1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public int minCost(int[][] costs) &#123; if (costs.length == 0 || costs[0].length == 0) &#123; return 0; &#125; int n = costs.length; int col = costs[0].length; int[][] dp = new int[n][col]; // first i houses painted and ith house painted with jth color for (int j = 0; j &lt; col;j++) &#123; dp[0][j] = costs[0][j]; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; int temp = Integer.MAX_VALUE; for (int k = 0; k &lt; col; k++) &#123; if (k != j) &#123; temp = Math.min(temp, dp[i - 1][k]); &#125; &#125; dp[i][j] = costs[i][j] + temp; &#125; &#125; int res = Integer.MAX_VALUE; for (int j = 0; j &lt; col; j++) &#123; res = Math.min(res, dp[n - 1][j]); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[591. Tag Validator]]></title>
    <url>%2F2017%2F07%2F10%2F2017-07-10-591-Tag-Validator%2F</url>
    <content type="text"><![CDATA[Given a string representing a code snippet, you need to implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold: The code must be wrapped in a valid closed tag. Otherwise, the code is invalid. A closed tag (not necessarily valid) has exactly the following format : &lt;TAG_NAME&gt;TAG_CONTENT&lt;/TAG_NAME&gt;. Among them, &lt;TAG_NAME&gt; is the start tag, and &lt;/TAG_NAME&gt; is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid. A valid TAG_NAME only contain upper-case letters, and has length in range [1,9]. Otherwise, the TAG_NAME is invalid. A valid TAG_CONTENT may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched &lt;, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the TAG_CONTENT is invalid. A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested. A &lt; is unmatched if you cannot find a subsequent &gt;. And when you find a &lt; or &lt;/, all the subsequent characters until the next &gt; should be parsed as TAG_NAME (not necessarily valid). The cdata has the following format : &lt;![CDATA[CDATA_CONTENT]]&gt;. The range of CDATA_CONTENT is defined as the characters between &lt;![CDATA[ and the first subsequent ]]&gt;. CDATA_CONTENT may contain any characters. The function of cdata is to forbid the validator to parse CDATA_CONTENT, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters. Valid Code Examples:1234567891011121314151617181920212223242526272829303132333435363738Input: &quot;&lt;DIV&gt;This is the first line &lt;![CDATA[&lt;div&gt;]]&gt;&lt;/DIV&gt;&quot;Output: TrueExplanation:The code is wrapped in a closed tag : &lt;DIV&gt; and &lt;/DIV&gt;.The TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata.Although CDATA_CONTENT has unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as tag.So TAG_CONTENT is valid, and then the code is valid. Thus return true.Input: &quot;&lt;DIV&gt;&gt;&gt; ![cdata[]] &lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&gt;]&lt;/DIV&gt;&quot;Output: TrueExplanation:We first separate the code into : start_tag|tag_content|end_tag.start_tag -&gt; &quot;&lt;DIV&gt;&quot;end_tag -&gt; &quot;&lt;/DIV&gt;&quot;tag_content could also be separated into : text1|cdata|text2.text1 -&gt; &quot;&gt;&gt; ![cdata[]] &quot;cdata -&gt; &quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;&quot;, where the CDATA_CONTENT is &quot;&lt;div&gt;]&gt;&quot;text2 -&gt; &quot;]]&gt;&gt;]&quot;The reason why start_tag is NOT &quot;&lt;DIV&gt;&gt;&gt;&quot; is because of the rule 6.The reason why cdata is NOT &quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&quot; is because of the rule 7. Invalid Code Examples:123456789101112131415161718Input: &quot;&lt;A&gt; &lt;B&gt; &lt;/A&gt; &lt;/B&gt;&quot;Output: FalseExplanation: Unbalanced. If &quot;&lt;A&gt;&quot; is closed, then &quot;&lt;B&gt;&quot; must be unmatched, and vice versa.Input: &quot;&lt;DIV&gt; div tag is not closed &lt;DIV&gt;&quot;Output: FalseInput: &quot;&lt;DIV&gt; unmatched &lt; &lt;/DIV&gt;&quot;Output: FalseInput: &quot;&lt;DIV&gt; closed tags with invalid tag name &lt;b&gt;123&lt;/b&gt; &lt;/DIV&gt;&quot;Output: FalseInput: &quot;&lt;DIV&gt; unmatched tags with invalid tag name &lt;/1234567890&gt; and &lt;CDATA[[]]&gt; &lt;/DIV&gt;&quot;Output: FalseInput: &quot;&lt;DIV&gt; unmatched start tag &lt;B&gt; and unmatched end tag &lt;/C&gt; &lt;/DIV&gt;&quot;Output: False Note: For simplicity, you could assume the input code (including the any characters mentioned above) only contain letters, digits, &apos;&lt;&apos;,&apos;&gt;&apos;,&apos;/&apos;,&apos;!&apos;,&apos;[&apos;,&apos;]&apos; and &apos; &apos;. 解法1：此题比较繁琐，题目也巨长。实际上并不是很难。主要要先总结一下要求：字符串一定是以tag开头和结尾tag的名字要符合： １． １－ ９个字符之内２． 只能是upper case letters３． 需要两两配对４． &lt;!出现的话一定需要match ＣＤＡＴＡ 然后对于每一个tag,用一个stack去记录上一个tag的顺序即可。 C++1 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class Solution &#123; public boolean isValid(String code) &#123; // It should start with &lt; and end with &gt; if (code == null || code.length() == 0) &#123; return false; &#125; if (code.charAt(0) != '&lt;' || code.charAt(code.length() - 1) != '&gt;') &#123; return false; &#125; Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); boolean tagExist = false; for (int i = 0; i &lt; code.length(); i++) &#123; if (stack.isEmpty() &amp;&amp; tagExist) &#123; return false; &#125; int last = -1; if (code.charAt(i) == '&lt;') &#123; if (!stack.isEmpty() &amp;&amp; code.charAt(i + 1) == '!') &#123; last = code.indexOf("]]&gt;", i + 1); if (last == -1 || !isValidCdata(code.substring(i + 2, last))) &#123; return false; &#125; &#125; else &#123; boolean close = false; if (code.charAt(i + 1) == '/') &#123; close = true; i++; &#125; last = code.indexOf("&gt;", i+1); if (last == -1 || !isValidTagName(code.substring(i + 1, last))) &#123; return false; &#125; if (close) &#123; if (stack.isEmpty() || !stack.peek().equals(code.substring(i + 1, last))) &#123; return false; &#125; else &#123; stack.pop(); &#125; &#125; else &#123; tagExist = true; stack.push(code.substring(i + 1, last)); &#125; &#125; i = last; // move i to the end of the tag &#125; &#125; return stack.isEmpty() &amp;&amp; tagExist; &#125; private boolean isValidCdata(String content) &#123; int tag = content.indexOf("[CDATA["); return tag == 0; &#125; private boolean isValidTagName(String tag) &#123; int len = tag.length(); if (len &lt; 1 || len &gt; 9) &#123; return false; &#125; for (int i = 0; i &lt; len; i++) &#123; if (tag.charAt(i) &lt; 'A' || tag.charAt(i) &gt; 'Z') &#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[32. Longest Valid Parentheses]]></title>
    <url>%2F2017%2F07%2F10%2F2017-07-10-32-Longest-Valid-Parentheses%2F</url>
    <content type="text"><![CDATA[Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring. For “(()”, the longest valid parentheses substring is “()”, which has length = 2. Another example is “)()())”, where the longest valid parentheses substring is “()()”, which has length = 4. 解法1：DP O(N) Time + O(N) Space此题有多种解法。DP只是其中一种。只有在碰到)的时候才需要去计算当前配对括号长度。状态方程的解释是：如果在)之前的符号是(，那么最长的合法字符串长度就是(之前的合法长度＋２如果之前的符号是), dp[i - 1]代表了如果i - 1结尾的合法的最长长度，那么如果在dp[i - 1]之前的那个字符是（，当前的合法长度就可以等于dp[i - 1] + dp[i - dp[i - 1] - 2] ＋ ２由此可以写出状态方程。 C++1 Java12345678910111213141516171819202122232425public class Solution &#123; public int longestValidParentheses(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; int[] dp = new int[s.length()]; int res = 0; for (int i = 1; i &lt; s.length(); i++) &#123; if (s.charAt(i) == ')') &#123; if (s.charAt(i - 1) == '(') &#123; dp[i] = (i &gt;= 2 ? dp[i - 2] : 0) + 2; // add () to dp[i - 2] &#125; else if (s.charAt(i - 1) == ')') &#123; if (i - dp[i -1] &gt;= 1 &amp;&amp; s.charAt(i - dp[i - 1] - 1) == '(') &#123; dp[i] = dp[i - 1] + (i - dp[i - 1] &gt;= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2; &#125; &#125; res = Math.max(dp[i], res); &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[522. Longest Uncommon Subsequence II]]></title>
    <url>%2F2017%2F07%2F09%2F2017-07-09-522-Longest-Uncommon-Subsequence-II%2F</url>
    <content type="text"><![CDATA[Given a list of strings, you need to find the longest uncommon subsequence among them. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings. A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string. The input will be a list of strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn’t exist, return -1. Example 1:12Input: &quot;aba&quot;, &quot;cdc&quot;, &quot;eae&quot;Output: 3 Note: All the given strings’ lengths will not exceed 10. The length of the given list will be in the range of [2, 50]. 解法1：O(N^2 * X)x is the average length of strings. N is the number of strings这题的关键在于substring的定义要注意，和平时遇到的substring定义不同。这里的substring是可以提取不连续的字符组成。分析一下可以发现，如果存在答案的话，那么uncommon subsequence 一定是其中某一个string，那么就把每一个string和其他的相比，看是否为其他的substring，如果不是，那么更新最大值。 C++1 Java1234567891011121314151617181920212223242526272829303132public class Solution &#123; public int findLUSlength(String[] strs) &#123; int j = 0; int res = -1; for (int i = 0; i &lt; strs.length; i++) &#123; for (j = 0; j &lt; strs.length; j++) &#123; if (j != i) &#123; if (isSubString(strs[i], strs[j])) &#123; break; &#125; &#125; &#125; if (j == strs.length) &#123; res = Math.max(res, strs[i].length()); &#125; &#125; return res; &#125; private boolean isSubString(String x, String y) &#123; // By definition, the substring can be derived by deleting some characters int j = 0; for (int i = 0; i &lt; y.length() &amp;&amp; j &lt; x.length(); i++) if (x.charAt(j) == y.charAt(i)) j++; return j == x.length(); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[539. Minimum Time Difference]]></title>
    <url>%2F2017%2F07%2F08%2F2017-07-08-539-Minimum-Time-Difference%2F</url>
    <content type="text"><![CDATA[Given a list of 24-hour clock time points in “Hour:Minutes” format, find the minimum minutes difference between any two time points in the list. Example 1: Input: [“23:59”,”00:00”]Output: 1 Note: The number of time points in the given list is at least 2 and won&apos;t exceed 20000. The input time is legal and ranges from 00:00 to 23:59. 解法1： O(NlogN)很直观的就是把array转化为分钟数的数组，然后两两比较，同时别忘了比较头和尾巴。 C++1 Java1234567891011121314151617181920212223242526272829public class Solution &#123; public int findMinDifference(List&lt;String&gt; timePoints) &#123; if (timePoints == null || timePoints.size() == 0) &#123; return 0; &#125; int[] times = new int[timePoints.size()]; for (int i = 0; i &lt; timePoints.size(); i++) &#123; int seperator = timePoints.get(i).indexOf(":"); int hour = Integer.parseInt(timePoints.get(i).substring(0, seperator)); int minute = Integer.parseInt(timePoints.get(i).substring(seperator + 1)); times[i] = hour * 60 + minute; &#125; Arrays.sort(times); int res = Integer.MAX_VALUE; int time24 = 24 * 60; for (int i = 0; i &lt; times.length - 1; i++) &#123; res = Math.min(res, Math.min(Math.abs(time24 + times[i] - times[i + 1]), Math.abs(times[i+1] - times[i]))); &#125; res = Math.min(res, Math.min(Math.abs(time24 + times[0] - times[times.length - 1]), Math.abs(times[0] - times[times.length - 1]))); return res; &#125;&#125; 解法2： O(N)借鉴了bucket sort 的解法，因为这里分钟数的总个数是固定的。可以用一个60 * 24 = 1440的数组来记录每一个分钟数是否出现。如果一个分钟数出现两次，那么最小值一定是0.同时需要维护一个first和last来记录第一个和最后一个出现过的分钟数。最后比较一下相邻出现过的分钟数以及头尾就可以了。Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[555. Split Concatenated Strings]]></title>
    <url>%2F2017%2F07%2F08%2F2017-07-08-555-Split-Concatenated-Strings%2F</url>
    <content type="text"><![CDATA[Given a list of strings, you could concatenate these strings together into a loop, where for each string you could choose to reverse it or not. Among all the possible loops, you need to find the lexicographically biggest string after cutting the loop, which will make the looped string into a regular one. Specifically, to find the lexicographically biggest string, you need to experience two phases: Concatenate all the strings into a loop, where you can reverse some strings or not and connect them in the same order as given. Cut and make one breakpoint in any place of the loop, which will make the looped string into a regular one starting from the character at the cutpoint. And your job is to find the lexicographically biggest one among all the possible regular strings. Example: Input: “abc”, “xyz”Output: “zyxcba”Explanation: You can get the looped string “-abcxyz-“, “-abczyx-“, “-cbaxyz-“, “-cbazyx-“,where ‘-‘ represents the looped status.The answer string came from the fourth looped one,where you could cut from the middle character ‘a’ and get “zyxcba”. Note: The input strings will only contain lowercase letters. The total length of all the strings will not over 1,000. 解法1：O(N^2) 此题参考了leetcode的解法：order to understand how this solution works, firstly we'll look at some of the properties of the transformation involved. The first point to note is that the relative ordering of the strings doesn't change after applying the transformations(i.e. reversing and applying cuts).12345678910The second property will be explained taking the help of an example. Consider the given list of strings: [s1,s2,s3,..,sj,..sn][s_1, s_2, s_3,..,s_j,..s_n][s​1​​,s​2​​,s​3​​,..,s​j​​,..s​n​​]. Now, assume that we choose sjs_js​j​​ to be the string on which the current cut is placed leading to the formation of two substrings from sjs_js​j​​, namely, say sjpres_&#123;jpre&#125;s​jpre​​, sjposts_&#123;jpost&#125;s​jpost​​. Thus, the concatenated string formed by such a cut will be: [sjpost,sj+1,...,sn,s1rev,s2rev,..,s(jpre)rev][s_&#123;jpost&#125;, s_&#123;j+1&#125;,..., s_n, s_&#123;1rev&#125;, s_&#123;2rev&#125;,.., s_&#123;(jpre)rev&#125;][s​jpost​​,s​j+1​​,...,s​n​​,s​1rev​​,s​2rev​​,..,s​(jpre)rev​​]. Here, sirevs_&#123;irev&#125;s​irev​​ means the reversed sis_is​i​​ string.The concatenated string formed follows the same pattern irrespective of where the cut is placed in sjs_js​j​​. But still, the relative ordering of the strings persists, even if we include the reverse operation as well.Now, if we consider only a single cut for the time being, in string sjs_js​j​​(not reversed) as discussed above, and allow for the reverse operation among the remaining strings, the lexicographically largest concatenated string will be given by: [sjpost,max(sj+1,s(j+1)rev),...,max(sn,s(n)rev),max(s1,s(1)rev),...,s(jpre)rev][s_&#123;jpost&#125;, \text&#123;max&#125;(s_&#123;j+1&#125;,s_&#123;(j+1)rev&#125;) ,..., \text&#123;max&#125;(s_&#123;n&#125;,s_&#123;(n)rev&#125;), \text&#123;max&#125;(s_&#123;1&#125;,s_&#123;(1)rev&#125;), ..., s_&#123;(jpre)rev&#125;][s​jpost​​,max(s​j+1​​,s​(j+1)rev​​),...,max(s​n​​,s​(n)rev​​),max(s​1​​,s​(1)rev​​),...,s​(jpre)rev​​]. Here, max\text&#123;max&#125;max refers to the lexicographic maximum operation.Thus, if a particular string sjs_js​j​​ is finalized for the cut, the largest lexicographic concatenated string is dependent only on whether the string sjs_js​j​​ is reversed or not, and also on the position of the cut. This happens because the reverse/not reverse operation for the rest of the strings is fixed for a chosen sjs_js​j​​ as shown above and thus, doesn&apos;t impact the final result.Based on the above observations, we follow the given procedure. For every given string, we replace the string with the lexicographically larger string out of the original string and the reversed one. After this, we pick up every new string(chosen as the string on which the cuts will be applied), and apply a cut at all the positions of the currently picked string and form the full concantenated string keeping the rest of the newly formed strings intact. We also reverse the current string and follow the same process. While doing this, we keep a track of the largest lexicographic string found so far. C++1 Java1234567891011121314151617181920212223242526272829303132333435363738public class Solution &#123; public String splitLoopedString(String[] strs) &#123; for (int i = 0; i &lt; strs.length; i++) &#123; String rev = new StringBuilder(strs[i]).reverse().toString(); if (strs[i].compareTo(rev) &lt; 0) &#123; strs[i] = rev; &#125; &#125; String res = ""; // store results for (int i = 0; i &lt; strs.length; i++) &#123; String rev = new StringBuilder(strs[i]).reverse().toString(); for (String str : new String[] &#123;strs[i], rev&#125;) &#123; for (int k = 0; k &lt; str.length(); k++) &#123; // get the head StringBuilder builder = new StringBuilder(str.substring(k)); // append i + 1 to n strings for (int j = i + 1; j &lt; strs.length; j++) &#123; builder.append(strs[j]); &#125; // append 0 to i -1 strings for (int j = 0; j &lt; i; j++) &#123; builder.append(strs[j]); &#125; builder.append(str.substring(0, k)); if (builder.toString().compareTo(res) &gt; 0) &#123; // lexi order res = builder.toString(); &#125; &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[609. Find Duplicate File in System]]></title>
    <url>%2F2017%2F07%2F06%2F2017-07-06-609-Find-Duplicate-File-in-System%2F</url>
    <content type="text"><![CDATA[Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths. A group of duplicate files consists of at least two files that have exactly the same content. A single directory info string in the input list has the following format: “root/d1/d2/…/dm f1.txt(f1_content) f2.txt(f2_content) … fn.txt(fn_content)” It means there are n files (f1.txt, f2.txt … fn.txt with content f1_content, f2_content … fn_content, respectively) in directory root/d1/d2/…/dm. Note that n &gt;= 1 and m &gt;= 0. If m = 0, it means the directory is just the root directory. The output is a list of group of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format: “directory_path/file_name.txt” Example 1:1234Input:[&quot;root/a 1.txt(abcd) 2.txt(efgh)&quot;, &quot;root/c 3.txt(abcd)&quot;, &quot;root/c/d 4.txt(efgh)&quot;, &quot;root 4.txt(efgh)&quot;]Output: [[&quot;root/a/2.txt&quot;,&quot;root/c/d/4.txt&quot;,&quot;root/4.txt&quot;],[&quot;root/a/1.txt&quot;,&quot;root/c/3.txt&quot;]] Note: No order is required for the final output. You may assume the directory name, file name and file content only has letters and digits, and the length of file content is in the range of [1,50]. The number of files given is in the range of [1,20000]. You may assume no files or directories share the same name in the same directory. You may assume each given directory info represents a unique directory. Directory path and file info are separated by a single blank space. Follow-up beyond contest: Imagine you are given a real file system, how will you search files? DFS or BFS? If the file content is very large (GB level), how will you modify your solution? If you can only read the file by 1kb each time, how will you modify your solution? What is the time complexity of your modified solution? What is the most time-consuming part and memory consuming part of it? How to optimize? How to make sure the duplicated files you find are not false positive? 解法1：没有难点，就是按部就班的把这个paths转换成为hashmap, 以content作为key.C++1 Java1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public List&lt;List&lt;String&gt;&gt; findDuplicate(String[] paths) &#123; HashMap&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;(); for (String path : paths) &#123; String[] temp = path.split(" "); String path_root = temp[0] + "/"; for (int i = 1; i &lt; temp.length; i++) &#123; // seperate contents from string int leftBracket = temp[i].indexOf("("); String fileName = temp[i].substring(0, leftBracket); String content = temp[i].substring(leftBracket + 1, temp[i].length() - 1); // get rid of the last bracket in the string String fullFileName = path_root + fileName; if (map.containsKey(content)) &#123; map.get(content).add(fullFileName); &#125; else &#123; List&lt;String&gt; files = new ArrayList&lt;String&gt;(); files.add(fullFileName); map.put(content, files); &#125; &#125; &#125; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;List&lt;String&gt;&gt;(); for (String key : map.keySet()) &#123; List&lt;String&gt; files = map.get(key); if (files.size() &gt; 1) &#123; res.add(files); &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[468. Validate IP Address]]></title>
    <url>%2F2017%2F07%2F06%2F2017-07-06-468-Validate-IP-Address%2F</url>
    <content type="text"><![CDATA[Write a function to check whether an input string is a valid IPv4 address or IPv6 address or neither. IPv4 addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots (“.”), e.g.,172.16.254.1; Besides, leading zeros in the IPv4 is invalid. For example, the address 172.16.254.01 is invalid. IPv6 addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (“:”). For example, the address 2001:0db8:85a3:0000:0000:8a2e:0370:7334 is a valid one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so 2001:db8:85a3:0:0:8A2E:0370:7334 is also a valid IPv6 address(Omit leading zeros and using upper cases). However, we don’t replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, 2001:0db8:85a3::8A2E:0370:7334 is an invalid IPv6 address. Besides, extra leading zeros in the IPv6 is also invalid. For example, the address 02001:0db8:85a3:0000:0000:8a2e:0370:7334 is invalid. Note: You may assume there is no extra space or special characters in the input string. Example 1:12345Input: &quot;172.16.254.1&quot;Output: &quot;IPv4&quot;Explanation: This is a valid IPv4 address, return &quot;IPv4&quot;. Example 2:12345Input: &quot;2001:0db8:85a3:0:0:8A2E:0370:7334&quot;Output: &quot;IPv6&quot;Explanation: This is a valid IPv6 address, return &quot;IPv6&quot;. Example 3:12345Input: &quot;256.256.256.256&quot;Output: &quot;Neither&quot;Explanation: This is neither a IPv4 address nor a IPv6 address. 解法1：C++1 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Solution &#123; public String validIPAddress(String IP) &#123; if (IP == null || IP.length() == 0) &#123; return "Neither"; &#125; if (IP.contains(":")) &#123; return IPV6(IP) ? "IPv6" : "Neither"; &#125; else &#123; return IPV4(IP) ? "IPv4" : "Neither"; &#125; &#125; private boolean IPV6(String ip) &#123; String[] temp = ip.split(":",-1); if (temp.length != 8) &#123; return false; &#125; for (String element : temp) &#123; if (element.isEmpty() || element.length() &gt; 4) &#123; return false; &#125; for(int i = 0;i&lt;element.length();i++)&#123; char ch = element.charAt(i); if(!((ch &gt;= '0' &amp;&amp; ch &lt;= '9') || (ch&gt;='a' &amp;&amp; ch&lt;='f') || (ch&gt;='A' &amp;&amp;ch&lt;='F'))) return false; &#125; &#125; return true; &#125; private boolean IPV4(String ip) &#123; String[] temp = ip.split("\\.",-1); if (temp.length != 4) &#123; return false; &#125; for (String element : temp) &#123; if (element.isEmpty()) &#123; return false; &#125; if (element.length() &gt; 1 &amp;&amp; element.charAt(0) == '0') &#123; return false; // leading zero is invalid &#125; if (element.length() &gt; 3) &#123; return false; &#125; if (element.compareTo("0") &lt; 0 || element.compareTo("255") &gt; 0) &#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[556. Next Great Element III]]></title>
    <url>%2F2017%2F07%2F06%2F2017-07-06-556-Next-Great-Element-III%2F</url>
    <content type="text"><![CDATA[Given a positive 32-bit integer n, you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive 32-bit integer exists, you need to return -1. Example 1:12Input: 12Output: 21 Example 2:12Input: 21Output: -1 解法1：用next permutation的算法来解，先把n转换成一个数字的数组，然后接下的算法就是一致的了。要注意的是算出来的答案可能会overflow,所以要判断一下是否overflow。C++1 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Solution &#123; public int nextGreaterElement(int n) &#123; int len = (int)Math.log10(n) + 1; int[] digits = new int[len]; int i = len - 1; while (n &gt; 0) &#123; digits[i--] = n % 10; n /= 10; &#125; // Use the next permutation algorithm int pivot = -1; for (i = len - 2; i &gt;= 0; i--) &#123; if (digits[i] &lt; digits[i + 1]) &#123; pivot = i; break; &#125; &#125; if (pivot == -1) &#123; return -1; &#125; for (i = len - 1; i &gt; pivot; i--) &#123; if (digits[i] &gt; digits[pivot]) &#123; int temp = digits[i]; digits[i] = digits[pivot]; digits[pivot] = temp; break; &#125; &#125; int j; for (i = pivot + 1, j = len - 1; i &lt; j; i++,j--) &#123; int temp = digits[i]; digits[i] = digits[j]; digits[j] = temp; &#125; // combine int res = 0; for (i = 0; i &lt; len; i++) &#123; if (res &gt; Integer.MAX_VALUE / 10 || (res == Integer.MAX_VALUE / 10 &amp;&amp; res % 10 &gt; Integer.MAX_VALUE % 10)) &#123; return -1; &#125; res = res * 10 + digits[i]; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[271. Encode and Decode Strings]]></title>
    <url>%2F2017%2F07%2F06%2F2017-07-06-271-Encode-and-Decode-Strings%2F</url>
    <content type="text"><![CDATA[Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings. Machine 1 (sender) has the function:1234string encode(vector&lt;string&gt; strs) &#123; // ... your code return encoded_string;&#125; Machine 2 (receiver) has the function:1234vector&lt;string&gt; decode(string s) &#123; //... your code return strs;&#125; So Machine 1 does:1string encoded_string = encode(strs); and Machine 2 does:1vector&lt;string&gt; strs2 = decode(encoded_string); strs2 in Machine 2 should be the same as strs in Machine 1. Implement the encode and decode methods. Note: The string may contain any possible characters out of 256 valid ascii characters. Your algorithm should be generalized enough to work on any possible characters. Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless. Do not rely on any library method such as eval or serialize methods. You should implement your own encode/decode algorithm. 解法1：把每一个string里的字符转换成ascii码，用一个＃分隔。同时每一个字符串间用，分隔。要注意的是，在decode的时候可能会出现,,的情况，所以要用string.split(pattern, -1)来保留所有的empty string C++1 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Codec &#123; // Encodes a list of strings to a single string. public String encode(List&lt;String&gt; strs) &#123; StringBuilder builder = new StringBuilder(); for (String str : strs) &#123; char[] chars = str.toCharArray(); for (char c : chars) &#123; builder.append("" + Integer.toString((int)c)); builder.append("#"); &#125; builder.append(","); // if (!str.length() == 0) &#123; // builder.append("#"); // &#125; &#125; return builder.toString(); &#125; // Decodes a single string to a list of strings. public List&lt;String&gt; decode(String s) &#123; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); if (s == null || s.isEmpty()) &#123; return res; &#125; String[] components = s.substring(0, s.length() - 1).split(",",-1); // Remove the "," at the end of the string for (String element : components) &#123; StringBuilder builder = new StringBuilder(); String[] codes = element.split("#"); for (String code : codes) &#123; if (!code.isEmpty()) &#123; builder.append((char)Integer.parseInt(code)); &#125; &#125; res.add(builder.length() == 0 ? "" : builder.toString()); &#125; return res; &#125;&#125;// Your Codec object will be instantiated and called as such:// Codec codec = new Codec();// codec.decode(codec.encode(strs)); 解法2：把一个string转化为size/stringcontent的形式。lang: java123456789101112131415161718192021222324252627282930public class Codec &#123; // Encodes a list of strings to a single string. public String encode(List&lt;String&gt; strs) &#123; StringBuilder sb = new StringBuilder(); for (String str : strs) &#123; sb.append(str.length()).append(&quot;/&quot;).append(str); &#125; return sb.toString(); &#125; // Decodes a single string to a list of strings. public List&lt;String&gt; decode(String s) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); int i = 0; while (i &lt; s.length()) &#123; int pos = s.indexOf(&apos;/&apos;, i); int len = Integer.parseInt(s.substring(i, pos)); res.add(s.substring(pos + 1, pos + 1 + len)); i = pos + 1 + len; &#125; return res; &#125;&#125;// Your Codec object will be instantiated and called as such:// Codec codec = new Codec();// codec.decode(codec.encode(strs));]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[227. Basic Calculator II]]></title>
    <url>%2F2017%2F07%2F06%2F2017-07-06-227-Basic-Calculator-II%2F</url>
    <content type="text"><![CDATA[Implement a basic calculator to evaluate a simple expression string. The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero. You may assume that the given expression is always valid. Some examples: “3+2*2” = 7“ 3/2 “ = 1“ 3+5 / 2 “ = 5 Note: Do not use the eval built-in library function. 解法1：用一个stack来存储中间结果。遇上×，／的时候计算之前的操作，遇上＋／－的时候只有在之前的操作为同一优先级的时候才计算。写的比较繁琐，不如leetcode上的答案好。答案里不需要有stack, 用一个preVal来记录上一个计算的结果，只有当当前操作为加或者减的时候才需要把上一次更新的结果并入最终的结果。C++1 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class Solution &#123; public int calculate(String s) &#123; Stack&lt;Integer&gt; operands = new Stack&lt;Integer&gt;(); Stack&lt;String&gt; operators = new Stack&lt;String&gt;(); int i = 0; while (i &lt; s.length()) &#123; if (s.charAt(i) == ' ') &#123; i++; continue; &#125; else if (s.charAt(i) == '+' || s.charAt(i) == '-')&#123; if (!operators.empty()) &#123; int right = operands.pop(); int left = operands.pop(); String last = operators.pop(); if (last.equals("+")) &#123; operands.push(left + right); &#125; else if (last.equals("-")) &#123; operands.push(left - right); &#125; else if (last.equals("*")) &#123; operands.push(left * right); &#125; else &#123; operands.push(left / right); &#125; &#125; operators.push(s.substring(i, i + 1)); i++; &#125; else if (s.charAt(i) == '*' || s.charAt(i) == '/') &#123; if (!operators.empty()) &#123; String last = operators.peek(); if (last.equals("*")) &#123; operators.pop(); int right = operands.pop(); int left = operands.pop(); operands.push(left * right); &#125; else if (last.equals("/")) &#123; operators.pop(); int right = operands.pop(); int left = operands.pop(); operands.push(left / right); &#125; &#125; operators.push(s.substring(i, i + 1)); i++; &#125; else &#123; int j = i + 1; while (j &lt; s.length() &amp;&amp; s.charAt(j) &gt;= '0' &amp;&amp; s.charAt(j) &lt;= '9') &#123; j++; &#125; int element = Integer.parseInt(s.substring(i, j)); // check if there is valid * or / operators if (!operators.empty()) &#123; if (operators.peek().equals("*")) &#123; operators.pop(); int left = operands.pop(); operands.push(left * element); &#125; else if (operators.peek().equals("/")) &#123; operators.pop(); int left = operands.pop(); operands.push(left / element); &#125; else &#123; operands.push(element); &#125; &#125; else &#123; operands.push(element); &#125; i = j; &#125; &#125; // empty operators until it is empty while (!operators.empty()) &#123; String operator = operators.pop(); int right = operands.pop(); int left = operands.pop(); if (operator.equals("*")) &#123; operands.push(left * right); &#125; else if (operator.equals("/")) &#123; operands.push(left / right); &#125; else if (operator.equals("+")) &#123; operands.push(left + right); &#125; else &#123; operands.push(left - right); &#125; &#125; return operands.pop(); &#125;&#125; ###解法２： ###答案来自与leetcodeJavalang: java12345678910111213141516171819202122232425262728293031323334public int calculate(String s) &#123; if (s == null) return 0; s = s.trim().replaceAll(&quot; +&quot;, &quot;&quot;); int length = s.length(); int res = 0; long preVal = 0; // initial preVal is 0 char sign = &apos;+&apos;; // initial sign is + int i = 0; while (i &lt; length) &#123; long curVal = 0; while (i &lt; length &amp;&amp; (int)s.charAt(i) &lt;= 57 &amp;&amp; (int)s.charAt(i) &gt;= 48) &#123; // int curVal = curVal*10 + (s.charAt(i) - &apos;0&apos;); i++; &#125; if (sign == &apos;+&apos;) &#123; res += preVal; // update res preVal = curVal; &#125; else if (sign == &apos;-&apos;) &#123; res += preVal; // update res preVal = -curVal; &#125; else if (sign == &apos;*&apos;) &#123; preVal = preVal * curVal; // not update res, combine preVal &amp; curVal and keep loop &#125; else if (sign == &apos;/&apos;) &#123; preVal = preVal / curVal; // not update res, combine preVal &amp; curVal and keep loop &#125; if (i &lt; length) &#123; // getting new sign sign = s.charAt(i); i++; &#125; &#125; res += preVal; return res;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[161. One Edit Distance]]></title>
    <url>%2F2017%2F07%2F06%2F2017-07-06-161-One-Edit-Distance%2F</url>
    <content type="text"><![CDATA[Given two strings S and T, determine if they are both one edit distance apart. 解法1：这题一开始如果用dp做的话需要O(MN)的复杂度，TLE了。那么一定有更简便的方法。这里呢用到了edit distance的性质。对于edit distance为１的两个string,只可能存在下面三种情况。长度相等 =&gt; 有且仅有一个字符不一样长度不相等， 那么如果删掉左面string的一个字符或者是右面的一个字符。最后还要比较一下两者的长度是否只差１。C++1 Java123456789101112131415161718public class Solution &#123; public boolean isOneEditDistance(String s, String t) &#123; int m = s.length(), n = t.length(); for (int i = 0; i &lt; Math.min(m, n); i++) &#123; if (s.charAt(i) != t.charAt(i)) &#123; if (m == n) &#123; return s.substring(i+1).equals(t.substring(i+1)); &#125; else if (m &gt; n) &#123; return s.substring(i+1).equals(t.substring(i)); &#125; else &#123; return s.substring(i).equals(t.substring(i+1)); &#125; &#125; &#125; return Math.abs(m - n) == 1; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[553. Optimal Division]]></title>
    <url>%2F2017%2F07%2F05%2F2017-07-05-553-Optimal-Division%2F</url>
    <content type="text"><![CDATA[Given a list of positive integers, the adjacent integers will perform the float division. For example, [2,3,4] -&gt; 2 / 3 / 4. However, you can add any number of parenthesis at any position to change the priority of operations. You should find out how to add parenthesis to get the maximum result, and return the corresponding expression in string format. Your expression should NOT contain redundant parenthesis. Example:Input: [1000,100,10,2]Output: “1000/(100/10/2)”Explanation:1000/(100/10/2) = 1000/((100/10)/2) = 200However, the bold parenthesis in “1000/((100/10)/2)” are redundant,since they don’t influence the operation priority. So you should return “1000/(100/10/2)”. Other cases:1000/(100/10)/2 = 501000/(100/(10/2)) = 501000/100/10/2 = 0.51000/100/(10/2) = 2Note: The length of the input array is [1, 10].Elements in the given array will be in range [2, 1000].There is only one optimal division for each test case. 解法1：O(N^3)这题的数学解法比较无聊，也不觉得对锻炼思路有帮助。倒是这个divide &amp; conquer的解法很清楚明白。题目一拿到比较懵，如果细细思考可以想到。要得到最大值，需要dividend最大,divisor最小。那么就可以不停的尝试分割的位置，然后维护每一个子段的最大最小值以及产生最大最小值分割的括号摆放字符串。这里就需要用一个辅助class。同时为了减少time complexity, 用一个二维数组做memorization来记录每一个子串的中间结果。 C++1 Java1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; class T &#123; float max_val, min_val; String min_str, max_str; &#125; public String optimalDivision(int[] nums) &#123; T[][] memo = new T[nums.length][nums.length]; T t = optimal(nums, 0, nums.length - 1, "", memo); return t.max_str; &#125; public T optimal(int[] nums, int start, int end, String res, T[][] memo) &#123; if (memo[start][end] != null) return memo[start][end]; T t = new T(); if (start == end) &#123; t.max_val = nums[start]; t.min_val = nums[start]; t.min_str = "" + nums[start]; t.max_str = "" + nums[start]; memo[start][end] = t; return t; &#125; t.min_val = Float.MAX_VALUE; t.max_val = Float.MIN_VALUE; t.min_str = t.max_str = ""; for (int i = start; i &lt; end; i++) &#123; T left = optimal(nums, start, i, "", memo); T right = optimal(nums, i + 1, end, "", memo); if (t.min_val &gt; left.min_val / right.max_val) &#123; t.min_val = left.min_val / right.max_val; t.min_str = left.min_str + "/" + (i + 1 != end ? "(" : "") + right.max_str + (i + 1 != end ? ")" : ""); &#125; if (t.max_val &lt; left.max_val / right.min_val) &#123; t.max_val = left.max_val / right.min_val; t.max_str = left.max_str + "/" + (i + 1 != end ? "(" : "") + right.min_str + (i + 1 != end ? ")" : ""); &#125; &#125; memo[start][end] = t; return t; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Divide &amp; Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[165. Compare Version Numbers]]></title>
    <url>%2F2017%2F07%2F05%2F2017-07-05-165-Compare-Version-Numbers%2F</url>
    <content type="text"><![CDATA[Compare two version numbers version1 and version2.If version1 &gt; version2 return 1, if version1 &lt; version2 return -1, otherwise return 0. You may assume that the version strings are non-empty and contain only digits and the . character.The . character does not represent a decimal point and is used to separate number sequences.For instance, 2.5 is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision. Here is an example of version numbers ordering:10.1 &lt; 1.1 &lt; 1.2 &lt; 13.37 解法1：应该算简单题。要注意的一点是java里string.split(regex), 如果是特殊字符比如”.”的时候，要注意escape。然后每一位比较，如果有一个字符串比较短，就把他对应的位看成是0。C++1 Java12345678910111213141516171819public class Solution &#123; public int compareVersion(String version1, String version2) &#123; String[] v1 = version1.split("\\."); String[] v2 = version2.split("\\."); for (int i = 0; i &lt; Math.max(v1.length, v2.length); i++) &#123; int v1number = i &lt; v1.length ? Integer.parseInt(v1[i]) : 0; int v2number = i &lt; v2.length ? Integer.parseInt(v2[i]) : 0; if (v1number &gt; v2number) &#123; return 1; &#125; else if (v1number &lt; v2number) &#123; return -1; &#125; &#125; return 0; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[544. Output Contest Matches]]></title>
    <url>%2F2017%2F07%2F05%2F2017-07-05-544-Output-Contest-Matches%2F</url>
    <content type="text"><![CDATA[During the NBA playoffs, we always arrange the rather strong team to play with the rather weak team, like make the rank 1 team play with the rank nth team, which is a good strategy to make the contest more interesting. Now, you’re given n teams, you need to output their final contest matches in the form of a string. The n teams are given in the form of positive integers from 1 to n, which represents their initial rank. (Rank 1 is the strongest team and Rank n is the weakest team.) We’ll use parentheses(‘(‘, ‘)’) and commas(‘,’) to represent the contest team pairing - parentheses(‘(‘ , ‘)’) for pairing and commas(‘,’) for partition. During the pairing process in each round, you always need to follow the strategy of making the rather strong one pair with the rather weak one. Example 1:12345Input: 2Output: (1,2)Explanation:Initially, we have the team 1 and the team 2, placed like: 1,2.Then we pair the team (1,2) together with &apos;(&apos;, &apos;)&apos; and &apos;,&apos;, which is the final answer. Example 2:1234567Input: 4Output: ((1,4),(2,3))Explanation:In the first round, we pair the team 1 and 4, the team 2 and 3 together, as we need to make the strong team and weak team together.And we got (1,4),(2,3).In the second round, the winners of (1,4) and (2,3) need to play again to generate the final winner, so you need to add the paratheses outside them.And we got the final answer ((1,4),(2,3)). Example 3:1234567Input: 8Output: (((1,8),(4,5)),((2,7),(3,6)))Explanation:First round: (1,8),(2,7),(3,6),(4,5)Second round: ((1,8),(4,5)),((2,7),(3,6))Third round: (((1,8),(4,5)),((2,7),(3,6)))Since the third round will generate the final winner, you need to output the answer (((1,8),(4,5)),((2,7),(3,6))). Note:The n is in range [2, 212].We ensure that the input n can be converted into the form 2k, where k is a positive integer. 解法1：题目一开始没理解。主要的思路就是每次缩短1/2，把排名第一的组合和排名最后的组合放在一起。用递归或者是iteration都可以做。C++1 Java1234567891011121314151617181920public class Solution &#123; public String findContestMatch(int n) &#123; List&lt;String&gt; matches = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= n; i++) &#123; matches.add("" + i); &#125; while (matches.size() != 1) &#123; List&lt;String&gt; round = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; matches.size() / 2; i++) &#123; round.add("(" + matches.get(i) + "," + matches.get(matches.size() - 1 -i) + ")"); &#125; matches = round; &#125; return matches.get(0); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[635. Design Log Storage System]]></title>
    <url>%2F2017%2F07%2F05%2F2017-07-05-635-Design-Log-Storage-System%2F</url>
    <content type="text"><![CDATA[You are given several logs that each log contains a unique id and timestamp. Timestamp is a string that has the following format: Year:Month:Day:Hour:Minute:Second, for example, 2017:01:01:23:59:59. All domains are zero-padded decimal numbers. Design a log storage system to implement the following functions: void Put(int id, string timestamp): Given a log’s unique id and timestamp, store the log in your storage system. int[] Retrieve(String start, String end, String granularity): Return the id of logs whose timestamps are within the range from start to end. Start and end all have the same format as timestamp. However, granularity means the time level for consideration. For example, start = “2017:01:01:23:59:59”, end = “2017:01:02:23:59:59”, granularity = “Day”, it means that we need to find the logs within the range from Jan. 1st 2017 to Jan. 2nd 2017. Example 1:12345put(1, &quot;2017:01:01:23:59:59&quot;);put(2, &quot;2017:01:01:22:59:59&quot;);put(3, &quot;2016:01:01:00:00:00&quot;);retrieve(&quot;2016:01:01:01:01:01&quot;,&quot;2017:01:01:23:00:00&quot;,&quot;Year&quot;); // return [1,2,3], because you need to return all logs within 2016 and 2017.retrieve(&quot;2016:01:01:01:01:01&quot;,&quot;2017:01:01:23:00:00&quot;,&quot;Hour&quot;); // return [1,2], because you need to return all logs start from 2016:01:01:01 to 2017:01:01:23, where log 3 is left outside the range. Note:There will be at most 300 operations of Put or Retrieve.Year ranges from [2000,2017]. Hour ranges from [00,23].Output for Retrieve has no order required. 解法1：用一个hashmap来存储log,这题的考点主要在retrieve上。retrieve的时候可以按照gra来截取相关的子串，然后和start, end直接比较大小就可以。C++1 Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class LogSystem &#123; HashMap&lt;Integer, String&gt; map; public LogSystem() &#123; map = new HashMap&lt;Integer, String&gt;(); &#125; public void put(int id, String timestamp) &#123; map.put(id, timestamp); &#125; public List&lt;Integer&gt; retrieve(String s, String e, String gra) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); int x = 0; switch (gra) &#123; case "Year": x = 4; break; case "Month": x = 7; break; case "Day": x = 10; break; case "Hour": x = 13; break; case "Minute": x = 16; break; case "Second": x = 19; break; &#125; String start = s.substring(0, x); String end = e.substring(0, x); for (int id : map.keySet()) &#123; String record = map.get(id).substring(0,x); if (record.compareTo(start) &gt;= 0 &amp;&amp; record.compareTo(end) &lt;= 0) &#123; res.add(id); &#125; &#125; return res; &#125;&#125;/** * Your LogSystem object will be instantiated and called as such: * LogSystem obj = new LogSystem(); * obj.put(id,timestamp); * List&lt;Integer&gt; param_2 = obj.retrieve(s,e,gra); */]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[583. Delete Operation for Two String]]></title>
    <url>%2F2017%2F07%2F05%2F2017-07-05-583-Delete-Operation-for-Two-String%2F</url>
    <content type="text"><![CDATA[Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string. Example 1:123Input: &quot;sea&quot;, &quot;eat&quot;Output: 2Explanation: You need one step to make &quot;sea&quot; to &quot;ea&quot; and another step to make &quot;eat&quot; to &quot;ea&quot;. Note:The length of given words won’t exceed 500.Characters in given words can only be lower-case letters. 解法1：这题和edit distance的思路一样。用二维dp即可解决。C++1 Java123456789101112131415161718192021222324252627282930public class Solution &#123; public int minDistance(String word1, String word2) &#123; int m = word1.length(); int n = word2.length(); int[][] dp = new int[m + 1][n + 1]; // first row for (int i = 0; i &lt;= n; i++) &#123; dp[0][i] = i; &#125; // first col for (int i = 0; i &lt;= m; i++) &#123; dp[i][0] = i; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (word1.charAt(i - 1) == word2.charAt(j - 1)) &#123; dp[i][j] = Math.min(dp[i][j - 1] + 1, Math.min(dp[i - 1][j] + 1, dp[i - 1][j - 1])); &#125; else &#123; dp[i][j] = Math.min(dp[i][j - 1] + 1, Math.min(dp[i - 1][j] + 1, dp[i - 1][j - 1] + 2)); &#125; &#125; &#125; return dp[m][n]; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[616. Add Bold Tag in String]]></title>
    <url>%2F2017%2F07%2F05%2F2017-07-05-616-Add-Bold-Tag-in-String%2F</url>
    <content type="text"><![CDATA[Given a string s and a list of strings dict, you need to add a closed pair of bold tag and to wrap the substrings in s that exist in dict. If two such substrings overlap, you need to wrap them together by only one pair of closed bold tag. Also, if two substrings wrapped by bold tags are consecutive, you need to combine them. Example 1:12345Input:s = &quot;abcxyz123&quot;dict = [&quot;abc&quot;,&quot;123&quot;]Output:&quot;&lt;b&gt;abc&lt;/b&gt;xyz&lt;b&gt;123&lt;/b&gt;&quot; Example 2:12345Input:s = &quot;aaabbcc&quot;dict = [&quot;aaa&quot;,&quot;aab&quot;,&quot;bc&quot;]Output:&quot;&lt;b&gt;aaabbc&lt;/b&gt;c&quot; Note:The given dict won’t contain duplicates, and its length won’t exceed 100.All the strings in input have length in range [1, 1000]. 解法1：这题可以分成两个部分，第一个部分是找出来所有在字典中出现的词。这一步可以遍历字典，按照每一个词的长度来遍历原字符串来找出出现的位置。可以用一个array来存储每一个词出现的(start, end)。然后问题就变成，要把这些pair先merge一下，然后头尾加上tag即可。C++1 Java12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public String addBoldTag(String s, String[] dict) &#123; List&lt;int[]&gt; pairs = new ArrayList&lt;int[]&gt;(); for (String d : dict) &#123; int len = d.length(); for (int i = 0; i &lt;= s.length() - len; i++) &#123; if (d.equals(s.substring(i, i + len))) &#123; pairs.add(new int[] &#123;i,i + len - 1&#125;); &#125; &#125; &#125; Collections.sort(pairs, (a, b) -&gt; a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]); StringBuilder builder = new StringBuilder(); int prev = 0; for (int i = 0; i &lt; pairs.size(); i++) &#123; builder.append(s.substring(prev, pairs.get(i)[0])); // Merge intervals int start = pairs.get(i)[0]; int end = pairs.get(i)[1]; while (i &lt; pairs.size() - 1 &amp;&amp; pairs.get(i + 1)[0] &lt;= end + 1) &#123; end = Math.max(end, pairs.get(i + 1)[1]); i++; &#125; builder.append("&lt;b&gt;" + s.substring(start, end + 1) + "&lt;/b&gt;"); prev = end + 1; &#125; builder.append(s.substring(prev, s.length())); return builder.toString(); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[43. Multiply Strings]]></title>
    <url>%2F2017%2F07%2F02%2F2017-07-02-43-Multiply-Strings%2F</url>
    <content type="text"><![CDATA[Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2. Note: The length of both num1 and num2 is &lt; 110. Both num1 and num2 contains only digits 0-9. Both num1 and num2 does not contain any leading zero. You must not use any built-in BigInteger library or convert the inputs to integer directly. 解法1：按位相乘，注意把中间结果要存储在一个res[length1 + length2]的数组里。然后从后往前扫描，比较容易错的是对应的res的数组的位置。要特别注意一下。C++1 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123;public String multiply(String num1, String num2) &#123; if (num1.length() == 0 || num2.length() == 0) &#123; return ""; &#125; int[] digits = new int[num1.length() + num2.length()]; // Start from the last digit in num2, i.e. the bottom one for (int i = num2.length() - 1; i &gt;= 0; i--) &#123; int carry = 0; for (int j = num1.length() - 1; j &gt;= 0; j--) &#123; int temp = carry + (num1.charAt(j) - '0')*(num2.charAt(i) - '0') + digits[num2.length() - 1 - i + num1.length() - 1 -j]; digits[num2.length() - 1 - i + num1.length() - 1 -j] = temp % 10; carry = temp / 10; &#125; if (carry != 0) &#123; digits[num1.length() + num2.length() - 1 - i] = carry; &#125; &#125; int i = 0, j = digits.length - 1; while (i &lt; j) &#123; int temp = digits[i]; digits[i] = digits[j]; digits[j] = temp; i++; j--; &#125; StringBuilder builder = new StringBuilder(); for (int k = 0; k &lt; digits.length; k++) &#123; if (builder.length() == 0 &amp;&amp; digits[k] == 0) &#123; continue; &#125; builder.append(digits[k]); &#125; if (builder.length() == 0) &#123; builder.append(0); &#125; return builder.toString(); &#125;&#125; 精简很多的code的写法： lang: java12345678910111213141516171819202122class Solution &#123; public String multiply(String num1, String num2) &#123; int m = num1.length(); int n = num2.length(); int[] res = new int[m + n]; for (int i = m - 1; i &gt;= 0; i--) &#123; for (int j = n - 1; j &gt;= 0; j--) &#123; int mul = (num1.charAt(i) - &apos;0&apos;) * (num2.charAt(j) - &apos;0&apos;); int index1 = i + j, index2 = i + j + 1; int sum = mul + res[index2]; res[index1] += sum / 10; res[index2] = (sum % 10); &#125; &#125; StringBuilder sb = new StringBuilder(); for (int num : res) &#123; if (!(sb.length() == 0 &amp;&amp; num == 0)) sb.append(num); &#125; return sb.length() == 0 ? &quot;0&quot; : sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[22. Generate Parentheses]]></title>
    <url>%2F2017%2F07%2F02%2F2017-07-02-22-Generate-Parentheses%2F</url>
    <content type="text"><![CDATA[Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is:1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 解法1：比较经典的DFS题目,dfs的思想要掌握C++1 Java12345678910111213141516171819202122232425public class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); helper("", res, n, n); return res; &#125; private void helper(String current, List&lt;String&gt; res, int left, int right) &#123; if (left == 0 &amp;&amp; right == 0) &#123; res.add(current); return; &#125; if (left &gt; 0) &#123; helper(current + "(", res, left - 1, right); &#125; if (right &gt; 0 &amp;&amp; left &lt; right) &#123; helper(current + ")", res, left, right - 1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[151. Reverse Words in a String]]></title>
    <url>%2F2017%2F07%2F02%2F2017-07-02-151-Reverse-Words-in-a-String%2F</url>
    <content type="text"><![CDATA[Given an input string, reverse the string word by word. For example,Given s = “the sky is blue”,return “blue is sky the”. Update (2015-02-12):For C programmers: Try to solve it in-place in O(1) space. Clarification: What constitutes a word? A sequence of non-space characters constitutes a word. Could the input string contain leading or trailing spaces? Yes. However, your reversed string should not contain leading or trailing spaces. How about multiple spaces between two words? Reduce them to a single space in the reversed string. 解法1：用一个stack来存储每一个找出来的word，然后再一个个pop出来同时加上spaceC++1 Java1234567891011121314151617181920212223242526272829303132333435363738public class Solution &#123; public String reverseWords(String s) &#123; if (s == null || s.length() == 0) &#123; return s; &#125; Stack&lt;String&gt; words = new Stack&lt;String&gt;(); int i = 0, j = 0; while (i &lt; s.length()) &#123; while (i &lt; s.length() &amp;&amp; s.charAt(i) == ' ') &#123; i++; &#125; j = i + 1; while (j &lt; s.length() &amp;&amp; s.charAt(j) != ' ') &#123; j++; &#125; if (i &lt; s.length()) &#123; words.push(s.substring(i, j)); &#125; i = j; &#125; StringBuilder builder = new StringBuilder(); while (!words.empty()) &#123; builder.append(words.pop()); builder.append(' '); &#125; if (builder.length() &gt; 0) &#123; builder.setLength(builder.length() - 1); &#125; return builder.toString(); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6. ZigZag Conversion]]></title>
    <url>%2F2017%2F07%2F02%2F2017-07-02-6-ZigZag-Conversion%2F</url>
    <content type="text"><![CDATA[The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)123P A H NA P L S I I GY I R And then read line by line: “PAHNAPLSIIGYIR” Write the code that will take a string and make this conversion given a number of rows:1string convert(string text, int nRows); convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”. 解法1：O(N) Time + O(N) Space这题的数学解法很难想，也比较花时间。很直观的做法倒是不错。就每一行用一个stringbuilder，然后一行行的塞。先从上往下，再从下往上斜着填。当所有数字填满了之后把stringbuilder连起来就可以了。C++1 Java1234567891011121314151617181920212223242526public class Solution &#123; public String convert(String s, int numRows) &#123; StringBuilder[] builders = new StringBuilder[numRows]; for (int i = 0; i &lt; numRows; i++) &#123; builders[i] = new StringBuilder(); &#125; int pos = 0; while (pos &lt; s.length()) &#123; for (int i = 0; i &lt; numRows &amp;&amp; pos &lt; s.length(); i++) &#123; builders[i].append(s.charAt(pos++)); &#125; for (int i = numRows - 2; i &gt;= 1 &amp;&amp; pos &lt; s.length(); i--) &#123; builders[i].append(s.charAt(pos++)); &#125; &#125; for (int i = 1; i &lt; numRows; i++) &#123; builders[0].append(builders[i]); &#125; return builders[0].toString(); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[521. Longest Uncommon Subsequence I]]></title>
    <url>%2F2017%2F07%2F02%2F2017-07-02-521-Longest-Uncommon-Subsequence-I%2F</url>
    <content type="text"><![CDATA[Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings. A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string. The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn’t exist, return -1. Example 1:12345Input: &quot;aba&quot;, &quot;cdc&quot;Output: 3Explanation: The longest uncommon subsequence is &quot;aba&quot; (or &quot;cdc&quot;),because &quot;aba&quot; is a subsequence of &quot;aba&quot;,but not a subsequence of any other strings in the group of two strings. Note: Both strings’ lengths will not exceed 100. Only letters from a ~ z will appear in input strings. 解法1：C++1 Java12345678910111213public class Solution &#123; public int findLUSlength(String a, String b) &#123; if (a == null || b == null) &#123; return -1; &#125; if (a.equals(b)) &#123; return -1; &#125; return Math.max(a.length(), b.length()); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[551. Student Attendance Record I]]></title>
    <url>%2F2017%2F07%2F02%2F2017-07-02-551-Student-Attendance-Record-I%2F</url>
    <content type="text"><![CDATA[You are given a string representing an attendance record for a student. The record only contains the following three characters: &apos;A&apos; : Absent. &apos;L&apos; : Late. &apos;P&apos; : Present. A student could be rewarded if his attendance record doesn’t contain more than one ‘A’ (absent) or more than two continuous ‘L’ (late). You need to return whether the student could be rewarded according to his attendance record. Example 1:12Input: &quot;PPALLP&quot;Output: True Example 2:12Input: &quot;PPALLL&quot;Output: False 解法1：C++1 Java12345678910111213141516171819202122public class Solution &#123; public boolean checkRecord(String s) &#123; int aCount = 0, lCount = 0; for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == 'A') &#123; aCount++; lCount = 0; &#125; else if (s.charAt(i) == 'L') &#123; lCount++; &#125; else &#123; lCount = 0; &#125; if (aCount &gt; 1 || lCount &gt; 2) &#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[606. Construct String from Binary Tree]]></title>
    <url>%2F2017%2F07%2F02%2F2017-07-02-606-Construct-String-from-Binary-Tree%2F</url>
    <content type="text"><![CDATA[You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way. The null node needs to be represented by empty parenthesis pair “()”. And you need to omit all the empty parenthesis pairs that don’t affect the one-to-one mapping relationship between the string and the original binary tree. Example 1:123456789101112Input: Binary tree: [1,2,3,4] 1 / \ 2 3 / 4 Output: &quot;1(2(4))(3)&quot;Explanation: Originallay it needs to be &quot;1(2(4)())(3()())&quot;,but you need to omit all the unnecessary empty parenthesis pairs.And it will be &quot;1(2(4))(3)&quot;. Example 2:1234567891011Input: Binary tree: [1,2,3,null,4] 1 / \ 2 3 \ 4Output: &quot;1(2()(4))(3)&quot;Explanation: Almost the same as the first example,except we can&apos;t omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output. 解法1：C++1 Java12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public String tree2str(TreeNode t) &#123; StringBuilder builder = new StringBuilder(); helper(builder, t); return builder.toString(); &#125; private void helper(StringBuilder builder, TreeNode t) &#123; if (t != null) &#123; builder.append(Integer.toString(t.val)); if (t.left != null || t.right != null) &#123; builder.append("("); helper(builder, t.left); builder.append(")"); if (t.right != null) &#123; builder.append("("); helper(builder, t.right); builder.append(")"); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[408. Valid Word Abbreviation]]></title>
    <url>%2F2017%2F07%2F02%2F2017-07-02-408-Valid-Word-Abbreviation%2F</url>
    <content type="text"><![CDATA[Given a non-empty string s and an abbreviation abbr, return whether the string matches with the given abbreviation. A string such as “word” contains only the following valid abbreviations:1[&quot;word&quot;, &quot;1ord&quot;, &quot;w1rd&quot;, &quot;wo1d&quot;, &quot;wor1&quot;, &quot;2rd&quot;, &quot;w2d&quot;, &quot;wo2&quot;, &quot;1o1d&quot;, &quot;1or1&quot;, &quot;w1r1&quot;, &quot;1o2&quot;, &quot;2r1&quot;, &quot;3d&quot;, &quot;w3&quot;, &quot;4&quot;] Notice that only the above abbreviations are valid abbreviations of the string “word”. Any other string is not a valid abbreviation of “word”. Note:Assume s contains only lowercase letters and abbr contains only lowercase letters and digits. Example 1:123Given s = &quot;internationalization&quot;, abbr = &quot;i12iz4n&quot;:Return true. Example 2:123Given s = &quot;apple&quot;, abbr = &quot;a2e&quot;:Return false. 解法1：string类的题目似乎用指针可以规避掉一些cornercase的处理。这题用两个指针维护当前比较的起始位置。先比较是否相等，如果相等则都往前进一步。如果不相等，则考虑abbr是否为数字，把数字parse出来后i相应的比较位置就前进对应的数字个数。这里要注意的是，数字的开端不能为０.C++1 Java1234567891011121314151617181920212223242526272829303132public class Solution &#123; public boolean validWordAbbreviation(String word, String abbr) &#123; if (word == null &amp;&amp; abbr == null) &#123; return true; &#125; else if (word == null || abbr == null) &#123; return false; &#125; int i = 0, j = 0; while (i &lt; word.length() &amp;&amp; j &lt; abbr.length()) &#123; char w = word.charAt(i); char a = abbr.charAt(j); if (w == a) &#123; i++; j++; &#125; else if (a &gt; '0' &amp;&amp; a &lt;= '9') &#123; int start = j; while (j &lt; abbr.length() &amp;&amp; abbr.charAt(j) &gt;= '0' &amp;&amp; abbr.charAt(j) &lt;= '9') &#123; j++; &#125; i += Integer.valueOf(abbr.substring(start, j)); &#125; else &#123; return false; &#125; &#125; return i == word.length() &amp;&amp; j == abbr.length(); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[157. Read N Characters Given Read4]]></title>
    <url>%2F2017%2F07%2F02%2F2017-07-02-157-Read-N-Characters-Given-Read4%2F</url>
    <content type="text"><![CDATA[The API: int read4(char[] buf) reads 4 characters at a time from a file. The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file. By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file. Note:The read function will only be called once for each test case. 解法1：C++1 Java12345678910111213141516171819202122232425262728/* The read4 API is defined in the parent class Reader4. int read4(char[] buf); */public class Solution extends Reader4 &#123; /** * @param buf Destination buffer * @param n Maximum number of characters to read * @return The number of characters read */ public int read(char[] buf, int n) &#123; char[] buffer = new char[4]; int pos = 0; while (pos &lt; n) &#123; int read = read4(buffer); for (int i = 0; i &lt; read &amp;&amp; pos &lt; n; i++) &#123; buf[pos++] = buffer[i]; &#125; if (read == 0) &#123; break; &#125; &#125; return pos; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[28. Implement strSTr()]]></title>
    <url>%2F2017%2F07%2F02%2F2017-07-02-28-Implement-strSTr%2F</url>
    <content type="text"><![CDATA[Implement strStr(). Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. 解法1：C++1 Java123456789101112131415161718192021public class Solution &#123; public int strStr(String haystack, String needle) &#123; if (needle == null || haystack == null) &#123; return -1; &#125; int n = haystack.length(), m = needle.length(); if (m &gt; n) &#123; return -1; &#125; for (int i = 0; i &lt;= n - m; i++) &#123; if (haystack.substring(i, i + m).equals(needle)) &#123; return i; &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[381. Insert Delete GetRandom O(1) - Duplicates allowed]]></title>
    <url>%2F2017%2F07%2F01%2F2017-07-01-381-Insert-Delete-GetRandom-O-1-Duplicates-allowed%2F</url>
    <content type="text"><![CDATA[Design a data structure that supports all following operations in average O(1) time.Note: Duplicate elements are allowed. insert(val): Inserts an item val to the collection. remove(val): Removes an item val from the collection if present. getRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains. Example: // Init an empty collection.RandomizedCollection collection = new RandomizedCollection(); // Inserts 1 to the collection. Returns true as the collection did not contain 1.collection.insert(1); // Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1].collection.insert(1); // Inserts 2 to the collection, returns true. Collection now contains [1,1,2].collection.insert(2); // getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3.collection.getRandom(); // Removes 1 from the collection, returns true. Collection now contains [1,2].collection.remove(1); // getRandom should return 1 and 2 both equally likely.collection.getRandom(); 解法1：自己写的怎么都没过OA,这个AC的答案是网上抄的[捂脸]。主要的思想和没有duplicates的版本很相似。区别就是这里对于每一个数字，要存储的是出现的index的list。删除操作的时候，把末尾的元素直接写到被删除的元素的位置。同时维护一下两个index的list.对于需要删除的数字，去掉list中相应的位置对于末尾的数字，在list中加入要删除的数字的位置在队列中把要删除的元素的位置置换为末尾的元素删除队列末尾的元素（因为已经放到了队列中间去了)C++1 Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class RandomizedCollection &#123; ArrayList&lt;Integer&gt; result; HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; map; public RandomizedCollection() &#123; result = new ArrayList&lt;Integer&gt;(); map = new HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt;(); &#125; /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */ public boolean insert(int val) &#123; // Add item to map if it doesn't already exist. boolean alreadyExists = map.containsKey(val); if(!alreadyExists) &#123; map.put(val, new LinkedHashSet&lt;Integer&gt;()); &#125; map.get(val).add(result.size()); result.add(val); return !alreadyExists; &#125; /** Removes a value from the collection. Returns true if the collection contained the specified element. */ public boolean remove(int val) &#123; if(!map.containsKey(val)) &#123; return false; &#125; // Get arbitary index of the ArrayList that contains val LinkedHashSet&lt;Integer&gt; valSet = map.get(val); int indexToReplace = valSet.iterator().next(); // Obtain the set of the number in the last place of the ArrayList int numAtLastPlace = result.get(result.size() - 1); LinkedHashSet&lt;Integer&gt; replaceWith = map.get(numAtLastPlace); // Replace val at arbitary index with very last number result.set(indexToReplace, numAtLastPlace); // Remove appropriate index valSet.remove(indexToReplace); // Don't change set if we were replacing the removed item with the same number if(indexToReplace != result.size() - 1) &#123; replaceWith.remove(result.size() - 1); replaceWith.add(indexToReplace); &#125; result.remove(result.size() - 1); // Remove map entry if set is now empty, then return if(valSet.isEmpty()) &#123; map.remove(val); &#125; return true; &#125; /** Get a random element from the collection. */ public int getRandom() &#123; // Get linearly random item Random random = new Random(); return result.get(random.nextInt(result.size())); // return result.get((int)(Math.random() * result.size())); &#125;&#125;/** * Your RandomizedCollection object will be instantiated and called as such: * RandomizedCollection obj = new RandomizedCollection(); * boolean param_1 = obj.insert(val); * boolean param_2 = obj.remove(val); * int param_3 = obj.getRandom(); */]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[126. Word Ladder II]]></title>
    <url>%2F2017%2F07%2F01%2F2017-07-01-126-Word-Ladder-II%2F</url>
    <content type="text"><![CDATA[Given two words (beginWord and endWord), and a dictionary’s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that: Only one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word. For example, Given:beginWord = “hit”endWord = “cog”wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”] Return1234[ [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;], [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]] Note: Return an empty list if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. UPDATE (2017/1/20):The wordList parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes. 解法1：这题挺繁琐的。思想不难，难的是优化。用到的几个知识点总结一下：一个是建立邻接链表来给DFS使用，也就是说，先用一次bfs来遍历出字典中所有word的前驱word. 从start开始，第一步就找出所有能转换为start的word。以此类推。同时，为了dfs中的优化，每一步时同时记录当前word能到达下一个word的最小步数。这里用一个distance来记录。当开始跑dfs的时候，distance就可以用来判断下一个变化的word是不是最短路上的。C++1 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class Solution &#123; public List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;List&lt;String&gt;&gt;(); Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;(); Map&lt;String, Integer&gt; distance = new HashMap&lt;String, Integer&gt;(); Set&lt;String&gt; dict = new HashSet&lt;String&gt;(); for (String ss : wordList) &#123; dict.add(ss); &#125; if (!dict.contains(endWord)) &#123; return res; &#125; dict.add(beginWord); dict.add(endWord); List&lt;String&gt; ladder = new ArrayList&lt;String&gt;(); bfs(map, distance, beginWord, endWord, dict); dfs(res, ladder, endWord, beginWord, map, distance); return res; &#125; private void bfs(Map&lt;String, List&lt;String&gt;&gt; map, Map&lt;String, Integer&gt; distance, String start, String end, Set&lt;String&gt; dict) &#123; Queue&lt;String&gt; q = new LinkedList&lt;String&gt;(); q.offer(start); distance.put(start, 0); // Create an adjacent list for (String s : dict) &#123; map.put(s, new ArrayList&lt;String&gt;()); &#125; while (!q.isEmpty()) &#123; String current = q.poll(); List&lt;String&gt; candidates = getCandidates(current, dict); for (String candidate : candidates) &#123; map.get(candidate).add(current); // reverse put // record the minimum length to the start point if (!distance.containsKey(candidate)) &#123; distance.put(candidate, distance.get(current) + 1); q.offer(candidate); &#125; &#125; &#125; &#125; private void dfs(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; ladder, String current, String start, Map&lt;String, List&lt;String&gt;&gt; map, Map&lt;String, Integer&gt; distance) &#123; ladder.add(current); if (current.equals(start)) &#123; Collections.reverse(ladder); res.add(new ArrayList&lt;String&gt;(ladder)); Collections.reverse(ladder); &#125; else &#123; for (String next : map.get(current)) &#123; if (distance.containsKey(next) &amp;&amp; distance.get(next) == distance.get(current) - 1) &#123; dfs(res, ladder, next, start, map, distance); &#125; &#125; &#125; ladder.remove(ladder.size() - 1); &#125; private List&lt;String&gt; getCandidates(String word, Set&lt;String&gt; wordList) &#123; List&lt;String&gt; candidates = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; word.length(); i++) &#123; for (char c = 'a'; c &lt;= 'z'; c++) &#123; if (c != word.charAt(i)) &#123; String modified = word.substring(0, i) + c + word.substring(i + 1); if (wordList.contains(modified)) &#123; candidates.add(modified); &#125; &#125; &#125; &#125; return candidates; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[154. Find Minimum in Rotated Sorted Array II]]></title>
    <url>%2F2017%2F07%2F01%2F2017-07-01-154-Find-Minimum-in-Rotated-Sorted-Array-II%2F</url>
    <content type="text"><![CDATA[1234Follow up for &quot;Find Minimum in Rotated Sorted Array&quot;:What if duplicates are allowed?Would this affect the run-time complexity? How and why? Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. The array may contain duplicates. 解法1：当有重复数字的时候，最差的情况会退化成O(N)的算法。在原来算法的基础上还要判断两个数字是否相等。如果相等的时候，只能排除掉一个数而不是一半的数字。C++1 Java123456789101112131415161718192021222324252627282930313233public class Solution &#123; public int findMin(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return Integer.MAX_VALUE; &#125; int start = 0, end = nums.length - 1; while (start + 1 &lt; end) &#123; int mid = start + (end - start) / 2; if (nums[start] == nums[end]) &#123; start++; &#125; else if (nums[start] &gt; nums[end]) &#123; if (nums[mid] &lt; nums[end]) &#123; end = mid; &#125; else if (nums[mid] == nums[end]) &#123; end--; &#125; else &#123; start = mid; &#125; &#125; else &#123; // nums[start] &lt; nums[end] end = mid; &#125; &#125; if (nums[start] &lt;= nums[end]) &#123; return nums[start]; &#125; return nums[end]; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[41. First Missing Positive]]></title>
    <url>%2F2017%2F06%2F29%2F2017-06-29-41-First-Missing-Positive%2F</url>
    <content type="text"><![CDATA[Given an unsorted integer array, find the first missing positive integer. For example,Given [1,2,0] return 3,and [3,4,-1,1] return 2. Your algorithm should run in O(n) time and uses constant space. 解法1：归位的思想。把每一个数字放到他该在的位置上。C++1 Java1234567891011121314151617181920212223public class Solution &#123; public int firstMissingPositive(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 1; &#125; int n = nums.length; for (int i = 0; i &lt; n; i++) &#123; while (nums[i] &lt;= n &amp;&amp; nums[i] &gt; 0 &amp;&amp; nums[i] != nums[nums[i] - 1]) &#123; int temp = nums[nums[i] - 1]; nums[nums[i] - 1] = nums[i]; nums[i] = temp; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (nums[i] != i + 1) return i + 1; &#125; return n + 1; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[128. Longest Consecutive Sequence]]></title>
    <url>%2F2017%2F06%2F29%2F2017-06-29-128-Longest-Consecutive-Sequence%2F</url>
    <content type="text"><![CDATA[Given an unsorted array of integers, find the length of the longest consecutive elements sequence. For example,Given [100, 4, 200, 1, 3, 2],The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4. Your algorithm should run in O(n) complexity. 解法1：复杂度要求比较高，算来算去能用的也只有HashMap了。这个解法不太常见，用一个map存储一个range。对于任意一个数，low和high都是数字本身。然后在map之内寻找下限和上限。寻找到之后更新res。C++1 Java123456789101112131415161718192021222324public class Solution &#123; public int longestConsecutive(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); int res = 0; for (int num : nums) &#123; if (map.containsKey(num)) continue; int low = num; int high = num; if (map.containsKey(num - 1)) low = map.get(num - 1); if (map.containsKey(num + 1)) high = map.get(num + 1); res = Math.max(res, high - low + 1); map.put(num, num); map.put(low, high); map.put(high, low); &#125; return res; &#125;&#125; 解法2：这个解法清楚多了，首先把所有数据加入一个hashset. 之后对于每一个数，往下以及往上找到所有在set中的数据。 然后更新一下range。Java123456789101112131415161718192021222324252627282930313233public class Solution &#123; public int longestConsecutive(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for (int num : nums) &#123; set.add(num); &#125; int res = 0; for (int num : nums) &#123; int down = num - 1; while (set.contains(down)) &#123; set.remove(down); down--; &#125; int upper = num + 1; while (set.contains(upper)) &#123; set.remove(upper); upper++; &#125; res = Math.max(res, upper - down - 1); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[85. Maximal Rectangle]]></title>
    <url>%2F2017%2F06%2F29%2F2017-06-29-85-Maximal-Rectangle%2F</url>
    <content type="text"><![CDATA[Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area. For example, given the following matrix:12341 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0 Return 6. 解法1：这题是运用了Largest Rectangle Area那题的解法。因为这题可以看成是一行一行的数字叠加起来，组成了一个histogram，求最大的面积。那么实际的算法就是对于每一层，计算一个当前累积的histogram，然后再求一个最大面积就可以了。C++1 Java12345678910111213141516171819202122232425262728public class Solution &#123; public int maximalRectangle(char[][] matrix) &#123; if (matrix == null || matrix.length == 0 || matrix[0] == null || matrix[0].length == 0) &#123; return 0; &#125; int res = 0; int[] heights = new int[matrix[0].length + 1]; for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix[0].length; j++) &#123; heights[j] = matrix[i][j] - '0' == 0 ? 0 : heights[j] + 1; &#125; // calculate the maximum rectangle in histogram Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); for (int j = 0; j &lt; heights.length; j++) &#123; int height = heights[j]; while (!stack.empty() &amp;&amp; height &lt; heights[stack.peek()]) &#123; int last = heights[stack.pop()]; int width = stack.empty() ? j : j - stack.peek() - 1; res = Math.max(res, last * width); &#125; stack.push(j); &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4. Median of Two Sorted Array]]></title>
    <url>%2F2017%2F06%2F27%2F2017-06-27-4-Median-of-Two-Sorted-Array%2F</url>
    <content type="text"><![CDATA[There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example 1:1234nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2:1234nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 解法1： Math参考这篇解释C++1 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int m = nums1.length; int n = nums2.length; if (m &gt; n) &#123; return findMedianSortedArrays(nums2, nums1); &#125; int start = 0, end = m, half = (m + n + 1) / 2; // Satisfy both condition, calculate the medium int max_of_left = 0, min_of_right = 0, i = 0, j = 0; while (start &lt;= end) &#123; i = (start + end) / 2; j = half- i; if (i &lt; m &amp;&amp; j &gt; 0 &amp;&amp; nums2[j - 1] &gt; nums1[i]) &#123; start = i + 1; &#125; else if (i &gt; 0 &amp;&amp; j &lt; n &amp;&amp; nums1[i - 1] &gt; nums2[j]) &#123; end = i - 1; &#125; else &#123; if (i == 0) &#123; max_of_left = nums2[j - 1]; &#125; else if (j == 0) &#123; max_of_left = nums1[i - 1]; &#125; else &#123; max_of_left = Math.max(nums1[i - 1], nums2[j - 1]); &#125; break; &#125; &#125; // Check if the total number of elements is odd or even if ((m + n) % 2 == 1) &#123; return max_of_left; &#125; if (i == m) &#123; min_of_right = nums2[j]; &#125; else if (j == n) &#123; min_of_right = nums1[i]; &#125; else &#123; min_of_right = Math.min(nums1[i], nums2[j]); &#125; return (max_of_left + min_of_right)/2.0; &#125;&#125; 解法2： Kth Value这个解法比较好理解一点，也不容易错，要考虑的edge case容易一些。基本的思想就是先要写出一个find kth element in a two sorted array的function。这个function可以用递归的方式实现，而每一次递归，两个array都需要去掉当中一个的一半。想法就是：如果第一个array的长度是0，那么第k个一定在第二个array的k-1位置。如果k==1，那么第k个就是当前比较的array的第一个的最小值如果都不是，那么可以把两个array都砍两半。假设是A和B。比较A和B的中点，一个是pa = k/2，另一个就是k - pa， 为的是保证左右两半都是k个数。然后比较这两个数，如果mA &lt; mB，则说明前pa个数都不是第k个数的备选，可以抛掉。相反同理如果ma == mB，则说明已经找到第k个数，返回即可。 等kth function写出来之后，就可以按照总长度是奇数还是偶数。如果是奇数，就直接求total / 2的数，如果是偶徐，需要把中间两个数的平均数返回。总的时间复杂度是O(logM + logN) = O(logMN) 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int m = nums1.length; int n = nums2.length; int total = m + n; if (total % 2 == 0) &#123; return (findKth(nums1, 0, nums2, 0, total / 2) + findKth(nums1, 0, nums2, 0, total / 2 + 1)) / 2.0; &#125; else &#123; return findKth(nums1, 0, nums2, 0, total / 2 + 1); &#125; &#125; private double findKth(int[] nums1, int i, int[] nums2, int j, int k) &#123; int len1 = nums1.length - i; int len2 = nums2.length - j; if (len1 &gt; len2) &#123; return findKth(nums2, j, nums1, i, k); &#125; if (len1 == 0) return nums2[j + k - 1]; if (k == 1) return Math.min(nums1[i], nums2[j]); int pa = Math.min(len1, k / 2); int pb = k - pa; if (nums1[i + pa - 1] &lt; nums2[j + pb - 1]) &#123; return findKth(nums1, i + pa, nums2, j, k - pa); &#125; else if (nums1[i + pa - 1] &gt; nums2[j + pb - 1]) &#123; return findKth(nums1, i, nums2, j + pb, k - pb); &#125; else &#123; return nums1[i + pa - 1]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[57. Insert Interval]]></title>
    <url>%2F2017%2F06%2F27%2F2017-06-27-57-Insert-Interval%2F</url>
    <content type="text"><![CDATA[Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Example 1:Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9]. Example 2:Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16]. This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10]. 解法1：自己写的版本比较繁琐，先用binary search来查找插入的位置，然后把interval插入，然后再merge interval。C++1 Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Solution &#123; public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123; List&lt;Interval&gt; res = new ArrayList&lt;Interval&gt;(); if (intervals.size() == 0 &amp;&amp; newInterval == null) &#123; return res; &#125; else if (intervals.size() == 0) &#123; res.add(newInterval); return res; &#125; int position = binarySearch(intervals, newInterval); // Insert into the intervals; if (position &lt; intervals.size()) &#123; intervals.add(position, newInterval); &#125; else &#123; intervals.add(newInterval); &#125; // Merge Intervals using intervals Interval last = intervals.get(0); res.add(last); for (int i = 1; i &lt; intervals.size(); i++) &#123; Interval current = intervals.get(i); // check if we need to merge if (current.start &lt;= last.end) &#123; last.end = Math.max(last.end, current.end); &#125; else &#123; res.add(current); last = current; &#125; &#125; return res; &#125; private int binarySearch(List&lt;Interval&gt; intervals, Interval newInterval) &#123; // return the first interval that the start is larger than newInterval's start int start = 0, end = intervals.size() - 1; while (start + 1 &lt; end) &#123; int mid = start + (end - start) / 2; Interval temp = intervals.get(mid); if (temp.start &lt;= newInterval.start) &#123; start = mid; &#125; else &#123; end = mid; &#125; &#125; if (intervals.get(start).start &gt;= newInterval.start) &#123; return start; &#125; if (intervals.get(end).start &gt;= newInterval.start) &#123; return end; &#125; return intervals.size(); &#125;&#125; 解法2：不需要用binary search来查找插入位置，而是在一边遍历的情况下用另一个指针pos来维护该插入的位置。这个思想在其他的题目中也见过。Java1234567891011121314151617181920212223public class Solution &#123; public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123; List&lt;Interval&gt; res = new ArrayList&lt;Interval&gt;(); int pos = 0; // find an insert position for newInterval for (Interval it : intervals) &#123; if (it.end &lt; newInterval.start) &#123; res.add(it); pos++; &#125; else if (newInterval.end &lt; it.start) &#123; res.add(it); &#125; else &#123; newInterval.start = Math.min(it.start, newInterval.start); newInterval.end = Math.max(it.end, newInterval.end); &#125; &#125; res.add(pos, newInterval); return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[45. Jump Game II]]></title>
    <url>%2F2017%2F06%2F27%2F2017-06-27-45-Jump-Game-II%2F</url>
    <content type="text"><![CDATA[Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. For example:Given array A = [2,3,1,1,4] The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.) Note:You can assume that you can always reach the last index. 解法1：Greedy O(N) Time O(1) Space这题可以作为复习Greedy Algorithm的一个很好的范例。最核心的思想和Jump Game一样，用一个变量维护上一步可以走到的最远距离。如果当前的距离比他远，则说明需要额外的一步。同时维护一个下一步可以走到的最远距离，便是在当前的最远距离和i + nums[i]中取最大值即可。 C++1 Java123456789101112131415161718192021222324252627public class Solution &#123; public int jump(int[] nums) &#123; if (nums.length == 0) &#123; return 0; &#125; // Greedy int cur = 0; int last = 0; int step = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (i &gt; last) &#123; last = cur; step++; if (last &gt;= nums.length) &#123; return step; &#125; &#125; cur = Math.max(cur, i + nums[i]); &#125; return step; &#125;&#125; 解法2：Greedy O(N) Time O(N) Space, DP thinking用一个dp数组来存储每一个点所需要的最少步数。然后从0开始扫描，找出当前点所能到的最远距离。然后从下一位置开始扫描，对于每一个可以到达的点都更新最少的步数，也就是dp[j] = dp[i] + 1。到此，j位置上的结果已经找出，不会再有比他步数更少的解了。最后返回dp[n-1]即可。C++1 Java12345678910111213141516171819public class Solution &#123; public int jump(int[] nums) &#123; int[] dp = new int[nums.length]; // dp pointer int j=1; for (int i=0; i&lt;nums.length; i++) &#123; int loc= nums[i] + i; while (j&lt;=loc &amp;&amp; j&lt;nums.length) &#123; dp[j] = dp[i] + 1; j++; &#125; &#125; return dp[dp.length-1]; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[533. Lonely Pixel II]]></title>
    <url>%2F2017%2F06%2F26%2F2017-06-26-533-Lonely-Pixel-II%2F</url>
    <content type="text"><![CDATA[Given a picture consisting of black and white pixels, and a positive integer N, find the number of black pixels located at some specific row R and column C that align with all the following rules: Row R and column C both contain exactly N black pixels. For all rows that have a black pixel at column C, they should be exactly the same as row R The picture is represented by a 2D char array consisting of ‘B’ and ‘W’, which means black and white pixels respectively. Example:12345678910111213141516171819Input: [[&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;], [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;], [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;], [&apos;W&apos;, &apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;W&apos;]]N = 3Output: 6Explanation: All the bold &apos;B&apos; are the black pixels we need (all &apos;B&apos;s at column 1 and 3). 0 1 2 3 4 5 column index 0 [[&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;], 1 [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;], 2 [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;], 3 [&apos;W&apos;, &apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;W&apos;]] row indexTake &apos;B&apos; at row R = 0 and column C = 1 as an example:Rule 1, row R = 0 and column C = 1 both have exactly N = 3 black pixels.Rule 2, the rows have black pixel at column C = 1 are row 0, row 1 and row 2. They are exactly the same as row R = 0. Note: The range of width and height of the input 2D array is [1,200]. 解法1：很繁琐的一道题。。。C++1 Java123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public int findBlackPixel(char[][] picture, int N) &#123; if (picture == null || picture.length == 0 || picture[0].length == 0) return 0; int m = picture.length, n = picture[0].length; int[] cols = new int[n]; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); // Use a hashMap to store the rows string that satisfy that row pixel count is N for (int i = 0; i &lt; m; i++) &#123; int count = 0; for (int j = 0; j &lt; n; j++) &#123; if (picture[i][j] == 'B') &#123; cols[j]++; count++; &#125; &#125; if (count == N) &#123; String curRow = new String(picture[i]); map.put(curRow, map.getOrDefault(curRow, 0) + 1); &#125; &#125; int res = 0; for (String row : map.keySet()) &#123; if (map.get(row) != N) continue; for (int i = 0; i &lt; n; i++) &#123; if (row.charAt(i) == 'B' &amp;&amp; cols[i] == N) &#123; res += N; &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[548. Split Array with Equal Sum]]></title>
    <url>%2F2017%2F06%2F26%2F2017-06-26-548-Split-Array-with-Equal-Sum%2F</url>
    <content type="text"><![CDATA[Given an array with n integers, you need to find if there are triplets (i, j, k) which satisfies following conditions: 0 &lt; i, i + 1 &lt; j, j + 1 &lt; k &lt; n - 1 Sum of subarrays (0, i - 1), (i + 1, j - 1), (j + 1, k - 1) and (k + 1, n - 1) should be equal. where we define that subarray (L, R) represents a slice of the original array starting from the element indexed L to the element indexed R. Example:12345678Input: [1,2,1,2,1,2,1]Output: TrueExplanation:i = 1, j = 3, k = 5.sum(0, i - 1) = sum(0, 0) = 1sum(i + 1, j - 1) = sum(2, 2) = 1sum(j + 1, k - 1) = sum(4, 4) = 1sum(k + 1, n - 1) = sum(6, 6) = 1 Note: 1 &lt;= n &lt;= 2000. Elements in the given array will be in range [-1,000,000, 1,000,000]. 解法1：这题又是2sum的一个变种。把一个数组分成加和相等的4份。trick在于如果遍历中间的点，那么左右那边变成找出是否存在切割点使得切割之后的两份的加和相等。那么这一部分就可以用hashset来解决。存储可以等分的sum，然后在右边的部分寻找等分的时候看是否在左面出现过。C++1 Java123456789101112131415161718192021222324252627282930public class Solution &#123; public boolean splitArray(int[] nums) &#123; if (nums.length &lt;= 6) &#123; return false; &#125; int[] sum = new int[nums.length]; sum[0] = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; sum[i] = sum[i - 1] + nums[i]; &#125; for (int j = 3; j &lt; nums.length - 3; j++) &#123; HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for (int i = 1; i &lt; j - 1; i++) &#123; if (sum[i - 1] == sum[j - 1] - sum[i]) &#123; set.add(sum[i - 1]); &#125; &#125; for (int k = j + 2; k &lt; nums.length - 1; k++) &#123; if (sum[k - 1] - sum[j] == sum[nums.length - 1] - sum[k] &amp;&amp; set.contains(sum[k - 1] - sum[j])) &#123; return true; &#125; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[560. Subarray Sum Equals K]]></title>
    <url>%2F2017%2F06%2F26%2F2017-06-26-560-Subarray-Sum-Equals-K%2F</url>
    <content type="text"><![CDATA[Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Example 1: Input:nums = [1,1,1], k = 2Output: 2 Note: The length of the array is in range [1, 20,000]. The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7]. 解法1：O(N) Time + O(N) Space这题和2Sum的思路有点像。首先是一道continuous sum的题，可以考虑用prefix sum的办法。每次计算一个累加和，假设为sum，sum-presum=k也就意味着，sum-k=presum,如果我们用一个hashtable存储每一个presum出现的次数，那就可以指导对于任意一个sum，其满足要求的presum是否出现过，并且出现过几次。这一点和2sum是一样的，只是一个用加法一个用减法。C++1 Java123456789101112131415161718192021222324252627282930313233public class Solution &#123; public int subarraySum(int[] nums, int k) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); if (nums == null || nums.length == 0) &#123; return 0; &#125; int sum = 0; int cnt = 0; for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; if (sum == k) &#123; cnt++; &#125; if (map.containsKey(sum - k)) &#123; cnt += map.get(sum - k); &#125; if (map.containsKey(sum)) &#123; map.put(sum, map.get(sum) + 1); &#125; else &#123; map.put(sum, 1); &#125; &#125; return cnt; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[682. Maximum Product of Three Numbers]]></title>
    <url>%2F2017%2F06%2F24%2F2017-06-24-682-Maximum-Product-of-Three-Numbers%2F</url>
    <content type="text"><![CDATA[Given an integer array, find three numbers whose product is maximum and output the maximum product. Example 1:12Input: [1,2,3]Output: 6 Example 2:12Input: [1,2,3,4]Output: 24 Note: The length of the given array will be in range [3,104] and all elements are in the range [-1000, 1000]. Multiplication of any three numbers in the input won&apos;t exceed the range of 32-bit signed integer. 解法1：这题用3Sum smaller的思路，不过是简化了的版本。每对应一个数字，只需要考虑如果是负数时最小的乘积和如果是正数时最大的乘积。C++1 Java12345678910111213141516171819202122public class Solution &#123; public int maximumProduct(int[] nums) &#123; if (nums.length == 0 ) &#123; return 0; &#125; Arrays.sort(nums); // sort ascending int res = Integer.MIN_VALUE; int n = nums.length; for (int i = 0; i &lt; nums.length - 2; i++) &#123; if (nums[i] &lt; 0) &#123; res = Math.max(res, nums[i] * nums[i + 1] * nums[n - 1]); &#125; else if (nums[i] &gt; 0) &#123; res = Math.max(res, nums[n - 1] * nums[n - 2] * nums[i]); &#125; else &#123; res = Math.max(res, 0); &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[562. Longest Line of Consecutive One in Matrix]]></title>
    <url>%2F2017%2F06%2F24%2F2017-06-24-562-Longest-Line-of-Consecutive-One-in-Matrix%2F</url>
    <content type="text"><![CDATA[Given a 01 matrix M, find the longest line of consecutive one in the matrix. The line could be horizontal, vertical, diagonal or anti-diagonal. Example: Input:[[0,1,1,0], [0,1,1,0], [0,0,0,1]]Output: 3 Hint: The number of elements in the given matrix will not exceed 10,000. 解法1：DP, O(nm)用一个三维数组记录每一个格子上4个方向的最长的个数。同时更新一下最长的值即可。C++1 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Solution &#123; public int longestLine(int[][] M) &#123; if (M.length == 0 || M[0].length == 0) &#123; return 0; &#125; int[][][] dp = new int[M.length][M[0].length][4]; if (M[0][0] == 1) &#123; for (int i = 0; i &lt; 4; i++) &#123; dp[0][0][i] = 1; &#125; &#125; int res = 0; for (int i = 0; i &lt; M.length; i++) &#123; for (int j = 0; j &lt; M[0].length; j++) &#123; if (M[i][j] == 0) &#123; continue; &#125; for (int k = 0; k &lt; 4; k++) &#123; dp[i][j][k] = 1; &#125; // vertical line if (i &gt; 0) &#123; dp[i][j][0] = dp[i - 1][j][0] + 1; &#125; // horizontal line if (j &gt; 0) &#123; dp[i][j][1] = dp[i][j - 1][1] + 1; &#125; // diagonal line if (i &gt; 0 &amp;&amp; j &lt; M[0].length - 1) &#123; dp[i][j][3] = dp[i - 1][j + 1][3] + 1; &#125; // anti diagonal line if (i &gt; 0 &amp;&amp; j &gt; 0) &#123; dp[i][j][2] = dp[i - 1][j - 1][2] + 1; &#125; res = Math.max(res, Math.max(dp[i][j][0], dp[i][j][1])); res = Math.max(res, Math.max(dp[i][j][2], dp[i][j][3])); &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[565. Array Nesting]]></title>
    <url>%2F2017%2F06%2F24%2F2017-06-24-565-Array-Nesting%2F</url>
    <content type="text"><![CDATA[A zero-indexed array A consisting of N different integers is given. The array contains all integers in the range [0, N - 1]. Sets S[K] for 0 &lt;= K &lt; N are defined as follows: S[K] = { A[K], A[A[K]], A[A[A[K]]], … }. Sets S[K] are finite for each K and should NOT contain duplicates. Write a function that given an array A consisting of N integers, return the size of the largest set S[K] for this array. Example 1:1234567Input: A = [5,4,0,3,1,6,2]Output: 4Explanation:A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.One of the longest S[K]:S[0] = &#123;A[0], A[5], A[6], A[2]&#125; = &#123;5, 6, 2, 0&#125; Note: N is an integer within the range [1, 20,000]. The elements of A are all distinct. Each element of array A is an integer within the range [0, N-1]. 解法1： O(N) Time + O(N) Space用DFS的思想，同时记录所访问过的元素。对于每一个未被访问过的元素跑一遍DFS，直到碰到已经访问过的元素位置，同时更新一下最大的值。C++1 Java12345678910111213141516171819202122232425public class Solution &#123; public int arrayNesting(int[] nums) &#123; // union find if (nums == null || nums.length == 0) &#123; return 0; &#125; boolean[] visited = new boolean[nums.length]; int res = Integer.MIN_VALUE; for (int i = 0; i &lt; nums.length; i++) &#123; int cnt = 0; int current = i; while (!visited[current]) &#123; cnt++; visited[current] = true; current = nums[current]; &#125; res = Math.max(res, cnt); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[611. Valid Triangle Number]]></title>
    <url>%2F2017%2F06%2F24%2F2017-06-24-611-Valid-Triangle-Number%2F</url>
    <content type="text"><![CDATA[Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle. Example 1:1234567Input: [2,2,3,4]Output: 3Explanation:Valid combinations are:2,3,4 (using the first 2)2,3,4 (using the second 2)2,2,3 Note: The length of the given array won&apos;t exceed 1000. The integers in the given array are in the range of [0, 1000]. 解法1：O(N^2)这题的思路和3SUM smaller很像，也可以用O(N^2)解决。首先要确定，满足一个三角形的条件是任意两条边之和要大于第三条边。那么如果先对数组排序。如果A]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[621. Task Scheduler]]></title>
    <url>%2F2017%2F06%2F24%2F2017-06-24-621-Task-Scheduler%2F</url>
    <content type="text"><![CDATA[Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks.Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle. However, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle. You need to return the least number of intervals the CPU will take to finish all the given tasks. Example 1: Input: tasks = [‘A’,’A’,’A’,’B’,’B’,’B’], n = 2Output: 8Explanation: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B. Note: The number of tasks is in the range [1, 10000]. The integer n is in the range [0, 100]. 解法1：先找出出现频率最大的数字，假设频率为k。然后分开每一个数字使得两个数字之间间隔为n。这样，会有k-1个间隔出现。所有频率小于k的数字都可以完全填充在这k-1个间隔里面。那么，这个时候总长度就是：(k - 1) * (n + 1) + 频率为k的数字的个数。（n+1)是因为每一个分段都是一个最高频的数字加上剩下的空， i.e. AXXXXXXXXXC++1 Java1234567891011121314151617181920212223242526public class Solution &#123; public int leastInterval(char[] tasks, int n) &#123; int[] map = new int[26]; for (char task: tasks) &#123; map[task - 'A']++; &#125; Arrays.sort(map); int maxFreq = map[25]; int t = 0; for (int i = map.length - 1; i &gt;= 0; i--) &#123; if (map[i] == maxFreq) &#123; t++; &#125; else &#123; break; &#125; &#125; return Math.max(tasks.length, (maxFreq - 1) * (n + 1) + t); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[495. Teemo Attacking]]></title>
    <url>%2F2017%2F06%2F24%2F2017-06-24-495-Teemo-Attacking%2F</url>
    <content type="text"><![CDATA[In LLP world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo’s attacking ascending time series towards Ashe and the poisoning time duration per Teemo’s attacking, you need to output the total time that Ashe is in poisoned condition. You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately. Example 1:123456Input: [1,4], 2Output: 4Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately.This poisoned status will last 2 seconds until the end of time point 2.And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds.So you finally need to output 4. Example 2:1234567Input: [1,2], 2Output: 3Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned.This poisoned status will last 2 seconds until the end of time point 2.However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status.Since the poisoned status won&apos;t add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3.So you finally need to output 3. Note: You may assume the length of given time series array won’t exceed 10000. You may assume the numbers in the Teemo’s attacking time series and his poisoning time duration per attacking are non-negative integers, which won’t exceed 10,000,000. 解法1： Greedy关键点在于： 两次攻击的间隔如果小于duration，那么上一次攻击的有效时间就是间隔时间。C++1 Java1234567891011121314151617181920212223public class Solution &#123; public int findPoisonedDuration(int[] timeSeries, int duration) &#123; int res = 0; if (timeSeries.length == 0 || duration == 0) &#123; return res; &#125; for (int i = 1; i &lt; timeSeries.length; i++) &#123; int diff = timeSeries[i] - timeSeries[i - 1]; if (diff &lt; duration) &#123; res += diff; &#125; else &#123; res += duration; &#125; &#125; // Add the last piece res += duration; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[370. Range Addition]]></title>
    <url>%2F2017%2F06%2F24%2F2017-06-24-370-Range-Addition%2F</url>
    <content type="text"><![CDATA[Assume you have an array of length n initialized with all 0’s and are given k update operations. Each operation is represented as a triplet: [startIndex, endIndex, inc] which increments each element of subarray A[startIndex … endIndex] (startIndex and endIndex inclusive) with inc. Return the modified array after all k operations were executed. Example:123456789101112Given: length = 5, updates = [ [1, 3, 2], [2, 4, 3], [0, 2, -2] ]Output: [-2, 0, 3, 5, 3] Explanation:1234567891011Initial state:[ 0, 0, 0, 0, 0 ]After applying operation [1, 3, 2]:[ 0, 2, 2, 2, 0 ]After applying operation [2, 4, 3]:[ 0, 2, 5, 5, 3 ]After applying operation [0, 2, -2]:[-2, 0, 3, 5, 3 ] 解法1： O(n) + O(k)这题如果用一般的办法会TLE。关键的点在于不用更新start和end之间所有的数。那么我们只更新start的数，意思是从这往后所有的数都要加上start对应的数字。同时需要在end+1的地方减去increment，意思是从这里往后所有的数要减去start对应的数字，以此来抵消多加的那一份。最后我们在遍历一遍数组，做一个累加就得到了结果。C++1 Java1234567891011121314151617181920212223public class Solution &#123; public int[] getModifiedArray(int length, int[][] updates) &#123; if (length &lt;= 0) &#123; return new int[0]; &#125; int[] res = new int[length]; for (int i = 0; i &lt; updates.length; i++) &#123; res[updates[i][0]] += updates[i][2]; if (updates[i][1] &lt; res.length - 1) &#123; res[updates[i][1] + 1] -= updates[i][2]; &#125; &#125; for (int i = 1; i &lt; res.length; i++) &#123; res[i] += res[i - 1]; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[245. Shortest Word Distance III]]></title>
    <url>%2F2017%2F06%2F24%2F2017-06-24-245-Shortest-Word-Distance-III%2F</url>
    <content type="text"><![CDATA[This is a follow up of Shortest Word Distance. The only difference is now word1 could be the same as word2. Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list. word1 and word2 may be the same and they represent two individual words in the list. For example,Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”]. Given word1 = “makes”, word2 = “coding”, return 1.Given word1 = “makes”, word2 = “makes”, return 3. Note:You may assume word1 and word2 are both in the list. 解法1：双指针区别就是当word1和word2相同的时候，退化成只需要一个指针就可以了。在这种情况下，先判断之前是否出现过这个单词，如果出现过计算下当前的距离，然后更新上一次出现的位置。C++1 Java12345678910111213141516171819202122232425262728293031323334public class Solution &#123; public int shortestWordDistance(String[] words, String word1, String word2) &#123; if (words.length == 0) &#123; return 0; &#125; int left = -1, right = -1; int res = Integer.MAX_VALUE; for (int i = 0; i &lt; words.length; i++) &#123; if (words[i].equals(word1) &amp;&amp; word1.equals(word2)) &#123; if (left != -1) &#123; res = Math.min(res, i - left); &#125; left = i; &#125; else if (words[i].equals(word1)) &#123; left = i; if (right != -1) &#123; res = Math.min(res, left - right); &#125; &#125; else if (words[i].equals(word2)) &#123; right = i; if (left != -1) &#123; res = Math.min(res, right - left); &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[259. 3Sum Smaller]]></title>
    <url>%2F2017%2F06%2F23%2F2017-06-23-259-3Sum-Smaller%2F</url>
    <content type="text"><![CDATA[Given an array of n integers nums and a target, find the number of index triplets i, j, k with 0 &lt;= i &lt; j &lt; k &lt; n that satisfy the condition nums[i] + nums[j] + nums[k] &lt; target. For example, given nums = [-2, 0, 1, 3], and target = 2. Return 2. Because there are two triplets which sums are less than 2: [-2, 0, 1][-2, 0, 3] Follow up:Could you solve it in O(n2) runtime? 解法1： O(N^2)O(N^2)的解法和3Sum或者3Sum closest类似，但比较tricky的地方是，在用双指针left和right找到一个&lt;target的数的时候，其实right 和left之间所有的数都满足要求（排序之后）。所以这个时候我们把right-left加入到res中，然后更新left即可。 12345678910111213141516171819202122232425262728public class Solution &#123; public int threeSumSmaller(int[] nums, int target) &#123; if (nums.length &lt; 3) &#123; return 0; &#125; Arrays.sort(nums); int n = nums.length; int cnt = 0; for (int i = 0; i &lt; n - 2; i++) &#123; int left = i + 1; int right = n - 1; while (left &lt; right) &#123; int sum = nums[i] + nums[left] + nums[right]; if (sum &lt; target) &#123; cnt += right - left; // trick is here left++; &#125; else &#123; right--; &#125; &#125; &#125; return cnt; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[163. Missing Ranges]]></title>
    <url>%2F2017%2F06%2F23%2F2017-06-23-163-Missing-Ranges%2F</url>
    <content type="text"><![CDATA[Given a sorted integer array where the range of elements are in the inclusive range [lower, upper], return its missing ranges. For example, given [0, 1, 3, 50, 75], lower = 0 and upper = 99, return [“2”, “4-&gt;49”, “51-&gt;74”, “76-&gt;99”]. 解法1：挺无聊的一道题，主要是corner case比较多。算法不难，就是遍历一遍数组。找出是否是连续的数，如果不是那么补上缺少的range。corner case有：缺少的是一个数，不是range两个相同的数数字已经是Integer.MAX_VALUE，会溢出。C++1 Java1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; public List&lt;String&gt; findMissingRanges(int[] nums, int lower, int upper) &#123; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); if (nums.length == 0) &#123; if (lower == upper) &#123; res.add(Integer.toString(lower)); &#125; else &#123; res.add(Integer.toString(lower) + "-&gt;" + Integer.toString(upper)); &#125; return res; &#125; for (int i = 0; i &lt; nums.length; ++i) &#123; if (i == 0 &amp;&amp; nums[i] &gt; lower) &#123; if (nums[i] == lower + 1) &#123; res.add(Integer.toString(lower)); &#125; else &#123; res.add(Integer.toString(lower) + "-&gt;" + Integer.toString(nums[i] - 1)); &#125; &#125; else if (i != 0) &#123; if (nums[i] != nums[i - 1] &amp;&amp; nums[i] &gt; nums[i - 1] + 1) &#123; if (nums[i] == nums[i - 1] + 2) &#123; res.add(Integer.toString(nums[i - 1] + 1)); &#125; else &#123; res.add(Integer.toString(nums[i - 1] + 1) + "-&gt;" + Integer.toString(nums[i] - 1)); &#125; &#125; &#125; if (i == nums.length - 1) &#123; if (upper &gt; nums[i]) &#123; if (upper == nums[i] + 1) &#123; res.add(Integer.toString(upper)); &#125; else &#123; res.add(Integer.toString(nums[i] + 1) + "-&gt;" + Integer.toString(upper)); &#125; &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[442. Find All Duplicates in an Array]]></title>
    <url>%2F2017%2F06%2F23%2F2017-06-23-442-Find-All-Duplicates-in-an-Array%2F</url>
    <content type="text"><![CDATA[Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements that appear twice in this array. Could you do it without extra space and in O(n) runtime? Example: Input:[4,3,2,7,8,2,3,1] Output:[2,3] 解法1：这题比较关键的是题目的条件，数字在1和n之间。那么用置换的办法可以达到复杂度的要求。对于每一个数字，如果没有重复，排序之后他应该在i+1上。那么我们可以把每一个数字归位。要注意，如果i和j置换了，i不应该往前进而是应该停留原地（i–那行很重要）C++1 Java1234567891011121314151617181920212223public class Solution &#123; public List&lt;Integer&gt; findDuplicates(int[] nums) &#123; // Use the condition that num in nums are between 1 and n for (int i = 0; i &lt; nums.length; ++i) &#123; if (nums[i] != nums[nums[i] - 1]) &#123; int temp = nums[i]; nums[i] = nums[temp -1]; nums[temp - 1] = temp; i--; // very important &#125; &#125; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if (i != nums[i] - 1) &#123; res.add(nums[i]); &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[209. Minimum Size Subarray Sum]]></title>
    <url>%2F2017%2F06%2F23%2F2017-06-23-209-Minimum-Size-Subarray-Sum%2F</url>
    <content type="text"><![CDATA[Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead. For example, given the array [2,3,1,2,4,3] and s = 7,the subarray [4,3] has the minimal length under the problem constraint. More practice: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n). 解法1：dynamic window O(N)动态窗口的一种应用。用左右两个指针维护一个窗口，先移动右指针直到加和&gt;=sum, 然后在开始移动左指针，每次移动判断加和是否还满足并且更新最小的差距。C++1 Java123456789101112131415161718192021222324252627public class Solution &#123; public int minSubArrayLen(int s, int[] nums) &#123; if (nums.length == 0) &#123; return 0; &#125; int left = 0, right = 0, n = nums.length, sum = 0; // left, right is a dynamic window int res = Integer.MAX_VALUE; while (right &lt; n) &#123; while (sum &lt; s &amp;&amp; right &lt; n) &#123; sum += nums[right++]; &#125; while (sum &gt;= s) &#123; res = Math.min(res, right - left); sum -= nums[left++]; &#125; &#125; return res == Integer.MAX_VALUE ? 0 : res; &#125;&#125; 解法2： binary search用binary search的条件是数组一定是一定程度上有序的。这里把数组变成了一个累加的数组。然后对于每一个加和sum， 寻找在之后的第一个数字k使得k&gt;=sum+s，找到之后更新坐标。Javalang: java123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Solution &#123; public int minSubArrayLen(int s, int[] nums) &#123; if (nums.length == 0) &#123; return 0; &#125; // Create a helper array int n = nums.length; int[] helper = new int[n + 1]; for (int i = 1; i &lt;= n; i++) &#123; helper[i] = helper[i - 1] + nums[i - 1]; &#125; int res = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) &#123; int temp = binarySearch(helper, i + 1, n, s + helper[i]); if (temp != -1) &#123; res = Math.min(res, temp - i); &#125; &#125; return res == Integer.MAX_VALUE ? 0 : res; &#125; private int binarySearch(int[] nums, int left, int right, int target) &#123; // Find the first element in nums that is larger or equal to the target while (left + 1 &lt; right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt; target) &#123; left = mid; &#125; else if (nums[mid] &gt;= target) &#123; right = mid; &#125; &#125; if (nums[left] &gt;= target) &#123; return left; &#125; else if (nums[right] &gt;= target) &#123; return right; &#125; else &#123; return -1; &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Dynamic Window</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[277. Find the Celebrity]]></title>
    <url>%2F2017%2F06%2F23%2F2017-06-23-277-Find-the-Celebrity%2F</url>
    <content type="text"><![CDATA[Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them. Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: “Hi, A. Do you know B?” to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense). You are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n), your function should minimize the number of calls to knows. Note: There will be exactly one celebrity if he/she is in the party. Return the celebrity’s label if there is a celebrity in the party. If there is no celebrity, return -1. 解法1: Greedy这题用暴力法解的话是O(N^2)的复杂度，那么要降低复杂度只有O(N), O(logN), O(NlogN)几种。似乎binary search也不能很好解决。在这种情况下，有一类算法可能有奇效，就是greedy。可以用greedy的题目有一类特征就是有的时候题目会告诉，如果有的话有且仅有一个解。这里我们就先遍历一遍数组，找到一个可能为celebrity的数字。然后再验证一遍该数字，是否满足条件，如果不满足条件，那么就说明没有celebrity。如果有，那么就是他。C++1 Java1234567891011121314151617181920public class Solution extends Relation &#123; public int findCelebrity(int n) &#123; int celebrity = 0; for (int i = 0; i &lt; n; ++i) &#123; if (knows(celebrity, i)) &#123; celebrity = i; &#125; &#125; for (int i = 0; i &lt; n; ++i) &#123; if (celebrity != i &amp;&amp; (knows(celebrity, i) || !knows(i, celebrity))) &#123; return -1; &#125; &#125; return celebrity; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[74. Search a 2D Matrix]]></title>
    <url>%2F2017%2F06%2F23%2F2017-06-23-74-Search-a-2D-Matrix%2F</url>
    <content type="text"><![CDATA[Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. For example, Consider the following matrix: [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]] Given target = 3, return true. 解法1：这题有两种做法，都用到了binary search。一种只需要一次binary search，也就是下面的这种解法。但缺点是row×col可能会溢出，同时取余数的操作比较expensive。还有一种是两次binary search。先用一次找出最后一行其中第一个数字小于target，然后再这行再用一次binary search。C++1 Java12345678910111213141516171819202122232425262728293031public class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; if (matrix.length == 0 || matrix[0].length == 0) &#123; return false; &#125; int m = matrix.length; int n = matrix[0].length; int start = 0, end = m * n - 1; while (start + 1 &lt; end) &#123; int mid = start + (end - start) / 2; int row = mid / n; int col = mid % n; if (matrix[row][col] &lt; target) &#123; start = mid; &#125; else if (matrix[row][col] &gt; target) &#123; end = mid; &#125; else &#123; return true; &#125; &#125; if (matrix[start / n][start % n] == target || matrix[end / n][end % n] == target) &#123; return true; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[81. Search in Rotated Sorted Array II]]></title>
    <url>%2F2017%2F06%2F23%2F2017-06-23-81-Search-in-Rotated-Sorted-Array-II%2F</url>
    <content type="text"><![CDATA[Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Write a function to determine if a given target is in the array. The array may contain duplicates. 解法1: O(logN), worst case O(n)当有重复值的时候，我们在判断丢弃left或者是right half的时候，如果碰到nums[mid] == nums[end]或者nums[mid] == nums[start]的时候，不能判断哪一个部分需要抛弃。这个时候只能让end–或者start–C++1 Java12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public boolean search(int[] nums, int target) &#123; if (nums == null || nums.length == 0) &#123; return false; &#125; int start = 0, end = nums.length - 1; while (start + 1 &lt; end) &#123; int mid = start + (end - start) / 2; if (nums[mid] == target) &#123; return true; &#125; else if (nums[mid] &lt; nums[end]) &#123; if (nums[mid] &lt; target &amp;&amp; nums[end] &gt;= target) &#123; start = mid; &#125; else &#123; end = mid; &#125; &#125; else if (nums[mid] &gt; nums[end]) &#123; if (nums[start] &lt;= target &amp;&amp; nums[mid] &gt; target) &#123; end = mid; &#125; else &#123; start = mid; &#125; &#125; else &#123; end--; // can not remove a half &#125; &#125; if (nums[end] == target || nums[start] == target) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18. 4Sum]]></title>
    <url>%2F2017%2F06%2F23%2F2017-06-23-18-4Sum%2F</url>
    <content type="text"><![CDATA[Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets.12345678For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 解法1： O(N^3)和3Sum一样的思路，最外层遍历第一个数，第二层遍历第二个数，之后用双指针像中间扫描。遇到加和为target的就推入list中。要注意的是需要去重。那么每一次去重的时候只需要跳过和前一个一样的数就可以了。C++1 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); int n = nums.length; if (n &lt; 4) &#123; return res; &#125; Arrays.sort(nums); // need to sort first for (int i = 0; i &lt; n - 3; i++) &#123; if (i != 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; for (int j = i + 1; j &lt; n - 2; j++) &#123; if (j != i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123; continue; &#125; int k = j + 1; int m = n - 1; while (k &lt; m) &#123; while (k != j + 1 &amp;&amp; k &lt; m &amp;&amp; nums[k] == nums[k - 1]) &#123; k++; // remove duplicates &#125; while (m != n - 1 &amp;&amp; k &lt; m &amp;&amp; nums[m] == nums[m + 1]) &#123; m--; &#125; if (k &lt; m) &#123; int sum = nums[i] + nums[j] + nums[k] + nums[m]; if (sum == target) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(); temp.add(nums[i]); temp.add(nums[j]); temp.add(nums[k]); temp.add(nums[m]); res.add(temp); k++; m--; &#125; else if (sum &lt; target) &#123; k++; &#125; else &#123; m--; &#125; &#125; &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[16.3Sum Closest]]></title>
    <url>%2F2017%2F06%2F23%2F2017-06-23-16-3Sum-Closest%2F</url>
    <content type="text"><![CDATA[Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. For example, given array S = {-1 2 1 -4}, and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 解法1：O(N^2)closest转化为程序的意思就是说，需要一个var来记录每一次的sum，然后把当前的diff和之前diff来比较。循环的时候从头开始像后循环。C++1 Java123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; Arrays.sort(nums); int closest = 0; for (int i = 0; i &lt; 3 &amp;&amp; i &lt; nums.length; i++) &#123; closest += nums[i]; &#125; if (nums.length &lt; 3) &#123; return closest; &#125; for (int i = 0; i &lt; nums.length - 2; i++) &#123; int j = i + 1; int k = nums.length - 1; while (j &lt; k) &#123; int sum = nums[i] + nums[j] + nums[k]; if (Math.abs(sum - target) &lt; Math.abs(closest - target)) &#123; closest = sum; if (closest == target) return closest; &#125; if (sum &lt; target) &#123; j++; &#125; else &#123; k--; &#125; &#125; &#125; return closest; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[575. Distribute Candies]]></title>
    <url>%2F2017%2F06%2F21%2F2017-06-21-575-Distribute-Candies%2F</url>
    <content type="text"><![CDATA[Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain. Example 1:123456Input: candies = [1,1,2,2,3,3]Output: 3Explanation:There are three different kinds of candies (1, 2 and 3), and two candies for each kind.Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too.The sister has three different kinds of candies. Example 2:1234Input: candies = [1,1,2,3]Output: 2Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1].The sister has two different kinds of candies, the brother has only one kind of candies. Note: The length of the given array is in range [2, 10,000], and will be even. The number in given array is in range [-100,000, 100,000]. 解法1：有一类问题的思路是这样的：如果求最大或者最小值，先考虑一下理论上可能可以取到的值。然后再以此为突破口看看是否有思路。这题就是这样，先想到要取n/2个数，那么最大的种类也就是n/2，不可能再大了。那么如果数组里的类别比n/2小，那么最大的值就是数组里的数的种类数。C++1 Java12345678910111213141516public class Solution &#123; public int distributeCandies(int[] candies) &#123; if (candies == null || candies.length == 0) &#123; return 0; &#125; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for (int candy: candies) &#123; set.add(candy); &#125; return Math.min(set.size(), candies.length / 2); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[557. Reverse Words in a String III]]></title>
    <url>%2F2017%2F06%2F21%2F2017-06-21-557-Reverse-Words-in-a-String-III%2F</url>
    <content type="text"><![CDATA[Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Example 1: Input: “Let’s take LeetCode contest”Output: “s’teL ekat edoCteeL tsetnoc” Note: In the string, each word is separated by single space and there will not be any extra space in the string. 解法1：用两个指针指向需要reverse的部分，再分别reverse。把string转化成char array之后比较好操作。char array到string可以用new string(a)来转化。C++1 Java12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123; public String reverseWords(String s) &#123; if (s == null || s.length() == 0) &#123; return s; &#125; int start = 0, end = 0; char[] ch = s.toCharArray(); while (end &lt; ch.length) &#123; if (ch[end] != ' ') &#123; end++; &#125; else &#123; // reverse substring from start to end reverse(ch, start, end - 1); while (end &lt; ch.length &amp;&amp; ch[end] == ' ') &#123; end++; &#125; start = end; &#125; &#125; reverse(ch, start, end - 1); return new String(ch); &#125; private void reverse(char[] ch, int start, int end) &#123; while (start &lt; end) &#123; char temp = ch[start]; ch[start] = ch[end]; ch[end] = temp; start++; end--; &#125; return; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[617. Merge Two Binary Trees]]></title>
    <url>%2F2017%2F06%2F21%2F2017-06-21-617-Merge-Two-Binary-Trees%2F</url>
    <content type="text"><![CDATA[Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree. Example 1:1234567891011121314Input: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 Output:Merged tree: 3 / \ 4 5 / \ \ 5 4 7 Note: The merging process must start from the root nodes of both trees. 解法1：Tree最常见的divide &amp; conquer思想，分成左右树。然后分别递归。C++1 Java1234567891011121314151617181920212223public class Solution &#123; public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123; if (t1 == null &amp;&amp; t2 == null) &#123; return null; &#125; TreeNode node = null; if (t2 == null) &#123; node = new TreeNode(t1.val); node.left = mergeTrees(t1.left, null); node.right = mergeTrees(t1.right, null); &#125; else if (t1 == null) &#123; node = new TreeNode(t2.val); node.left = mergeTrees(t2.left, null); node.right = mergeTrees(t2.right, null); &#125; else &#123; node = new TreeNode(t1.val + t2.val); node.left = mergeTrees(t1.left, t2.left); node.right = mergeTrees(t1.right, t2.right); &#125; return node; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[80. Remove Duplicates from Sorted Array II]]></title>
    <url>%2F2017%2F06%2F21%2F2017-06-21-80-Remove-Duplicates-from-Sorted-Array-II%2F</url>
    <content type="text"><![CDATA[Follow up for “Remove Duplicates”:What if duplicates are allowed at most twice? For example,Given sorted array nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn’t matter what you leave beyond the new length. 解法1：还是双指针。用一个慢指针p来记录下一个需要插入的位置。一开始快慢指针都在一起。然后比较快指针p所对应的元素与p-2所对应的元素。C++1 Java1234567891011121314151617181920212223public class Solution &#123; public int removeDuplicates(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; if (nums.length &lt;= 2) &#123; return nums.length; &#125; int p = 2, i = 2; while (i &lt; nums.length) &#123; if (nums[i] != nums[p - 2]) &#123; nums[p++] = nums[i]; &#125; i++; &#125; return p; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[289. Game of Life]]></title>
    <url>%2F2017%2F06%2F20%2F2017-06-20-289-Game-of-Life%2F</url>
    <content type="text"><![CDATA[According to the Wikipedia’s article: “The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.” Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article): Any live cell with fewer than two live neighbors dies, as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population.. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. Write a function to compute the next state (after one update) of the board given its current state. Follow up: Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells. In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems? 解法1：这题的关键点在于要想到用状态机来存储过去的历史。如果一位上仅用0,1表示的话，那么只能表示两个状态。如果我们用2 bits（也就是0,1,2,3）来表示的话可以表示4个状态。这里我们有0 -&gt; 0 : 01 -&gt; 1 : 11 -&gt; 0 : 20 -&gt; 1 : 3然后逐个扫描，根据规则update每一个元素。要注意的是判断live cell的时候要check两个数值，一个是1，一个是2。这个地方很容易错。最后我们对结果数组对2取对数就可以了。C++1 Java12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123; public void gameOfLife(int[][] board) &#123; if (board.length == 0 || board[0].length == 0) &#123; return; &#125; int m = board.length, n = board[0].length; // define directions int[][] directions = new int[][]&#123;&#123;0,-1&#125;,&#123;-1,-1&#125;,&#123;-1,0&#125;,&#123;-1,1&#125;,&#123;0,1&#125;,&#123;1,1&#125;,&#123;1,0&#125;,&#123;1,-1&#125;&#125;; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; int cnt = 0; for (int k = 0; k &lt; directions.length; k++) &#123; int row = i + directions[k][0]; int col = j + directions[k][1]; if (row &gt;= 0 &amp;&amp; row &lt; m &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; n &amp;&amp; (board[row][col] == 1 || board[row][col] == 2)) &#123; cnt++; &#125; &#125; if (board[i][j] == 1 &amp;&amp; (cnt &lt; 2 || cnt &gt; 3)) &#123; board[i][j] = 2; &#125; else if (board[i][j] == 0 &amp;&amp; cnt == 3) &#123; board[i][j] = 3; &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; board[i][j] %= 2; &#125; &#125; return; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>状态机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[229. Majority Element II]]></title>
    <url>%2F2017%2F06%2F20%2F2017-06-20-229-Majority-Element-II%2F</url>
    <content type="text"><![CDATA[Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space. 解法1：Moore Voting 算法的延伸。 和Majority Element I类似，这里用两个变量来维护当前出现次数较大的数字。对于第二个元素n2初始化为0是没关系的，因为他的计数器初始化为0。如果有数字和他一样的话计数器再加1。C++1 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; public List&lt;Integer&gt; majorityElement(int[] nums) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if (nums == null || nums.length == 0) &#123; return res; &#125; int n1 = nums[0], n2 = 0, c1 = 0, c2 = 0; for (int num : nums) &#123; if (num == n1) &#123; c1++; &#125; else if (num == n2) &#123; c2++; &#125; else if (c1 == 0) &#123; n1 = num; c1 = 1; &#125; else if (c2 == 0) &#123; n2 = num; c2 = 1; &#125; else &#123; c1--; c2--; &#125; &#125; c1 = 0; c2 = 0; for (int num : nums) &#123; if (num == n1) &#123; c1++; &#125; else if (num == n2) &#123; c2++; &#125; &#125; if (c1 &gt; nums.length / 3) &#123; res.add(n1); &#125; if (c2 &gt; nums.length / 3) &#123; res.add(n2); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[287. Find the Duplicate Number]]></title>
    <url>%2F2017%2F06%2F20%2F2017-06-20-287-Find-the-Duplicate-Number%2F</url>
    <content type="text"><![CDATA[Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Note: You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space. Your runtime complexity should be less than O(n2). There is only one duplicate number in the array, but it could be repeated more than once. 解法1：O(NlogN)这题是一个binary search的变形。题目给的条件显示能套用的常用算法应该只剩下binary search了。难点是怎么舍弃一半的空间。这里巧妙的用了这个特性：1 - n的数字的mid是（1+n)/2, 那么如果比mid小的数较多，说明重复的数在小半区。这样我们可以缩小范围。如果比mid小的数较少，那么重复的数就在大半区。计算出一个mid之后统计和mid大小的时候要遍历。C++1 Java123456789101112131415161718192021222324public class Solution &#123; public int findDuplicate(int[] nums) &#123; int left = 1, right = nums.length - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; // loop through nums int cnt = 0; for (int num : nums) &#123; if (num &lt;= mid) &#123; cnt++; &#125; &#125; if (cnt &gt; mid) &#123; right = mid; &#125; else &#123; left = mid + 1; &#125; &#125; return left; &#125;&#125; 解法2：O(N)龟兔赛跑的算法，和找闭环的入口的思路一样。这里用的是一个扩展了的算法。核心就是对于slow指针apply function一次，而对于fast指针apply function两次。具体的解释可以参考这个Java1234567891011121314151617181920212223242526public class Solution &#123; public int findDuplicate(int[] nums) &#123; int slow = 0, fast = 0; while (true) &#123; slow = nums[slow]; fast = nums[nums[fast]]; if (slow == fast) &#123; break; &#125; &#125; fast = 0; while (true) &#123; slow = nums[slow]; fast = nums[fast]; if (slow == fast) &#123; break; &#125; &#125; return slow; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Moore Voting</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[33. Search in Rotated Sorted Array]]></title>
    <url>%2F2017%2F06%2F20%2F2017-06-20-33-Search-in-Rotated-Sorted-Array%2F</url>
    <content type="text"><![CDATA[Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. 解法1：Binary Search的经典题。主要是要考虑怎么扔掉一半。C++1 Java12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public int search(int[] nums, int target) &#123; if (nums == null || nums.length == 0) &#123; return -1; &#125; int start = 0, end = nums.length - 1; while (start + 1 &lt; end) &#123; int mid = start + (end - start) / 2; if (nums[start] == nums[mid]) &#123; return mid; &#125; if (nums[start] &lt; nums[mid]) &#123; if (target &lt; nums[mid] &amp;&amp; target &gt;= nums[start]) &#123; end = mid; &#125; else &#123; start = mid; &#125; &#125; else &#123; if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end]) &#123; start = mid; &#125; else &#123; end = mid; &#125; &#125; &#125; if (nums[end] == target) &#123; return end; &#125; if (nums[start] == target) &#123; return start; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[228. Summary Ranges]]></title>
    <url>%2F2017%2F06%2F20%2F2017-06-20-228-Summary-Ranges%2F</url>
    <content type="text"><![CDATA[Given a sorted integer array without duplicates, return the summary of its ranges. For example, given [0,1,2,4,5,7], return [“0-&gt;2”,”4-&gt;5”,”7”]. 解法1：这题思路很简单，双指针。就是要写好写的没有bug不容易。用一个j记录end的距离，然后在push到结果的时候检查j是否为1，以此来判断是否是单数。C++1 Java123456789101112131415161718192021222324public class Solution &#123; public List&lt;String&gt; summaryRanges(int[] nums) &#123; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); if (nums == null || nums.length == 0) &#123; return res; &#125; int i = 0; int n = nums.length; while (i &lt; n) &#123; int j = 1; while (i + j &lt; n &amp;&amp; nums[i + j] - nums[i] == j) &#123; j++; &#125; String range = j == 1 ? Integer.toString(nums[i]) : Integer.toString(nums[i]) + "-&gt;" + Integer.toString(nums[i + j - 1]); res.add(range); i += j; &#125; return res; &#125;&#125; 重写了一个清楚点的版本lang: java1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;String&gt; summaryRanges(int[] nums) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); if (nums == null || nums.length == 0) &#123; return res; &#125; int start = 0; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] &gt; nums[i - 1] + 1) &#123; res.add(getRange(nums[start], nums[i - 1])); start = i; &#125; &#125; res.add(getRange(nums[start], nums[nums.length - 1])); return res; &#125; private String getRange(int start, int end) &#123; if (start == end) &#123; return Integer.toString(start); &#125; return Integer.toString(start) + &quot;-&gt;&quot; + Integer.toString(end); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[624. Maximum Distance in Arrays]]></title>
    <url>%2F2017%2F06%2F20%2F2017-06-20-624-Maximum-Distance-in-Arrays%2F</url>
    <content type="text"><![CDATA[Given m arrays, and each array is sorted in ascending order. Now you can pick up two integers from two different arrays (each array picks one) and calculate the distance. We define the distance between two integers a and b to be their absolute difference |a-b|. Your task is to find the maximum distance. Example 1:1234567Input:[[1,2,3],[4,5],[1,2,3]]Output: 4Explanation:One way to reach the maximum distance 4 is to pick 1 in the first or third array and pick 5 in the second array. Note: Each given array will have at least 1 number. There will be at least two non-empty arrays. The total number of the integers in all the m arrays will be in the range of [2, 10000]. The integers in the m arrays will be in the range of [-10000, 10000]. 解法1： O(NM)Maintain global min and max calculated from previous arrays and compare current min, max wrt to the global ones.Results should be in Max(res, abs(global_min - current_max)) and Max(res, abs(global_max - current_min))C++1 Java12345678910111213141516171819202122232425262728293031public class Solution &#123; public int maxDistance(List&lt;List&lt;Integer&gt;&gt; arrays) &#123; int res = Integer.MIN_VALUE; int amin = Integer.MAX_VALUE; int amax = Integer.MIN_VALUE; for (int i = 0; i &lt; arrays.get(0).size(); i++) &#123; amin = Math.min(amin, arrays.get(0).get(i)); amax = Math.max(amax, arrays.get(0).get(i)); &#125; for (int i = 1; i &lt; arrays.size(); i++) &#123; // get min and max from each array int cmin = Integer.MAX_VALUE; int cmax = Integer.MIN_VALUE; for (int j = 0; j &lt; arrays.get(i).size(); j++) &#123; cmin = Math.min(cmin, arrays.get(i).get(j)); cmax = Math.max(cmax, arrays.get(i).get(j)); res = Math.max(res, Math.abs(amin - cmax)); res = Math.max(res, Math.abs(amax - cmin)); &#125; amin = Math.min(cmin, amin); amax = Math.max(cmax, amax); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[219. Contains Duplicate II]]></title>
    <url>%2F2017%2F06%2F06%2F2017-06-06-219-Contains-Duplicate-II%2F</url>
    <content type="text"><![CDATA[Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. 解法1：O(N) Time + O(N) Space用一个HashMap来存储每一个number出现的位置。然后对于所有出现过两次以上的数字计算是否有满足的答案。Java123456789101112131415161718192021222324252627282930313233public class Solution &#123; public boolean containsNearbyDuplicate(int[] nums, int k) &#123; if (nums == null || nums.length == 0) &#123; return false; &#125; Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;Integer, List&lt;Integer&gt;&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; if (map.containsKey(nums[i])) &#123; map.get(nums[i]).add(i); &#125; else &#123; map.put(nums[i], new ArrayList&lt;Integer&gt;()); map.get(nums[i]).add(i); &#125; &#125; // traverse the HashMap for (int num : map.keySet()) &#123; if (map.get(num).size() &gt;= 2) &#123; List&lt;Integer&gt; indices = map.get(num); // traverse the list for (int i = 0; i &lt; indices.size() - 1; ++i) &#123; if (indices.get(i + 1) - indices.get(i) &lt;= k) &#123; return true; &#125; &#125; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[566. Reshape the Matrix]]></title>
    <url>%2F2017%2F06%2F06%2F2017-06-06-566-Reshape-the-Matrix%2F</url>
    <content type="text"><![CDATA[In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data. You’re given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively. The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were. If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix. Example 1:123456789Input: nums = [[1,2], [3,4]]r = 1, c = 4Output: [[1,2,3,4]]Explanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list. Example 2:12345678910Input: nums = [[1,2], [3,4]]r = 2, c = 4Output: [[1,2], [3,4]]Explanation:There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix. Note:The height and width of the given matrix is in range [1, 100].The given r and c are all positive.Show Company TagsShow Tags 解法1：O(MN)主要就是掌握一个二维数组的index对应的行列的求法。Java123456789101112131415161718192021222324252627public class Solution &#123; public int[][] matrixReshape(int[][] nums, int r, int c) &#123; if (nums == null || nums[0] == null) &#123; return null; &#125; int row = nums.length; int col = nums[0].length; // check for dimension match if (row * col != r * c) &#123; return nums; &#125; int[][] res = new int[r][c]; for (int i = 0; i &lt; r; ++i) &#123; for (int j = 0; j &lt; c; ++j) &#123; // calculate the original index int index = i * c + j; res[i][j] = nums[index / col][index % col]; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[581. Shortest Unsorted Continuous Subarray]]></title>
    <url>%2F2017%2F06%2F06%2F2017-06-06-581-Shortest-Unsorted-Continuous-Subarray%2F</url>
    <content type="text"><![CDATA[Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too. You need to find the shortest such subarray and output its length. Example 1:Input: [2, 6, 4, 8, 10, 9, 15]Output: 5Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.Note:Then length of the input array is in range [1, 10,000].The input array may contain duplicates, so ascending order here means &lt;=. 解法1：O(NlogN)这题的思路是从一个sorted过的array出发，然后再用两个指针从两端往里面找和sorted之后的结果不一样的位置。Java12345678910111213141516171819202122232425262728public class Solution &#123; public int findUnsortedSubarray(int[] nums) &#123; int[] sorted = nums.clone(); Arrays.sort(sorted); // two pointers from left and from right int len = 0; for (int i = 0; i &lt; nums.length; ++i) &#123; if (nums[i] == sorted[i]) &#123; len++; &#125; else &#123; break; &#125; &#125; for (int i = nums.length - 1; i &gt;= 0; --i) &#123; if (nums[i] == sorted[i]) &#123; len++; &#125; else &#123; break; &#125; &#125; return Math.max(0, nums.length - len); &#125;&#125; 解法2：O(N)这个解法是从discuss里看来的，照搬他的解释：123456789101112131415It turns out that the two boundary indices i and j can be found in linear time, if we take advantage of the following three properties:nums[0, i - 1] and nums[j + 1, n - 1] are both sorted.nums[i] != nums_sorted[i] and nums[j] != nums_sorted[j].nums[i - 1] &lt;= min and max &lt;= nums[j + 1], where min and max are the minimum and maximum values of subarray nums[i, j].The first and third properties guarantee that the subarray nums[0, i - 1] will be exactly the same as subarray nums_sorted[0, i - 1], and the subarray nums[j + 1, n - 1] exactly the same as nums_sorted[j + 1, n - 1], while the second property ensures that i will be the first index at which the two elements of nums and nums_sorted are different and j be the last such index.Since we aim at the shortest subarrays, from the first property alone, we need to find the two longest sorted subarrays starting at index 0 and ending at index n - 1, respectively. Assume the two subarrays are nums[0, l] and nums[r, n - 1]. If there is overlapping between these two subarrays, i.e.l &gt;= r, then the whole array is sorted so 0 will be returned. Otherwise, the input array is not sorted. However, we cannot say sorting nums[l, r] will leave the whole array sorted, because at this moment the third property may not be satisfied.To guarantee the third property, assume min and max are the minimum and maximum values of subarray nums[l, r], then we need to decrease l as long as nums[l] &gt; min, and increase r as long as nums[r] &lt; max. After this is done, it can be shown that the second property will be met automatically, and nums[l + 1, r - 1] will be the shortest subarray we are looking for (that is, i = l + 1 and j = r - 1).Finding the longest subarrays and the maximum and minimum values of the middle subarray takes one-pass. Ensuring the third property requires a second pass. Therefore we have this two-pass solution: 12345678910111213141516171819public int findUnsortedSubarray(int[] nums) &#123; int l = 0, r = nums.length - 1, max = Integer.MIN_VALUE, min = Integer.MAX_VALUE; while (l &lt; r &amp;&amp; nums[l] &lt;= nums[l + 1]) l++; if (l &gt;= r) return 0; while (nums[r] &gt;= nums[r - 1]) r--; for (int k = l; k &lt;= r; k++) &#123; max = Math.max(max, nums[k]); min = Math.min(min, nums[k]); &#125; while (l &gt;= 0 &amp;&amp; min &lt; nums[l]) l--; while (r &lt; nums.length &amp;&amp; nums[r] &lt; max) r++; return (r - l - 1);&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Array Partition I (561)]]></title>
    <url>%2F2017%2F06%2F06%2F2017-06-06-leetcode-solution-Array-Partition-I-561%2F</url>
    <content type="text"><![CDATA[Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. Example 1:1234Input: [1,4,3,2]Output: 4Explanation: n is 2, and the maximum sum of pairs is 4. Note:n is a positive integer, which is in the range of [1, 10000].All the integers in the array will be in the range of [-10000, 10000]. 解法1：这题其实是一个数学题，先排序之后每两个组成一组的话选出的最小值的和是最大的。Java123456789101112public class Solution &#123; public int arrayPairSum(int[] nums) &#123; Arrays.sort(nums); int sum = 0; for (int i = 0; i &lt;nums.length; i = i + 2) &#123; sum += nums[i]; &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Can Place Flowers (605)]]></title>
    <url>%2F2017%2F06%2F06%2F2017-06-06-leetcode-solutions-Can-Place-Flowers-605%2F</url>
    <content type="text"><![CDATA[Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die. Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule. Example 1:12Input: flowerbed = [1,0,0,0,1], n = 1Output: True Example 2:12Input: flowerbed = [1,0,0,0,1], n = 2Output: False Note:The input array won’t violate no-adjacent-flowers rule.The input array size is in the range of [1, 20000].n is a non-negative integer which won’t exceed the input array size. 解法1：Java12345678910111213141516171819202122232425262728293031public class Solution &#123; public boolean canPlaceFlowers(int[] flowerbed, int n) &#123; if (flowerbed == null || flowerbed.length == 0) &#123; return false; &#125; // traverse from left to right int i = 0; int size = flowerbed.length; while (n &gt; 0) &#123; if (i &lt; size &amp;&amp; flowerbed[i] == 1) &#123; i += 2; &#125; else if (i &gt;= size) &#123; break; &#125; else &#123; // check left &amp; right if ((i == 0 || flowerbed[i - 1] == 0) &amp;&amp; (i == size - 1 || flowerbed[i + 1] == 0)) &#123; flowerbed[i] = 1; n--; i += 2; &#125; else &#123; i += 1; &#125; &#125; &#125; return n == 0; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Spiral Matrix II (59)]]></title>
    <url>%2F2017%2F06%2F06%2F2017-06-06-leetcode-solution-Spiral-Matrix-II-59%2F</url>
    <content type="text"><![CDATA[Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. For example,Given n = 3, You should return the following matrix:12345[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 解法1：Java123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; public int[][] generateMatrix(int n) &#123; int level = (n + 1) / 2; int[][] res = new int[n][n]; // fill by level int num = 1; for (int i = 0; i &lt; level; ++i) &#123; int lastrow = n - i - 1; int lastcol = n - i - 1; // move right for (int j = i; j &lt;= lastcol; ++j) &#123; res[i][j] = num; num++; &#125; // move down for (int j = i + 1; j &lt;= lastrow; ++j) &#123; res[j][lastcol] = num; num++; &#125; // move left for (int j = lastcol - 1; j &gt;= i; --j) &#123; res[lastrow][j] = num; num++; &#125; // move up for (int j = lastrow - 1; j &gt; i; --j) &#123; res[j][i] = num; num++; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode solution: Sort Characters By Frequency (451)]]></title>
    <url>%2F2017%2F04%2F20%2F2017-04-20-leetcode-solution-Sort-Characters-By-Frequency-451%2F</url>
    <content type="text"><![CDATA[Given a string, sort it in decreasing order based on the frequency of characters. Example 1:123456789Input:&quot;tree&quot;Output:&quot;eert&quot;Explanation:&apos;e&apos; appears twice while &apos;r&apos; and &apos;t&apos; both appear once.So &apos;e&apos; must appear before both &apos;r&apos; and &apos;t&apos;. Therefore &quot;eetr&quot; is also a valid answer. Example 2:123456789Input:&quot;cccaaa&quot;Output:&quot;cccaaa&quot;Explanation:Both &apos;c&apos; and &apos;a&apos; appear three times, so &quot;aaaccc&quot; is also a valid answer.Note that &quot;cacaca&quot; is incorrect, as the same characters must be together. Example 3:123456789Input:&quot;Aabb&quot;Output:&quot;bbAa&quot;Explanation:&quot;bbaA&quot; is also a valid answer, but &quot;Aabb&quot; is incorrect.Note that &apos;A&apos; and &apos;a&apos; are treated as two different characters. 解法1：Java12345678910111213141516171819202122232425262728public class Solution &#123; public String frequencySort(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;Character,Integer&gt;(); for (char c: s.toCharArray()) &#123; map.put(c, map.getOrDefault(c,0) + 1); &#125; List&lt;Map.Entry&lt;Character, Integer&gt;&gt; list = new ArrayList&lt;&gt;(map.entrySet()); Comparator&lt;Map.Entry&lt;Character,Integer&gt;&gt; comparator = new Comparator&lt;Map.Entry&lt;Character, Integer&gt;&gt;() &#123; public int compare(Map.Entry&lt;Character, Integer&gt; left, Map.Entry&lt;Character, Integer&gt; right) &#123; return right.getValue().compareTo(left.getValue()); &#125; &#125;; list.sort(comparator); // Create String StringBuffer ss = new StringBuffer(); for (Map.Entry&lt;Character, Integer&gt; entry : list) &#123; for (int i = 0; i &lt; entry.getValue(); ++i) &#123; ss.append(entry.getKey()); &#125; &#125; return ss.toString(); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Search a 2D Matrix (74)]]></title>
    <url>%2F2017%2F04%2F08%2F2017-04-08-leetcode-solution-Search-a-2D-Matrix-74%2F</url>
    <content type="text"><![CDATA[Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right.The first integer of each row is greater than the last integer of the previous row.For example, Consider the following matrix: [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]Given target = 3, return true. 解法1：Binary Search O(logMN) MN = total # of elementsJava1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode解题: Merge Intervals (56)]]></title>
    <url>%2F2017%2F04%2F08%2F2017-04-08-Leetcode-solution-Merge-Intervals-56%2F</url>
    <content type="text"><![CDATA[Given a collection of intervals, merge all overlapping intervals. For example,Given [1,3],[2,6],[8,10],[15,18],return [1,6],[8,10],[15,18]. 解法1：O(NlogN) Time先排序之后再合并比较简单。只要检查后面的start是否比前面的end小就可以了。 Java主要是锻炼一下Java中用Collections.sort(list, comparator)的用法。1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for an interval. * public class Interval &#123; * int start; * int end; * Interval() &#123; start = 0; end = 0; &#125; * Interval(int s, int e) &#123; start = s; end = e; &#125; * &#125; */public class Solution &#123; public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; if (intervals == null || intervals.size() == 0) &#123; return intervals; &#125; Comparator&lt;Interval&gt; comparator = new Comparator&lt;Interval&gt;() &#123; public int compare(Interval left, Interval right) &#123; return left.start - right.start; &#125; &#125;; // Sort the interval based on the start Collections.sort(intervals, comparator); List&lt;Interval&gt; res = new ArrayList&lt;Interval&gt;(); res.add(intervals.get(0)); for (int i = 1; i &lt; intervals.size(); ++i) &#123; Interval current = intervals.get(i); Interval previous = res.get(res.size() - 1); if (current.start &lt;= previous.end) &#123; previous.end = Math.max(current.end, previous.end); &#125; else &#123; res.add(current); &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Integer to Roman (12)]]></title>
    <url>%2F2017%2F04%2F08%2F2017-04-08-leetcode-solution-Integer-to-Roman-12%2F</url>
    <content type="text"><![CDATA[Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. 解法1：主要的思路是要先构造出来罗马数字中的“根”数。也就是说，除了那么1,5,10,50,100,500,1000的数字，还有那些需要特殊处理的，比如40.然后得算法就简单了，就遍历一遍dict， 每当找出来一个比当前base小的数就计算出需要重复几遍，比如III。然后更新base数值。Java123456789101112131415161718192021222324public class Solution &#123; public String intToRoman(int n) &#123; // Write your code here String dict[] = new String[]&#123;"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"&#125;; int base[] = new int[]&#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;; String res = ""; for (int i = 0; i &lt; dict.length; i++) &#123; if (n &gt;= base[i]) &#123; int count = n / base[i]; n = n % base[i]; for (int j = 0; j &lt; count; j++) &#123; res += dict[i]; &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: String to Integer (8)]]></title>
    <url>%2F2017%2F04%2F08%2F2017-04-08-leetcode-solution-String-to-Integer-8%2F</url>
    <content type="text"><![CDATA[Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. 解法1：这题要考虑的corner case比较多，也是这题的难点。corner case有：empty stringstring with spacestring with positive or negative signstring with non-digit numbersoverflow integer对于overflow的处理有两种情况。一个是当前的total乘以10之后超过Integer.MAX_VALUE，由于不能直接比total * 10 &gt; Integer.MAX_VALUE, 我们可以换一种比法。用Integer.MAX_VALUE / 10 &lt; total 表示判断标准。但是这又有一种情况就是Integer.MAX_VALUE / 10 是整数除法，可能会有遗漏的情况是最后一位不同。那么就需要排除Integer.MAX_VALUE / 10 == total &amp;&amp; Integer.MAX_VALUE % 10 &lt; digit 的情况。Java12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public int myAtoi(String str) &#123; if (str == null || str.isEmpty() || str.trim().isEmpty()) &#123; return 0; &#125; str = str.trim(); boolean isNegative = false; if (str.charAt(0) == '-') &#123; isNegative = true; str = str.substring(1); &#125; else if (str.charAt(0) == '+') &#123; str = str.substring(1); &#125; // check if all characters are digits int total = 0; for (int i = 0; i &lt; str.length(); ++i) &#123; char ch = str.charAt(i); if (ch &lt; '0' || ch &gt;'9') &#123; break; &#125; int digit = ch - '0'; if (Integer.MAX_VALUE/10 &lt; total || (Integer.MAX_VALUE/10 == total &amp;&amp; Integer.MAX_VALUE % 10 &lt; digit)) &#123; return isNegative ? Integer.MIN_VALUE : Integer.MAX_VALUE; &#125; total = total * 10 + digit; &#125; return isNegative ? (-1) * total : total; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[random interviews: identify the heavy ball]]></title>
    <url>%2F2017%2F04%2F08%2F2017-04-08-random-interviews-identify-the-heavy-ball%2F</url>
    <content type="text"><![CDATA[Given an array with 100 balls (each ball is to be imagined as an element in the array). 99 are of same weight only 1 is not. Identify the ball. 解法1：Java1]]></content>
      <categories>
        <category>面经题</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[random interviews: shortest path in a matrix]]></title>
    <url>%2F2017%2F04%2F08%2F2017-04-08-random-interviews-shortest-path-in-a-matrix%2F</url>
    <content type="text"><![CDATA[The task was to find the shortest path between x1,y1 and x2,y2 in a maze. You can move horizontally and vertically, where 1 is a wall and 0 is free space. output is k shortest steps to move from the start point to end point. 解法1：BFS典型的BFS题目，用一个queue来解决。同时标记每一个已经visit过的元素的parent123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Java&#123;% codeblock lang:java %&#125;public List&lt;List&lt;Integer&gt;&gt; shortestPath(int[][] maze, int[] start, int[] end) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (maze == null || maze.length == 0 || maze[0].length == 0) &#123; return res; &#125; if (start[0] == end[0] &amp;&amp; start[1] == end[1]) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(Arrays.asList(start)); res.add(temp); return res; &#125; int row = maze.length; int col = maze[0].length; // Use a map to store each point&apos;s shortest parent from the start point Map&lt;List&lt;Integer&gt;, List&lt;Integer&gt;&gt; map = new HashMap&lt;List&lt;Integer&gt;, List&lt;Integer&gt;&gt;(); int[][] directions = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;; List&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(Arrays.asList(start)); map.put(temp, null); Queue&lt;List&lt;Integer&gt;&gt; queue = new LinkedList&lt;List&lt;Integer&gt;&gt;(); queue.offer(temp); maze[start[0]][start[1]] = -1; while(!queue.isEmpty()) &#123; int size = queue.size(); for (int i = 0; i &lt; size; ++i) &#123; List&lt;Integer&gt; cur = queue.poll(); for (int j = 0; j &lt; directions.length; ++j) &#123; int x = cur.get(0) + directions[j][0]; int y = cur.get(1) + directions[j][1]; if (x &gt;= 0 &amp;&amp; x &lt; row &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; col &amp;&amp; maze[x][j] != -1) &#123; ArrayList&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(Arrays.asList(x,y)); if (x == end[0] &amp;&amp; y == end[1]) &#123; // find the destination res = getPath(map, temp); return res; &#125; queue.offer(temp); map.put(temp, cur); maze[x][y] = -1; // mark as visited &#125; &#125; &#125; &#125; return res;&#125;private List&lt;List&lt;Integer&gt;&gt; getPath(HashMap&lt;List&lt;Integer&gt;, List&lt;Integer&gt;&gt; map, List&lt;Integer&gt; end) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; cur = end; while(map.get(cur) != null) &#123; res.add(cur); cur = map.get(cur); &#125; return res;&#125;&#123;% endcodeblock %&#125;]]></content>
      <categories>
        <category>面经题</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>Amazon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[random interviews: create a file system]]></title>
    <url>%2F2017%2F04%2F08%2F2017-04-08-random-interviews-create-a-file-system%2F</url>
    <content type="text"><![CDATA[Design a file system. Write code for file, directory and all necessary classes. 解法1：这下面的解法来源于这个career cup上的回答A file system can be represented with a Tree data structure. We can have one class called file (a directory is also a file). This class can track its current directory, its parent directory and files in this directory (in case this file is a special file called directory). Then we can create a class to manage file system which is manipulating the nodes of the tree. Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package filesystem;import java.util.ArrayList;import java.util.Date;public class FileSystem &#123; public class file &#123; private String name; private long size; private Date timeStamp; private file currentDir; private file parentDir; // a directory is also a file containing reference to other files private boolean isDirectory; public ArrayList&lt;file&gt; subfiles; // Advanced class members if required private boolean[] permissions; private String owner; private String group; public file(String name, file currentDir, boolean isDir) &#123; this.name = name; this.currentDir = currentDir; this.timeStamp = new Date(); this.isDirectory = isDir; this.size = 0; // initial size this.parentDir = currentDir.getParentDirectory(); if (isDir == true) this.subfiles = new ArrayList&lt;file&gt;(); &#125; public void updateTimeStamp() &#123; this.timeStamp = new Date(); &#125; public file getParentDirectory() &#123; return this.parentDir; &#125; public void rename(String name) &#123; this.name = name; &#125; &#125; private file root; // root folder public FileSystem() &#123; // every file system should have a root folder this.root = new file("root", null, true); &#125; public void createFile(String name, file curDir, boolean isDir) &#123; file f = new file(name, curDir, isDir); curDir.subfiles.add(f); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[random interviews: k closest neighbors]]></title>
    <url>%2F2017%2F04%2F08%2F2017-04-08-random-interviews-k-closest-neighbors%2F</url>
    <content type="text"><![CDATA[Given a set of points in a cartesian plane, and a start point , find the k closest points to the starting point. Points = [(1,2),(2,3),(4,6),(7,9)]Start Point = (2,2) Find 2 closest points to start point这题要考虑的corner case比较多，也是这题的难点。corner case有：empty stringstring with spacestring with positive or negative signstring with non-digit numbersoverflow integer对于overflow的处理有两种情况。一个是当前的total乘以10之后超过Integer.MAX_VALUE，由于不能直接比total * 10 &gt; Integer.MAX_VALUE, 我们可以换一种比法。用Integer.MAX_VALUE / 10 &lt; total 表示判断标准。但是这又有一种情况就是Integer.MAX_VALUE / 10 是整数除法，可能会有遗漏的情况是最后一位不同。那么就需要排除Integer.MAX_VALUE / 10 == total &amp;&amp; Integer.MAX_VALUE % 10 &lt; digit 的情况。 解法1：Priority Queue, O(NlogK)最容易想的就是用一个size为k的heap来存储每一个点。如果还没存满k个就直接存入。如果存满了每当下一个点到p的距离比top的小的时候在把top弹出。Java12345678910111213141516171819202122232425262728293031public List&lt;Point&gt; closestNeighbors(Point[] points, Point center) &#123; Comparator&lt;Point&gt; comparator = new Comparator&lt;Point&gt;() &#123; public int compare(Point left, Point right) &#123; return distance(right, center) - distance(left, center); &#125; &#125;; PriorityQueue&lt;Point&gt; queue = new PriorityQueue&lt;Point&gt;(comparator); for (Point p : points) &#123; if (queue.size() &lt; k) &#123; queue.offer(p); &#125; else &#123; if (distance(p, center) &lt; queue.peek()) &#123; queue.poll(); queue.offer(p); &#125; &#125; &#125; List&lt;Point&gt; res = new ArrayList&lt;Point&gt;(); while (!queue.isEmpty()) &#123; res.offer(queue.poll()); &#125; return res;&#125;private int distance(Point a, Point b) &#123; return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);&#125; 解法2： Quick Select, O(N)一般面试给出上面的解法就可以了。如果面试官喜欢刁难的话可能是需要这个解法。思路和find median有点类似，就是先用quick select找出到center距离为第k大的point.然后再扫描一遍数组得到所有小于那个距离的点即可。code有空的时候再来补上吧。。Javalang: java1]]></content>
      <categories>
        <category>面经题</category>
      </categories>
      <tags>
        <tag>PriorityQueue</tag>
        <tag>Amazon</tag>
        <tag>Selection Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Largest Rectangle in Histogram (84)]]></title>
    <url>%2F2017%2F04%2F08%2F2017-04-08-leetcode-solution-Largest-Rectangle-in-Histogram-84%2F</url>
    <content type="text"><![CDATA[Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area = 10 unit. For example,Given heights = [2,1,5,6,2,3],return 10. 解法1：Stack O(N)这题的思路比较巧妙。一般的思路计算面积，办法是先找出左右的边界，然后找出高度。那么这种算法的复杂度是O(N^3)的。如果我们换一个思路，枚举高度而不是枚举边界。那么对于任意一个高度的bar，我们只需要找出来他左面第一个比它矮的和右边第一个比它矮的bar就能算出来对应的使用这个bar作为最高高度的面积了。那么这里需要记录左面的已经遍历过的高度。如果说我们维护一个递增的stack，每一个栈顶元素他对应的左面的比他小的bar的位置就确定了。如果碰到右面比他矮的bar，那么我们就可以计算出当前栈顶的bar对应的面积。stack中存上index而不是高度方便计算面积并且要注意计算到最后一个bar之后要清理stack中还存在的barJava123456789101112131415161718192021222324252627282930313233public class Solution &#123; public int largestRectangleArea(int[] heights) &#123; if (heights == null || heights.length == 0) &#123; return 0; &#125; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); int max = Integer.MIN_VALUE; stack.push(0); for (int i = 1; i &lt; heights.length; ++i) &#123; int current = heights[i]; while (!stack.isEmpty() &amp;&amp; current &lt; heights[stack.peek()]) &#123; int bar = heights[stack.pop()]; int left = stack.isEmpty()? -1 : stack.peek(); max = Math.max(bar * (i - left - 1), max); &#125; stack.push(i); &#125; while (!stack.isEmpty()) &#123; int bar = heights[stack.pop()]; while (!stack.isEmpty() &amp;&amp; heights[stack.peek()] == bar) &#123; stack.pop(); &#125; int left = stack.isEmpty() ? -1 : stack.peek(); max = Math.max(max, bar * (heights.length - left - 1)); &#125; return max; &#125;&#125; 另一种写法较为简单。诀窍是在数组的最后放一个0，这样可以保证清空stack中的值。123456789101112131415161718192021222324252627public class Solution &#123; public int largestRectangleArea(int[] heights) &#123; if (heights == null || heights.length == 0) &#123; return 0; &#125; int res = 0; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); int[] h = Arrays.copyOf(heights, heights.length + 1); // padding zero at the end for (int i = 0; i &lt; h.length; ++i) &#123; int bar = h[i]; while (!stack.empty() &amp;&amp; bar &lt; h[stack.peek()]) &#123; int last = h[stack.pop()]; // calculate the width int width = stack.empty() ? i : i - stack.peek() - 1; res = Math.max(res, width * last); &#125; stack.push(i); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Amazon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[random interviews: check if a piece is valid in a go game]]></title>
    <url>%2F2017%2F04%2F07%2F2017-04-07-random-interviews-check-if-a-piece-is-valid-in-a-go-game%2F</url>
    <content type="text"><![CDATA[Given a go board, check if a piece is alive or not. 123XXXX0XXXX is not alive 123XXXX0 XXXXX is still alive Assume your piece is marked as 1, enemy’s pieces are marked as -1. Empty space is marked as 0. 解法1：DFSJava12345678910111213public bool isAlive(int[][] board, int i, int j) &#123; // Mark visited nodes as Integer.MAX_VALUE; if (i &lt; 0 || i &gt;= board.length || j &lt; 0 || j &gt;= board[0].length || board[i][j] == -1 || board[i][j] == Integer.MAX_VALUE) &#123; return false; &#125; if (board[i][j] == 0) &#123; return true; &#125; board[i][j] = Integer.MAX_VALUE; return isAlive(board, i + 1, j) || isAlive(board, i - 1, j) || isAlive(board, i, j + 1) || isAlive(board, i, j - 1);&#125;]]></content>
      <categories>
        <category>面经题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Most Frequent Subtree Sum (508)]]></title>
    <url>%2F2017%2F04%2F07%2F2017-04-07-leetcode-solution-Most-Frequent-Subtree-Sum-508%2F</url>
    <content type="text"><![CDATA[Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order. Examples 1Input: 5 / \2 -3return [2, -3, 4], since all the values happen only once, return all of them in any order.Examples 2Input: 5 / \2 -5return [2], since 2 happens twice, however -5 only occur once.Note: You may assume the sum of values in any subtree is in the range of 32-bit signed integer. 解法1：Tree traversal + HashMap O(N)计算每一个节点的sum很方便，就是leftsum + rightsum。然后用一个hashmap维护每一个sum的出现的频率。最后统计最大频率的key。下面的解法我用了排序，实际上不需要排序。只需要遍历两遍，一遍找出最大频率，第二部就是找出所有频率为max的key就可以了。Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public int[] findFrequentTreeSum(TreeNode root) &#123; if (root == null) &#123; return new int[0]; &#125; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); helper(root, map); // Sort map entry based on the frequency Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; comparator = new Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() &#123; public int compare(Map.Entry&lt;Integer, Integer&gt; left, Map.Entry&lt;Integer, Integer&gt; right) &#123; return right.getValue().compareTo(left.getValue()); &#125; &#125;; List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; res = new ArrayList&lt;Map.Entry&lt;Integer, Integer&gt;&gt;(); for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; res.add(entry); &#125; res.sort(comparator); // Sort by frequency in decreasing order int maxFreq = res.get(0).getValue(); List&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt; res.size(); ++i) &#123; if (res.get(i).getValue() == maxFreq) &#123; temp.add(res.get(i).getKey()); &#125; &#125; int[] resArray = new int[temp.size()]; for (int i = 0; i &lt; temp.size(); ++i) &#123; resArray[i] = temp.get(i); &#125; return resArray; &#125; private int helper(TreeNode root, Map&lt;Integer, Integer&gt; freqMap) &#123; if (root == null) &#123; return 0; &#125; int left = helper(root.left, freqMap); int right = helper(root.right, freqMap); int sum = left + right + root.val; freqMap.put(sum, freqMap.getOrDefault(sum, 0) + 1); return sum; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Amazon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Sliding Window Maximum (239)]]></title>
    <url>%2F2017%2F04%2F07%2F2017-04-07-leetcode-solution-Sliding-Window-Maximum-239%2F</url>
    <content type="text"><![CDATA[Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. For example,Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.12345678Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Therefore, return the max sliding window as [3,3,5,5,6,7]. Note:You may assume k is always valid, ie: 1 ≤ k ≤ input array’s size for non-empty array. Follow up:Could you solve it in linear time? Hint: How about using a data structure such as deque (double-ended queue)?The queue size need not be the same as the window’s size.Remove redundant elements and the queue should store only elements that need to be considered 解法1：Heap这题用Heap来解的话比较直观，维护一个k大小的priorityqueue。这里有一个用法是可以用Collections.reverseOrder()来生成一个comparator。但是复杂度感觉不太清楚。remove的复杂度是O(k), insert的复杂度是O(logk),感觉整体的复杂度应该是O(NK)，而有些地方说是O(NlogK). Java123456789101112131415161718192021222324public class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; if (nums == null || nums.length == 0) &#123; return new int[0]; &#125; PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;Integer&gt;(Collections.reverseOrder()); int[] res = new int[nums.length - k + 1]; for (int i = 0; i &lt; nums.length; ++i) &#123; if (queue.size() &gt;= k) &#123; queue.remove(nums[i - k]); &#125; queue.offer(nums[i]); if (i + 1 &gt;= k) &#123; res[i - k + 1] = queue.peek(); &#125; &#125; return res; &#125;&#125; 解法2: double linked list (deque), O(N)基本思路是维护一个deque，这个deque的head就存着当前window中的最大值。那么要维护这么一个数据结构，就要求我们在每一次insert的时候要把所有小于他的数都弹出去。同时，要维护窗口，需要加入一个的同时也弹出最左边的元素。由于我们在insert的时候有可能已经把需要弹出的元素弹出了，那么就先用一个if语句来判断是否head是一个需要被弹出的元素。复杂度的分析是基于，每一个元素只可能被弹出和访问一次。所以是O(N)Java1234567891011121314151617181920212223242526public class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; if (nums.length == 0) &#123; return new int[0]; &#125; LinkedList&lt;Integer&gt; deque = new LinkedList&lt;Integer&gt;(); int[] res = new int[nums.length - k + 1]; for (int i = 0; i &lt; nums.length; ++i) &#123; if (!deque.isEmpty() &amp;&amp; deque.peekFirst() == i - k) &#123; deque.removeFirst(); &#125; while (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123; deque.removeLast(); &#125; deque.offer(i); if (i + 1 &gt;= k) &#123; res[i - k + 1] = nums[deque.peekFirst()]; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Amazon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Serialize and Deserialize BST (449)]]></title>
    <url>%2F2017%2F03%2F30%2F2017-03-30-leetcode-solution-Serialize-and-Deserialize-BST-449%2F</url>
    <content type="text"><![CDATA[Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure. The encoded string should be as compact as possible. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless. 解法1：Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Rotate Function (396)]]></title>
    <url>%2F2017%2F03%2F30%2F2017-03-30-leetcode-solution-Rotate-Function-396%2F</url>
    <content type="text"><![CDATA[Given an array of integers A and let n to be its length. Assume Bk to be an array obtained by rotating the array A k positions clock-wise, we define a “rotation function” F on A as follow: F(k) = 0 Bk[0] + 1 Bk[1] + … + (n-1) * Bk[n-1]. Calculate the maximum value of F(0), F(1), …, F(n-1). Note:n is guaranteed to be less than 105. Example:12345678A = [4, 3, 2, 6]F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26. 解法1：找规律 O(N) Time + O(1) Space这题用找规律的办法，找规律的时候把数字简化成A,B,C,D.f(0) = 0A + 1B + 2C + 3Df(1) = 0D + 1A + 2B + 3Cf(2) = OC + 1D + 2A + 3B 在考虑一个sum = 1A + 1B + 1C + 1D那么可以得到f(1) = f(0) + sum - 4Df(2) = f(1) + sum - 4C…于是一个O(N)的解法就出来了Java12345678910111213141516171819202122public class Solution &#123; public int maxRotateFunction(int[] A) &#123; if (A == null || A.length == 0) &#123; return 0; &#125; int f = 0; int sum = 0; for (int i = 0; i &lt; A.length; ++i) &#123; f += i * A[i]; sum += A[i]; &#125; int res = f; // f(0) for (int i = 1; i &lt; A.length; ++i) &#123; f = f + sum - A.length * A[A.length - i]; res = Math.max(res, f); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Boundary of Binary Tree (545)]]></title>
    <url>%2F2017%2F03%2F30%2F2017-03-30-leetcode-solution-Boundary-of-Binary-Tree-545%2F</url>
    <content type="text"><![CDATA[Given a binary tree, return the values of its boundary in anti-clockwise direction starting from root. Boundary includes left boundary, leaves, and right boundary in order without duplicate nodes. Left boundary is defined as the path from root to the left-most node. Right boundary is defined as the path from root to the right-most node. If the root doesn’t have left subtree or right subtree, then the root itself is left boundary or right boundary. Note this definition only applies to the input binary tree, and not applies to any subtrees. The left-most node is defined as a leaf node you could reach when you always firstly travel to the left subtree if exists. If not, travel to the right subtree. Repeat until you reach a leaf node. The right-most node is also defined by the same way with left and right exchanged. Example 1123456789101112131415Input: 1 \ 2 / \ 3 4Ouput:[1, 3, 4, 2]Explanation:The root doesn&apos;t have left subtree, so the root itself is left boundary.The leaves are node 3 and 4.The right boundary are node 1,2,4. Note the anti-clockwise direction means you should output reversed right boundary.So order them in anti-clockwise without duplicates and we have [1,3,4,2]. Example 21234567891011121314151617Input: ____1_____ / \ 2 3 / \ / 4 5 6 / \ / \ 7 8 9 10 Ouput:[1,2,4,7,8,9,10,6,3]Explanation:The left boundary are node 1,2,4. (4 is the left-most node according to definition)The leaves are node 4,7,8,9,10.The right boundary are node 1,3,6,10. (10 is the right-most node).So order them in anti-clockwise without duplicate nodes we have [1,2,4,7,8,9,10,6,3]. 解法1：参考了这篇的解法。对于leaf我们可以用dfs来解决。似乎还需要两个function分别来存储left path和right path。那么在找寻left path的过程中，我们一直向左，如果碰到左面的节点就属于left path，如果还有右节点那么就用dfs搜索leaf。对于right path也是一个原理。对于rightPath函数的写法，要注意对于每一个节点，要先得出leaf node，再得出right node。因为题目要求是逆时针Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public List&lt;Integer&gt; boundaryOfBinaryTree(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if (root == null) &#123; return res; &#125; res.add(root.val); leftPath(root.left, res); rightPath(root.right, res); return res; &#125; private void leftPath(TreeNode root, List&lt;Integer&gt; res) &#123; if (root != null) &#123; res.add(root.val); if (root.left != null) &#123; leftPath(root.left, res); dfs(root.right,res); &#125; else &#123; leftPath(root.right, res); &#125; &#125; &#125; private void rightPath(TreeNode root, List&lt;Integer&gt; res) &#123; if (root != null) &#123; if (root.right != null) &#123; dfs(root.left, res); // 这里的顺序要注意 rightPath(root.right, res); &#125; else &#123; rightPath(root.left, res); &#125; res.add(root.val); &#125; &#125; private void dfs(TreeNode root, List&lt;Integer&gt; res) &#123; if (root == null) &#123; return; &#125; if (root.left == null &amp;&amp; root.right == null) &#123; res.add(root.val); return; &#125; dfs(root.left, res); dfs(root.right, res); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Trapping Rain Water (42)]]></title>
    <url>%2F2017%2F03%2F29%2F2017-03-29-leetcode-solution-Trapping-Rain-Water-42%2F</url>
    <content type="text"><![CDATA[Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. For example,Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! 解法1: 两遍扫描 O(N) Time O(N) Space这题和Product of Array except itself有点类似。对于每一个bar，顶端是否能储水取决于左面和右面是否有比它高的bar，假设有而且较低的bar的高度是h，那么对于现在这个bar能储水的量就是h-height。由此我们可以得出一个思路：对于每一个bar，计算出左边和右边的最高的bar。在计算右面的bar的时候，我们不必要维护一个新的数组，而是用一个变量就可以了。Java12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; /** * @param heights: an array of integers * @return: a integer */ public int trapRainWater(int[] heights) &#123; // write your code here if (heights == null || heights.length == 0) &#123; return 0; &#125; int n = heights.length; if (n &lt; 3) &#123; return 0; &#125; int[] leftHeight = new int[heights.length]; for (int i =1; i &lt; n; i++) &#123; leftHeight[i] = Math.max(leftHeight[i - 1], heights[i - 1]); &#125; int rightHeight = 0; int sum = 0; for (int i = n - 2; i &gt;= 0; i--) &#123; rightHeight = Math.max(rightHeight, heights[i + 1]); sum += Math.max(0, Math.min(leftHeight[i], rightHeight) - heights[i]); &#125; return sum; &#125;&#125; 解法2：Stack, O(N) Time O(N) Space这题也可以用stack来做。但感觉stack比较容易错。stack的思路是，要存水必须有一个凹槽。那么我们用stack维护一个递减的数列，遇到比现在的top的数更大的时候就知道有水可以存储了。当前的top即是凹槽的底，弹出top之后如果还不是空，则继续比较top和当前的bar的高度，如果当前bar还高，那么存储的水就是top - bottom 乘上距离。这里有一个地方容易错就是，如果当前的height不比top高，那么这个时候也要存储结果。Java12345678910111213141516171819202122232425262728293031323334public class Solution &#123; public int trap(int[] height) &#123; if (height == null || height.length == 0) &#123; return 0; &#125; if (height.length &lt; 3) &#123; return 0; &#125; // Stack stores the index of a element in the array Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); stack.push(0); int res = 0; for (int i = 1; i &lt; height.length; ++i) &#123; if (height[i] &gt; height[stack.peek()]) &#123; int bottom = height[stack.peek()]; stack.pop(); while (!stack.isEmpty() &amp;&amp; height[i] &gt;= height[stack.peek()]) &#123; res += (height[stack.peek()] - bottom) * (i - stack.peek() - 1); bottom = height[stack.pop()]; &#125; if (!stack.isEmpty()) &#123; res += (height[i] - bottom) * ( i - stack.peek() - 1); //这地方容易漏掉 &#125; &#125; stack.push(i); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Insert Delete GetRandom O(1) (380)]]></title>
    <url>%2F2017%2F03%2F29%2F2017-03-29-leetcode-solution-Insert-Delete-GetRandom-O-1-380%2F</url>
    <content type="text"><![CDATA[Design a data structure that supports all following operations in average O(1) time. insert(val): Inserts an item val to the set if not already present.remove(val): Removes an item val from the set if present.getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.Example:1234567891011121314151617181920212223// Init an empty set.RandomizedSet randomSet = new RandomizedSet();// Inserts 1 to the set. Returns true as 1 was inserted successfully.randomSet.insert(1);// Returns false as 2 does not exist in the set.randomSet.remove(2);// Inserts 2 to the set, returns true. Set now contains [1,2].randomSet.insert(2);// getRandom should return either 1 or 2 randomly.randomSet.getRandom();// Removes 1 from the set, returns true. Set now contains [2].randomSet.remove(1);// 2 was already in the set, so return false.randomSet.insert(2);// Since 2 is the only number in the set, getRandom always return 2.randomSet.getRandom(); 解法1：Two HashMaps这题如果没有getRandom的话用一个set就可以解决了。因为加上了getRandom，那么需要用一些方法来存储每一个数字对应的index。由此就想到用两个hashmap来存储数字和他位置的对应关系。insert比较好解决，就是把对应关系加入两个map中。remove稍微复杂一点，首先将对应的数字pair从两个map中移除。如果说移除的是最后一个元素或者是唯一一个元素，移除之后不需要对map额外处理。如果是移除的当中的某个元素。那么移除之后他们的index就不是连续的了。这个时候就要额外的来处理一下。因为要把最后一位的元素对应的位置-1， 那么我们可以把最后一位元素对应的位置放到刚才删除的元素的位置上。然后更新存储位置的hashmap就可以了。Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class RandomizedSet &#123; private Map&lt;Integer, Integer&gt; valueIndex; private Map&lt;Integer, Integer&gt; indexValue; private Random rand; /** Initialize your data structure here. */ public RandomizedSet() &#123; valueIndex = new HashMap&lt;Integer, Integer&gt;(); indexValue = new HashMap&lt;Integer, Integer&gt;(); rand = new Random(System.currentTimeMillis()); &#125; /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */ public boolean insert(int val) &#123; if (valueIndex.containsKey(val)) &#123; return false; &#125; else &#123; int index = valueIndex.size(); valueIndex.put(val, index); indexValue.put(index, val); return true; &#125; &#125; /** Removes a value from the set. Returns true if the set contained the specified element. */ public boolean remove(int val) &#123; if (valueIndex.containsKey(val)) &#123; int index = valueIndex.get(val); valueIndex.remove(val); indexValue.remove(index); if (valueIndex.isEmpty() || index == valueIndex.size()) &#123; return true; &#125; // if delete from the middle, // put the last element into the middle int last = indexValue.get(indexValue.size()); valueIndex.put(last, index); indexValue.remove(indexValue.size()); indexValue.put(index, last); return true; &#125; else &#123; return false; &#125; &#125; /** Get a random element from the set. */ public int getRandom() &#123; if (valueIndex.isEmpty()) &#123; return -1; &#125; else if (valueIndex.size() == 1) &#123; return indexValue.get(0); &#125; else &#123; int index = rand.nextInt(valueIndex.size()); return indexValue.get(index); &#125; &#125;&#125;/** * Your RandomizedSet object will be instantiated and called as such: * RandomizedSet obj = new RandomizedSet(); * boolean param_1 = obj.insert(val); * boolean param_2 = obj.remove(val); * int param_3 = obj.getRandom(); */]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Product of Array Except Self (238)]]></title>
    <url>%2F2017%2F03%2F29%2F2017-03-29-leetcode-solution-Product-of-Array-Except-Self-238%2F</url>
    <content type="text"><![CDATA[Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Solve it without division and in O(n). For example, given [1,2,3,4], return [24,12,8,6]. Follow up:Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.) 解法1：O(N) Time + O(1) Space把题目分成两个小问题来解决。except self换句话说就是左面的和右面的乘积。那么从左面扫一遍得到一组数，从右面扫一遍得到一组数。然后把左右两组数相乘便是答案。一个小要求是需要O(1)的space。在从右面扫描的时候我们不用维护一个数组，而是用一个变量product来记录现在的乘积。Java12345678910111213141516171819202122232425public class Solution &#123; public int[] productExceptSelf(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return nums; &#125; int[] res = new int[nums.length]; // from left to right res[0] = 1; for (int i = 1; i &lt; nums.length; ++i) &#123; res[i] = res[i - 1] * nums[i - 1]; &#125; int product = 1; // from right to left for (int i = nums.length - 1; i &gt;= 0; --i) &#123; res[i] = res[i] * product; product = product * nums[i]; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Longest Palindromic Substring (5)]]></title>
    <url>%2F2017%2F03%2F28%2F2017-03-28-leetcode-solution-Longest-Palindromic-Substring-5%2F</url>
    <content type="text"><![CDATA[Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example:12345Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. Example:123Input: &quot;cbbd&quot;Output: &quot;bb&quot; 解法1：DP: O(N^2)字符串的问题，如果牵涉到substring(i,j)的，要是往dp方向上考虑就需要用二维的。这题也不例外。dp[i][j]表示的是，(i,j)这个字符串是否是palindrome。有三种情况可以考虑，一个是i == j, 一个是相邻，还有一个是距离大于2。每次找到一个palindrome的时候都更新下max，同时也更新一下res的string。要注意的是我们要求矩阵从下往上搜索，并且j &gt;= i, 所以我们只搜索了上半部的矩阵。Java12345678910111213141516171819202122232425262728293031public class Solution &#123; public String longestPalindrome(String s) &#123; int n = s.length(); boolean[][] state = new boolean[n][n]; int maxlen = Integer.MIN_VALUE; String res = ""; for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = i; j &lt; n; j++) &#123; if (i == j) &#123; state[i][j] = true; &#125; else if (j == i + 1) &#123; state[i][j] = s.charAt(i) == s.charAt(j); &#125; else &#123; state[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; state[i + 1][j - 1]; &#125; if (state[i][j]) &#123; int len = j - i + 1; if (len &gt; maxlen) &#123; maxlen = len; res = s.substring(i, j + 1); &#125; &#125; &#125; &#125; return res; &#125;&#125; 解法2：O(n^2) Time, O(1) SpaceJava12345678910111213141516171819202122232425262728293031323334class Solution &#123; public String longestPalindrome(String s) &#123; if (s == null) &#123; return s; &#125; // loop through each possible expanding center int start = 0, end = 0; int maxLen = Integer.MIN_VALUE; for (int i = 0; i &lt; s.length(); i++) &#123; int len1 = expand(s, i, i); int len2 = expand(s, i, i + 1); int len = Math.max(len1, len2); if (len &gt; end - start) &#123; start = i - (len - 1) / 2; end = i + len / 2; &#125; &#125; return s.substring(start, end + 1); &#125; private int expand(String s, int left, int right) &#123; int L = left, R = right; while (L &gt;= 0 &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123; L--; R++; &#125; return R - L - 1; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Longest Substring Without Repeating Characters (3)]]></title>
    <url>%2F2017%2F03%2F28%2F2017-03-28-leetcode-solution-Longest-Substring-Without-Repeating-Characters-3%2F</url>
    <content type="text"><![CDATA[Given a string, find the length of the longest substring without repeating characters. Examples: Given “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the answer is “b”, with the length of 1. Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. 解法1：这个答案对我的启发比较大，主要可以用于一类题目。思路是用一个hashtable维护出现过的字母的位置，只存储上一次出现过的位置。那么如果遇到还未出现过的字符则直接向前进，如果遇到出现过的字符那么需要比较当前的substring的长度和max。同时，需要移动left指针，因为从left开始到right部分已经不符合要求了。left需要移动到上一次出现的位置+1.注意这里有个坑：因为可能出现上一次的位置比现在left的位置还好往后，要保证left只进不退，只能用left = Math.max(left, last_pos)来保证。还有一个坑，就是在最后一步还需要判断max和当前right - left的大小的比较。Java1234567891011121314151617181920212223242526public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int[] table = new int[256]; Arrays.fill(table, -1); int left = 0, right = 0; int max = 0; while (right &lt; s.length()) &#123; int current_char = (int)s.charAt(right); int last_pos = table[current_char]; if (last_pos != -1) &#123; max = Math.max(right - left, max); // move left pointer left = Math.max(left, table[current_char] + 1); table[current_char] = right; &#125; else &#123; table[current_char] = right; &#125; ++right; &#125; return Math.max(max, right - left); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Rotate Image (48)]]></title>
    <url>%2F2017%2F03%2F28%2F2017-03-28-leetcode-solution-Rotate-Image-48%2F</url>
    <content type="text"><![CDATA[You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Follow up:Could you do this in-place? Show Company TagsShow Tags 解法1：特殊解法 如果是out-of-place的解法，就用temp[j][n - 1 - j] = matrix[i][j] 如果要inplace的解法：可以有这么几种： 先按逆对角线翻转一次，然后按ｘ轴中线翻转一次。 或者呢也可以先transpose，然后把每一行翻转。个人感觉第二种解法比较好记也比较好写。不容易出错 Java1234567891011121314151617181920212223242526272829303132public class Solution &#123; public void rotate(int[][] matrix) &#123; if (matrix.length == 0 || matrix[0].length == 0) &#123; return; &#125; int n = matrix.length; // flip along / for (int i = 0; i &lt; n - 1; ++i) &#123; for (int j = 0; j &lt; n - 1 - i; ++j) &#123; swap(matrix, i, j, n - 1 - j, n - 1 - i); &#125; &#125; // flip between for (int i = 0; i &lt; n / 2; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; swap(matrix, i, j, n - 1 - i, j); &#125; &#125; return; &#125; private void swap(int[][] matrix, int ix, int iy, int jx, int jy) &#123; int temp = matrix[ix][iy]; matrix[ix][iy] = matrix[jx][jy]; matrix[jx][jy] = temp; return; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Word Break (139)]]></title>
    <url>%2F2017%2F03%2F28%2F2017-03-28-leetcode-solution-Word-Break-139%2F</url>
    <content type="text"><![CDATA[Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words. For example, given12s = &quot;leetcode&quot;,dict = [&quot;leet&quot;, &quot;code&quot;]. Return true because “leetcode” can be segmented as “leet code”. 解法1：DP O(N^2)经典的用DP的问题，用一个dp数组来记录。dp[i]表示前i个字符是否可能分词。所以对于每一个dp[i], dp[i] = true if word(0,i) in dict, or dp[k] = true &amp;&amp; word(k, i) in dict这题的坑在于java的substring比较坑，string.substring(j,k)表示从第j个字符到第k-1个字符所组成的substring。我们这里需要用word(k,i)表示的是第k+1个字符到第i-1个字符。这里容易出错需要注意一下。Java123456789101112131415161718192021222324252627282930313233public class Solution &#123; public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; if (s == null || s.isEmpty() || wordDict == null || wordDict.size() == 0) &#123; return false; &#125; // convert to set Set&lt;String&gt; set = new HashSet&lt;String&gt;(); for (String word: wordDict) &#123; set.add(word); &#125; boolean[] dp = new boolean[s.length() + 1]; dp[0] = true; for (int i = 1; i &lt;= s.length(); ++i) &#123; if (set.contains(s.substring(0,i))) &#123; dp[i] = true; &#125; else &#123; for (int j = 0; j &lt; i; ++j) &#123; if (dp[j] &amp;&amp; set.contains(s.substring(j, i))) &#123; dp[i] = true; break; &#125; &#125; &#125; &#125; return dp[s.length()]; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Kth Largest Element in an Array (215)]]></title>
    <url>%2F2017%2F03%2F27%2F2017-03-27-leetcode-solution-Kth-Largest-Element-in-an-Array-215%2F</url>
    <content type="text"><![CDATA[Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. For example,Given [3,2,1,5,6,4] and k = 2, return 5. Note:You may assume k is always valid, 1 ≤ k ≤ array’s length. 解法1：PriorityQueue, O(NlogK), Space O(K)一种解法是很直观的用heap来解决，维护一个大小为k的堆。因为每次insert的操作的时间复杂度是O(logK), 一共要遍历N个元素。最后取出顶元素即可。Java1234567891011121314public class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;Integer&gt;(k); for (int num: nums) &#123; queue.offer(num); if (queue.size() &gt; k) &#123; queue.poll(); &#125; &#125; return queue.poll(); &#125;&#125; 解法2：比较优解 Quick Select, Average O(N), worst O(N^2), Space O(1)主要是用到了Quick Select中一次partition就可以知道pivot在array中的具体位置，假设是X。那么如果X == k, 我们要求的就求道了。假设是X &lt; k, 那么我们只需要在右半边找，反之就在左半边找。要掌握partition函数的写法。Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; if (k &lt;= 0) &#123; return 0; &#125; return helper(nums, nums.length - k + 1, 0, nums.length - 1); &#125; private int helper(int[] nums, int k, int start, int end) &#123; if (start == end) &#123; return nums[start]; &#125; int p = partition(nums, start, end); if (p + 1 == k) &#123; return nums[p]; &#125; else if (p + 1 &lt; k) &#123; return helper(nums, k, p + 1, end); &#125; else &#123; return helper(nums, k, start, p - 1); &#125; &#125; private int partition(int[] nums, int start, int end) &#123; int pivot = nums[end]; int index = start; for (int i = start; i &lt; end; ++i) &#123; if (nums[i] &lt; pivot) &#123; swap(nums, index, i); ++index; &#125; &#125; swap(nums, end, index); return index; &#125; private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>PriorityQueue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Add Two Numbers (2)]]></title>
    <url>%2F2017%2F03%2F27%2F2017-03-27-leetcode-solution-Add-Two-Numbers-2%2F</url>
    <content type="text"><![CDATA[You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 解法1：O(N + M) Time + O(1) Space这题的坑是leetocde的OJ可能会TLE，要用tail.next = new ListNode(temp)就可以过了。Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(0); ListNode tail = dummy; int carry = 0; while (l1 != null &amp;&amp; l2 != null) &#123; int val = l1.val + l2.val + carry; int digit = val % 10; carry = val / 10; ListNode temp = new ListNode(digit); tail.next = temp; tail = tail.next; l1 = l1.next; l2 = l2.next; &#125; while (l1 != null) &#123; int val = l1.val + carry; int digit = val % 10; carry = val / 10; tail.next = new ListNode(digit); tail = tail.next; l1 = l1.next; &#125; while (l2 != null) &#123; int val = l2.val + carry; int digit = val % 10; carry = val / 10; tail.next = new ListNode(digit); tail = tail.next; l2 = l2.next; &#125; if (carry != 0) &#123; tail.next = new ListNode(carry); &#125; return dummy.next; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Group Anagrams (49)]]></title>
    <url>%2F2017%2F03%2F27%2F2017-03-27-leetcode-solution-Group-Anagrams-49%2F</url>
    <content type="text"><![CDATA[Given an array of strings, group anagrams together. For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],Return:12345[ [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] Note: All inputs will be in lower-case. 解法1：HashMap, O(N) Time + O(N) Space因为anagram是表示排序后A,B的字母一样，那么就可以用一个hashmap存储每一个group， group的key就是排序后的string。string排序在java中并没有自带的函数，可以先转换成chararray，然后用Arrays.sort来排序。Java1234567891011121314151617181920212223242526272829303132public class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;List&lt;String&gt;&gt;(); if (strs == null || strs.length == 0) &#123; return res; &#125; HashMap&lt;String, ArrayList&lt;String&gt;&gt; map = new HashMap&lt;String, ArrayList&lt;String&gt;&gt;(); for (String str: strs) &#123; String temp = sorted(str); if (!map.containsKey(temp)) &#123; ArrayList&lt;String&gt; collection = new ArrayList&lt;String&gt;(); collection.add(str); map.put(temp, collection); &#125; else &#123; map.get(temp).add(str); &#125; &#125; for (String key : map.keySet()) &#123; res.add(map.get(key)); &#125; return res; &#125; public String sorted(String x) &#123; char[] temp = x.toCharArray(); Arrays.sort(temp); return new String(temp); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode解题: Word Ladder (127)]]></title>
    <url>%2F2017%2F03%2F27%2F2017-03-27-leetcode-solution-Word-Ladder-127%2F</url>
    <content type="text"><![CDATA[Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that: Only one letter can be changed at a time.Each transformed word must exist in the word list. Note that beginWord is not a transformed word.For example, Given:beginWord = “hit”endWord = “cog”wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,return its length 5. Note:Return 0 if there is no such transformation sequence.All words have the same length.All words contain only lowercase alphabetic characters.You may assume no duplicates in the word list.You may assume beginWord and endWord are non-empty and are not the same. 解法1：BFS, Time O(26LN)求最小路径，用BFS比较自然可以想到。关键是怎么构建一个图. 我们把每一个word改变一个字母，检查是否在已知的dict中。由于查询用hashtable是最快的，这里需要考虑用一个hashset来存放dict。然后用一个BFS遍历就可以了。Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class Solution &#123; public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; if (wordList == null || wordList.size() == 0) &#123; return 0; &#125; if (beginWord.equals(endWord)) &#123; return 1; &#125; // To boost lookup Set&lt;String&gt; dict = new HashSet&lt;String&gt;(); for (String word: wordList) &#123; dict.add(word); &#125; Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); Set&lt;String&gt; visited = new HashSet&lt;String&gt;(); queue.offer(beginWord); visited.add(beginWord); int res = 1; while(!queue.isEmpty()) &#123; ++res; int size = queue.size(); for (int i = 0; i &lt; size; ++i) &#123; String current = queue.poll(); List&lt;String&gt; next = getNextWords(current, dict); for (String candidate: next) &#123; if (candidate.equals(endWord)) &#123; return res; &#125; if (!visited.contains(candidate)) &#123; queue.offer(candidate); visited.add(candidate); &#125; &#125; &#125; &#125; return 0; &#125; private String replace(String origin, int index, char c) &#123; char[] temp = origin.toCharArray(); temp[index] = c; return new String(temp); &#125; public List&lt;String&gt; getNextWords(String origin, Set&lt;String&gt; dict) &#123; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); for (char i = 'a'; i &lt;= 'z'; ++i) &#123; for (int j = 0; j &lt; origin.length(); ++j) &#123; if (origin.charAt(j) == i) &#123; continue; &#125; String temp = replace(origin, j, i); if (dict.contains(temp)) &#123; res.add(temp); &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Search a 2D Matrix II (240)]]></title>
    <url>%2F2017%2F03%2F26%2F2017-03-26-leetcode-solution-Search-a-2D-Matrix-II-240%2F</url>
    <content type="text"><![CDATA[Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right.Integers in each column are sorted in ascending from top to bottom.For example, Consider the following matrix:1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] Given target = 5, return true. Given target = 20, return false. 解法1：O(N + M)这题和Matrix I的区别是上一行和下一行不是递增的，也就是说不能串起来当成一个sorted array来处理。这题要变换下思路，考虑右上角和左下角两个点。比如左下角，比数字大就往上，比它数字小就往右。直到找到所要求的答案。Java1234567891011121314151617181920212223public class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; if (matrix.length == 0 || matrix[0].length == 0) &#123; return false; &#125; int m = matrix.length, n = matrix[0].length; int x = m - 1; int y = 0; while (true) &#123; if (matrix[x][y] &lt; target) &#123; ++y; &#125; else if (matrix[x][y] &gt; target) &#123; --x; &#125; else &#123; return true; &#125; if (x &lt; 0 || y &gt;= n) &#123; return false; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Count Primes (204)]]></title>
    <url>%2F2017%2F03%2F26%2F2017-03-26-leetcode-solution-Count-Primes-204%2F</url>
    <content type="text"><![CDATA[Description: Count the number of prime numbers less than a non-negative number, n. Hint: Let’s start with a isPrime function. To determine if a number is prime, we need to check if it is not divisible by any number less than n. The runtime complexity of isPrime function would be O(n) and hence counting the total prime numbers up to n would be O(n2). Could we do better? As we know the number must not be divisible by any number &gt; n / 2, we can immediately cut the total iterations half by dividing only up to n / 2. Could we still do better? Let’s write down all of 12’s factors: 2 × 6 = 123 × 4 = 124 × 3 = 126 × 2 = 12As you can see, calculations of 4 × 3 and 6 × 2 are not necessary. Therefore, we only need to consider factors up to √n because, if n is divisible by some number p, then n = p × q and since p ≤ q, we could derive that p ≤ √n. Our total runtime has now improved to O(n1.5), which is slightly better. Is there a faster approach?1234567891011121314151617public int countPrimes(int n) &#123; int count = 0; for (int i = 1; i &lt; n; i++) &#123; if (isPrime(i)) count++; &#125; return count;&#125;private boolean isPrime(int num) &#123; if (num &lt;= 1) return false; // Loop&apos;s ending condition is i * i &lt;= num instead of i &lt;= sqrt(num) // to avoid repeatedly calling an expensive function sqrt(). for (int i = 2; i * i &lt;= num; i++) &#123; if (num % i == 0) return false; &#125; return true;&#125; The Sieve of Eratosthenes is one of the most efficient ways to find all prime numbers up to n. But don’t let that name scare you, I promise that the concept is surprisingly simple. Sieve of Eratosthenes: algorithm steps for primes below 121. “Sieve of Eratosthenes Animation” by SKopp is licensed under CC BY 2.0. We start off with a table of n numbers. Let’s look at the first number, 2. We know all multiples of 2 must not be primes, so we mark them off as non-primes. Then we look at the next number, 3. Similarly, all multiples of 3 such as 3 × 2 = 6, 3 × 3 = 9, … must not be primes, so we mark them off as well. Now we look at the next number, 4, which was already marked off. What does this tell you? Should you mark off all multiples of 4 as well? 4 is not a prime because it is divisible by 2, which means all multiples of 4 must also be divisible by 2 and were already marked off. So we can skip 4 immediately and go to the next number, 5. Now, all multiples of 5 such as 5 × 2 = 10, 5 × 3 = 15, 5 × 4 = 20, 5 × 5 = 25, … can be marked off. There is a slight optimization here, we do not need to start from 5 × 2 = 10. Where should we start marking off? In fact, we can mark off multiples of 5 starting at 5 × 5 = 25, because 5 × 2 = 10 was already marked off by multiple of 2, similarly 5 × 3 = 15 was already marked off by multiple of 3. Therefore, if the current number is p, we can always mark off multiples of p starting at p2, then in increments of p: p2 + p, p2 + 2p, … Now what should be the terminating loop condition? It is easy to say that the terminating loop condition is p &lt; n, which is certainly correct but not efficient. Do you still remember Hint #3? Yes, the terminating loop condition can be p &lt; √n, as all non-primes ≥ √n must have already been marked off. When the loop terminates, all the numbers in the table that are non-marked are prime. The Sieve of Eratosthenes uses an extra O(n) memory and its runtime complexity is O(n log log n). For the more mathematically inclined readers, you can read more about its algorithm complexity on Wikipedia. 解法1：Java12345678910111213141516171819202122public class Solution &#123; public int countPrimes(int n) &#123; boolean[] isPrime = new boolean[n]; Arrays.fill(isPrime, true); for (int i = 2; i * i &lt; n; ++i) &#123; if (!isPrime[i]) continue; for (int j = i * i; j &lt; n; j += i) &#123; isPrime[j] = false; &#125; &#125; int count = 0; for (int i = 2; i &lt; n; ++i) &#123; if (isPrime[i]) &#123; ++count; &#125; &#125; return count; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: K-diff Pairs in an Array (532)]]></title>
    <url>%2F2017%2F03%2F26%2F2017-03-26-leetcode-solution-K-diff-Pairs-in-an-Array-532%2F</url>
    <content type="text"><![CDATA[Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k. Example 1:1234Input: [3, 1, 4, 1, 5], k = 2Output: 2Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs. Example 2:123Input:[1, 2, 3, 4, 5], k = 1Output: 4Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5). Example 3:123Input: [1, 3, 1, 5, 4], k = 0Output: 1Explanation: There is one 0-diff pair in the array, (1, 1). Note:The pairs (i, j) and (j, i) count as the same pair.The length of the array won’t exceed 10,000.All the integers in the given input belong to the range: [-1e7, 1e7]. 解法1：Two pointers, O(NlogN) Time + O(1) Space可以先排序，这样找距离为k的数就好找了。用Two pointers的方法来解，left负责从左到右遍历，right负责找对应于left的距离为k的数。这题的坑点在于有重复的值，所以left需要去重，也就是下面程序的i， 那么如果说i在循环内因为重复的问题已经向前进了，那么right进行到下一次循环的时候需要至少从i+1开始，也就是我们的那句j = Math.max(i + 1, j)的意义。Java1234567891011121314151617181920212223242526public class Solution &#123; public int findPairs(int[] nums, int k) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; Arrays.sort(nums); // first sort the input int res = 0, j = 1; int n = nums.length; for (int i = 0; i &lt; n - 1; ++i) &#123; j = Math.max(i + 1, j); while ( j &lt; n &amp;&amp; (long)nums[j] - nums[i] &lt; k) &#123; ++j; &#125; if (j &lt; n &amp;&amp; (long)nums[j] - nums[i] == k) &#123; ++res; &#125; while (i &lt; n - 1 &amp;&amp; nums[i + 1] == nums[i]) &#123; ++i; &#125; &#125; return res; &#125;&#125; 解法2：HashMap, O(N) Time + O(N) Space这个解法借用了Two sum的思路，在two sum里，我们用一个hashmap来判断对应的两个数的和是否为target。这里也一样。如果要找寻是否有两个数的差是否为k， 那么我们也可以把他们都放到map中。所不同的地方就是这里是统计个数。那么如果k是一个正数，我们只需要判断对应的另外一个数是否在map中。如果k为0， 那么要判断现在这个数出现的次数是否大于1.Java12345678910111213141516171819202122232425262728public class Solution &#123; public int findPairs(int[] nums, int k) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int num: nums) &#123; if (map.containsKey(num)) &#123; map.put(num, map.get(num) + 1); &#125; else &#123; map.put(num, 1); &#125; &#125; int res = 0; for (Integer key : map.keySet()) &#123; if (k == 0 &amp;&amp; map.get(key) &gt; 1) &#123; ++res; &#125; if (k &gt; 0 &amp;&amp; map.containsKey(key + k)) &#123; ++res; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Two Sum II - Input array is sorted (167)]]></title>
    <url>%2F2017%2F03%2F26%2F2017-03-26-leetcode-solution-Two-Sum-II-Input-array-is-sorted-167%2F</url>
    <content type="text"><![CDATA[Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Input: numbers={2, 7, 11, 15}, target=9Output: index1=1, index2=2 解法1：O(N) Time + O(1) Complexity如果是已经sorted的话这题就很简单了，比较容易的能想到可以用two pointers， left和right按照加和的大小不停的移动。 Java1234567891011121314151617181920212223242526public class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; if (numbers == null || numbers.length == 0) &#123; return null; &#125; int[] res = new int[2]; int left = 0, right = numbers.length - 1; while (left &lt; right) &#123; int sum = numbers[left] + numbers[right]; if (sum &lt; target) &#123; ++left; &#125; else if (sum &gt; target) &#123; --right; &#125; else &#123; res[0] = left + 1; res[1] = right + 1; return res; &#125; &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode解题: Min stack (155)]]></title>
    <url>%2F2017%2F03%2F23%2F2017-03-23-leetcode-solution-Min-stack-155%2F</url>
    <content type="text"><![CDATA[Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. 12345678910111213push(x) -- Push element x onto stack.pop() -- Removes the element on top of the stack.top() -- Get the top element.getMin() -- Retrieve the minimum element in the stack.Example:MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; Returns -3.minStack.pop();minStack.top(); --&gt; Returns 0.minStack.getMin(); --&gt; Returns -2. 解法1：这题可以作为让你写一个Stack的class的follow up问题。Implenment stack的时候可以用arraylist而不是用array, 这样就不用自己写一个resize function来维护底层数据的存放。维护一个min, 可以有两个方法。一个是维护另一个arraylist， 保存对应每一个数据当前的最小值。另一个方法是class MinStack extends Iterable, 然后需要有一个iterator(), 来返回一个Iterator的classmyiteraor，这个myiterator implements Iterator 需要两个函数，hasNext()和next() Java12345678910111213141516171819202122232425262728293031323334353637383940414243public class MinStack &#123; /** initialize your data structure here. */ List&lt;Integer&gt; data; List&lt;Integer&gt; mins; public MinStack() &#123; data = new ArrayList&lt;Integer&gt;(); mins = new ArrayList&lt;Integer&gt;(); &#125; public void push(int x) &#123; data.add(x); if (mins.size() &gt; 0) &#123; mins.add(mins.get(mins.size() - 1) &lt; x ? mins.get(mins.size() - 1) : x); &#125; else &#123; mins.add(x); &#125; &#125; public void pop() &#123; if (data.size() &gt; 0) &#123; data.remove(data.size() - 1); mins.remove(mins.size() - 1); &#125; &#125; public int top() &#123; return data.get(data.size() - 1); &#125; public int getMin() &#123; return mins.get(mins.size() - 1); &#125;&#125;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Spiral Matrix (54)]]></title>
    <url>%2F2017%2F03%2F23%2F2017-03-23-leetcode-solution-Spiral-Matrix-54%2F</url>
    <content type="text"><![CDATA[Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. For example,Given the following matrix:12345[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]] You should return [1,2,3,6,9,8,7,4,5]. 解法1：O(M*N) Time, O(1) Space运用分层处理的思想。一般情况，每一层有4条边组成，顺序是按照right, down, left, up。而且每一层的最后一行和第一行， 最后一列和第一列是对应关系。意思是说如果我们从第i行开始，那么与之对应的最后一行便是m - 1 - i, 列野同理。那么层数有多少呢？这是又行数和列数决定的. level = (min(row, col) + 1) / 2还有一个坑是对于单行或者单列的处理需要单独计算。 Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Solution &#123; public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if (matrix.length == 0 || matrix[0].length == 0) &#123; return res; &#125; int m = matrix.length, n = matrix[0].length; int level = (Math.min(m, n) + 1) / 2; for (int i = 0; i &lt; level; ++i) &#123; int lastrow = m - i - 1; int lastcol = n - i - 1; if (i == lastrow) &#123; for (int j = i; j &lt;= lastcol; ++j) &#123; res.add(matrix[i][j]); &#125; &#125; else if (i == lastcol) &#123; for (int j = i; j &lt;= lastrow; ++j) &#123; res.add(matrix[j][i]); &#125; &#125; else &#123; // To right for (int j = i; j &lt; lastcol; ++j) &#123; res.add(matrix[i][j]); &#125; // down for (int j = i; j &lt; lastrow; ++j) &#123; res.add(matrix[j][lastcol]); &#125; // left for (int j = lastcol; j &gt; i; --j) &#123; res.add(matrix[lastrow][j]); &#125; // up for (int j = lastrow; j &gt; i; --j) &#123; res.add(matrix[j][i]); &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Divide two Integers (29)]]></title>
    <url>%2F2017%2F03%2F23%2F2017-03-23-leetcode-solution-Divide-two-Integers-29%2F</url>
    <content type="text"><![CDATA[Divide two integers without using multiplication, division and mod operator. If it is overflow, return MAX_INT. 解法1：这题有几个坑：一个是分母有可能是0， 这种情况要判断dividend的正负而返回。一个是INT_MIN/(-1) &gt; INT_MAX, 所以这种条件下会overflow。还有一个是分子分母有可能符号不同。除法的基本算法是把被除数A分拆成A = B*(2^n1 + 2^n2 + ….), 每一次找出比A小的最大的B的2的倍数，也就是求出Ni。这里每一次B乘以2的操作可以用左位移表示。这里引出了另外一个坑，就是往左移的时候可能会溢出，所以一开始要把他们转化为long型再操作。Java1234567891011121314151617181920212223242526272829public class Solution &#123; public int divide(int dividend, int divisor) &#123; if (divisor == 0) &#123; return dividend &gt;= 0 ? Integer.MAX_VALUE : Integer.MIN_VALUE; &#125; if (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1) &#123; return Integer.MAX_VALUE; &#125; boolean neg = false; if ((dividend &gt; 0 &amp;&amp; divisor &lt; 0) || (dividend &lt; 0 &amp;&amp; divisor &gt; 0)) &#123; neg = true; &#125; int res = 0; long x = Math.abs((long)dividend); long y = Math.abs((long)divisor); while ( x &gt;= y) &#123; int shift = 1; while (x &gt;= (y&lt;&lt;shift)) &#123; ++shift; &#125; x -= y &lt;&lt; (shift - 1); res += 1 &lt;&lt; (shift - 1); &#125; return neg ? 0 - res : res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Amazon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Relative Ranks (506)]]></title>
    <url>%2F2017%2F03%2F12%2F2017-03-12-leetcode-solution-Relative-Ranks-506%2F</url>
    <content type="text"><![CDATA[Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: “Gold Medal”, “Silver Medal” and “Bronze Medal”. Example 1:1234Input: [5, 4, 3, 2, 1]Output: [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;, &quot;4&quot;, &quot;5&quot;]Explanation: The first three athletes got the top three highest scores, so they got &quot;Gold Medal&quot;, &quot;Silver Medal&quot; and &quot;Bronze Medal&quot;. For the left two athletes, you just need to output their relative ranks according to their scores. Note:N is a positive integer and won’t exceed 10,000.All the scores of athletes are guaranteed to be unique. 解法1：Priority Queue这里感觉是要用一个带下标的排序，那么我们可以自己实现一个带下标的排序，或者可以使用已有的可排序的数据结构。对于可排序的比较熟悉的就是PriorityQueue了。每一个放入的元素都会自动排序，那么我们只需要全部放入然后一个个读出同时判断是第几个元素就可以解决medal的归属问题。用一个辅助class记录data和index，同时实现一个comparator，来比较这两个pair。 Java12345678910111213141516171819202122232425262728293031323334353637383940414243class pair &#123; int data; int index; public pair(int d, int i) &#123; this.data = d; this.index = i; &#125;&#125;;public class Solution &#123; public String[] findRelativeRanks(int[] nums) &#123; Comparator&lt;pair&gt; comparator = new Comparator&lt;pair&gt;() &#123; public int compare(pair a, pair b) &#123; if (a.data &lt; b.data) &#123; return -1; &#125; else if (a.data == b.data) &#123; return 0; &#125; else &#123; return 1; &#125; &#125; &#125;; PriorityQueue&lt;pair&gt; queue = new PriorityQueue&lt;pair&gt;(nums.length, comparator); for (int i = 0; i &lt; nums.length; ++i) &#123; queue.offer(new pair(nums[i], i)); &#125; String[] res = new String[nums.length]; for (int i = 0; i &lt; nums.length; ++i) &#123; pair temp = queue.peek(); if (queue.size() &gt; 3) &#123; res[temp.index] = Integer.toString(queue.size()); &#125; else if (queue.size() == 3) &#123; res[temp.index] = "Bronze Medal"; &#125; else if (queue.size() == 2) &#123; res[temp.index] = "Silver Medal"; &#125; else &#123; res[temp.index] = "Gold Medal"; &#125; queue.poll(); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>PriorityQueue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Minesweeper (529)]]></title>
    <url>%2F2017%2F03%2F12%2F2017-03-12-leetcode-solution-Minesweeper-529%2F</url>
    <content type="text"><![CDATA[Let’s play the minesweeper game (Wikipedia, online game)! You are given a 2D char matrix representing the game board. ‘M’ represents an unrevealed mine, ‘E’ represents an unrevealed empty square, ‘B’ represents a revealed blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit (‘1’ to ‘8’) represents how many mines are adjacent to this revealed square, and finally ‘X’ represents a revealed mine. Now given the next click position (row and column indices) among all the unrevealed squares (‘M’ or ‘E’), return the board after revealing this position according to the following rules: If a mine (‘M’) is revealed, then the game is over - change it to ‘X’.If an empty square (‘E’) with no adjacent mines is revealed, then change it to revealed blank (‘B’) and all of its adjacent unrevealed squares should be revealed recursively.If an empty square (‘E’) with at least one adjacent mine is revealed, then change it to a digit (‘1’ to ‘8’) representing the number of adjacent mines.Return the board when no more squares will be revealed.Example 1:Input:1234[[&apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;], [&apos;E&apos;, &apos;E&apos;, &apos;M&apos;, &apos;E&apos;, &apos;E&apos;], [&apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;], [&apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;]] Click : [3,0] Output:1234[[&apos;B&apos;, &apos;1&apos;, &apos;E&apos;, &apos;1&apos;, &apos;B&apos;], [&apos;B&apos;, &apos;1&apos;, &apos;M&apos;, &apos;1&apos;, &apos;B&apos;], [&apos;B&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;B&apos;], [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;]] Explanation:Example 2:Input:1234[[&apos;B&apos;, &apos;1&apos;, &apos;E&apos;, &apos;1&apos;, &apos;B&apos;], [&apos;B&apos;, &apos;1&apos;, &apos;M&apos;, &apos;1&apos;, &apos;B&apos;], [&apos;B&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;B&apos;], [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;]] Click : [1,2] Output:1234[[&apos;B&apos;, &apos;1&apos;, &apos;E&apos;, &apos;1&apos;, &apos;B&apos;], [&apos;B&apos;, &apos;1&apos;, &apos;X&apos;, &apos;1&apos;, &apos;B&apos;], [&apos;B&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;B&apos;], [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;]] Explanation: Note:The range of the input matrix’s height and width is [1,50].The click position will only be an unrevealed square (‘M’ or ‘E’), which also means the input board contains at least one clickable square.The input board won’t be a stage when game is over (some mines have been revealed).For simplicity, not mentioned rules should be ignored in this problem. For example, you don’t need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares. 解法1：题目看起来很复杂，其实实现起来比较简单。就一步步按照他的规则来就可以。主要是考察了DFS或者是BFS的应用。这里我用了DFS的解法，对于每一个click的方块。如果是地雷，那么直接return了。如果不是地雷，那么统计一下周围地雷的个数。如果是空的，那么就对所有相邻的都做一遍DFS，如果是有地雷则直接范围地雷的个数。 Java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Solution &#123; // defines the 8 directions it can point to private int[][] directions = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;-1,1&#125;,&#123;1,1&#125;,&#123;1,-1&#125;,&#123;-1,-1&#125;&#125;; public char[][] updateBoard(char[][] board, int[] click) &#123; if (board.length == 0 || board[0].length == 0) &#123; return board; &#125; dfs(board, click[0], click[1]); return board; &#125; private void dfs(char[][] board, int i, int j) &#123; if (board[i][j] == &apos;M&apos;) &#123; board[i][j] = &apos;X&apos;; return; &#125; if (board[i][j] == &apos;E&apos;) &#123; int n = getNumberOfMines(board, i, j); if (n == 0) &#123; board[i][j] = &apos;B&apos;; // doing dfs for each direction for (int[] direction: directions) &#123; int x = i + direction[0]; int y = j + direction[1]; if (x &lt; 0 || x &gt;= board.length || y &lt; 0 || y &gt;= board[0].length || board[x][y] == &apos;M&apos;) &#123; continue; &#125; dfs(board, x, y); &#125; &#125; else &#123; board[i][j] = (char)(n + &apos;0&apos;); &#125; &#125; return; &#125; private int getNumberOfMines(char[][] board, int i, int j) &#123; int n = board.length; int m = board[0].length; int count = 0; for (int[] direction: directions) &#123; int x = i + direction[0]; int y = j + direction[1]; if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m) &#123; continue; &#125; if (board[x][y] == &apos;M&apos;) &#123; ++count; &#125; &#125; return count; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode解题: Lonely Pixel (531)]]></title>
    <url>%2F2017%2F03%2F12%2F2017-03-12-leetcode-solution-Lonely-Pixel-531%2F</url>
    <content type="text"><![CDATA[Given a picture consisting of black and white pixels, find the number of black lonely pixels. The picture is represented by a 2D char array consisting of ‘B’ and ‘W’, which means black and white pixels respectively. A black lonely pixel is character ‘B’ that located at a specific position where the same row and same column don’t have any other black pixels. Example:1234567Input: [[&apos;W&apos;, &apos;W&apos;, &apos;B&apos;], [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;], [&apos;B&apos;, &apos;W&apos;, &apos;W&apos;]]Output: 3Explanation: All the three &apos;B&apos;s are black lonely pixels. Note:The range of width and height of the input 2D array is [1,500]. 解法1：O(MN) Time + O(M + N) Space用两个数组分别记录每一行， 每一列的pixel的个数，然后遍历一遍矩阵，对于每一个B的位置查看当前行列的B的个数。Java1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public int findLonelyPixel(char[][] picture) &#123; if (picture.length == 0 || picture[0].length == 0) &#123; return 0; &#125; int n = picture.length; int m = picture[0].length; int[] row = new int[n]; int[] col = new int[m]; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (picture[i][j] == 'B') &#123; row[i]++; col[j]++; &#125; &#125; &#125; int count = 0; for (int i = 0; i &lt; n;++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (picture[i][j] == 'B') &#123; if (row[i] == 1 &amp;&amp; col[j] == 1) &#123; ++count; &#125; &#125; &#125; &#125; return count; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Find Largest Value in Each Tree Row (515)]]></title>
    <url>%2F2017%2F03%2F12%2F2017-03-12-leetcode-solution-Find-Largest-Value-in-Each-Tree-Row-515%2F</url>
    <content type="text"><![CDATA[You need to find the largest value in each row of a binary tree. Example:123456789Input: 1 / \ 3 2 / \ \ 5 3 9 Output: [1, 3, 9] 解法1：BFS因为是按行来选择最大值，自然想到用BFS遍历每一行，然后存储下每一行的最大值。主要考察了BFS的写法。Java1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public List&lt;Integer&gt; largestValues(TreeNode root) &#123; // bfs List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); if (root == null) &#123; return result; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; int size = queue.size(); int levelmax = Integer.MIN_VALUE; for (int i = 0; i &lt; size; ++i) &#123; TreeNode cur = queue.poll(); levelmax = Math.max(levelmax, cur.val); if (cur.left != null) &#123; queue.offer(cur.left); &#125; if (cur.right != null) &#123; queue.offer(cur.right); &#125; &#125; result.add(levelmax); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Number of Islands II (305)]]></title>
    <url>%2F2017%2F03%2F12%2F2017-03-12-leetcode-solution-Number-of-Islands-II-305%2F</url>
    <content type="text"><![CDATA[A 2d grid map of m rows and n columns is initially filled with water. We may perform an addLand operation which turns the water at position (row, col) into a land. Given a list of positions to operate, count the number of islands after each addLand operation. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example: Given m = 3, n = 3, positions = [[0,0], [0,1], [1,2], [2,1]].Initially, the 2d grid grid is filled with water. (Assume 0 represents water and 1 represents land). 0 0 00 0 00 0 0Operation #1: addLand(0, 0) turns the water at grid[0][0] into a land. 1 0 00 0 0 Number of islands = 10 0 0Operation #2: addLand(0, 1) turns the water at grid0 into a land. 1 1 00 0 0 Number of islands = 10 0 0Operation #3: addLand(1, 2) turns the water at grid[1][2] into a land. 1 1 00 0 1 Number of islands = 20 0 0Operation #4: addLand(2, 1) turns the water at grid2 into a land. 1 1 00 0 1 Number of islands = 30 1 0We return the result as an array: [1, 1, 2, 3] Challenge: Can you do it in time complexity O(k log mn), where k is the length of the positions? 解法1：Union Find O(k logmn)这是一题难题了，为了熟悉Union Find的算法也做（抄）一下吧。主要是参考了这篇.Union Find很适合用来解决两点是否想通的问题。用一个roots来记录每一个点的group id也就是下面code中的parent。然后对于每一个插入的点，首先把自己的点的group id设为自己，然后搜索周围相邻的点，如果相邻的点是陆地并且相邻的点的group id和自己不同的时候，则说明需要进行Union操作。这个时候对于当前岛屿的数量需要-1，因为合并了一个。Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Solution &#123; private int[][] directions = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;; public List&lt;Integer&gt; numIslands2(int m, int n, int[][] positions) &#123; // Union Find List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); if (m &lt;= 0 || n &lt;= 0 || positions.length == 0 || positions[0].length == 0) &#123; return result; &#125; int count = 0; int[] roots = new int[m * n]; Arrays.fill(roots, -1); for (int[] position: positions) &#123; // positions count++; int index = n * position[0] + position[1]; roots[index] = index; // perform union operations for (int[] direction: directions) &#123; int x = position[0] + direction[0]; int y = position[1] + direction[1]; int neighbor = x * n + y; if ( x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || roots[neighbor] == -1) &#123; continue; &#125; int parent = find(roots, neighbor); if (parent != index) &#123; roots[index] = parent; count--; index = parent; &#125; &#125; result.add(count); &#125; return result; &#125; private int find(int[] roots, int index) &#123; while (roots[index] != index) &#123; index = roots[index]; &#125; return index; &#125; &#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Keyboard Row (500)]]></title>
    <url>%2F2017%2F03%2F12%2F2017-03-12-leetcode-solution-Keyboard-Row-500%2F</url>
    <content type="text"><![CDATA[Given a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below. Example 1:12Input: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]Output: [&quot;Alaska&quot;, &quot;Dad&quot;] Note:You may use one character in the keyboard more than once.You may assume the input string will only contain letters of alphabet. 解法1：这题就是掌握一下语言中对于string查找相关的操作。JavaJava中的string.toCharArray()，还有查找一个char是否在string里的操作string.indexOf(s) == -1123456789101112131415161718192021222324252627public class Solution &#123; String[] keyboards = &#123;"qwertyuiop","asdfghjkl","zxcvbnm"&#125;; public String[] findWords(String[] words) &#123; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); for (String word: words) &#123; for (String row: keyboards) &#123; boolean temp = true; for (char s: word.toLowerCase().toCharArray()) &#123; if (row.indexOf(s) == -1) &#123; temp = false; break; &#125; &#125; if (temp) &#123; res.add(word); break; &#125; &#125; &#125; String[] r = new String[res.size()]; res.toArray(r); return r; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Construct the rectangle (492)]]></title>
    <url>%2F2017%2F03%2F12%2F2017-03-12-leetcode-solution-Construct-the-rectangle-492%2F</url>
    <content type="text"><![CDATA[For a web developer, it is very important to know how to design a web page’s size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:123451. The area of the rectangular web page you designed must equal to the given target area.2. The width W should not be larger than the length L, which means L &gt;= W.3. The difference between length L and width W should be as small as possible. You need to output the length L and the width W of the web page you designed in sequence.Example:1234Input: 4Output: [2, 2]Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. But according to requirement 2, [1,4] is illegal; according to requirement 3, [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2. Note:The given area won’t exceed 10,000,000 and is a positive integerThe web page’s width and length you designed must be positive integers. 解法1：O(Sqrt(area))按照提议，如果area是一个完全平方数的话正方形的边长就是最佳答案。那么可以从平方根出发，找出 1 &lt;= x &lt;= sqrt(area)当中最大的能被area整除的数就是所要求的。Java1234567891011121314public class Solution &#123; public int[] constructRectangle(int area) &#123; int temp = (int) Math.sqrt(area); while (area % temp != 0 ) &#123; --temp; &#125; int[] res = &#123;area / temp, temp &#125;; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Detect Capital (520)]]></title>
    <url>%2F2017%2F03%2F12%2F2017-03-12-leetcode-solution-Detect-Capital-520%2F</url>
    <content type="text"><![CDATA[Given a word, you need to judge whether the usage of capitals in it is right or not. We define the usage of capitals in a word to be right when one of the following cases holds: All letters in this word are capitals, like “USA”.All letters in this word are not capitals, like “leetcode”.Only the first letter in this word is capital if it has more than one letter, like “Google”.Otherwise, we define that this word doesn’t use capitals in a right way.Example 1:12Input: &quot;USA&quot;Output: True Example 2:12Input: &quot;FlaG&quot;Output: False Note: The input will be a non-empty word consisting of uppercase and lowercase latin letters. 解法1：Regex 表达式感觉这个做法比较像作弊。。Java12345public class Solution &#123; public boolean detectCapitalUse(String word) &#123; return word.matches("[A-Z]+|[a-z]+|[A-Z][a-z]+"); &#125;&#125; 解法2: 常规解法常规的想法，可以判断是否都是大写或者都是小写，或者第2个字母开始是否都是小写。Java1234567891011121314151617public class Solution &#123; public boolean detectCapitalUse(String word) &#123; if (word.equals(word.toUpperCase())) &#123; return true; &#125; if (word.equals(word.toLowerCase())) &#123; return true; &#125; if (word.substring(1).equals(word.substring(1).toLowerCase())) &#123; return true; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Max Consecutive Ones (485)]]></title>
    <url>%2F2017%2F03%2F12%2F2017-03-12-leetcode-solution-Max-Consecutive-Ones-485%2F</url>
    <content type="text"><![CDATA[Given a binary array, find the maximum number of consecutive 1s in this array. Example 1:1234Input: [1,1,0,1,1,1]Output: 3Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. Note: The input array will only contain 0 and 1.The length of input array is a positive integer and will not exceed 10,000 解法1：O(N),一次遍历dp的思想，dp[i] = dp[i - 1] + 1 if dp[i] == 1 else dp[i] = 0, 然后用一个res来记录当前遇到的最大值即可。Java12345678910111213141516public class Solution &#123; public int findMaxConsecutiveOnes(int[] nums) &#123; int count = 0; int res = 0; for (int num: nums) &#123; if (num == 1) &#123; ++count; res = Math.max(res, count); &#125; else &#123; count = 0; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Next Greater Element I (496)]]></title>
    <url>%2F2017%2F03%2F12%2F2017-03-12-leetcode-solution-Next-Greater-Element-I-496%2F</url>
    <content type="text"><![CDATA[You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1’s elements in the corresponding places of nums2. The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number. Example 1:123456Input: nums1 = [4,1,2], nums2 = [1,3,4,2].Output: [-1,3,-1]Explanation: For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1. For number 1 in the first array, the next greater number for it in the second array is 3. For number 2 in the first array, there is no next greater number for it in the second array, so output -1. Example 2:12345Input: nums1 = [2,4], nums2 = [1,2,3,4].Output: [3,-1]Explanation: For number 2 in the first array, the next greater number for it in the second array is 3. For number 4 in the first array, there is no next greater number for it in the second array, so output -1. Note:All elements in nums1 and nums2 are unique.The length of both nums1 and nums2 would not exceed 1000. 解法1：Stack + HashMap: O(N) Time + O(N) Space很好的一道题，主要的思路是在扫描的过程中得出每一个element对应的next greater element。 然后在hashmap中查找所需要的结果。一次遍历找出next greater element的思路是[A,B] 如果B比A大那么B就是A对应的结果。如果B比A小的话要找出第一个比B大的数才是B的结果，而A要等到比A自己大的才可以。那么试想，如果碰到一个递减数列[5,4,3,2,1]如果出现一个6，比前面所有的数都大，这个时候这个6就是所有数的NGE。所以有此我们可以用一个stack来维护递减的数列，只要下一个数比stack的top大，那么top值得NGE就是当前的值。不停的弹出stack的值直到top的值比当前的值大为止。 Java1234567891011121314151617181920212223public class Solution &#123; public int[] nextGreaterElement(int[] findNums, int[] nums) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); for (int num: nums) &#123; while (!stack.isEmpty() &amp;&amp; num &gt; stack.peek()) &#123; map.put(stack.pop(), num); &#125; stack.push(num); &#125; // scan through findNums int[] res = new int[findNums.length]; for (int i = 0; i &lt; res.length; ++i) &#123; res[i] = map.getOrDefault(findNums[i], -1); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode解题: Number of Islands (200)]]></title>
    <url>%2F2017%2F03%2F08%2F2017-03-08-leetcode-solution-Number-of-Islands-200%2F</url>
    <content type="text"><![CDATA[Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: 11110110101100000000Answer: 1 Example 2: 11000110000010000011Answer: 3 解法1：DFS用DFS遍历每一个元素，如果是1就表示有一个岛屿，并且用DFS遍历所有与之相连的节点。并且把他们标注为非岛屿。Java123456789101112131415161718192021222324252627282930313233public class Solution &#123; public int numIslands(char[][] grid) &#123; if (grid.length == 0 || grid[0].length == 0) &#123; return 0; &#125; int res = 0; for (int i = 0; i &lt; grid.length; ++i) &#123; for (int j = 0; j &lt; grid[0].length; ++j) &#123; if (grid[i][j] == '1') &#123; ++res; dfs(grid, i, j); &#125; &#125; &#125; return res; &#125; void dfs (char[][] grid, int i, int j) &#123; if (i &lt; 0 || i &gt;= grid.length || j &lt; 0 || j &gt;= grid[0].length) &#123; return; &#125; if (grid[i][j] == '1') &#123; grid[i][j] = '0'; dfs(grid, i + 1, j); dfs(grid, i - 1, j); dfs(grid, i, j + 1); dfs(grid, i, j - 1); &#125; return; &#125; &#125; 解法2：BFSJava12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class pair &#123; int x, y; public pair(int row, int col) &#123; this.x = row; this.y = col; &#125;&#125;;public class Solution &#123; public int numIslands(char[][] grid) &#123; if (grid.length == 0 || grid[0].length == 0) &#123; return 0; &#125; int res = 0; for (int i = 0; i &lt; grid.length; ++i) &#123; for (int j = 0; j &lt; grid[0].length; ++j) &#123; if (grid[i][j] == &apos;1&apos;) &#123; ++res; bfs(grid, i, j); &#125; &#125; &#125; return res; &#125; private int[][] directions = new int[][] &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;; private void bfs(char[][] grid, int i, int j) &#123; int row = grid.length; int col = grid[0].length; Queue&lt;pair&gt; queue = new LinkedList&lt;pair&gt;(); if (grid[i][j] == &apos;1&apos;) &#123; queue.offer(new pair(i, j)); grid[i][j] = &apos;0&apos;; &#125; while (!queue.isEmpty()) &#123; pair cur = queue.poll(); for (int d = 0; d &lt; directions.length; ++d) &#123; int x = cur.x + directions[d][0]; int y = cur.y + directions[d][1]; if (!isInbound(row, col, x, y)) &#123; continue; &#125; if (grid[x][y] == &apos;1&apos;) &#123; queue.offer(new pair(x,y)); grid[x][y] = &apos;0&apos;; &#125; &#125; &#125; return; &#125; private boolean isInbound(int row, int col, int i, int j) &#123; return i &gt;= 0 &amp;&amp; i &lt; row &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; col; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Graph Valid Tree (261)]]></title>
    <url>%2F2017%2F03%2F08%2F2017-03-08-leetcode-solution-Graph-Valid-Tree-261%2F</url>
    <content type="text"><![CDATA[Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree. For example: Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true. Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false. Hint: Given n = 5 and edges = [[0, 1], [1, 2], [3, 4]], what should your return? Is this case a valid tree?According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.”Note: you can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges. 总结此题用Union Find最简便，DFS 和 BFS 都可以。 解法1： DFS按照题目意思，这是一个undirectedgraph判定是否是tree的问题，那么一个无向图要满足两个条件。一个是要全连通，另一个是要没有环。基本思想是用DFS遍历，如果遍历到之前遇过的节点说明有环。遍历之后如果还有没有遍历过的节点那么就不是全通图。 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Solution &#123; public boolean validTree(int n, int[][] edges) &#123; // Construct the graph using hashmap // Empty Tree // Need to satisfy two conditions, 1) all nodes are linked 2) no cycle in the list if ((edges.length == 0 || edges[0].length == 0)) &#123; return n == 1 || n == 0; &#125; HashMap&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;Integer, List&lt;Integer&gt;&gt;(); for (int[] edge: edges) &#123; if (!map.containsKey(edge[0])) &#123; map.put(edge[0], new ArrayList&lt;Integer&gt;()); &#125; if (!map.containsKey(edge[1])) &#123; map.put(edge[1], new ArrayList&lt;Integer&gt;()); &#125; map.get(edge[0]).add(edge[1]); map.get(edge[1]).add(edge[0]); &#125; List&lt;Boolean&gt; visited = new ArrayList&lt;Boolean&gt;(n); for (int i = 0; i &lt; n; ++i) &#123; visited.add(false); &#125; boolean res = dfs(map, visited, 0, -1); if (!res) &#123; return false; &#125; for (boolean node: visited) &#123; if (!node) &#123; return false; &#125; &#125; return true; &#125; private boolean dfs(HashMap&lt;Integer, List&lt;Integer&gt;&gt; map, List&lt;Boolean&gt; visited, int cur, int prev) &#123; if (visited.get(cur)) &#123; return false; &#125; // prev records the node that link to the current dfs function call visited.set(cur, true); List&lt;Integer&gt; connected = map.get(cur); if (connected == null) &#123; return false; &#125; for (int node: connected) &#123; if (node != prev) &#123; boolean res = dfs(map, visited, node, cur); if (!res) &#123; return false; &#125; &#125; &#125; return true; &#125; &#125; 解法2： BFSBFS 的思想和DFS的基本一致。要注意的是，在存储图的信息的时候，用一个Set比较方便。因为之后当我们在扫描一个节点连接的节点时，要删除对应节点中的edge（就是a连向b，那么b的相连node中一定有a，为了避免出现再遇到a，需要把对应的a从b相连的节点的list中删除，用set比较方便的解决此问题）同时用一个set来维护已经访问过的节点。Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; public boolean validTree(int n, int[][] edges) &#123; if (edges.length == 0 || edges[0].length == 0) &#123; return n == 1 || n == 0; &#125; HashMap&lt;Integer, Set&lt;Integer&gt;&gt; map = new HashMap&lt;Integer, Set&lt;Integer&gt;&gt;(); for (int[] edge: edges) &#123; if (!map.containsKey(edge[0])) &#123; map.put(edge[0], new HashSet&lt;Integer&gt;()); &#125; if (!map.containsKey(edge[1])) &#123; map.put(edge[1], new HashSet&lt;Integer&gt;()); &#125; map.get(edge[0]).add(edge[1]); map.get(edge[1]).add(edge[0]); &#125; // Start BFS Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); queue.offer(0); set.add(0); while (!queue.isEmpty()) &#123; int node = queue.poll(); Set&lt;Integer&gt; elements = map.get(node); if (elements != null) &#123; for (int element: elements) &#123; if (set.contains(element)) &#123; return false; &#125; queue.offer(element); set.add(element); map.get(element).remove(node); &#125; &#125; &#125; // Check the length of Set return set.size() == n; &#125;&#125; 解法3： Union FindUnion Find的算法就不详述了。Union Find很适合来解决Graph找circle的问题。 这里的思路是如果两个node同属于一个parent那么就有circle存在。如果不属于同一个parent，那么就把他们union起来成为一个group.要注意的是最后如果没有出现circle，要比较一下是否每一个node都连接起来了，用edges.length == n - 1就可以判断Java123456789101112131415161718192021222324public class Solution &#123; public boolean validTree(int n, int[][] edges) &#123; int[] parents = new int[n]; Arrays.fill(parents, -1); for (int[] edge: edges) &#123; int x = find(parents, edge[0]); int y = find(parents, edge[1]); if (x == y) &#123; return false; &#125; parents[x] = y; &#125; return edges.length == n - 1; &#125; int find(int[] parents, int x) &#123; while (parents[x] != -1) x = parents[x]; return x; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode solution: Reconstruct Itinerary (332)]]></title>
    <url>%2F2017%2F03%2F05%2F2017-03-05-leetcode-solution-Reconstruct-Itinerary-332%2F</url>
    <content type="text"><![CDATA[Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note:If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [“JFK”, “LGA”] has a smaller lexical order than [“JFK”, “LGB”].All airports are represented by three capital letters (IATA code).You may assume all tickets form at least one valid itinerary.Example 1:tickets = [[“MUC”, “LHR”], [“JFK”, “MUC”], [“SFO”, “SJC”], [“LHR”, “SFO”]]Return [“JFK”, “MUC”, “LHR”, “SFO”, “SJC”].Example 2:tickets = [[“JFK”,”SFO”],[“JFK”,”ATL”],[“SFO”,”ATL”],[“ATL”,”JFK”],[“ATL”,”SFO”]]Return [“JFK”,”ATL”,”JFK”,”SFO”,”ATL”,”SFO”].Another possible reconstruction is [“JFK”,”SFO”,”ATL”,”JFK”,”ATL”,”SFO”]. But it is larger in lexical order. 解法1：建图 + DFS首先是建图的思想，这题看起来就要用DFS，可是没有图可以操作，对于这类的问题要想到用一个Hashmap来构造图的边的关系。这里有一个小的trick是用到了PriorityQueue， 因为最后的结果是要排序后较小的，那么我们构建hashmap的时候就要把每一个start对应的destination排好序，我们就可以用PQ来存储。而题目有一个隐含的条件就是一定有解，那么如果我们在搜索碰到一个没有对应destination的城市的时候，他一定是要求的最后一个string。所以我们在写DFS的时候，要把res.add(cur)放在while语句之后。 Java1234567891011121314151617181920212223242526272829303132public class Solution &#123; public List&lt;String&gt; findItinerary(String[][] tickets) &#123; // Construct the graph, using HashMap HashMap&lt;String, PriorityQueue&lt;String&gt;&gt; map = new HashMap&lt;String, PriorityQueue&lt;String&gt;&gt;(); for (String[] pair: tickets) &#123; if (map.containsKey(pair[0])) &#123; map.get(pair[0]).add(pair[1]); &#125; else &#123; map.put(pair[0], new PriorityQueue&lt;String&gt;()); map.get(pair[0]).add(pair[1]); &#125; &#125; // DFS the map and construct the itinerary List&lt;String&gt; res = new ArrayList&lt;String&gt;(); dfs(map, "JFK", res); Collections.reverse(res); return res; &#125; void dfs(HashMap&lt;String, PriorityQueue&lt;String&gt;&gt; map, String cur, List&lt;String&gt; res) &#123; while (map.containsKey(cur) &amp;&amp; !map.get(cur).isEmpty()) &#123; dfs(map, map.get(cur).poll(), res); &#125; res.add(cur); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>PriorityQueue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Find Bottom Left Tree Value (513)]]></title>
    <url>%2F2017%2F03%2F05%2F2017-03-05-leetcode-solution-Find-Bottom-Left-Tree-Value-513%2F</url>
    <content type="text"><![CDATA[Given a binary tree, find the leftmost value in the last row of the tree. Example 1:Input:123 2 / \1 3 Output:1Example 2:Input:1234567 1 / \ 2 3 / / \4 5 6 / 7 Output:7Note: You may assume the tree (i.e., the given root node) is not NULL. 解法1：DFS, O(N)这题code写起来很简单，思路是这样的：每到一层第一个扫描到的可能就是我们要找的node。那么不断的更新这个node的值最后当遍历完这个树之后就可以得到答案了。DFS遍历的时候维护一个全局变量maxdepth， 然后每下一层就更新一下当前的depth，如果depth比maxdepth大，说明当前到达的是一个新层，而且访问的一定是这一层的最左的元素。Java12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; int val = 0; int maxDepth = 0; public int findBottomLeftValue(TreeNode root) &#123; dfs(root, 1); return val; &#125; void dfs(TreeNode root, int depth) &#123; if (root == null) &#123; return; &#125; if (depth &gt; maxDepth) &#123; maxDepth = depth; val = root.val; &#125; if (root.left != null) &#123; dfs(root.left, depth + 1); &#125; if (root.right != null) &#123; dfs(root.right, depth + 1); &#125; &#125; &#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode solution: The Maze (490)]]></title>
    <url>%2F2017%2F03%2F05%2F2017-03-05-leetcode-solution-The-Maze-490%2F</url>
    <content type="text"><![CDATA[There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won’t stop rolling until hitting a wall. When the ball stops, it could choose the next direction. Given the ball’s start position, the destination and the maze, determine whether the ball could stop at the destination. The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes. Example 1 Input 1: a maze represented by a 2D array123450 0 1 0 00 0 0 0 00 0 0 1 01 1 0 1 10 0 0 0 0 Input 2: start coordinate (rowStart, colStart) = (0, 4)Input 3: destination coordinate (rowDest, colDest) = (4, 4)Output: trueExplanation: One possible way is : left -&gt; down -&gt; left -&gt; down -&gt; right -&gt; down -&gt; right. Example 2 Input 1: a maze represented by a 2D array123450 0 1 0 00 0 0 0 00 0 0 1 01 1 0 1 10 0 0 0 0 Input 2: start coordinate (rowStart, colStart) = (0, 4)Input 3: destination coordinate (rowDest, colDest) = (3, 2)Output: falseExplanation: There is no way for the ball to stop at the destination. Note:There is only one ball and one destination in the maze.Both the ball and the destination exist on an empty space, and they will not be at the same position initially.The given maze does not contain border (like the red rectangle in the example pictures), but you could assume the border of the maze are all walls.The maze contains at least 2 empty spaces, and both the width and height of the maze won’t exceed 100. 解法1：DFS + Memorization这题和一般的地图题或者是有一题岛屿的题目类似，都可以用DFS来解决。这里的难点或者是区别在，球会一直往一个方向滚直到撞到了墙。所以在设计dfs程序的时候要考虑这个问题，可以用一个while循环解决。另外，对于已经访问过的点，不需要额外的申请一个空间来存储，只需要把已经访问过的node对应的maze的值设为-1就可。对于dfs的优化呢，可以用一个dp矩阵来记录每一个扫描过的初始节点是否有解来剪掉一些枝 Java public class Solution { public boolean hasPath(int[][] maze, int[] start, int[] destination) { if (maze.length == 0 || maze[0].length == 0) { return true; } int[][] dp = new int[maze.length][maze[0].length]; for (int[] row: dp) { Arrays.fill(row, -1); } return dfs(maze, start[0], start[1], destination, dp); } private boolean dfs(int[][] maze, int i, int j, int[] destination, int[][] dp) { if (i == destination[0] && j == destination[1]) { return true; } if (dp[i][j]!= -1) { return dp[i][j] == 1 ? true: false; } boolean res = false; int[][] directions = {{0,-1},{-1,0},{0,1},{1,0}}; maze[i][j] = -1; for (int[] dir: directions) { int x = i, y = j; int xinc = dir[0]; int yinc = dir[1]; while (x >= 0 && x < maze.length && y >= 0 && y < maze[0].length && maze[x][y] != 1) { x += xinc; y += yinc; } x -= xinc; y -= yinc; if (maze[x][y] != -1) { res = res || dfs(maze, x,y, destination, dp); } } dp[i][j] = res? 1: 0; maze[i][j] = 0; return res; } }]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Clone Graph (133)]]></title>
    <url>%2F2017%2F03%2F05%2F2017-03-05-leetcode-solution-Clone-Graph-133%2F</url>
    <content type="text"><![CDATA[Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors. OJ’s undirected graph serialization:Nodes are labeled uniquely. We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.As an example, consider the serialized graph {0,1,2#1,2#2,2}. The graph has a total of three nodes, and therefore contains three parts as separated by #. First node is labeled as 0. Connect node 0 to both nodes 1 and 2.Second node is labeled as 1. Connect node 1 to node 2.Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.Visually, the graph looks like the following:123456 1 / \ / \0 --- 2 / \ \_/ 解法1：HashMap + DFS, O(N) Time + O(N) Space思路和有一题linkedlist有random pointer的一样，要分两步进行，一个是要遍历整个图（可选dfs或者bfs），另外要用一个hashmap来记录node和node之间的对应关系。 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for undirected graph. * class UndirectedGraphNode &#123; * int label; * List&lt;UndirectedGraphNode&gt; neighbors; * UndirectedGraphNode(int x) &#123; label = x; neighbors = new ArrayList&lt;UndirectedGraphNode&gt;(); &#125; * &#125;; */public class Solution &#123; public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) &#123; if (node == null) &#123; return node; &#125; HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map = new HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt;(); dfs(node, map); for (UndirectedGraphNode old: map.keySet()) &#123; if (node.neighbors != null) &#123; List&lt;UndirectedGraphNode&gt; ns = new ArrayList&lt;UndirectedGraphNode&gt;(); for (int i = 0; i &lt; old.neighbors.size(); ++i) &#123; ns.add(map.get(old.neighbors.get(i))); &#125; map.get(old).neighbors = ns; &#125; &#125; return map.get(node); &#125; void dfs(UndirectedGraphNode node, HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map) &#123; if (node == null) &#123; return; &#125; if (!map.containsKey(node)) &#123; // Delay the assignment of neighbors UndirectedGraphNode cloned = new UndirectedGraphNode(node.label); map.put(node, cloned); if (node.neighbors!= null) &#123; for (int i = 0; i &lt; node.neighbors.size(); ++i) &#123; dfs(node.neighbors.get(i), map); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Partition Equal Subset Sum (416)]]></title>
    <url>%2F2017%2F02%2F20%2F2017-02-20-leetcode-solution-Partition-Equal-Subset-Sum-416%2F</url>
    <content type="text"><![CDATA[Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Note:Each of the array element will not exceed 100.The array size will not exceed 200.Example 1: Input: [1, 5, 11, 5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11].Example 2: Input: [1, 2, 3, 5] Output: false Explanation: The array cannot be partitioned into equal sum subsets. 解法1：DP: O(N*M), M是要找的子数组的和的大小。这题参考了这个的解法， 这一类的dp的题目里，dp[i]的数组的下标往往表示的是能取得值。这里呢，首先想到要能分成两个同等大小的数组，原数组的和一定必须是偶数，而且这样的话每一个子数组的和是sum/2有了这个之后，dp[i]的定义就变成了原数组是否有一个子数组他的和是i。进一步，我们可以遍历整个数组，对于每一个数x，我们从target开始往下update， dp[x] = dp[x] || dp[target - x]就是说，如果dp[x]要存在的话，dp[target - x]一定也存在。 C++1234567891011121314151617181920212223class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt;= 1) &#123; return false; &#125; int sum = accumulate(nums.begin(), nums.end(), 0); if (sum % 2 != 0) &#123; return false; &#125; int target = sum / 2; vector&lt;bool&gt; dp(target + 1, false); dp[0] = true; for (int i = 0; i &lt; nums.size(); ++i) &#123; for (int j = target; j &gt;= nums[i]; --j) &#123; dp[j] = dp[j] || dp[j - nums[i]]; &#125; &#125; return dp[target]; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode解题: Range Sum Query 2D - Immutable]]></title>
    <url>%2F2017%2F02%2F20%2F2017-02-20-Leetcode-solution-Range-Sum-Query-2D-Immutable%2F</url>
    <content type="text"><![CDATA[Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2). The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8. Example:Given matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]] sumRegion(2, 1, 4, 3) -&gt; 8sumRegion(1, 1, 2, 2) -&gt; 11sumRegion(1, 2, 2, 4) -&gt; 12Note:You may assume that the matrix does not change.There are many calls to sumRegion function.You may assume that row1 ≤ row2 and col1 ≤ col2. 解法1：DP: O(N^2) Initialization, O(1) Function Call这题不难，题目意思是里面的程序会要call很多次。如果不做优化的话每次的成本都是O(N^2).如果我们先预处理一下，把每一个点的累计和存储一下，就是说dp[i][j]是从[0][0]到[i][j]的和。那么当要计算子矩阵的和的时候，我们可以得到如下的关系1sum[i][j] = dp[i][j] - dp[i][j-1] - dp[i-1][j] + dp[i-1][j-1] C++1234567891011121314151617181920212223242526class NumMatrix &#123;public: NumMatrix(vector&lt;vector&lt;int&gt;&gt; matrix) &#123; // initialize dp dp = matrix; // copy assignment operator for (int i = 0; i &lt; matrix.size(); ++i) &#123; for (int j = 0; j &lt; matrix[i].size(); ++j) &#123; dp[i][j] = (i == 0?0: dp[i - 1][j]) + (j == 0?0:dp[i][j - 1]) - (i &gt; 0 &amp;&amp; j &gt; 0?dp[i -1][j - 1]: 0) + matrix[i][j]; &#125; &#125; &#125; int sumRegion(int row1, int col1, int row2, int col2) &#123; return dp[row2][col2] - (row1 &gt; 0? dp[row1 - 1][col2]: 0) - (col1 &gt; 0 ? dp[row2][col1 - 1]: 0) + (row1 &gt; 0 &amp;&amp; col1 &gt;0 ? dp[row1 - 1][col1 - 1]: 0); &#125; private: vector&lt;vector&lt;int&gt;&gt; dp;&#125;;/** * Your NumMatrix object will be instantiated and called as such: * NumMatrix obj = new NumMatrix(matrix); * int param_1 = obj.sumRegion(row1,col1,row2,col2); */ Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode解题: Best time to buy and sell stock with cooldown (309)]]></title>
    <url>%2F2017%2F02%2F19%2F2017-02-19-Leetcode-solution-Best-time-to-buy-and-sell-stock-with-cooldown-309%2F</url>
    <content type="text"><![CDATA[Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)Example: prices = [1, 2, 3, 0, 2]maxProfit = 3transactions = [buy, sell, cooldown, buy, sell] 解法1：DP O(N) Time + O(N) Space这题主要要想到用两个数组来记录每一天的两种状态。一个是第i天持有股票，一个是第i天未持有股票。用sell和buy代表两个数组。buy就是第i天持有股票的投资组合的最大市值。sell就是第i天未持有股票时的投资组合的最大市值。那么初始状态sell[0] = 0, buy[0] = -prices[0]这是表示如果第一天持有股票的话一定是买入操作，那么需要花去prices[0]的钱。那么每一天投资组合的演化可以得出下面的关系123456第i天未持股的最大市值要么是上一天1）持股2）未持股。如果未持股则市值不变，如果持股那么因为第i天一定要卖掉，所以如果上一天持股的话则今天的最大市值只能是buy[i-1]+Prices[i]sell[i] = max(sell[i - 1], buy[i - 1] + prices[i])同理，buy[i] = max(buy[i - 1], sell[i - 2] - prices[i]) 依此写出如下程序，如果要求的话可以对空间进一步优化成O(1)C++123456789101112131415161718192021class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.size() &lt;= 1) &#123; return 0; &#125; int n = prices.size(); vector&lt;int&gt; sell(n, 0); vector&lt;int&gt; buy(n, 0); buy[0] = -prices[0]; for (int i = 1; i &lt; n; ++i) &#123; sell[i] = max(sell[i - 1], buy[i - 1] + prices[i]); buy[i] = max(buy[i - 1], (i &gt; 1? sell[i - 2]:0) - prices[i]); &#125; return sell[n - 1]; &#125;&#125;; 解法1： 另外一种解释以下的说明直接来自leetcode discussion12345678910111213141516171819202122232425262728293031323334351. Define StatesTo represent the decision at index i:buy[i]: Max profit till index i. The series of transaction is ending with a buy.sell[i]: Max profit till index i. The series of transaction is ending with a sell.To clarify:Till index i, the buy / sell action must happen and must be the last action. It may not happen at index i. It may happen at i - 1, i - 2, ... 0.In the end n - 1, return sell[n - 1]. Apparently we cannot finally end up with a buy. In that case, we would rather take a rest at n - 1.For special case no transaction at all, classify it as sell[i], so that in the end, we can still return sell[n - 1]. Thanks @alex153 @kennethliaoke @anshu2.2. Define Recursionbuy[i]: To make a decision whether to buy at i, we either take a rest, by just using the old decision at i - 1, or sell at/before i - 2, then buy at i, We cannot sell at i - 1, then buy at i, because of cooldown.sell[i]: To make a decision whether to sell at i, we either take a rest, by just using the old decision at i - 1, or buy at/before i - 1, then sell at i.So we get the following formula:buy[i] = Math.max(buy[i - 1], sell[i - 2] - prices[i]); sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]);3. Optimize to O(1) SpaceDP solution only depending on i - 1 and i - 2 can be optimized using O(1) space.Let b2, b1, b0 represent buy[i - 2], buy[i - 1], buy[i]Let s2, s1, s0 represent sell[i - 2], sell[i - 1], sell[i]Then arrays turn into Fibonacci like recursion:b0 = Math.max(b1, s2 - prices[i]);s0 = Math.max(s1, b1 + prices[i]);4. Write Code in 5 MinutesFirst we define the initial states at i = 0:We can buy. The max profit at i = 0 ending with a buy is -prices[0].We cannot sell. The max profit at i = 0 ending with a sell is 0. 12345678910111213public int maxProfit(int[] prices) &#123; if(prices == null || prices.length &lt;= 1) return 0; int b0 = -prices[0], b1 = b0; int s0 = 0, s1 = 0, s2 = 0; for(int i = 1; i &lt; prices.length; i++) &#123; b0 = Math.max(b1, s2 - prices[i]); s0 = Math.max(s1, b1 + prices[i]); b1 = b0; s2 = s1; s1 = s0; &#125; return s0;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>DP交叉状态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Longest Palindromic Subsequence (516)]]></title>
    <url>%2F2017%2F02%2F16%2F2017-02-16-leetcode-solution-Longest-Palindromic-Subsequence-516%2F</url>
    <content type="text"><![CDATA[Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000. Example 1:Input: &quot;bbbab&quot; Output:4One possible longest palindromic subsequence is “bbbb”.Example 2:Input: &quot;cbbd&quot; Output:2One possible longest palindromic subsequence is “bb” 解法1：DP: O(N^2)字符串的问题的DP有的时候需要考虑2D的DP解法。这题就是一个列子。假设dp[i][j]是指(i,j)的子字符串的LPS, 那么如果首尾字符相同的话dp[i][j] = dp[i + 1][j - 1] + 2如果不相同的话，可以是错位match，也就是说要么用上尾字符，要么用上头字符。dp[i][j] = max(dp[i+1][j], dp[i][j-1]) C++123456789101112131415161718192021222324252627class Solution &#123;public: int longestPalindromeSubseq(string s) &#123; if (s.size() == 0) return 0; int n = s.size() - 1; int dp[n + 1][n + 1] &#123;0&#125;; for (int i = 0; i &lt;= n; ++i) &#123; dp[i][i] = 1; &#125; for (int i = n - 1; i &gt;= 0; --i) &#123; for (int j = i + 1; j &lt;= n; ++j) &#123; if (s[i] == s[j]) &#123; dp[i][j] = dp[i + 1][j - 1] + 2; &#125; else &#123; dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); &#125; &#125; &#125; return dp[0][n]; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Coin Change (322)]]></title>
    <url>%2F2017%2F02%2F16%2F2017-02-16-leetcode-solution-Coin-Change-322%2F</url>
    <content type="text"><![CDATA[You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1:coins = [1, 2, 5], amount = 11return 3 (11 = 5 + 5 + 1) Example 2:coins = [2], amount = 3return -1. Note:You may assume that you have an infinite number of each kind of coin. 解法1：DP, O(N*M), N 是coin的个数，M是amount的数字用DP来解，因为涉及到了“检验某一种步骤是否可行”。基本思路是假设dp[i]代表的是$i所需要的最少的coins的数目。因为我们的coins的面额是已知的。那么对每一个coins的面额j我们可以有如下的关系1dp[i + coins[j]] = min(dp[i] + 1, dp[i + coins[j]]) 因为dp[i]已知，那么最多的coins就能确定是dp[i] + 1, 直接用下一个可用的coin即可。然后对于coins的array和从1到i循环，不停的更新dp[i], dp[amount]就是我们要求的数值。要注意的是，在更新一个dp[i‘]的时候， 要保证dp[i]已知（！=INT_MAX)而且下标不要超界，还有coins[j]也不要超过INT_MAX (不会overflow)可以用coins[j] &lt;= INT_MAX - iC++123456789101112131415class Solution &#123;public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; vector&lt;int&gt; dp(amount + 1, INT_MAX); dp[0] = 0; // initialize the first data point for (int i = 0; i &lt;= amount; ++i) &#123; for (int j = 0; j &lt; coins.size(); ++j) &#123; if (coins[j] != INT_MAX &amp;&amp; i + coins[j] &lt;= amount &amp;&amp; dp[i] != INT_MAX) &#123; dp[i + coins[j]] = min(dp[i] + 1, dp[i + coins[j]]); &#125; &#125; &#125; return dp[amount] == INT_MAX ? -1: dp[amount]; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Counting Bits (338)]]></title>
    <url>%2F2017%2F02%2F16%2F2017-02-16-leetcode-solution-Counting-Bits-338%2F</url>
    <content type="text"><![CDATA[Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array. Example:For num = 5 you should return [0,1,1,2,1,2]. Follow up: It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?Space complexity should be O(n).Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.Hint: You should make use of what you have produced already.Divide the numbers in ranges like [2-3], [4-7], [8-15] and so on. And try to generate new range from previous.Or does the odd/even status of the number help you in calculating the number of 1s? 解法1：找规律， O（N）本题比较简单的解法也是从找规律而来0 -&gt; 01 -&gt; 12 -&gt; 10 -&gt; 13 -&gt; 11 -&gt; 24 -&gt; 100 -&gt; 15 -&gt; 101 -&gt; 2对于偶数i，他的1的个数是i/2的1的个数杜宇奇数i，他的1的个数是i/的1的个数+1 因为对于一个数除以2的操作就是一个右移操作，而偶数的最低位为0，奇数的最低位为1， 那么右移的时候偶数的1的个数不会变，奇数的1的个数会减少1. 由此写出程序。1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; countBits(int num) &#123; if (num == 0) &#123; return vector&lt;int&gt;&#123;0&#125;; &#125; else if (num == 1) &#123; return vector&lt;int&gt;&#123;0,1&#125;; &#125; vector&lt;int&gt; res&#123;0,1&#125;; for (int i = 2; i &lt;= num; ++i) &#123; if (i % 2 == 0) &#123; res.push_back(res[i/2]); &#125; else &#123; res.push_back(res[i/2] + 1); &#125; &#125; return res; &#125;&#125;; 解法2： HashMap观察现象可以发现，每一个数字如果是2的幂次，那么1的个数为1.如果不是，则 = 1 + dp[数字 - 最接近这个数的2的幂次数]这里dp记录的是每一个数字的1的个数。 12345678910111213141516171819202122232425262728class Solution &#123; public int[] countBits(int num) &#123; if (num == 0) return new int[]&#123;0&#125;; if (num == 1) return new int[]&#123;0, 1&#125;; int[] res = new int[num + 1]; res[0] = 0; res[1] = 1; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); map.put(0, 0); map.put(1, 1); int largest = 1; for (int i = 2; i &lt;= num; i++) &#123; if ( ( i &amp; (i - 1)) == 0) &#123; res[i] = 1; map.put(i, 1); largest = i; &#125; else &#123; res[i] = 1 + map.get(i - largest); map.put(i, res[i]); &#125; &#125; return res; &#125;&#125; 解法3：观察现象，如果是偶数，则结果和偶数/2一样，如果是奇数，那么是奇数/2 + 1. 123456789101112131415161718192021class Solution &#123; public int[] countBits(int num) &#123; if (num == 0) &#123; return new int[]&#123;0&#125;; &#125; if (num == 1) &#123; return new int[]&#123;0, 1&#125;; &#125; int[] res = new int[num + 1]; res[0] = 0; res[1] = 1; for (int i = 2; i &lt;= num; i++) &#123; res[i] = i % 2 == 0 ? res[i &gt;&gt; 1] : res[i &gt;&gt; 1] + 1; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Integer Break (343)]]></title>
    <url>%2F2017%2F02%2F16%2F2017-02-16-leetcode-solution-Integer-Break-343%2F</url>
    <content type="text"><![CDATA[Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get. For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4). Note: You may assume that n is not less than 2 and not larger than 58. Hint: There is a simple O(n) solution to this problem.You may check the breaking results of n ranging from 7 to 10 to discover the regularities. 解法1：找规律， O(N)如果把从2到10的结果写出来可以发现，最大的结果是每一个数先分解成3的和，然后和剩下的数的乘积最大。本题还有DP的解法，之后补上 123456789101112class Solution &#123;public: int integerBreak(int n) &#123; if (n == 2 || n == 3) return n - 1; int res = 1; while (n &gt; 4) &#123; res *= 3; n -= 3; &#125; return res * n; &#125;&#125;; 12345678910111213141516class Solution &#123; public int integerBreak(int n) &#123; if (n &lt;= 1) return n; int[] dp = new int[n + 1]; // stores the max if split the number into 2 or more numbers dp[0] = 0; dp[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i / 2; j++) &#123; int temp = Math.max(dp[j] * dp[i - j], j * (i - j)); dp[i] = Math.max(dp[i], Math.max(j, dp[j]) * Math.max(dp[i - j], (i - j))); &#125; &#125; return dp[n]; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Search Insert Position (35)]]></title>
    <url>%2F2017%2F02%2F16%2F2017-02-16-leetcode-solution-Search-Insert-Position-35%2F</url>
    <content type="text"><![CDATA[Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Here are few examples.1234[1,3,5,6], 5 → 2[1,3,5,6], 2 → 1[1,3,5,6], 7 → 4[1,3,5,6], 0 → 0 解法1：Binary Search O(NLogn)因为是sorted， 用binary search很容易解决。要注意的是最后判断nums[start], nums[end]的时候如果都没有符合的，那么说明要插入的位置是array的尾巴，要返回的结果是end+1， 比如searchInsert([0],1)这样的情况。C++1234567891011121314151617181920212223class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; if (nums.size() == 0) return 0; int start = 0, end = nums.size() -1; while (start + 1 &lt; end) &#123; int mid = start + (end - start) / 2; if (nums[mid] &gt; target) &#123; end = mid; &#125; else &#123; start = mid; &#125; &#125; if (nums[start] &gt;= target) &#123; return start; &#125; if (nums[end] &gt;= target) &#123; return end; &#125; return end + 1; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Find Minimum in Rotated Sorted Array (153)]]></title>
    <url>%2F2017%2F02%2F16%2F2017-02-16-leetcode-solution-Find-Minimum-in-Rotated-Sorted-Array-153%2F</url>
    <content type="text"><![CDATA[Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. You may assume no duplicate exists in the array. 解法1：Binary Search这也是一题经典的binary search的题目。 难点在于怎么判断最小值是在mid的左面还是右面，以此来缩小范围。当搜索的范围[start, end]确定了之后，mid的取值可以有几种情况 start &lt; end, 那么最小值在start和mid之间 start &gt; end, 那么最小值的位置取决于mid和start，end的关系 如果mid &lt; end, 那么最小值一定在start和mid之间 如果mid &gt; end, 那么pivot点一定在mid和end之间。按照这个思路写程序就很简单了。C++123456789101112131415161718192021222324252627class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) &#123; return -1; &#125; int start = 0, end = nums.size() - 1; while (start + 1 &lt; end) &#123; int mid = start + (end - start) / 2; if (nums[start] &lt; nums[end]) &#123; end = mid; &#125; else &#123; if (nums[mid] &lt; nums[end]) &#123; end = mid; &#125; else &#123; start = mid; &#125; &#125; &#125; if (nums[start] &lt; nums[end]) &#123; return nums[start]; &#125; else &#123; return nums[end]; &#125; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解法: Search for a Range (34)]]></title>
    <url>%2F2017%2F02%2F16%2F2017-02-16-leetcode-solution-Search-for-a-Range-34%2F</url>
    <content type="text"><![CDATA[Given an array of integers sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. For example,Given [5, 7, 7, 8, 8, 10] and target value 8,return [3, 4]. 解法1：Binary Search, O(logN)看到在sorted array里找元素的问题，首先想到可以用binary search。 这里用两次binarysearch， 一次找到range的起始点，一次找到最后一个点。C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; if (nums.size() == 0) return vector&lt;int&gt;&#123;-1,-1&#125;; int start = searchFirst(nums, target); int end = searchLast(nums, target); return vector&lt;int&gt;&#123;start, end&#125;; &#125; int searchFirst(vector&lt;int&gt;&amp; nums, int target) &#123; int start = 0, end = nums.size() - 1; while (start + 1 &lt; end) &#123; int mid = start + (end - start) / 2; if (nums[mid] &lt; target) &#123; start = mid; &#125; else &#123; end = mid; &#125; &#125; if (nums[start] == target) &#123; return start; &#125; else if (nums[end] == target) &#123; return end; &#125; else &#123; return -1; &#125; &#125; int searchLast(vector&lt;int&gt;&amp; nums, int target) &#123; int start = 0, end = nums.size() - 1; while (start + 1 &lt; end) &#123; int mid = start + (end - start) / 2; if (nums[mid] &lt;= target) &#123; start = mid; &#125; else &#123; end = mid; &#125; &#125; if (nums[end] == target) &#123; return end; &#125; else if (nums[start] == target) &#123; return start; &#125; else &#123; return -1; &#125; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Sort Colors (75)]]></title>
    <url>%2F2017%2F02%2F09%2F2017-02-09-leetcode-solution-Sort-Colors-75%2F</url>
    <content type="text"><![CDATA[Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note:You are not suppose to use the library’s sort function for this problem. Follow up:A rather straight forward solution is a two-pass algorithm using counting sort.First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s. Could you come up with an one-pass algorithm using only constant space? 解法1： Bucket sort/counting sort, O(N) Time with two passesBucket sort, 统计0,1,2的个数然后再逐个写入C++123456789101112131415161718192021222324252627class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; // bucket sort int red = 0, white = 0, blue = 0; for (int i = 0; i &lt; nums.size(); ++i) &#123; if (nums[i] == 0) &#123; red++; &#125; else if (nums[i] == 1) &#123; white++; &#125; else &#123; blue++; &#125; &#125; int i = 0; for (int j = 1; j &lt;= red; j++) &#123; nums[i++] = 0; &#125; for(int j = 1; j &lt;= white; j++) &#123; nums[i++] = 1; &#125; for (int j = 1; j &lt;= blue; j++) &#123; nums[i++] = 2; &#125; &#125;&#125;; Java1 解法2： One pass O(N)类似于双指针的思路,这里用了一个low记录0的位置,用了一个high记录2的位置,然后从左往右扫描. 如果是0或者2就知道该插入在什么地方,如果是1那么就往前移动.C++12345678910111213141516171819202122232425262728293031class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt;= 1) &#123; return; &#125; int low = 0, high = nums.size() -1; int mid = 0; while (mid &lt; nums.size() &amp;&amp; mid &lt;= high) &#123; if (nums[mid] == 0) &#123; swap(nums, low, mid); ++low; ++mid; &#125; else if (nums[mid] == 2) &#123; swap(nums, high, mid); --high; &#125; else &#123; ++mid; &#125; &#125; return; &#125; void swap(vector&lt;int&gt;&amp; nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] =temp; &#125;&#125;; ###解法3: One pass O(N) ###用两个指针记录zero和one插入的位置。对于每一个新数字，先插入最大的数字。因为如果是其他数字的话在之后的操作中会被覆盖。然后从大到小的判断当前数字为哪一个。如果是1那么只移动one的位置并插入。如果是zero，那么需要先移动one并且赋值，然后移动zero再赋值。如果zero插入的位置原本是一个1，那么被覆盖的1就被one的指针找回了。Java123456789101112131415161718192021public class Solution &#123; public void sortColors(int[] nums) &#123; int zero = -1; int one = -1; for (int k = 0; k &lt; nums.length; ++k) &#123; int v = nums[k]; nums[k] = 2; // no matter what, set this to 2 if (v == 0) &#123; nums[++one] = 1; nums[++zero] = 0; &#125; else if (v == 1) &#123; nums[++one] = 1; // advance one &#125; &#125; return; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Jump Game (55)]]></title>
    <url>%2F2017%2F02%2F09%2F2017-02-09-leetcode-solution-Jump-Game-55%2F</url>
    <content type="text"><![CDATA[Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. For example:123A = [2,3,1,1,4], return true.A = [3,2,1,0,4], return false. 解法1： Greedy, O(N) Time一个贪心的解法, 主要是维护一个variable叫reach, 他记录目前为止能达到的最远的距离. 然后扫描vector,如果当前的位置是不能达到的,则返回false.否则更新reach的值,进入下一个元素.C++1234567891011121314151617class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) &#123; return false; &#125; int reach = 0; int i = 0; for (; i &lt; nums.size() &amp;&amp; reach &gt;= i; ++i) &#123; reach = max(reach, i + nums[i]); &#125; return i == nums.size(); &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解法: Next Permutation (31)]]></title>
    <url>%2F2017%2F02%2F09%2F2017-02-09-leetcode-solution-Next-Permutation-31%2F</url>
    <content type="text"><![CDATA[Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place, do not allocate extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.1231,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 解法1： O(N) Time一个固定的解法,可以写出来几个答案然后从当中找结论.解法是:从右往左找到第一个数字使得num[i] &lt; num[i + 1], 设i为pivot从右往左找到第一个数字使得num[j] &gt; num[pivot], 记录j将pivot和j指向的item互换将pivot右边的数组reverse 要注意的是,在第二步中由于pviot右面的数组一定是sorted(从大到小), 所以我们在寻找第一个比pivot数字大的时候可以采用binary search来提供一些小的optimization. C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt;= 1) &#123; return; &#125; int pivot = -1; for (int i = nums.size() - 1; i &gt;= 1; --i) &#123; if (nums[i - 1] &lt; nums[i]) &#123; pivot = i - 1; break; &#125; &#125; if (pivot == -1) &#123; std::reverse(nums.begin(), nums.end()); return; &#125; // find the first element that is larger than nums[pivot] int ex = bsearch(nums, pivot + 1, nums.size() - 1, nums[pivot]); int temp = nums[pivot]; nums[pivot] = nums[ex]; nums[ex] = temp; // reverse ex + 1 ~ end std::reverse(nums.begin() + pivot + 1, nums.end()); return; &#125; int bsearch(vector&lt;int&gt;&amp; nums, int start, int end, int ref) &#123; while (start + 1 &lt; end) &#123; int mid = start + (end - start) / 2; if (nums[mid] &gt; ref) &#123; start = mid; &#125; else &#123; end = mid; &#125; &#125; if (nums[end] &gt; ref) &#123; return end; &#125; return start; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解法: Container With Most Water (11)]]></title>
    <url>%2F2017%2F02%2F09%2F2017-02-09-leetcode-solution-Container-With-Most-Water-11%2F</url>
    <content type="text"><![CDATA[Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. 解法1： Two pointers, O(N) Time, One pass比较典型的two pointers的题目. 主要思路是, 一个container的面积是(right- left) * (左右两块挡板较短的那一块的长度)那么要maximize一个面积,可以做的是增长距离,或者是增长板的长度.设两个指针,从左右边界开始,这个时候,我们的长度是最长的.计算一下当前的面积如果要提高这个面积, 因为只能缩小长度,则我们必须要提高短板的长度.那么不停的移动左右指针(哪一根指针指向的板较短就移哪一根)C++12345678910111213141516class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int area = INT_MIN; int left = 0, right = height.size() - 1; while (left &lt; right) &#123; area = max(area, (right - left) * (min(height[left], height[right]))); if (height[left] &lt;= height[right]) &#123; ++left; &#125; else &#123; --right; &#125; &#125; return area; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Verify Preorder Serialization of a Binary Tree (331)]]></title>
    <url>%2F2017%2F02%2F09%2F2017-02-09-leetcode-solution-Verify-Preorder-Serialization-of-a-Binary-Tree-331%2F</url>
    <content type="text"><![CDATA[One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as #.1234567 _9_ / \ 3 2 / \ / \ 4 1 # 6/ \ / \ / \# # # # # # For example, the above binary tree can be serialized to the string “9,3,4,#,#,1,#,#,2,#,6,#,#”, where # represents a null node. Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree. Each comma separated value in the string must be either an integer or a character ‘#’ representing null pointer. You may assume that the input format is always valid, for example it could never contain two consecutive commas such as “1,,3”. Example 1:&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;Return true Example 2:&quot;1,#&quot;Return false Example 3:&quot;9,#,#,1&quot;Return false 解法1： 剪叶子的思路每当遇到两个连续的”#”的时候,并且前一个字符不是”#”的时候,可以判断这是一个叶子.如果我们把每一个叶子剪掉并且替换成”#”的话,我们实际上在不停的从下往上的砍叶子直到砍完为止.这样的思路对于binary tree在其他题目中似乎也见过.那么对于一个valid的binary tree,最后一定是能砍光的. 以此可以得出如下的算法.C++注意的是这里用vector当成一个stack用,因为我们需要access前面的2个元素,用vector效率较高.123456789101112131415161718class Solution &#123;public: bool isValidSerialization(string preorder) &#123; std::istringstream ss(preorder); vector&lt;string&gt; s; string item; while (getline(ss, item, ',')) &#123; s.push_back(item); while (s.size() &gt;= 3 &amp;&amp; item == "#" &amp;&amp; s[s.size() - 2] == "#" &amp;&amp; s[s.size() -3] != "#") &#123; s.pop_back(); s.pop_back(); s.pop_back(); s.push_back(item); &#125; &#125; return s.size() == 1 &amp;&amp; s[0] == "#"; &#125;&#125;; 1234567891011121314151617181920class Solution &#123; public boolean isValidSerialization(String preorder) &#123; if (preorder == null || preorder.length() == 0) &#123; return true; &#125; Stack&lt;String&gt; stack = new Stack&lt;&gt;(); String[] nodes = preorder.split(","); for (String ch : nodes) &#123; while (ch.equals("#") &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek().equals("#")) &#123; stack.pop(); if (stack.isEmpty()) return false; stack.pop(); &#125; stack.push(ch); &#125; return stack.size() == 1 &amp;&amp; stack.peek().equals("#"); &#125;&#125; 解法2: outbound - inbound这个解法的核心是. 首先把所有的NULL NODE看成是valid node. 每一个node的inbound/outbound的connection可以统计如下: 每一个非NULL节点都有两个outbound和一个inbound (除了root) 每一个NULL节点都有一个inbound和0个outbound 一个valid的树如果计算所有的outbound和inbound的差,一定是等于0的,并且从root到任意一节点, outbound - inbound都一定不是负数.有了这个结论之后, code写起来很直白.C++lang: cpp1234567891011121314class Solution &#123;public: bool isValidSerialization(string preorder) &#123; std::istringstream ss(preorder); string item; int diff = 1; while (getline(ss, item, &apos;,&apos;)) &#123; if (--diff &lt; 0) return false; if (item != &quot;#&quot;) diff += 2; &#125; return diff == 0; &#125;&#125;; 12345678910111213class Solution &#123; public boolean isValidSerialization(String preorder) &#123; String[] nodes = preorder.split(","); int diff = 1; // calculate outdegree - indegree for (int i = 0; i &lt; nodes.length; i++) &#123; diff--; if (diff &lt; 0) return false; if (!nodes[i].equals("#")) diff += 2; &#125; return diff == 0; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: 132 Pattern (456)]]></title>
    <url>%2F2017%2F02%2F04%2F2017-02-04-leetcode-Solution-132-Pattern-456%2F</url>
    <content type="text"><![CDATA[Given a sequence of n integers a1, a2, …, an, a 132 pattern is a subsequence ai, aj, ak such that i &lt; j &lt; k and ai &lt; ak &lt; aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list. Note: n will be less than 15,000. Example 1:12345Input: [1, 2, 3, 4]Output: FalseExplanation: There is no 132 pattern in the sequence. Example 2:12345Input: [3, 1, 4, 2]Output: TrueExplanation: There is a 132 pattern in the sequence: [1, 4, 2]. Example 3:12345Input: [-1, 3, 2, 0]Output: TrueExplanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0]. 解法1： O(N) Time参考了discussion的解答, 基本思想是我们从后往前扫描. 用一个stack维护一个递增的序列, stack中的值则是s2的备选. 每当扫描一个新数时,先比较是否比s3小,如果比s3小则说明已找到答案.如果比s3大则更新s3和s2的值.更新的时候: 把stack中所有比当前值小的数弹出, 每一个弹出的数都是s3的备选.C++12345678910111213141516171819class Solution &#123;public: bool find132pattern(vector&lt;int&gt;&amp; nums) &#123; int s3 = INT_MIN; stack&lt;int&gt; s2; for (int i = nums.size() - 1; i &gt;= 0; --i) &#123; if (nums[i] &lt; s3) &#123; return true; &#125; while (!s2.empty() &amp;&amp; s2.top() &lt; nums[i]) &#123; s3 = s2.top(); s2.pop(); &#125; s2.push(nums[i]); &#125; return false; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Remove K Digits (402)]]></title>
    <url>%2F2017%2F02%2F04%2F2017-02-04-leetcode-solution-Remove-K-Digits-402%2F</url>
    <content type="text"><![CDATA[Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible. Note:The length of num is less than 10002 and will be ≥ k.The given num does not contain any leading zero.Example 1:123Input: num = &quot;1432219&quot;, k = 3Output: &quot;1219&quot;Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest. Example 2:123Input: num = &quot;10200&quot;, k = 1Output: &quot;200&quot;Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes. Example 3:123Input: num = &quot;10&quot;, k = 2Output: &quot;0&quot;Explanation: Remove all the digits from the number and it is left with nothing which is 0. 解法1： 贪心算法这题用贪心的算法, 观察可以发现如果每次remove的时候满足if (num[i] &gt; num[i + 1]), 那么得到的数一定是最小的.这里可以用一个string来存储当前扫描的结果,如果发现现在的字符比string的最后一个字符小,那么就把string的最后一个字符去掉. (目的是维护一个递增的数列)最后呢,我们只需要去前num.size() - k个数即可.要注意的是因为每次去除数字的时候k数会变,所以一开始需要用一个变量存储初值.最后返回的时候要去掉leading zero.C++123456789101112131415161718192021222324252627282930class Solution &#123;public: string removeKdigits(string num, int k) &#123; if (k &gt;= num.size()) &#123; return "0"; &#125; string res = ""; int n = k; for (auto ch : num) &#123; while (!res.empty() &amp;&amp; res.back() &gt; ch &amp;&amp; k &gt; 0) &#123; k--; res.pop_back(); &#125; res.push_back(ch); &#125; int start = 0; while (res[start] == '0') &#123;start++;&#125; // Take first num.size() - k elements if (start &gt;= res.size()) &#123; return "0"; &#125; else &#123; return res.substr(start, min(start + num.size() - n, res.size())); &#125; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Stack</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Simplify Path (71)]]></title>
    <url>%2F2017%2F02%2F04%2F2017-02-04-leetcode-solution-Simplify-Path-71%2F</url>
    <content type="text"><![CDATA[Total Accepted: 74685Total Submissions: 309287Difficulty: MediumContributors: AdminGiven an absolute path for a file (Unix-style), simplify it. For example,path = &quot;/home/&quot;, =&gt; &quot;/home&quot;path = &quot;/a/./b/../../c/&quot;, =&gt; &quot;/c&quot; Corner Cases:Did you consider the case where path = &quot;/../&quot;?In this case, you should return &quot;/&quot;.Another corner case is the path might contain multiple slashes ‘/‘ together, such as &quot;/home//foo/&quot;.In this case, you should ignore redundant slashes and return &quot;/home/foo&quot;. 解法1： Stack比较清楚的思路是, 用一个stack来存储每一级的path, 如果遇到”.”则跳过,如果遇到”..”表明要前进一级, 那就把当前的栈顶的path弹出最后栈就是存放的reverse过的path,一个个把他们串起来就可以了.C++12345678910111213141516171819202122232425262728class Solution &#123;public: string simplifyPath(string path) &#123; stack&lt;string&gt; items; string item = ""; stringstream ss(path); while(getline(ss, item, '/')) &#123; if (item.size() == 0 || item == ".") &#123; continue; &#125; else if (item == "..") &#123; if (!items.empty()) &#123; items.pop(); &#125; &#125; else &#123; items.push(item); &#125; &#125; string res = ""; while (!items.empty()) &#123; res += "/" + items.top() + res; &#125; return res.empty() ? "/" : res; &#125;&#125;; 也可以用一个deque来解决，这样在结束了之后不需要reverse stack里的结果。1234567891011121314151617181920212223242526class Solution &#123; public String simplifyPath(String path) &#123; Deque&lt;String&gt; deque = new LinkedList&lt;String&gt;(); String[] comps = path.split("/"); for (String comp : comps) &#123; if (comp.equals("..")) &#123; deque.pollLast(); &#125; else if (comp.equals(".") || comp.equals("")) &#123; continue; &#125; else &#123; deque.offerLast(comp); &#125; &#125; StringBuilder sb = new StringBuilder(); while (!deque.isEmpty()) &#123; sb.append("/" + deque.pollFirst()); &#125; return sb.length() == 0 ? "/" : sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Stack</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Decode String (394)]]></title>
    <url>%2F2017%2F02%2F04%2F2017-01-26-leetcode-solution-Decode-String-394%2F</url>
    <content type="text"><![CDATA[Given an encoded string, return it’s decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like 3a or 2[4]. Examples:123s = &quot;3[a]2[bc]&quot;, return &quot;aaabcbc&quot;.s = &quot;3[a2[c]]&quot;, return &quot;accaccacc&quot;.s = &quot;2[abc]3[cd]ef&quot;, return &quot;abcabccdcdcdef&quot;. 解法1： 递归主要的想法就是， 每一个数字后面一定跟着一个左括号。 而左括号里面的东西是另外一个decode的过程，一个decode结束的标志是要么string结束了，或者是遇到了右括号（[),要注意的是,为了要不停的往前扫描,我们在递归函数返回的时候需要记录当前扫描到的位置. 可以用辅助class解决,在c++里也可以用引用解决这个问题.C++12345678910111213141516171819202122232425262728293031class Solution &#123;public: string decodeString(string s) &#123; int pos = 0; string res = decode(s, pos); return res; &#125; string decode(string s, int&amp; pos) &#123; string res = ""; while (pos &lt; s.size() &amp;&amp; s[pos] != ']') &#123; if (!isdigit(s[pos])) &#123; res += s[pos]; &#125; else &#123; int start = pos; while (pos &lt; s.size() &amp;&amp; isdigit(s[pos])) &#123; pos++; &#125; int number = stoi(s.substr(start, pos)); pos++; // skip the [ string next = decode(s, pos); pos++; // since decode stops at ] or at the end of string, we need to skip ] for (int i = 0; i &lt; number; ++i) &#123; res += next; &#125; &#125; &#125; return res; &#125; &#125;; Java1 解法2: Stack用递归的算法如果要用iteration的办法解决一般会用到Stack. 基本的思路是用两个stack分别记录数字和字符, 当遇到”]”时使用当前栈顶的字母和数字来进行decode, 然后decode的结果要存入字母的栈顶.最后的结果要么是当前的字符串, 要么是栈顶的字符串.C++lang: cpp12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: string decodeString(string s) &#123; stack&lt;int&gt; numbers; stack&lt;string&gt; decoded; string t; // 记录在遇到&quot;[&quot;之前的string int number = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; if (isdigit(s[i])) &#123; number = number * 10 + s[i] - &apos;0&apos;; &#125; else if (s[i] == &apos;[&apos;) &#123; numbers.push(number); number = 0; decoded.push(t); // 把当前所记录到的string存入栈中 t = &quot;&quot;; &#125; else if (s[i] == &apos;]&apos;) &#123; int rep = numbers.top(); numbers.pop(); for (int j = 0; j &lt; rep; ++j) &#123; decoded.top() += t; // t记录了当前扫描到还没有decode的string &#125; t = decoded.top(); decoded.pop(); &#125; else &#123; t += s[i]; &#125; &#125; return decoded.empty()? t : decoded.top(); &#125;&#125;;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Mini Parser (385)]]></title>
    <url>%2F2017%2F01%2F26%2F2017-01-26-leetcode-solution-Mini-Parser-385%2F</url>
    <content type="text"><![CDATA[Given a nested list of integers represented as a string, implement a parser to deserialize it. Each element is either an integer, or a list – whose elements may also be integers or other lists. Note: You may assume that the string is well-formed: String is non-empty.String does not contain white spaces.String contains only digits 0-9, [, - ,, ].Example 1:123Given s = &quot;324&quot;,You should return a NestedInteger object which contains a single integer 324. Example 2:123456789Given s = &quot;[123,[456,[789]]]&quot;,Return a NestedInteger object containing a nested list with 2 elements:1. An integer containing value 123.2. A nested list containing two elements: i. An integer containing value 456. ii. A nested list with one element: a. An integer containing value 789. 解法1： Iterative这题自己写的stack版本怎么也过不了OJ， 参考了这篇帖子的解法C++123456789101112131415161718192021222324252627class Solution &#123;public: NestedInteger deserialize(string s) &#123; if (s.empty()) return NestedInteger(); if (s[0] != '[') return NestedInteger(stoi(s)); stack&lt;NestedInteger&gt; st; int start = 1; for (int i = 0; i &lt; s.size(); ++i) &#123; if (s[i] == '[') &#123; st.push(NestedInteger()); start = i + 1; &#125; else if (s[i] == ',' || s[i] == ']') &#123; if (i &gt; start) &#123; st.top().add(NestedInteger(stoi(s.substr(start, i - start)))); &#125; start = i + 1; if (s[i] == ']') &#123; if (st.size() &gt; 1) &#123; NestedInteger t = st.top(); st.pop(); st.top().add(t); &#125; &#125; &#125; &#125; return st.top(); &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Flatten Nested List Iterator (341)]]></title>
    <url>%2F2017%2F01%2F23%2F2017-01-23-leetcode-solution-Flatten-Nested-List-Iterator-341%2F</url>
    <content type="text"><![CDATA[Given a nested list of integers, implement an iterator to flatten it. Each element is either an integer, or a list – whose elements may also be integers or other lists. Example 1:Given the list [[1,1],2,[1,1]], By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1]. Example 2:Given the list [1,[4,[6]]], By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6]. 解法1： Stack， O(N) Time, O(N) Space, N is the number of total items这题是用iteration的办法解决递归的问题，一般此类问题容易想到用stack解决。这题哪里可以用stack呢？每一个nestedInteger都可能是一个list of nestedInteger， 那么我们对于每一个元素，如果是单数，则任务完成，如果是一个list， 那么我们把所有的元素都推入栈中，直到第一个元素是单数或者到遍历结束为止。 由于栈是FILO, 所以每次推入的时候需要从后往前推。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * class NestedInteger &#123; * public: * // Return true if this NestedInteger holds a single integer, rather than a nested list. * bool isInteger() const; * * // Return the single integer that this NestedInteger holds, if it holds a single integer * // The result is undefined if this NestedInteger holds a nested list * int getInteger() const; * * // Return the nested list that this NestedInteger holds, if it holds a nested list * // The result is undefined if this NestedInteger holds a single integer * const vector&lt;NestedInteger&gt; &amp;getList() const; * &#125;; */class NestedIterator &#123;public: NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) &#123; for (int i = nestedList.size() - 1; i &gt;= 0; --i) &#123; s.push(nestedList[i]); &#125; &#125; int next() &#123; int res = s.top().getInteger(); s.pop(); return res; &#125; bool hasNext() &#123; while (!s.empty()) &#123; if (s.top().isInteger()) &#123; return true; &#125; vector&lt;NestedInteger&gt; cur = s.top().getList(); s.pop(); for (int i = cur.size() - 1; i &gt;= 0; --i) &#123; s.push(cur[i]); &#125; &#125; return false; &#125;private: stack&lt;NestedInteger&gt; s;&#125;;/** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i(nestedList); * while (i.hasNext()) cout &lt;&lt; i.next(); */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * public interface NestedInteger &#123; * * // @return true if this NestedInteger holds a single integer, rather than a nested list. * public boolean isInteger(); * * // @return the single integer that this NestedInteger holds, if it holds a single integer * // Return null if this NestedInteger holds a nested list * public Integer getInteger(); * * // @return the nested list that this NestedInteger holds, if it holds a nested list * // Return null if this NestedInteger holds a single integer * public List&lt;NestedInteger&gt; getList(); * &#125; */public class NestedIterator implements Iterator&lt;Integer&gt; &#123; Stack&lt;NestedInteger&gt; stack; public NestedIterator(List&lt;NestedInteger&gt; nestedList) &#123; stack = new Stack&lt;NestedInteger&gt;(); for (int i = nestedList.size() - 1; i &gt;= 0; i--) &#123; stack.push(nestedList.get(i)); &#125; &#125; @Override public Integer next() &#123; int res = stack.pop().getInteger(); return res; &#125; @Override public boolean hasNext() &#123; while (!stack.isEmpty()) &#123; if (stack.peek().isInteger()) &#123; return true; &#125; NestedInteger top = stack.pop(); List&lt;NestedInteger&gt; list = top.getList(); for (int i = list.size() - 1; i &gt;= 0; i--) &#123; stack.push(list.get(i)); &#125; &#125; return false; &#125;&#125;/** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i = new NestedIterator(nestedList); * while (i.hasNext()) v[f()] = i.next(); */]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Letter Combinations of a Phone Number (17)]]></title>
    <url>%2F2017%2F01%2F23%2F2017-01-23-leetcode-solution-Letter-Combinations-of-a-Phone-Number-17%2F</url>
    <content type="text"><![CDATA[Given a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. 12Input:Digit string &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. Note:Although the above answer is in lexicographical order, your answer could be in any order you want. 解法1：先建一个map来存储每一个字母可以映射的字母，然后就是常规的backtracking的解法。没有特殊的地方。C++1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; unordered_map&lt;char, vector&lt;char&gt;&gt; map; map['2'] = vector&lt;char&gt; &#123;'a','b','c'&#125;; map['3'] = vector&lt;char&gt; &#123;'d','e','f'&#125;; map['4'] = vector&lt;char&gt; &#123;'g','h','i'&#125;; map['5'] = vector&lt;char&gt; &#123;'j','k','l'&#125;; map['6'] = vector&lt;char&gt; &#123;'m','n','o'&#125;; map['7'] = vector&lt;char&gt; &#123;'p','q','r','s'&#125;; map['8'] = vector&lt;char&gt; &#123;'t','u','v'&#125;; map['9'] = vector&lt;char&gt; &#123;'w','x','y','z'&#125;; vector&lt;string&gt; res; string cur = ""; if (digits.size() == 0) &#123; return res; &#125; helper(digits, 0, cur, res, map); return res; &#125; void helper(string digits, int pos, string cur, vector&lt;string&gt;&amp; res, unordered_map&lt;char, vector&lt;char&gt;&gt;&amp; map) &#123; if (cur.size() == digits.size()) &#123; res.push_back(cur); return; &#125; for (int i = pos; i &lt; digits.size(); ++i) &#123; char digit = digits[i]; if (!map.count(digit)) &#123; continue; &#125; else &#123; vector&lt;char&gt; dict = map[digit]; for (int j = 0; j &lt; dict.size(); ++j) &#123; string temp = cur + dict[j]; helper(digits, i + 1, temp, res, map); &#125; &#125; &#125; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Permutation II (47)]]></title>
    <url>%2F2017%2F01%2F21%2F2017-01-21-leetcode-solution-Permutation-II-47%2F</url>
    <content type="text"><![CDATA[Given a collection of numbers that might contain duplicates, return all possible unique permutations. For example,[1,1,2] have the following unique permutations:12345[ [1,1,2], [1,2,1], [2,1,1]] 解法1： O(n!)主要是理解在递归的过程中，怎么算一个重复的数字。这里重复是指如果当前数和前一个数相同（排序后）， 并且前面一个数还没有被使用过的情况下，那么这个数算重复了（因为可能的答案已经被从前一个数字出发的递归中概括了）。C++12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; if (nums.empty()) &#123; return res; &#125; vector&lt;int&gt; cur; vector&lt;bool&gt; visited (nums.size(), false); std::sort(nums.begin(), nums.end()); helper(nums, visited, cur, res); return res; &#125; void helper(vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp; visited, vector&lt;int&gt;&amp; cur, vector&lt;vector&lt;int&gt;&gt;&amp; res) &#123; if (cur.size() == nums.size()) &#123; res.push_back(cur); return; &#125; for (int i = 0; i &lt; nums.size(); ++i) &#123; if (visited[i]) continue; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !visited[i - 1]) continue; cur.push_back(nums[i]); visited[i] = true; helper(nums, visited, cur, res); cur.pop_back(); visited[i] = false; &#125; return; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Permutations (46)]]></title>
    <url>%2F2017%2F01%2F21%2F2017-01-21-leetcode-solution-Permutations-46%2F</url>
    <content type="text"><![CDATA[Given a collection of distinct numbers, return all possible permutations. For example,[1,2,3] have the following permutations:12345678[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 解法1： O(n!)也是经典的backtracking的问题，对于这种permutation的问题， 要维护一个visited数组来记录每一个元素是否被选取了，因为这里每次都是从头开始扫描。 递归终止的条件是当选取的答案的长度和原数组的长度一致的时候就说明一个permutation已经完成。因为有n!个组合，每一个组合访问一次，总的复杂度是O（n!).C++12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; if (nums.empty()) &#123; return res; &#125; vector&lt;bool&gt; visited (nums.size(), false); vector&lt;int&gt; cur; helper(nums, visited, cur, res); return res; &#125; void helper(vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp; visited, vector&lt;int&gt;&amp; cur, vector&lt;vector&lt;int&gt;&gt;&amp; res) &#123; if (cur.size() == nums.size()) &#123; res.push_back(cur); return; &#125; for (int i = 0; i &lt; nums.size(); ++i) &#123; if (!visited[i]) &#123; cur.push_back(nums[i]); visited[i] = true; helper(nums, visited, cur, res); cur.pop_back(); visited[i] = false; &#125; &#125; return; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Combination Sum II (40)]]></title>
    <url>%2F2017%2F01%2F21%2F2017-01-21-leetcode-solution-Combination-Sum-II-40%2F</url>
    <content type="text"><![CDATA[Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination. Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,A solution set is:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 解法1：这题和Combination Sum的唯一区别是每一个数字只能使用一次，那么每一次挑选的时候无论是否有解都往前进一格就可以了。C++12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; current; sort(candidates.begin(),candidates.end()); backTracking(candidates.begin(),current,res,candidates,target); return res;&#125;void backTracking(vector&lt;int&gt;::iterator n, vector&lt;int&gt;&amp; current,vector&lt;vector&lt;int&gt;&gt;&amp; res, const vector&lt;int&gt;&amp; candidates, int target)&#123; if(!target) res.push_back(current); else if(target&gt;0)&#123; for(;n!=candidates.end()&amp;&amp;*n&lt;=target;++n)&#123; current.push_back(*n); backTracking(n+1,current,res,candidates,target-*n); current.pop_back(); while(n+1!=candidates.end()&amp;&amp;*(n+1)==*n) ++n; &#125; &#125;&#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Combination Sum (39)]]></title>
    <url>%2F2017%2F01%2F21%2F2017-01-21-leetcode-solution-Combination-Sum-39%2F</url>
    <content type="text"><![CDATA[Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.For example, given candidate set [2, 3, 6, 7] and target 7,A solution set is:1234[ [7], [2, 2, 3]] 解法1：经典的backtracking的做法。 一个可能的小改进是可以先对原数组进行排序，然后再判断target是否还大于当前可选的节点，这样可以提高一点效率。C++1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; if (candidates.size() == 0 || target &lt;= 0) &#123; return res; &#125; vector&lt;int&gt; cur; helper(candidates, target, 0, cur, res); return res; &#125; void helper(vector&lt;int&gt;&amp; candidates, int target, int pos, vector&lt;int&gt;&amp; cur, vector&lt;vector&lt;int&gt;&gt;&amp; res) &#123; if (target &lt; 0) &#123; return; &#125; if (target == 0) &#123; res.push_back(cur); return; &#125; for (int i = pos; i &lt; candidates.size(); ++i) &#123; cur.push_back(candidates[i]); helper(candidates, target - candidates[i], i,cur, res); cur.pop_back(); &#125; return; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Combinations (77)]]></title>
    <url>%2F2017%2F01%2F17%2F2017-01-17-leetcode-solution-Combinations-77%2F</url>
    <content type="text"><![CDATA[Given two integers n and k, return all possible combinations of k numbers out of 1 … n. For example,If n = 4 and k = 2, a solution is:12345678[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 解法1： Backtracking常规的backtracking的题目，这里的特殊点是每一次要更新还剩下需要挑选的数字的个数。 然后用另外一个变量pos记录当前已经探索到的数字的位置。 C++12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; res; if (k &lt;= 0 || n == 0) &#123; return res; &#125; vector&lt;int&gt; cur; helper(n, k, 1, cur, res); return res; &#125; void helper(int n, int k, int pos, vector&lt;int&gt;&amp; cur, vector&lt;vector&lt;int&gt;&gt;&amp; res) &#123; if (k == 0) &#123; res.push_back(cur); return; &#125; for (int i = pos; i &lt;= n; ++i) &#123; cur.push_back(i); helper(n, k - 1, i + 1, cur, res); cur.pop_back(); &#125; return; &#125; &#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Subsets II (90)]]></title>
    <url>%2F2017%2F01%2F17%2F2017-01-17-leetcode-solution-Subsets-II-90%2F</url>
    <content type="text"><![CDATA[Given a collection of integers that might contain duplicates, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. For example,If nums = [1,2,2], a solution is:12345678[ [2], [1], [1,2,2], [2,2], [1,2], []] 解法1：还是用通用的backtracking的模板，这里考察的是一个去重的feature。 对于题目意思中需要排除掉重复情况的时候， 我们首先要记得要把原数组进行排序。然后去重时对于每一个选取的元素，考虑是否和之前的一致（或者是这次循环中第一个选取的值）C++12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; temp; // sort the nums std::sort(nums.begin(), nums.end()); helper(nums, 0, temp, res); return res; &#125; void helper(vector&lt;int&gt;&amp; nums, int pos, vector&lt;int&gt;&amp; cur, vector&lt;vector&lt;int&gt;&gt;&amp; res) &#123; res.push_back(cur); if (pos == nums.size()) &#123; return; &#125; for (int i = pos; i &lt; nums.size(); ++i) &#123; if (i == pos || nums[i] != nums[i - 1]) &#123; cur.push_back(nums[i]); helper(nums, i + 1, cur, res); cur.pop_back(); &#125; &#125; return; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Subsets (78)]]></title>
    <url>%2F2017%2F01%2F14%2F2017-01-14-leetcode-solution-Subsets-78%2F</url>
    <content type="text"><![CDATA[Given a set of distinct integers, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. For example,If nums = [1,2,3], a solution is:12345678910[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 解法1： Backtracking O(2^N)Backtracking的模板解法。 用一个pos记录当前扫描到的位置。对于每一种情况，都是一个subset，所以递归的时候一开始就要把当前的结果给保存到结果集中。C++12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; if (nums.empty()) &#123; return res; &#125; vector&lt;int&gt; cur; helper(nums, 0, cur, res); return res; &#125; void helper(vector&lt;int&gt;&amp; nums, int pos, vector&lt;int&gt;&amp; cur, vector&lt;vector&lt;int&gt;&gt;&amp; res) &#123; res.push_back(cur); for (int i = pos; i &lt; nums.size(); ++i) &#123; cur.push_back(nums[i]); helper(nums, i + 1, cur, res); cur.pop_back(); &#125; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Word Search (79)]]></title>
    <url>%2F2017%2F01%2F14%2F2017-01-14-leetcode-solution-Word-Search-79%2F</url>
    <content type="text"><![CDATA[Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. For example,Given board =12345[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]] word = “ABCCED”, -&gt; returns true,word = “SEE”, -&gt; returns true,word = “ABCB”, -&gt; returns false. 解法1： DFS O(N^2) N是元素的个数这题的思路是，对于一个给定的string， 他的起点可以在图中的任意位置，那么我们就必须要对每一个起点进行遍历。 对于任意一个遍历， 需要维护一个visited图，来记录已经访问过的节点。对于每一个节点，有4个方向可以选择，对每一个方向进行探索，只要其中有一个方向能找到string， 那么就算找到了。C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; if (word.empty()) &#123; return true; &#125; if (board.empty() || board[0].empty()) &#123; return false; &#125; vector&lt;vector&lt;bool&gt;&gt; visited(board.size(), vector&lt;bool&gt;(board[0].size(), false)); for (int i = 0; i &lt; board.size(); ++i) &#123; for (int j = 0; j &lt; board[0].size(); ++j) &#123; bool temp = helper(word, board, visited, i, j); if (temp) &#123; return true; &#125; &#125; &#125; return false; &#125; bool helper(string word, vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int row, int col) &#123; if (word.empty()) &#123; return true; &#125; if (board[row][col] != word[0]) &#123; return false; &#125; if (word.size() == 1) &#123; return true; &#125; visited[row][col] = true; string next = word.substr(1, word.size() - 1); // check up // bool up = false, right = false, bot = false, left = false; if (row &gt; 0 &amp;&amp; !visited[row - 1][col] ) &#123; bool up = helper(next, board, visited, row - 1, col); if (up) &#123; return true; &#125; &#125; // right if (col &lt; board[0].size() - 1 &amp;&amp; !visited[row][col + 1]) &#123; bool right = helper(next, board, visited, row, col + 1); if (right) &#123; return true; &#125; &#125; // down if (row &lt; board.size() - 1 &amp;&amp; !visited[row + 1][col]) &#123; bool bot = helper(next, board, visited, row + 1, col); if (bot) &#123; return true; &#125; &#125; // left if (col &gt; 0 &amp;&amp; !visited[row][col - 1]) &#123; bool left = helper(next, board, visited, row, col - 1); if (left) &#123; return true; &#125; &#125; visited[row][col] = false; return false; &#125;&#125;; Java12&lt;!--￼1--&gt;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode解题: Gray Code (89)]]></title>
    <url>%2F2017%2F01%2F14%2F2017-01-14-leetcode-solution-Gray-Code-89%2F</url>
    <content type="text"><![CDATA[The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:123400 - 001 - 111 - 310 - 2 Note:For a given n, a gray code sequence is not uniquely defined. For example, [0,2,3,1] is also a valid gray code sequence according to the above definition. For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that. 解法1： Recursive O(2^N)这题一开始没有思路， 对于没思路的可以考虑多写几个最简单的情况的结果来找规律。本题就是一个列子。如果我们把n = 1， n = 2, n = 3的结果写出来就一目了然了。123n = 101 12345n = 200011110 123456789n = 3000001011010110111101100 可以发现，对于n的结果，有2^n个数，前2^n-1个数来自于n-1的结果，后一半的数是把n-1的结果倒序后最高位（n)位上加1即可。有了这个结论，写程序就比较简单了。复杂度应该是O（2^N) C++1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;int&gt; grayCode(int n) &#123; if (n == 0) &#123; return vector&lt;int&gt; &#123;0&#125;; &#125; if (n == 1) &#123; return vector&lt;int&gt; &#123;0,1&#125;; &#125; vector&lt;int&gt; previous = grayCode(n - 1); vector&lt;int&gt; res; // add previous level for (int i = 0; i &lt; previous.size(); ++i) &#123; res.push_back(previous[i]); &#125; for (int i = previous.size() - 1; i &gt;= 0; --i) &#123; // add one to the high bits int temp = previous[i] | (1 &lt;&lt; n - 1); res.push_back(temp); &#125; return res; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Restore IP Address (93)]]></title>
    <url>%2F2017%2F01%2F13%2F2017-01-13-leetcode-solution-Restore-IP-Address-93%2F</url>
    <content type="text"><![CDATA[Given a string containing only digits, restore it by returning all possible valid IP address combinations. For example:Given “25525511135”, return [“255.255.11.135”, “255.255.111.35”]. (Order does not matter) 解法1： Backtracking, Time O(2^N), Space O(2^N)也是比较经典的backtracking的题目，也是不停的去取一部分string，要判断不用继续搜索的条件有这些： 每个字串是否符合ip的条件，一定要是0到255， 并且开头的不能是0， 除了0本身。 字串的长度不能超过3 ip一共有4部分组成，所以也要判断是否超i过了这个条件。 C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution &#123;public: vector&lt;string&gt; restoreIpAddresses(string s) &#123; vector&lt;string&gt; res; if (s.empty()) &#123; return res; &#125; vector&lt;string&gt; cur; helper(s, 0, cur, res); return res; &#125; bool isValid(string s) &#123; if (s[0] == '0' &amp;&amp; s.size() &gt; 1) &#123; return false; &#125; int temp = stoll(s); if (temp &gt;= 0 &amp;&amp; temp &lt;= 255) &#123; return true; &#125; else &#123; return false; &#125; &#125; string createIP(vector&lt;string&gt;&amp; cur) &#123; string res = ""; for (int i = 0; i &lt; cur.size() - 1; ++i) &#123; res += cur[i] + "."; &#125; res += cur[cur.size() - 1]; return res; &#125; void helper(string s, int pos, vector&lt;string&gt;&amp; cur, vector&lt;string&gt;&amp; res) &#123; if (pos == s.size()) &#123; if (cur.size() == 4) &#123; res.push_back(createIP(cur)); &#125; return; &#125; if (cur.size() &gt; 4) &#123; return; &#125; for (int i = pos; i &lt; s.size(); ++i) &#123; if (cur.size() &lt; 4 &amp;&amp; i - pos &lt; 3) &#123; string item = s.substr(pos, i - pos + 1); // check if the item is between 0 and 255 if (!isValid(item)) &#123; continue; &#125; cur.push_back(item); helper(s, i + 1, cur, res); cur.pop_back(); &#125; &#125; &#125;&#125;; Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123; public List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); if (s == null || s.length() == 0) &#123; return res; &#125; List&lt;String&gt; current = new ArrayList&lt;String&gt;(); helper(s, 0, current, res); return res; &#125; boolean isValid(String s) &#123; if (s.charAt(0) == '0' &amp;&amp; s.length() &gt; 1) &#123; return false; &#125; int temp = Integer.parseInt(s); if (temp &gt;= 0 &amp;&amp; temp &lt;= 255) &#123; return true; &#125; return false; &#125; String createIP(List&lt;String&gt; current) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; current.size() - 1; i++) &#123; sb.append(current.get(i)); sb.append("."); &#125; sb.append(current.get(current.size() - 1)); return sb.toString(); &#125; private void helper(String s, int pos, List&lt;String&gt; current, List&lt;String&gt; res) &#123; if (pos == s.length()) &#123; if (current.size() == 4) &#123; res.add(createIP(current)); &#125; return; &#125; if (current.size() &gt; 4) return; for (int i = pos; i &lt; s.length() &amp;&amp; i &lt; pos + 3; i++) &#123; if (current.size() &lt; 4) &#123; String item = s.substring(pos, i + 1); if (!isValid(item)) &#123; continue; &#125; current.add(item); helper(s, i + 1, current, res); current.remove(current.size() - 1); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Palindrome Partitioning (131)]]></title>
    <url>%2F2017%2F01%2F12%2F2017-01-12-leetcode-solution-Palindrome-Partitioning-131%2F</url>
    <content type="text"><![CDATA[Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. For example, given s = “aab”,Return1234[ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]] 解法1： O(n*2^n)常规的backtracking解法，这里我们用一个变量cut来记录当前cut的位置， 然后从cut + 1 开始一个一个个试是否是palindrome。复杂度的计算是由于一共有O(2^N)种可能的partition。C++1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;private: bool isPalindrome(string s) &#123; for (int i = 0, j = s.size() - 1; i &lt; j; ++i, --j) &#123; if (s[i] != s[j]) &#123; return false; &#125; &#125; return true; &#125;public: vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; vector&lt;vector&lt;string&gt;&gt; res; if (s.empty()) &#123; return res; &#125; vector&lt;string&gt; cur; helper(s, 0, cur, res); return res; &#125; void helper(string s, int cut, vector&lt;string&gt;&amp; cur, vector&lt;vector&lt;string&gt;&gt;&amp; res) &#123; if (cut == s.size()) &#123; res.push_back(vector&lt;string&gt;(cur)); return; &#125; for (int i = cut + 1; i &lt;= s.size(); ++i) &#123; string prefix = s.substr(cut, i - cut); if (!isPalindrome(prefix)) &#123; continue; &#125; cur.push_back(prefix); helper(s, i, cur, res); cur.pop_back(); &#125; &#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); if (s == null || s.length() == 0) &#123; return res; &#125; helper(s, 0, new ArrayList&lt;String&gt;(), res); return res; &#125; private void helper(String s, int pos, List&lt;String&gt; current, List&lt;List&lt;String&gt;&gt; res) &#123; if (pos == s.length()) &#123; res.add(new ArrayList&lt;&gt;(current)); return; &#125; for (int i = pos + 1; i &lt;= s.length(); i++) &#123; String cut = s.substring(pos, i); if (isPalindrome(cut)) &#123; current.add(cut); helper(s, i, current, res); current.remove(current.size() - 1); &#125; &#125; &#125; private boolean isPalindrome(String s) &#123; if (s == null || s.length() == 0) &#123; return true; &#125; for (int i = 0, j = s.length() - 1; i &lt; j; i++, j--) &#123; if (s.charAt(i) != s.charAt(j)) &#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Reverse Bits (190)]]></title>
    <url>%2F2017%2F01%2F10%2F2017-01-10-leetcode-solution-Reverse-Bits-190%2F</url>
    <content type="text"><![CDATA[Reverse bits of a given 32 bits unsigned integer. For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000). Follow up:If this function is called many times, how would you optimize it? Related problem: Reverse Integer 解法1：C++12345678910111213class Solution &#123;public: uint32_t reverseBits(uint32_t n) &#123; int res = 0; for (int i = 0; i &lt; 32; ++i) &#123; res &lt;&lt;= 1; int bit = n &amp; 1; res = res | bit; n &gt;&gt;= 1; &#125; return res; &#125;&#125;; Java1 Follow up本题的follow up的解法参考这个帖子]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Number Complement (476)]]></title>
    <url>%2F2017%2F01%2F10%2F2017-01-10-leetcode-solution-Number-Complement-476%2F</url>
    <content type="text"><![CDATA[Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation. Note:The given integer is guaranteed to fit within the range of a 32-bit signed integer.You could assume no leading zero bit in the integer’s binary representation.Example 1:123Input: 5Output: 2Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. Example 2:12Input: 1Output: 0 解法1：观察可以发现，可以用XOR来flip每一位的bit， 而mark数是从第一个set bit开始所有位都为1的数字。怎么判断最高的set bit是哪一个呢？可以用log2函数，最高位的1的位置一定是log2(num), 那么为了得到所有都是1的一个数，可以先左移log2(num) + 1， 然后把所得的数字-1即可。C++12345678910class Solution &#123;public: int findComplement(int num) &#123; int mask = (1 &lt;&lt; 1 + static_cast&lt;int&gt;(log2(num))) - 1; return mask ^ num; &#125;&#125;; Java12345678class Solution &#123; public int findComplement(int num) &#123; int mask = (1 &lt;&lt; ((int)(Math.log10(num) / Math.log10(2)) + 1)) - 1; return num ^ mask; &#125;&#125; 解法2：一位一位的转换Java123456789101112131415161718public int findComplement(int num) &#123; // last digit is set bit int pos = 0; int res = 0; for (int i = 0; i &lt; 31 &amp;&amp; num != 0; i++) &#123; int digit = num &amp; 1; num &gt;&gt;= 1; pos++; int setBit = 1 - digit; setBit &lt;&lt;= i; res |= setBit; &#125; return res;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Combination Sum III (216)]]></title>
    <url>%2F2017%2F01%2F10%2F2017-01-10-leetcode-solution-Combination-Sum-III-216%2F</url>
    <content type="text"><![CDATA[Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Example 1: Input: k = 3, n = 7 Output:1[[1,2,4]] Example 2: Input: k = 3, n = 9 Output:1[[1,2,6], [1,3,5], [2,3,4]] 解法1：典型的backtracking的题目，用一般的模板就能解决。用一个helper函数，用一个数保存当前试的数的起始位置， 用一个vector存储当前选出的答案。要注意的是退出条件。 同时注意到由于存在可能计算重复的数据，所以memorization可以帮助efficiency，不过下面的答案没有用。C++123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; vector&lt;int&gt; temp; vector&lt;vector&lt;int&gt;&gt; res; int num = 1; int max = 9; helper(temp, res, k, n, num, max); return res; &#125; void helper(vector&lt;int&gt;&amp; cur, vector&lt;vector&lt;int&gt;&gt;&amp; res, int k, int n, int num, int max) &#123; if (n &lt; 0 || (k == 0 &amp;&amp; n &gt; 0) || (n == 0 &amp;&amp; k != 0)) &#123; return; &#125; if (n == 0 &amp;&amp; k == 0) &#123; res.push_back(cur); return; &#125; for (int i = num; i &lt;= max; ++i) &#123; cur.push_back(i); helper(cur, res, k - 1,n - i, i + 1, max); cur.pop_back(); &#125; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Permutation Sequence (60)]]></title>
    <url>%2F2017%2F01%2F09%2F2017-01-09-leetcode-solution-Permutation-Sequence-60%2F</url>
    <content type="text"><![CDATA[The set [1,2,3,…,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order,We get the following sequence (ie, for n = 3): “123”“132”“213”“231”“312”“321”Given n and k, return the kth permutation sequence. Note: Given n will be between 1 and 9 inclusive. 解法1： Math数学题，解法就不重复了，第一位取值每(n - 1)!变化一位，第二位取值每（n - 2)% 变化一位。 通过k / (n - i)! 算出来的是index， 这就意味着每次取完一个数以后要把那个数删除。 C++1c++ 里面vector的初始化如果用vector&lt;int&gt; (n, initial_value)的形式要注意是“（”， 不是“&#123;“， 花括号是给了一组初始的array 12345678910111213141516171819202122class Solution &#123;public: string getPermutation(int n, int k) &#123; vector&lt;int&gt; number ; int perm = 1; for (int i = 1; i &lt;= n; ++i) &#123; number.push_back(i); perm *= i; &#125; k--; string res; for (int i = 0; i &lt; n; ++i) &#123; perm /= (n - i); int choosed = k / perm; k %= perm; res += to_string(number[choosed]); number.erase(number.begin() + choosed); &#125; return res; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Binary Tree Upside Down (156)]]></title>
    <url>%2F2017%2F01%2F09%2F2017-01-09-leetcode-solution-Binary-Tree-Upside-Down-156%2F</url>
    <content type="text"><![CDATA[Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root. For example:Given a binary tree {1,2,3,4,5},12345 1 / \ 2 3 / \4 5 return the root of the binary tree [4,5,2,#,#,3,1].12345 4 / \5 2 / \ 3 1 解法1：用分治的方法思考比较容易， 题目的意思是只有两种情况，一种是没有右子树，但可能有左子树，一种是有右子树但一定也有左子树。变换之后，right tree变成left， root变成left， 而原来的left也需要进行upside down的变化。最后他的root是最终的root， 而他的最右子树变成了现在root和right的parentC++1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */struct res &#123; TreeNode* root; TreeNode* tail; res(TreeNode* r, TreeNode* t):root(r),tail(t) &#123;&#125;&#125;;class Solution &#123;public: TreeNode* upsideDownBinaryTree(TreeNode* root) &#123; res result = helper(root); return result.root; &#125; res helper(TreeNode* root) &#123; if (!root) &#123; return res(NULL, NULL); &#125; if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; return res(root, root); &#125; res left = helper(root-&gt;left); left.tail-&gt;left = root-&gt;right; left.tail-&gt;right = root; root-&gt;left = NULL; root-&gt;right = NULL; return res(left.root, root); &#125;&#125;; Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; class NodeMark &#123; TreeNode root; TreeNode tail; public NodeMark(TreeNode root, TreeNode tail) &#123; this.root = root; this.tail = tail; &#125; &#125;; public TreeNode upsideDownBinaryTree(TreeNode root) &#123; if (root == null) return root; NodeMark temp = helper(root); return temp.root; &#125; private NodeMark helper(TreeNode root) &#123; if (root == null) &#123; return new NodeMark(null, null); &#125; if (root.left == null &amp;&amp; root.right == null) &#123; return new NodeMark(root, root); &#125; NodeMark left = helper(root.left); left.tail.left = root.right; left.tail.right = root; root.left = null; root.right = null; return new NodeMark(left.root, root); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Divide &amp; Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Contains Duplicate II (219)]]></title>
    <url>%2F2017%2F01%2F07%2F2017-01-07-leetcode-solution-Contains-Duplicate-II-219%2F</url>
    <content type="text"><![CDATA[解法1：C++1 Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Length of Last Word (58)]]></title>
    <url>%2F2017%2F01%2F07%2F2017-01-07-leetcode-solution-Length-of-Last-Word-58%2F</url>
    <content type="text"><![CDATA[Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. For example,Given s = “Hello World”,return 5. 解法1：首这题的启发，也用istringstream来读取一个个的word，直到最后一个string。C++```这里要注意的是， getline会读取word直到下一个delimiter的出现，那么如果有两个连续的space，第二个space之前会读出一个“”， 也就是空字符串。1234567891011121314class Solution &#123;public: int lengthOfLastWord(string s) &#123; istringstream ss(s); string word; int res = 0; while (getline(ss, word, ' ')) &#123; if (!word.empty()) &#123; res = word.size(); &#125; &#125; return res; &#125;&#125;; Java1 解法2：不用istringstream的操作， 一位位的读。C++12345678910111213141516171819class Solution &#123;public: int lengthOfLastWord(string s) &#123; int res = 0; int count = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; if (s[i] == ' ') &#123; if (count != 0) &#123; res = count; &#125; count = 0; &#125; else &#123; ++count; &#125; &#125; if (count) res = count; return res; &#125;&#125;;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Word Pattern (290)]]></title>
    <url>%2F2017%2F01%2F07%2F2017-01-07-leetcode-solution-Word-Pattern-290%2F</url>
    <content type="text"><![CDATA[Given a pattern and a string str, find if str follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str. Examples:pattern = “abba”, str = “dog cat cat dog” should return true.pattern = “abba”, str = “dog cat cat fish” should return false.pattern = “aaaa”, str = “dog cat cat dog” should return false.pattern = “abba”, str = “dog dog dog dog” should return false.Notes:You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space. 解法1： HashMap, O(N + M)这题对于我主要是学习C++的各种知识。。。 主要的思路是用两个map存储p到s的映射，也存储s到p的映射。C++1234读取一个string可以用到istringstream, 用法是istringstream ss(str);然后读取ss中的string可以用getline(const istringstream&amp;, const string&amp; word, char delimiter)getline如果返回为空则证明stream已经结束。最后要判断getline是否为空是因为有可能str比pattern长。 12345678910111213141516171819202122232425class Solution &#123;public: bool wordPattern(string pattern, string str) &#123; istringstream ss(str); string word; // store the word from str unordered_map&lt;char, string&gt; p2s; unordered_map&lt;string, char&gt; s2p; for (auto c : pattern) &#123; if (!getline(ss, word, ' ')) &#123; return false; &#125; if (p2s.count(c) &amp;&amp; p2s[c] != word) &#123; return false; &#125; if (s2p.count(word) &amp;&amp; s2p[word] != c) &#123; return false; &#125; p2s[c] = word; s2p[word] = c; &#125; return !getline(ss, word, ' '); &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Find Leaves of Binary Tree (366)]]></title>
    <url>%2F2017%2F01%2F07%2F2017-01-07-leetcode-solution-Find-Leaves-of-Binary-Tree-366%2F</url>
    <content type="text"><![CDATA[Given a binary tree, collect a tree’s nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty. Example:Given binary tree12345678910 1 / \ 2 3 / \ 4 5``` Returns [4, 5, 3], [2], [1].Explanation:1. Removing the leaves [4, 5, 3] would result in this tree: 1 / 2 12. Now removing the leaf [2] would result in this tree: 1 13. Now removing the leaf [1] would result in the empty tree: [] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160Returns [4, 5, 3], [2], [1].### 解法1： DFS ###这题一开始想用Hashtable把tree转化成一个图然后不停的拨洋葱，后来参考了别人的做法发现不需要这样。 每一个点属于第几层的leave是由他的高度决定的。 那么我们只要遍历一次，算出每一个node的高度，如果高度为0， 那么就是leaf， 放在结果的第一个vector中，如果高度为1，那么放在第二个vector中以此类推。C++&#123;% codeblock lang:cpp %&#125;/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; findLeaves(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; helper(root, res); return res; &#125; int helper(TreeNode* root, vector&lt;vector&lt;int&gt;&gt;&amp; res) &#123; if (!root) &#123; return -1; &#125; int height = max(helper(root-&gt;left, res), helper(root-&gt;right, res)) + 1; if (height &gt;= res.size()) res.resize(height + 1); res[height].push_back(root-&gt;val); return height; &#125;&#125;;&#123;% endcodeblock %&#125;Java&#123;% codeblock lang:java %&#125;/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; findLeaves(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (root == null) &#123; return res; &#125; helper(root, res); return res; &#125; private int helper(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res) &#123; if (root == null) &#123; return -1; &#125; int left = helper(root.left, res); int right = helper(root.right, res); int depth = Math.max(left, right) + 1; if (depth &gt;= res.size()) &#123; res.add(new ArrayList&lt;Integer&gt;()); &#125; res.get(depth).add(root.val); return depth; &#125;&#125;&#123;% endcodeblock %&#125;### 解法2： 剥洋葱 ###这种解法是用递归的方式不停的remove tree node。 用递归的方式的时候，如果要删掉一个leaf，办法是如果是leaf，则返回null， 而每一次递归的时候root-&gt;left = remove(left);这样返回的NULL就会被赋值给root的left tree，所以就删掉了那个node。每一次遍历的时候，都返回更新过的root， 直到root被删成空为止。C++&#123;% codeblock lang: cpp %&#125;/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; findLeaves(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; while (root) &#123; vector&lt;int&gt; leaves; root = removeLeaves(root, leaves); res.push_back(leaves); &#125; return res; &#125; TreeNode* removeLeaves(TreeNode* root, vector&lt;int&gt;&amp; leaves) &#123; if (!root) &#123; return NULL; &#125; if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; leaves.push_back(root-&gt;val); return NULL; &#125; root-&gt;left = removeLeaves(root-&gt;left, leaves); root-&gt;right = removeLeaves(root-&gt;right, leaves); return root; &#125;&#125;;&#123;% endcodeblock %&#125;```java/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; findLeaves(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (root == null) &#123; return res; &#125; while (root != null) &#123; List&lt;Integer&gt; leaves = new ArrayList&lt;&gt;(); root = remove(root, leaves); res.add(leaves); &#125; return res; &#125; private TreeNode remove(TreeNode root, List&lt;Integer&gt; leaves) &#123; if (root == null) &#123; return null; &#125; if (root.left == null &amp;&amp; root.right == null) &#123; leaves.add(root.val); return null; &#125; root.left = remove(root.left, leaves); root.right = remove(root.right, leaves); return root; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 解题: Construct Binary Tree from Preorder and Inorder Traversal (105)]]></title>
    <url>%2F2017%2F01%2F07%2F2017-01-07-leetcode-solution-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-105%2F</url>
    <content type="text"><![CDATA[Given preorder and inorder traversal of a tree, construct the binary tree. 解法1： RecursivePreorder的顺序是root，left，rightinorder的顺序是left，root，right可见preorder的第一个一定是root，这样有了root的数值，我们就可以在inorder中找到root的位置，左边都是left，右边都是right对左右子树同时进行tree construction。要注意的是下标容易出错， 要注意。 C++123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; if (preorder.size() != inorder.size()) &#123; return NULL; &#125; return helper(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1); &#125; TreeNode* helper(vector&lt;int&gt;&amp; preorder, int pstart, int pend, vector&lt;int&gt;&amp; inorder, int istart, int iend) &#123; if (pstart &gt; pend || istart &gt; iend) &#123; return NULL; &#125; if (pstart == pend) &#123; return new TreeNode(preorder[pstart]); &#125; int rootval = preorder[pstart]; TreeNode* root = new TreeNode(rootval); auto iter = find(inorder.begin() + istart, inorder.begin() + iend + 1, rootval); int leftNum = iter - (inorder.begin() + istart); TreeNode* left = helper(preorder, pstart + 1, pstart + leftNum, inorder, istart, istart + leftNum - 1); TreeNode* right = helper(preorder, pstart + leftNum + 1, pend, inorder, istart + leftNum + 1, iend); root-&gt;left = left; root-&gt;right = right; return root; &#125;&#125;; Java123456789101112131415161718192021class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; return helper(0, 0, inorder.length - 1, preorder, inorder); &#125; public TreeNode helper(int preStart, int inStart, int inEnd, int[] preorder, int[] inorder) &#123; if (preStart &gt; preorder.length - 1 || inStart &gt; inEnd) &#123; return null; &#125; TreeNode root = new TreeNode(preorder[preStart]); int inIndex = 0; // Index of current root in inorder for (int i = inStart; i &lt;= inEnd; i++) &#123; if (inorder[i] == root.val) &#123; inIndex = i; &#125; &#125; root.left = helper(preStart + 1, inStart, inIndex - 1, preorder, inorder); root.right = helper(preStart + inIndex - inStart + 1, inIndex + 1, inEnd, preorder, inorder); return root; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>In-order-traversal</tag>
        <tag>Pre-order-traversal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Unique Binary Search Trees II (95)]]></title>
    <url>%2F2017%2F01%2F05%2F2017-01-05-leetcode-solution-Unique-Binary-Search-Trees-II-95%2F</url>
    <content type="text"><![CDATA[Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1…n. For example,Given n = 3, your program should return all 5 unique BST’s shown below.123451 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \2 1 2 3 解法1： Recursive, Divide &amp; Conquer用分治的思想考虑会比较容易，从1到n，如果选择了i，那么1到i-1所能组成的tree都是i的左子树，i+1到n都为右子树。对于每一颗左子树和右子树的组合，我们都能构建一个新的树。用递归的方式很容易解决。C++1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;TreeNode*&gt; generateTrees(int n) &#123; vector&lt;TreeNode*&gt; res; if (n == 0) &#123; return res; &#125; return generate(1, n); &#125; vector&lt;TreeNode*&gt; generate(int start, int end) &#123; vector&lt;TreeNode*&gt; res; if (start &gt; end) &#123; res.push_back(NULL); return res; &#125; for (int i = start; i&lt;= end; ++i) &#123; vector&lt;TreeNode*&gt; left = generate(start, i -1); vector&lt;TreeNode*&gt; right = generate(i + 1, end); for (TreeNode* l: left) &#123; for (TreeNode* r: right) &#123; TreeNode* root = new TreeNode(i); root-&gt;left = l; root-&gt;right = r; res.push_back(root); &#125; &#125; &#125; return res; &#125;&#125;; Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;TreeNode&gt; generateTrees(int n) &#123; List&lt;TreeNode&gt; res = new ArrayList&lt;&gt;(); if (n &lt;= 0) &#123; return res; &#125; return generateTrees(1, n); &#125; private List&lt;TreeNode&gt; generateTrees(int start, int end) &#123; List&lt;TreeNode&gt; res = new ArrayList&lt;&gt;(); if (start &gt; end) &#123; return res; &#125; if (start == end) &#123; res.add(new TreeNode(start)); return res; &#125; for (int i = start; i &lt;= end; i++) &#123; List&lt;TreeNode&gt; left = generateTrees(start, i - 1); List&lt;TreeNode&gt; right = generateTrees(i + 1, end); if (left.isEmpty()) &#123; for (TreeNode x : right) &#123; TreeNode root = new TreeNode(i); root.right = x; res.add(root); &#125; &#125; else if (right.isEmpty()) &#123; for (TreeNode x : left) &#123; TreeNode root = new TreeNode(i); root.left = x; res.add(root); &#125; &#125; else &#123; for (TreeNode l : left) &#123; for (TreeNode r : right) &#123; TreeNode root = new TreeNode(i); root.left = l; root.right = r; res.add(root); &#125; &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Minimum Height Trees (310)]]></title>
    <url>%2F2017%2F01%2F04%2F2017-01-04-leetcode-solution-Minimum-Height-Trees-310%2F</url>
    <content type="text"><![CDATA[For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels. FormatThe graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels). You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges. Example 1: Given n = 4, edges = [[1, 0], [1, 2], [1, 3]]12345 0 | 1 / \2 3 return 1 Example 2:123456789Given n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]] 0 1 2 \ | / 3 | 4 | 5 return [3, 4] 解法1： O(N) Time + O(N) Space这题有些难度。。一开始自己想了O(N*N)的算法，果断TLE了。 这里的解法是参考了Discussion里的一个解法。首先要观察， 看对于一个图最多有几个可能的MHT， 答案是最多有两个。 为什么呢？假设有1个，那么就是自己。假设有两个节点，则无论他们是否连接， 其中任何一个作为节点高度都是一样的。如果只有三个节点， 那么如果有两个线连着，那么有两个叶子和一个中间点，那个中间点就是MHT。有了这个思路， 我们可以从leaf出发，不停的向图中间靠拢，直到没有leaf为止（leaf定义为有且仅有一条边界）/ C++123可以用unordered_set&lt;int&gt;来表示children， 对应的操作有erase（）， insert（）C++中有std::swap可以用来交换两个container中的数据。vector可以用vector.clear()来清除里面的数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;pair&lt;int, int&gt;&gt;&amp; edges) &#123; vector&lt;int&gt; res; if (n == 1) &#123; res.push_back(0); return res; &#125; if (n == 2) &#123; res.push_back(0); res.push_back(1); return res; &#125; // Construct the tree unordered_map&lt;int, unordered_set&lt;int&gt;&gt; map; for (auto p : edges) &#123; if (!map.count(p.first)) &#123; map[p.first] = unordered_set&lt;int&gt;(); &#125; if (!map.count(p.second)) &#123; map[p.second] = unordered_set&lt;int&gt;(); &#125; map[p.first].insert(p.second); map[p.second].insert(p.first); &#125; // Remove leaves until we have only 1 or 2 nodes vector&lt;int&gt; leaves; for (int i = 0; i &lt; n; ++i) &#123; if (map[i].size() == 1) &#123; leaves.push_back(i); &#125; &#125; vector&lt;int&gt; newLeaves; while (true) &#123; for (int leaf : leaves) &#123; unordered_set&lt;int&gt; innerLayer = map[leaf]; for (int node : innerLayer) &#123; map[node].erase(leaf); if (map[node].size() == 1) &#123; newLeaves.push_back(node); &#125; &#125; &#125; if (newLeaves.empty()) &#123; return leaves; &#125; leaves.clear(); swap(leaves, newLeaves); &#125; &#125;&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123; public List&lt;Integer&gt; findMinHeightTrees(int n, int[][] edges) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if (n == 1) &#123; res.add(0); return res; &#125; if (n == 2) &#123; res.add(0); res.add(1); return res; &#125; if (edges == null || edges.length == 0 || edges[0] == null || edges[0].length == 0) &#123; return res; &#125; // BFS and 剥洋葱 Map&lt;Integer, Set&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for (int[] edge: edges) &#123; int start = edge[0]; int end = edge[1]; if (!map.containsKey(start)) &#123; map.put(start, new HashSet&lt;&gt;()); &#125; if (!map.containsKey(end)) &#123; map.put(end, new HashSet&lt;&gt;()); &#125; map.get(start).add(end); map.get(end).add(start); &#125; // Doing a bfs Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int key : map.keySet()) &#123; if (map.get(key).size() == 1) &#123; queue.offer(key); &#125; &#125; // Doing a peel-an-onion algorithm while ( n &gt; 2) &#123; int size = queue.size(); // number of leaf nodes at this time n -= size; for (int i = 0; i &lt; size; i++) &#123; int node = queue.poll(); Set&lt;Integer&gt; connected = map.get(node); for (int c : connected) &#123; map.get(c).remove(node); if (map.get(c).size() == 1) &#123; queue.offer(c); // next round onion peel &#125; &#125; &#125; &#125; while (!queue.isEmpty()) &#123; res.add(queue.poll()); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Count and Say (38)]]></title>
    <url>%2F2017%2F01%2F03%2F2017-01-03-leetcode-solution-Count-and-Say-38%2F</url>
    <content type="text"><![CDATA[The count-and-say sequence is the sequence of integers beginning as follows:1, 11, 21, 1211, 111221, … 1 is read off as “one 1” or 11.11 is read off as “two 1s” or 21.21 is read off as “one 2, then one 1” or 1211.Given an integer n, generate the nth sequence. Note: The sequence of integers will be represented as a string. 解法1： Recursive用递归求得n-1的字符串，然后一位位遍历，每当得到和前一位不一样的字符时，保存前一位的字符的计数和字符。要注意的是最后一位的结果要在扫描结束后保存。C++C++ 里 从1个char转换到string可以用string(1, character)123456789101112131415161718192021222324252627class Solution &#123;public: string countAndSay(int n) &#123; if (n &lt;= 0) &#123; return ""; &#125; if (n == 1) &#123; return "1"; &#125; string prev = countAndSay(n - 1); string res = ""; int count = 1; char cur = prev[0]; for (int i = 1; i &lt; prev.size(); ++i) &#123; if (prev[i] == prev[i - 1]) &#123; count++; &#125; else &#123; res += to_string(count) + string(1, cur); cur = prev[i]; count = 1; &#125; &#125; res += to_string(count) + string(1, prev[prev.size() - 1]); return res; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Bulls and Cows (299)]]></title>
    <url>%2F2017%2F01%2F03%2F2017-01-03-leetcode-solution-Bulls-and-Cows-299%2F</url>
    <content type="text"><![CDATA[You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number. For example: Secret number: “1807”Friend’s guess: “7810”Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.)Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return “1A3B”. Please note that both secret number and friend’s guess may contain duplicate digits, for example: Secret number: “1123”Friend’s guess: “0111”In this case, the 1st 1 in friend’s guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return “1A1B”.You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal. 解法1： O（N) Time , 一次遍历参考了[这个][1]的解法， 只需要一次遍历即可。思路是按位一个个遍历，如果碰到一样的字符则bull加1。 如果碰到不一样的字符，secret的字符对应的+1， guess对应的减1。这样就同时保存了secret和guess出现的字符的情况。 如果后续碰到如果secret字符对应的次数为负，则证明在guess中出现过； 如果guess字符对应的次数为正，则说明在secret中出现过。 这样的话就能记录一次cow。C++123456789101112131415161718192021222324252627282930class Solution &#123;public: string getHint(string secret, string guess) &#123; vector&lt;int&gt; map(10, 0); int bulls, cows; bulls = cows = 0; for (int i = 0; i &lt; secret.size(); ++i) &#123; if (secret[i] == guess[i]) &#123; ++bulls; &#125; else &#123; if (map[secret[i] - '0'] &lt; 0) &#123; ++cows; &#125; if (map[guess[i] - '0'] &gt; 0) &#123; ++cows; &#125; map[secret[i] -'0']++; map[guess[i] - '0']--; &#125; &#125; return to_string(bulls) + "A" + to_string(cows) + "B"; &#125;&#125;; Java1234567891011121314151617181920212223242526class Solution &#123; public String getHint(String secret, String guess) &#123; int[] map = new int[10]; int bull = 0, cow = 0; for (int i = 0; i &lt; secret.length(); i++) &#123; if (secret.charAt(i) == guess.charAt(i)) &#123; bull++; &#125; else &#123; if (map[secret.charAt(i) - '0'] &lt; 0) &#123; cow++; &#125; if (map[guess.charAt(i) - '0'] &gt; 0) &#123; cow++; &#125; map[secret.charAt(i) - '0']++; map[guess.charAt(i) - '0']--; &#125; &#125; return Integer.toString(bull) + "A" + Integer.toString(cow) + "B"; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Implement Trie (Prefix Tree) (208)]]></title>
    <url>%2F2017%2F01%2F03%2F2017-01-03-leetcode-solution-Implement-Trie-Prefix-Tree-208%2F</url>
    <content type="text"><![CDATA[Implement a trie with insert, search, and startsWith methods. 解法1：本题主要是考察Trie树的基本概念，可以参考Wiki的解释。 实现的时候，每一个node的children可以用一个map来实现，做insert或者是search的时候可以用一个current的指针从root开始不停的往下搜索。比较直观，并没有难度。C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class TrieNode &#123;public: // Initialize your data structure here. TrieNode() &#123; isWord = false; &#125; unordered_map&lt;char, TrieNode*&gt; children; bool isWord;&#125;;class Trie &#123;public: Trie() &#123; root = new TrieNode(); &#125; // Inserts a word into the trie. void insert(string word) &#123; TrieNode* cur = root; for (char c: word) &#123; if (!cur-&gt;children.count(c)) &#123; cur-&gt;children[c] = new TrieNode(); &#125; cur = cur-&gt;children[c]; &#125; cur-&gt;isWord = true; &#125; // Returns if the word is in the trie. bool search(string word) &#123; TrieNode* cur = root; for (char c: word) &#123; if (!cur-&gt;children.count(c)) &#123; return false; &#125; cur = cur-&gt;children[c]; &#125; return cur-&gt;isWord; &#125; // Returns if there is any word in the trie // that starts with the given prefix. bool startsWith(string prefix) &#123; TrieNode* cur = root; for (char c: prefix) &#123; if (!cur-&gt;children.count(c)) &#123; return false; &#125; cur = cur-&gt;children[c]; &#125; return true; &#125;private: TrieNode* root;&#125;;// Your Trie object will be instantiated and called as such:// Trie trie;// trie.insert("somestring");// trie.search("key"); Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class TrieNode &#123; Map&lt;Character, TrieNode&gt; map; boolean isWord; public TrieNode() &#123; this.map = new HashMap&lt;Character, TrieNode&gt;(); &#125;&#125;;public class Trie &#123; private TrieNode root; /** Initialize your data structure here. */ public Trie() &#123; this.root = new TrieNode(); &#125; /** Inserts a word into the trie. */ public void insert(String word) &#123; TrieNode current = root; for (char c : word.toCharArray()) &#123; if (!current.map.containsKey(c)) &#123; current.map.put(c, new TrieNode()); &#125; current = current.map.get(c); &#125; current.isWord = true; &#125; /** Returns if the word is in the trie. */ public boolean search(String word) &#123; TrieNode current = root; for (char c : word.toCharArray()) &#123; if (!current.map.containsKey(c)) &#123; return false; &#125; current = current.map.get(c); &#125; return current.isWord; &#125; /** Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) &#123; TrieNode current = root; for (char c: prefix.toCharArray()) &#123; if (!current.map.containsKey(c)) &#123; return false; &#125; current = current.map.get(c); &#125; return true; &#125;&#125;/** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: House Robber III (337)]]></title>
    <url>%2F2017%2F01%2F01%2F2017-01-01-leetcode-solution-House-Robber-III-337%2F</url>
    <content type="text"><![CDATA[The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. Example 1:12345 3 / \2 3 \ \ 3 1 Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.Example 2:12345 3 / \ 4 5 / \ \1 3 1 Maximum amount of money the thief can rob = 4 + 5 = 9. 解法1：参考了这个帖子的解法3。 对于每一个节点，存在两种可能， 取或者不取。 那么可以用一个帮助函数，每一次计算的时候保存这两种情况的值。用一个vector保存，v[0]表示从这个点出发，不包含这个点最大的可取值， v1表示从这个点出发并且包含这个点可取的最大值。那么对于一个root， 分别计算left和right的vector，再按取或者不取的情况计算出root的vector。如果取root的值，那一定不能取left和right的值， 所以最大取值是left1 + right1 + val如果不取root的值，那可以取left和right的值， 这也等价于两颗树，对这两颗树取这个问题的最大值，就是left两种情况的最大值+right两种情况的最大值。C++1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int rob(TreeNode* root) &#123; vector&lt;int&gt; temp = helper(root); return max(temp[0], temp[1]); &#125; vector&lt;int&gt; helper(TreeNode* root) &#123; if (!root) &#123; return vector&lt;int&gt;(2, 0); &#125; vector&lt;int&gt; left = helper(root-&gt;left); vector&lt;int&gt; right = helper(root-&gt;right); vector&lt;int&gt; res(2,0); res[0] = max(left[0], left[1]) + max(right[0], right[1]); res[1] = left[0] + right[0] + root-&gt;val; return res; &#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; class MarkedTreeNode &#123; int take; int notake; public MarkedTreeNode(int take, int notake) &#123; this.take = take; this.notake = notake; &#125; &#125;; public int rob(TreeNode root) &#123; if (root == null) return 0; MarkedTreeNode res = helper(root); return Math.max(res.take, res.notake); &#125; private MarkedTreeNode helper(TreeNode root) &#123; if (root == null) return new MarkedTreeNode(0,0); MarkedTreeNode left = helper(root.left); MarkedTreeNode right = helper(root.right); int take = root.val + left.notake + right.notake; int notake = Math.max(left.notake, left.take) + Math.max(right.notake, right.take); return new MarkedTreeNode(take, notake); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Implement Stack using Queues (225)]]></title>
    <url>%2F2016%2F12%2F31%2F2016-12-31-leetcode-solution-Implement-Stack-using-Queues-225%2F</url>
    <content type="text"><![CDATA[Implement the following operations of a stack using queues. push(x) – Push element x onto stack.pop() – Removes the element on top of the stack.top() – Get the top element.empty() – Return whether the stack is empty.Notes:You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty operations are valid.Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack). 解法1：基本思路是当执行top或者是pop的时候，我们需要取出最后一个元素。那么前面的元素放哪里？ 可以直接push回当前的queue。 这样，当除最后一个元素被重新push后，第一个就是我们要求的元素。要注意的是，top是不改变数据的，所以执行完top之前，要把第一个元素push回queueC++123456789101112131415161718192021222324252627282930313233343536373839class Stack &#123;public: // Push element x onto stack. void push(int x) &#123; q.push(x); &#125; // Removes the element on top of the stack. void pop() &#123; int s = q.size(); for (int i = 0; i &lt; s - 1; ++i) &#123; q.push(q.front()); q.pop(); &#125; q.pop(); &#125; // Get the top element. int top() &#123; int s = q.size(); for (int i = 0; i &lt; s - 1; ++i) &#123; q.push(q.front()); q.pop(); &#125; int res = q.front(); q.push(res); q.pop(); return res; &#125; // Return whether the stack is empty. bool empty() &#123; return q.empty(); &#125;private: queue&lt;int&gt; q;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Intersection of Two Linked Lists (160)]]></title>
    <url>%2F2016%2F12%2F31%2F2016-12-31-leetcode-solution-Intersection-of-Two-Linked-Lists-160%2F</url>
    <content type="text"><![CDATA[Write a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: A: a1 → a2 ↘ c1 → c2 → c3 ↗B: b1 → b2 → b3begin to intersect at node c1. Notes: If the two linked lists have no intersection at all, return null.The linked lists must retain their original structure after the function returns.You may assume there are no cycles anywhere in the entire linked structure.Your code should preferably run in O(n) time and use only O(1) memory. 解法1： O（M + N） Time + O（1） Space很巧妙的一个方法是如果我们将其中一个list的尾巴和另一个list的头部连接，那么就变成了求这个长list中是否有circle，如果有那么他们的交点是什么的题目。要注意求交点的算法是： slow，fast pointer slow = head， fast = head.next 找到slow和fast相等的点 把slow挪到head， fast往下移一格 一步一步走直到slow和fast相等C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; if (!headA || !headB) &#123; return NULL; &#125; ListNode *a = headA; while (a -&gt;next) &#123; a = a-&gt;next; &#125; a-&gt;next =headB; ListNode* temp = circle(headA); a-&gt;next = NULL; return temp; &#125; ListNode* circle(ListNode* head) &#123; ListNode* slow = head; ListNode* fast = head-&gt;next; while (slow != fast) &#123; if (!fast || !fast-&gt;next) &#123; return NULL; &#125; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; slow = head; fast = fast-&gt;next; while (slow != fast) &#123; slow =slow-&gt;next; fast =fast-&gt;next; &#125; return slow; &#125;&#125;; Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) &#123; return null; &#125; ListNode tailA = headA; while (tailA.next != null) &#123; tailA = tailA.next; &#125; tailA.next = headB; // A -&gt; B ListNode slow = headA, fast = headA.next; while (slow != fast) &#123; if (fast == null || fast.next == null) &#123; tailA.next = null; return null; // no cycle found &#125; slow = slow.next; fast = fast.next.next; &#125; slow = headA; fast = fast.next; while (slow != fast) &#123; slow = slow.next; fast = fast.next; &#125; tailA.next = null; // restore the original linked List return slow; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Construct Binary Tree from Inorder and Postorder Traversal (106)]]></title>
    <url>%2F2016%2F12%2F31%2F2016-12-31-leetcode-solution-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-106%2F</url>
    <content type="text"><![CDATA[Given inorder and postorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. 解法1：首先回想一下inorder和postorder的遍历顺序是什么样的。 inorder是left，root，right。 postorder是left，right，root。 那么发现postorder对应的最后一个数就是tree的root， 当我们找到乐root之后就可以在inorder里面找到root的位置，假设为i。按照inorder的顺序，在i左面的都是root的左节点，而在i右面的都是root的右节点。对于左右子树，我们只要在运行一次同样的算法，只是更新一下取值的范围（左右边界）就可以了。C++12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; if (inorder.empty()) &#123; return NULL; &#125; return helper(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1); &#125; TreeNode* helper(vector&lt;int&gt;&amp; inorder, int istart, int iend, vector&lt;int&gt;&amp; postorder, int pstart, int pend) &#123; if (istart &gt; iend) &#123; return NULL; &#125; if (istart == iend) &#123; TreeNode* node = new TreeNode(inorder[istart]); return node; &#125; int val = postorder[pend]; TreeNode* root = new TreeNode(val); auto iter = find(inorder.begin(), inorder.end(), val); int index = iter - inorder.begin(); int leftNum = index - istart; int rightNum = iend - index; // Find left tree TreeNode* left = helper(inorder, istart, index - 1, postorder, pstart, pstart + leftNum - 1); // Find right tree TreeNode* right = helper(inorder, index + 1, iend, postorder, pstart + leftNum, pstart + leftNum + rightNum - 1); root-&gt;left = left; root-&gt;right = right; return root; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Remove Linked List Elements (203)]]></title>
    <url>%2F2016%2F12%2F30%2F2016-12-30-leetcode-solution-Remove-Linked-List-Elements-203%2F</url>
    <content type="text"><![CDATA[Remove all elements from a linked list of integers that have value val. ExampleGiven: 1 –&gt; 2 –&gt; 6 –&gt; 3 –&gt; 4 –&gt; 5 –&gt; 6, val = 6Return: 1 –&gt; 2 –&gt; 3 –&gt; 4 –&gt; 5 解法1： O(N) One Pass要注意的是因为可能头指针会被删除或者整条list会被删，要用dummy node。C++12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeElements(ListNode* head, int val) &#123; ListNode* dummy = new ListNode(0); dummy-&gt;next = head; head = dummy; while (head-&gt;next) &#123; if (head-&gt;next-&gt;val == val) &#123; ListNode* temp = head-&gt;next; head-&gt;next = head-&gt;next-&gt;next; delete temp; &#125; else &#123; head = head-&gt;next; &#125; &#125; ListNode* res = dummy-&gt;next; delete dummy; return res; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode solution: Remove Nth Node From End of List (19)]]></title>
    <url>%2F2016%2F12%2F30%2F2016-12-30-leetcode-solution-Remove-Nth-Node-From-End-of-List-19%2F</url>
    <content type="text"><![CDATA[Given a linked list, remove the nth node from the end of list and return its head. For example,123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note:Given n will always be valid.Try to do this in one pass. 解法1： Two pointers, One Pass, O(N) Time头node不确定，上dummy node大法。然后用双指针向前移动，找到Nth node的前一个node，删除后返回dummy-&gt;nextC++12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* dummy = new ListNode(0); dummy-&gt;next = head; ListNode* left = dummy; head = dummy; for (int i = 0; i &lt; n; ++i) &#123; head = head-&gt;next; &#125; while (head-&gt;next) &#123; left = left-&gt;next; head = head-&gt;next; &#125; ListNode* temp = left-&gt;next; left-&gt;next = left-&gt;next-&gt;next; ListNode* res = dummy-&gt;next; delete temp; delete dummy; return res; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode解题: Path Sum II (113)]]></title>
    <url>%2F2016%2F12%2F30%2F2016-12-30-leetcode-solution-Path-Sum-II-113%2F</url>
    <content type="text"><![CDATA[Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum. For example:Given the below binary tree and sum = 22,1234567 5 / \ 4 8 / / \ 11 13 4 / \ / \7 2 5 1 return[ [5,4,11,2], [5,8,4,5]] 解法1： DFS关于求所有的路径之类的题目，首先想到的都是DFS。 这道题也不例外。 用DFS遍历tree， 每一次往下一个node， 就把当前的sum减去node的val， 如果碰到叶子并且叶子的val和所剩的val相等，则加入paths中。C++1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;vector&lt;int&gt; &gt; paths; vector&lt;int&gt; path; helper(root, sum, path, paths); return paths; &#125;private: void helper(TreeNode* node, int sum, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt; &gt;&amp; paths) &#123; if (!node) &#123; return; &#125; path.push_back(node-&gt;val); if (!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; sum == node-&gt;val) &#123; paths.push_back(path); &#125; helper(node-&gt;left, sum - node-&gt;val, path, paths); helper(node-&gt;right, sum - node-&gt;val, path, paths); path.pop_back(); &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Find All Anagrams in a String (438)]]></title>
    <url>%2F2016%2F12%2F29%2F2016-12-29-leetcode-solution-Find-All-Anagrams-in-a-String-438%2F</url>
    <content type="text"><![CDATA[Given a string s and a non-empty string p, find all the start indices of p’s anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1: Input:s: “cbaebabacd” p: “abc” Output:[0, 6] Explanation:The substring with start index = 0 is “cba”, which is an anagram of “abc”.The substring with start index = 6 is “bac”, which is an anagram of “abc”.Example 2: Input:s: “abab” p: “ab” Output:[0, 1, 2] Explanation:The substring with start index = 0 is “ab”, which is an anagram of “ab”.The substring with start index = 1 is “ba”, which is an anagram of “ab”.The substring with start index = 2 is “ab”, which is an anagram of “ab”. 解法1： 滑动窗口， O（N) Time比较自然想到的是用一个hash来记录p中出现的字符个数，然后对于每一个字串去比较是否是一个p的anagram。但如果一个一个的字串比较的话，复杂度很高。仔细想一想，每次向前挪一位的时候，我们只是更新了一个字符的信息，所以说一部分在hashtable中的信息还是可以用的。那么我们可以运用滑动窗口的算法来保留已经得到的信息，每移动一格就更新一下hashtable中的信息。具体的算法是这样的：先遍历一遍p，记录每一个字符出现的次数并记录在hashtable中。这里用的是滑动窗口的算法。用两个指针记录当前窗口的大小， right指针不停的向右侧移动。如果right指向的字符出现次数&gt;=1， 则表示找到一个对应的字符，所剩下的字符-1。 right字符在hashtable中出现的次数-1（无论是否出现过， 如果没有出现过，则数值为负值，便于区分是否是p中的字符） right向右移动 判断count是否为0， 如果是表明所有的字符都出现过，则left指向的起始点就是一个有效的起始点。 如果窗口大小已经大于p的大小，那么就需要移动左指针。 首先看left指向的是否出现在p中（一定是》0的），如果是则count++ 无论是否出现过，hash的值+1， 表明这个值已经退回。 C++1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: vector&lt;int&gt; findAnagrams(string s, string p) &#123; vector&lt;int&gt; res; if (s.empty() || p.empty() ) &#123; return res; &#125; vector&lt;int&gt; hash(26, 0); for (char c : p) &#123; hash[c - 'a']+=1; &#125; int left = 0, right = 0; int count = p.size(); while (right &lt; s.size()) &#123; if (hash[s[right] - 'a'] &gt;= 1) &#123; --count; &#125; hash[s[right] - 'a']-=1; ++right; if (count == 0) &#123; res.push_back(left); &#125; if (right - left == p.size()) &#123; if (hash[s[left] - 'a'] &gt;= 0) &#123; count++; &#125; hash[s[left] - 'a']+=1; left++; &#125; &#125; return res; &#125;&#125;; Java1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if (p == null || s == null || p.length() == 0 || s.length() == 0) &#123; return res; &#125; int[] hash = new int[26]; for (char ss: p.toCharArray()) &#123; hash[ss - 'a']++; &#125; int left = 0, right = 0, count = p.length(); while (right &lt; s.length()) &#123; char cur = s.charAt(right); if (hash[cur - 'a'] &gt; 0) &#123; count--; &#125; ++right; hash[cur - 'a']--; if (count == 0) &#123; res.add(left); &#125; if (right - left == p.length()) &#123; if (hash[s.charAt(left) - 'a'] &gt;= 0) &#123; ++count; &#125; hash[s.charAt(left) - 'a']++; ++left; &#125; &#125; return res; &#125;&#125; 运用滑动窗口的模板写一下Java123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (char c : p.toCharArray()) &#123; map.put(c, map.getOrDefault(c,0) + 1); &#125; int start = 0, end = 0; int count = map.size(); while (end &lt; s.length()) &#123; char current = s.charAt(end); if (map.containsKey(current)) &#123; map.put(current, map.get(current) - 1); if (map.get(current) == 0) &#123; count--; &#125; &#125; end++; while (count == 0) &#123; // check if the current substring (start, end) qualify for a anagram if (end - start == p.length()) &#123; res.add(start); &#125; char temp = s.charAt(start); if (map.containsKey(temp)) &#123; map.put(temp, map.get(temp) + 1); if (map.get(temp) &gt; 0) &#123; count++; &#125; &#125; start++; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Isomorphic Strings (205)]]></title>
    <url>%2F2016%2F12%2F29%2F2016-12-29-leetcode-solution-Isomorphic-Strings-205%2F</url>
    <content type="text"><![CDATA[Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. For example,Given “egg”, “add”, return true. Given “foo”, “bar”, return false. Given “paper”, “title”, return true. Note:You may assume both s and t have the same length. 解法1：用hashmap， 要注意的是，除了有aa-&gt;ab情况要排除，还有ab-&gt;aa的情况也要排除，所以这里用到了两个hashmap。C++C++里hashmap查看是否有key也可以用map.count(key)123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: bool isIsomorphic(string s, string t) &#123; if (s.size() != t.size()) &#123; return false; &#125; if (s.empty()) &#123; return true; &#125; unordered_map&lt;char, char&gt; mapLeft; unordered_map&lt;char, char&gt; mapRight; for (int i = 0; i &lt; s.size(); ++i) &#123; auto left2Right = mapLeft.find(s[i]); auto right2Left = mapRight.find(t[i]); if (left2Right == mapLeft.end() &amp;&amp; right2Left == mapRight.end()) &#123; mapLeft[s[i]] = t[i]; mapRight[t[i]] = s[i]; &#125; else if (left2Right != mapLeft.end()) &#123; if (mapLeft[s[i]] != t[i]) &#123; return false; &#125; mapRight[t[i]] = s[i]; &#125; else if (right2Left != mapRight.end()) &#123; if (mapRight[t[i]] != s[i]) &#123; return false; &#125; mapLeft[s[i]] = t[i]; &#125; else if (mapLeft[s[i]] != t[i] || mapRight[t[i]] != s[i]) &#123; return false; &#125; &#125; return true; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Flatten Binary Tree to Linked List (114)]]></title>
    <url>%2F2016%2F12%2F29%2F2016-12-29-leetcode-solution-Flatten-Binary-Tree-to-Linked-List-114%2F</url>
    <content type="text"><![CDATA[Given a binary tree, flatten it to a linked list in-place. For example,Given 1 / \ 2 5 / \ \ 3 4 6 The flattened tree should look like: 1 \ 2 \ 3 \ 4 \ 5 \ 6 解法1： Divide &amp; Conquer思路是对于每一个节点，如果有left和right两个child, 对left和right分别做flatten的话，只需要把left的child和right的root相连，同时把left的root设为NULL. 然后把root和left的root相连就得到了flatten的list。具体实现起来的时候，可以建立一个辅助的struct来存储每一个节点对应的flatten之后的root和child。C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */struct NodePair &#123; TreeNode* root; TreeNode* child; NodePair(TreeNode* r, TreeNode* c):root(r),child(c) &#123;&#125;&#125;;class Solution &#123;public: void flatten(TreeNode* root) &#123; if (!root) &#123; return; &#125; NodePair res = helper(root); &#125; NodePair helper(TreeNode* root) &#123; if (!root) &#123; return NodePair(NULL, NULL); &#125; if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; return NodePair(root, root); &#125; NodePair left = helper(root-&gt;left); NodePair right = helper(root-&gt;right); // Combine root-&gt;left = NULL; if (!left.root) &#123; root-&gt;right = right.root; &#125; else &#123; root-&gt;right = left.root; left.child-&gt;left = NULL; left.child-&gt;right = right.root; &#125; return NodePair(root, right.child?right.child:left.child); &#125;&#125;; Java1 解法2： Preorder traversal从给的例子可以看到，最后的顺序是一个preorder traversal。 那么我们可以先进行preorder， 然后把vector中的node都连接起来。C++12345678910111213141516171819202122232425262728class Solution &#123;public: void flatten(TreeNode* root) &#123; if (!root) &#123; return; &#125; vector&lt;TreeNode*&gt; nodes; preorder(nodes, root); for (int i = 0; i &lt; nodes.size() - 1; ++i) &#123; nodes[i]-&gt;left = NULL; nodes[i]-&gt;right = nodes[i + 1]; &#125; nodes[nodes.size() - 1]-&gt;left = nodes[nodes.size() - 1]-&gt;right = NULL; return; &#125; void preorder(vector&lt;TreeNode*&gt;&amp; nodes, TreeNode* root) &#123; if (!root) &#123; return; &#125; nodes.push_back(root); preorder(nodes, root-&gt;left); preorder(nodes, root-&gt;right); &#125;&#125;; 解法3： Iterative基本思想就是从上往下，如果有left child就把最右端的接到right child上，然后把left child移到左边。然后再按照路劲往下一个node，也就是说root = root.right12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public void flatten(TreeNode root) &#123; if (root == null) return; while (root != null) &#123; if (root.left != null) &#123; TreeNode prev = root.left; while (prev.right != null) &#123; prev = prev.right; &#125; prev.right = root.right; root.right = root.left; root.left = null; &#125; root = root.right; // go down along the path &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Divide &amp; Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Merge Sorted Array (88)]]></title>
    <url>%2F2016%2F12%2F28%2F2016-12-28-leetcode-solution-Merge-Sorted-Array-88%2F</url>
    <content type="text"><![CDATA[Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note:You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. 解法1： O（M + N）， O（1） Space本题的function的return是void，看来必须是inplace的。 由于两个array都是sorted， 我们可以从大到小的merge，这样我们可以把merge过的数值插入到第一个array的尾部。用一个指针维护插入的位置，另两个指针从大到小遍历两个array。C++1234567891011121314151617181920212223class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int mp = m - 1; int np = n - 1; int i = nums1.size() - 1; while (mp &gt;= 0 &amp;&amp; np &gt;= 0) &#123; if (nums1[mp] &gt;= nums2[np]) &#123; nums1[i--] = nums1[mp--]; &#125;else &#123; nums1[i--] = nums2[np--]; &#125; &#125; while (mp &gt;= 0) &#123; nums1[i--] = nums1[mp--]; &#125; while (np &gt;= 0) &#123; nums1[i--] = nums2[np--]; &#125; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Path Sum (112)]]></title>
    <url>%2F2016%2F12%2F28%2F2016-12-28-leetcode-solution-Path-Sum-112%2F</url>
    <content type="text"><![CDATA[Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. For example:Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. 解法1： DFS很直白的一个DFS的题目，用递归的方式很简洁的完成。基本思路是对每一个子节点，都可以看成是一个新的问题，只是问题变成了要求的sum是sum-root-&gt;val。直到leaf的时候判断当前要求的sum和自己是否一致（或者是更新了的sum是否为0）C++123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if (!root) &#123; return false; &#125; int cur = sum - root-&gt;val; if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; return cur == 0; &#125; return hasPathSum(root-&gt;left, cur) || hasPathSum(root-&gt;right, cur); &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Sum Root to Leaf Numbers (129)]]></title>
    <url>%2F2016%2F12%2F28%2F2016-12-28-leetcode-solution-Sum-Root-to-Leaf-Numbers-129%2F</url>
    <content type="text"><![CDATA[Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123. Find the total sum of all root-to-leaf numbers. For example, 1 / \ 2 3The root-to-leaf path 1-&gt;2 represents the number 12.The root-to-leaf path 1-&gt;3 represents the number 13. Return the sum = 12 + 13 = 25. Hide Tags Tree Depth-first SearchShow Similar Problems 解法1： DFS ， O(N) Space + O（N） Time题意是对每一个path做一个操作（记录成一个数字），容易想到用DFS来遍历整棵数。遍历的时候用一个vector存储每一个数字，最后对vector求一下和。C++1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int sumNumbers(TreeNode* root) &#123; if (!root) &#123; return 0; &#125; vector&lt;int&gt; temp; helper(root, temp, 0); int sum = 0; for (int i = 0; i &lt; temp.size(); ++i) &#123; sum += temp[i]; &#125; return sum; &#125; void helper(TreeNode* root, vector&lt;int&gt;&amp; buf, int cur) &#123; if (!root) &#123; return; &#125; cur = cur * 10 + root-&gt;val; if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; buf.push_back(cur); return; &#125; helper(root-&gt;left, buf, cur); helper(root-&gt;right, buf, cur); &#125;&#125;; Java1 解法2： DFS ， O(1) Space + O（N） Time实际上不需要用一个vector来存储见到的数字。C++123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int sumNumbers(TreeNode* root) &#123; if (!root) &#123; return 0; &#125; return helper(root, 0); &#125; int helper(TreeNode* root, int cur) &#123; if (!root) &#123; return 0; &#125; cur = cur * 10 + root-&gt;val; if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; return cur; &#125; int sum = helper(root-&gt;left, cur) + helper(root-&gt;right, cur); return sum; &#125; &#125;;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Guess Number Higher or Lower (374)]]></title>
    <url>%2F2016%2F12%2F27%2F2016-12-27-leetcode-solution-Guess-Number-Higher-or-Lower-374%2F</url>
    <content type="text"><![CDATA[We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I’ll tell you whether the number is higher or lower. You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0): -1 : My number is lower 1 : My number is higher 0 : Congrats! You got it!Example:n = 10, I pick 6. Return 6. 解法1： Binary Search O（logn)很典型的二分法的题目。 没有难点。C++1234567891011121314151617181920212223242526// Forward declaration of guess API.// @param num, your guess// @return -1 if my number is lower, 1 if my number is higher, otherwise return 0int guess(int num);class Solution &#123;public: int guessNumber(int n) &#123; int start = 1, end = n; while (start + 1 &lt; end) &#123; int mid = start + (end - start) / 2; if (guess(mid) &lt;0 ) &#123; end = mid; &#125; else &#123; start = mid; &#125; &#125; if (guess(end) == 0) &#123; return end; &#125; return start; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Valid Sudoku (36)]]></title>
    <url>%2F2016%2F12%2F27%2F2016-12-27-leetcode-solution-Valid-Sudoku-36%2F</url>
    <content type="text"><![CDATA[Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’. A partially filled sudoku which is valid. Note:A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated. 解法1： O（N N） Time + O(NN) Space, 一次遍历本题要满足三个条件，行，列以及小方块都不能包含重复的数字。可以用三个数组记录每一个条件是否满足，因为每个条件有9行，9列或者9个小方块。 每一个条件能出现的数字只有1到9。那么每次扫描一个数字时，判断三个条件是否出现过一样的数字，如果有则返回false。这样的做法好处是只需要遍历一次，代码很整洁。要注意的是在计算小方块的index的时候， 用了k = i / 3 3 + j / 3, 注意这里因为i是int，所以不能把/33抵消掉。C++12345678910111213141516171819202122class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; bool rule1[9][9] = &#123;false&#125;, rule2[9][9] = &#123;false&#125;, rule3[9][9] = &#123;false&#125;; for (int i = 0; i &lt; board.size(); ++i) &#123; for (int j = 0; j &lt; board[0].size(); ++j) &#123; if (board[i][j] != '.') &#123; int digit = board[i][j] - '0' - 1; int smallMatrixIndex = i / 3 * 3 + j / 3; if (rule1[i][digit] || rule2[j][digit] || rule3[smallMatrixIndex][digit]) &#123; return false; &#125; rule1[i][digit] = rule2[j][digit] = rule3[smallMatrixIndex][digit] = true; &#125; &#125; &#125; return true; &#125;&#125;; Java1 解1法2： O（N * N） Time + O(1) Space， 三次遍历C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; unordered_map&lt;int, int&gt; map; // check row for (int i = 0; i &lt; board.size(); ++i) &#123; map.clear(); for (int j = 0; j &lt; board[i].size(); ++j) &#123; if (board[i][j] == '.') &#123; continue; &#125; if (map[board[i][j]] != 0) &#123; return false; &#125; map[board[i][j]] = 1; &#125; &#125; // check col int row = board.size(); int col = board[0].size(); for (int i = 0; i &lt; col; ++i) &#123; map.clear(); for (int j = 0; j &lt; row; ++j) &#123; if (board[j][i] == '.') &#123; continue; &#125; if (map[board[j][i]] != 0) &#123; return false; &#125; map[board[j][i]] = 1; &#125; &#125; // check small matrix for (int i = 0; i &lt; row / 3; ++i) &#123; for (int j = 0; j &lt; col / 3; ++j) &#123; map.clear(); for (int k = i * 3; k &lt; i * 3 + 3; ++k) &#123; for (int m = j * 3; m &lt; j * 3 + 3; ++m) &#123; if (board[k][m] == '.') &#123; continue; &#125; if (map[board[k][m]] != 0) &#123; return false; &#125; map[board[k][m]] = 1; &#125; &#125; &#125; &#125; return true; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Binary Tree Inorder Traversal]]></title>
    <url>%2F2016%2F12%2F27%2F2016-12-27-leetcode-solution-Binary-Tree-Inorder-Traversal%2F</url>
    <content type="text"><![CDATA[Given a binary tree, return the inorder traversal of its nodes’ values. For example:Given binary tree [1,null,2,3], 1 \ 2 / 3return [1,3,2]. Note: Recursive solution is trivial, could you do it iteratively? Show Company TagsShow TagsShow Similar Problems 解法1： Recursion用递归的in-order很简单，按字面理解就是先左再自己再右。C++1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; helper(root, res); return res; &#125; void helper(TreeNode* root, vector&lt;int&gt;&amp; res) &#123; if (!root) &#123; return; &#125; helper(root-&gt;left, res); res.push_back(root-&gt;val); helper(root-&gt;right, res); &#125;&#125;; Java1 解法2： Iterative主要考虑的就是用一个stack来存储还没有访问的节点， 难点在于确定什么时候push和pop。那么在寻找最小值的时候，一路上碰到的所有node都push如果碰到了空节点，则证明现在的这条路已经到底了，需要往回寻找，这个时候就可以pop了，记录节点的数值。并且把将要探寻的指针放到right上继续。C++123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if (!root) &#123; return res; &#125; stack&lt;TreeNode*&gt; store; TreeNode* cur = root; while (cur || !store.empty()) &#123; if (cur) &#123; store.push(cur); cur = cur-&gt;left; &#125; else &#123; TreeNode* temp = store.top(); res.push_back(temp-&gt;val); store.pop(); cur = temp-&gt;right; &#125; &#125; return res; &#125;&#125;; Java123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if (root == null) return res; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while (root!= null || !stack.isEmpty()) &#123; if (root != null) &#123; stack.push(root); root = root.left; &#125; else &#123; TreeNode temp = stack.pop(); res.add(temp.val); root = temp.right; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>In-order-traversal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Kth Smallest Element in a BST (230)]]></title>
    <url>%2F2016%2F12%2F27%2F2016-12-27-leetcode-solution-Kth-Smallest-Element-in-a-BST-230%2F</url>
    <content type="text"><![CDATA[Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note:You may assume k is always valid, 1 ≤ k ≤ BST’s total elements. Follow up:What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine? Hint: Try to utilize the property of a BST.What if you could modify the BST node’s structure?The optimal runtime complexity is O(height of BST). 解法1： In-order traversal O（N）， N is number of elements这题可以看成是一个in-order traversal的直接应用，因为BST的in-order traversal是一个有序数组，那么我们就可以根据这个性质，对数进行遍历直到找到第k个node。C++123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int kthSmallest(TreeNode* root, int k) &#123; // implement a in-order-traversal int count = 0; int res; stack&lt;TreeNode*&gt; s; TreeNode* cur = root; while (cur || !s.empty()) &#123; if (cur) &#123; s.push(cur); cur = cur-&gt;left; &#125; else &#123; ++count; TreeNode* temp = s.top(); s.pop(); if (count == k) &#123; res = temp-&gt;val; break; &#125; cur = temp-&gt;right; &#125; &#125; return res; &#125;&#125;; Java12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int kthSmallest(TreeNode root, int k) &#123; // in-order traversal iterative solution Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); TreeNode current = root; int count = 0; int val = 0; while ( current != null || !stack.isEmpty()) &#123; if (current != null) &#123; stack.push(current); current = current.left; &#125; else &#123; TreeNode temp = stack.pop(); val = temp.val; count++; current = temp.right; if (count == k) &#123; return val; &#125; &#125; &#125; return val; &#125;&#125; Follow up : O(logN)参考这篇文章的思路如果可以修改每一个tree的node的结构，而使其保存leftcount和totalcount。那么一开始建立树需要O(N)的时间，而之后每一次insert和查找则只需要O(logN)的时间。lang: java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; class SuperNode &#123; int val; int count; int total; SuperNode left; SuperNode right; public SuperNode(int val) &#123; this.val = val; count = 0; total = 1; left = null; right = null; &#125; &#125;; public SuperNode build(TreeNode root) &#123; if (root == null) return null; SuperNode superRoot = new SuperNode(root.val); SuperNode left = build(root.left); SuperNode right = build(root.right); superRoot.left = left; superRoot.right = right; if (left != null) &#123; superRoot.count = left.total; &#125; else &#123; superRoot.count = 0; &#125; superRoot.total += ((left == null ? 0 : left.total) + (right == null ? 0 : right.total)); return superRoot; &#125; public int kthSmallest(TreeNode root, int k) &#123; SuperNode superRoot = build(root); return kth(superRoot, k); &#125; private int kth(SuperNode root, int k) &#123; if (root == null || k &lt;= 0) &#123; return 0; &#125; if (k == root.count + 1) &#123; return root.val; &#125; else if (k &lt; root.count + 1) &#123; return kth(root.left, k); &#125; else &#123; return kth(root.right, k - root.count - 1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>In-order-traversal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Arranging Coins (441)]]></title>
    <url>%2F2016%2F12%2F26%2F2016-12-26-leetcode-solution-Arranging-Coins-441%2F</url>
    <content type="text"><![CDATA[You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins. Given n, find the total number of full staircase rows that can be formed. n is a non-negative integer and fits within the range of a 32-bit signed integer. Example 1: n = 5 The coins can form the following rows:¤¤ ¤¤ ¤ Because the 3rd row is incomplete, we return 2.Example 2: n = 8 The coins can form the following rows:¤¤ ¤¤ ¤ ¤¤ ¤ Because the 4th row is incomplete, we return 3. 解法1： O(logN)一道很典型的binary search的题目，实际上这题是求最大的K， 满足1+2+… + k &lt;= n.记录1+2+…+k = k*(k+1)/2那么我们就可以用二分法来求出最大的k。要注意的是当计算乘积的时候可能会溢出，所以需要用long来存放start和end。C++123456789101112131415161718192021222324class Solution &#123;public: int arrangeCoins(int n) &#123; if (n &lt;= 0) &#123; return 0; &#125; long start = 1, end = n; while (start + 1 &lt; end) &#123; long mid = start + (end - start) / 2; if (mid * (mid + 1) / 2 &lt; n) &#123; start = mid; &#125; else &#123; end = mid; &#125; &#125; if (end * (end + 1) / 2 &lt;= n) &#123; return (int)end; &#125; return (int)start; &#125;&#125;; Java12345678910111213141516171819202122class Solution &#123; public int arrangeCoins(int n) &#123; if (n &lt;= 0) return 0; long start = 1, end = n; while (start + 1 &lt; end) &#123; long mid = start + (end - start) / 2; if ( mid * (mid + 1) / 2 &lt; n) &#123; start = mid; &#125; else &#123; end = mid; &#125; &#125; if (end * (end + 1) / 2 &lt;= n) &#123; return (int)end; &#125; return (int)start; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Valid Word Square (422)]]></title>
    <url>%2F2016%2F12%2F26%2F2016-12-26-leetcode-solution-Valid-Word-Square-422%2F</url>
    <content type="text"><![CDATA[Given a sequence of words, check whether it forms a valid word square. A sequence of words forms a valid word square if the kth row and column read the exact same string, where 0 ≤ k &lt; max(numRows, numColumns). Note:The number of words given is at least 1 and does not exceed 500.Word length will be at least 1 and does not exceed 500.Each word contains only lowercase English alphabet a-z.Example 1: Input:[ “abcd”, “bnrt”, “crmy”, “dtye”] Output:true Explanation:The first row and first column both read “abcd”.The second row and second column both read “bnrt”.The third row and third column both read “crmy”.The fourth row and fourth column both read “dtye”. Therefore, it is a valid word square.Example 2: Input:[ “abcd”, “bnrt”, “crm”, “dt”] Output:true Explanation:The first row and first column both read “abcd”.The second row and second column both read “bnrt”.The third row and third column both read “crm”.The fourth row and fourth column both read “dt”. Therefore, it is a valid word square.Example 3: Input:[ “ball”, “area”, “read”, “lady”] Output:false Explanation:The third row reads “read” while the third column reads “lead”. Therefore, it is NOT a valid word square. 解法1： O(M * N)就是遍历一遍每个字母，对每个字母判断是否有对应的字母。如果没有，则为falseC++12345678910111213141516171819202122class Solution &#123;public: bool validWordSquare(vector&lt;string&gt;&amp; words) &#123; int m = words.size(); for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; words[i].size(); ++j) &#123; char cur = words[i][j]; if (j &gt;= m) &#123; return false; &#125; if (words[j].size() &lt;= i) &#123; return false; &#125; if (words[j][i] != words[i][j]) &#123; return false; &#125; &#125; &#125; return true; &#125;&#125;; Java12345678910111213141516171819202122class Solution &#123; public boolean validWordSquare(List&lt;String&gt; words) &#123; if (words == null || words.size() == 0) &#123; return false; &#125; // Only need to search for the top diagonal int n = words.size(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; words.get(i).length(); j++) &#123; if (j &gt;= n) &#123; return false; &#125; if (words.get(j).length() &lt;= i || words.get(j).charAt(i) != words.get(i).charAt(j)) &#123; return false; &#125; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Delete Node in a BST (450)]]></title>
    <url>%2F2016%2F12%2F26%2F2016-12-26-leetcode-solution-Delete-Node-in-a-BST-450%2F</url>
    <content type="text"><![CDATA[Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST. Basically, the deletion can be divided into two stages: Search for a node to remove.If the node is found, delete the node.Note: Time complexity should be O(height of tree). Example: root = [5,3,6,2,4,null,7]key = 3 5 / \ 3 6 / \ \2 4 7 Given key to delete is 3. So we find the node with value 3 and delete it. One valid answer is [5,4,6,2,null,null,7], shown in the following BST. 5 / \ 4 6 / \2 7 Another valid answer is [5,2,6,null,4,null,7]. 5 / \ 2 6 \ \ 4 7 解法1：此题比较复杂，参考了这篇的解法。主要的思路是把要删除的节点分情况讨论。基本的思路是： 对于一个要删除的节点，找出大于他的最小的node作为新的子root，或者是选出小于他的最大的node作为新的root。解决此题的步骤如下： 找出要删除的节点的父节点。 如果删除节点是leaf， 那么直接把父节点相应的连接设为null 如果删除节点只有一个子树， 那么把父节点指向唯一的那个子树 如果删除节点有两个子树， 那么找出大于删除节点的最小节点（设为x), 然后把删除节点的数值设为x的值，然后重新运行一遍删除操作。 上一步中，程序一定会终止因为最左节点一定是只有小于等于1个子节点。等找出最小的大于他的node的时候（也就是右子树的最左节点）， 要分C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* deleteNode(TreeNode* root, int key) &#123; TreeNode* dummy = new TreeNode(0); dummy-&gt;left = root; TreeNode* parent = findNode(dummy, root, key); TreeNode* node; if (parent-&gt;left &amp;&amp; parent-&gt;left-&gt;val == key) &#123; node = parent-&gt;left; &#125; else if (parent-&gt;right &amp;&amp; parent-&gt;right-&gt;val == key) &#123; node = parent-&gt;right; &#125; else &#123; // can't find the node return dummy-&gt;left; &#125; deleteNode(parent, node); TreeNode* res = dummy-&gt;left; delete dummy; return res; &#125; TreeNode* findNode(TreeNode* parent, TreeNode* cur,int key) &#123; if (!cur || cur-&gt;val == key) &#123; return parent; &#125; if (cur-&gt;val &lt; key) &#123; return findNode(cur, cur-&gt;right, key); &#125; else &#123; return findNode(cur, cur-&gt;left, key); &#125; &#125; void deleteNode(TreeNode* parent, TreeNode* node) &#123; // delete the node, giving the parent if (!node-&gt;right) &#123; if (parent-&gt;left == node) &#123; parent-&gt;left = node-&gt;left; &#125; else &#123; parent-&gt;right = node-&gt;left; &#125; &#125; else if (!node-&gt;left) &#123; if (parent-&gt;left == node) &#123; parent-&gt;left = node-&gt;right; &#125; else &#123; parent-&gt;right = node-&gt;right; &#125; &#125; else &#123; TreeNode* father = node; TreeNode* child = node-&gt;right; while (child-&gt;left) &#123; father = child; child = child-&gt;left; &#125; node-&gt;val = child-&gt;val; deleteNode(father, child); &#125; &#125; &#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Palindrome Number (9)]]></title>
    <url>%2F2016%2F12%2F25%2F2016-12-25-leetcode-solution-Palindrome-Number-9%2F</url>
    <content type="text"><![CDATA[Determine whether an integer is a palindrome. Do this without extra space. click to show spoilers. Some hints:Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case? There is a more generic way of solving this problem. 解法1： Reverse integer O（N）， N is the number of digits用一个循环来反转数字，最后比较数字和反转的是否相等即可。C++1234567891011121314151617181920212223class Solution &#123;public: bool isPalindrome(int x) &#123; if (x &lt; 0) &#123; return false; &#125; if (x == 0) &#123; return true; &#125; int copy = x; int re = 0; while (x != 0) &#123; re = re*10 + x % 10; x /= 10; &#125; if (copy == re) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125;; Java1 解法2： Without overflow比较最左边和最右边的两个数，这样就不会有overflow的问题了。 取得左边的数的时候我们需要的是一个除数，这个可以先用O(N)的时间求出。然后每次求出最右位和最左位。然后每次消掉两位数，相应的div也要缩小100C++12345678910111213141516171819202122232425262728class Solution &#123;public: bool isPalindrome(int x) &#123; if (x &lt; 0) &#123; return false; &#125; if (x == 0) &#123; return true; &#125; int div = 1; while ( x / div &gt;= 10) &#123; div *= 10; &#125; while (x != 0) &#123; int left = x / div; int right = x % 10; if (left != right) &#123; return false; &#125; x = (x % div) / 10; // 消掉两位 div /= 100; // 除数缩小100 &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Closest Binary Search Tree Value (270)]]></title>
    <url>%2F2016%2F12%2F25%2F2016-12-25-leetcode-solution-Closest-Binary-Search-Tree-Value-270%2F</url>
    <content type="text"><![CDATA[Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target. Note:Given target value is a floating point.You are guaranteed to have only one unique value in the BST that is closest to the target. 解法1： Divide &amp; Conquer关于树的题目，先考虑试试分治的思想，对于一个root，要找出最接近他的数值，可能比他小也可能比他大。所以如果他本身不等于target的话需要比较left 和right。似乎分治行得通。由于题目给出guarantee有一个解，则不需要考虑空树的情况。 那么只要分三种情况考虑： 左右子树都有， 那么比较左右子树的closestvalue和自身哪一个更close 左子树 右子树其中2，3 只要比较root和其中一个子树算出来的结果就可以了。 C++1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int closestValue(TreeNode* root, double target) &#123; if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; return root-&gt;val; &#125; if (root-&gt;val == target) &#123; return target; &#125; int child; if (root-&gt;left &amp;&amp; root-&gt;right) &#123; int left = closestValue(root-&gt;left, target); int right = closestValue(root-&gt;right, target); child = abs(left - target) &lt;= abs(right - target)? left : right; &#125; else if (root-&gt;left) &#123; child = closestValue(root-&gt;left, target); &#125; else if (root-&gt;right) &#123; child = closestValue(root-&gt;right, target); &#125; return abs(child - target) &lt;= abs(root-&gt;val - target) ? child: root-&gt;val; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Divide &amp; Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode解题: Binary Tree Right Side View (199)]]></title>
    <url>%2F2016%2F12%2F25%2F2016-12-25-leetcode-solution-Binary-Tree-Right-Side-View-199%2F</url>
    <content type="text"><![CDATA[Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. For example:Given the following binary tree, 1 &lt;— / \2 3 &lt;— \ \ 5 4 &lt;—You should return [1, 3, 4]. 解法1： BFS, O（N）这题也是考察BFS算法的一个变形，题意是要求每一层最右边的node。那么我们按层遍历，对于每一层只取第一个（最右边）的node的数值就可以了。C++1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; rightSideView(TreeNode* root) &#123; vector&lt;int&gt; res; if (!root) &#123; return res; &#125; queue&lt;TreeNode*&gt; q; q.push(root); while (!q.empty()) &#123; int k = q.size(); for (int i = 0; i &lt; k; ++i) &#123; TreeNode* cur = q.front(); if (i == 0) &#123; res.push_back(cur-&gt;val); &#125; q.pop(); if (cur-&gt;right) &#123; q.push(cur-&gt;right); &#125; if (cur-&gt;left) &#123; q.push(cur-&gt;left); &#125; &#125; &#125; return res; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Populating next right pointers in each node II (117)]]></title>
    <url>%2F2016%2F12%2F24%2F2016-12-24-leetcode-solution-Populkating-next-right-pointers-in-each-node-II-117%2F</url>
    <content type="text"><![CDATA[Follow up for problem “Populating Next Right Pointers in Each Node”. What if the given tree could be any binary tree? Would your previous solution still work? Note: You may only use constant extra space.For example,Given the following binary tree, 1 / \ 2 3 / \ \ 4 5 7After calling your function, the tree should look like: 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ \ 4-&gt; 5 -&gt; 7 -&gt; NULL 解法1： BFS， O（N） Time + O（N） Space运用此前perfect tree的解法，此题任然有效。C++12345678910111213141516171819202122232425void connect(TreeLinkNode *root) &#123; if (!root) &#123; return; &#125; queue&lt;TreeLinkNode*&gt; q; q.push(root); while(!q.empty()) &#123; int number = q.size(); TreeLinkNode* prev = NULL; for (int i = 0; i &lt; number; ++i) &#123; TreeLinkNode* cur = q.front(); q.pop(); cur-&gt;next = prev; prev = cur; if (cur-&gt;right) &#123; q.push(cur-&gt;right); &#125; if (cur-&gt;left) &#123; q.push(cur-&gt;left); &#125; &#125; &#125; return;&#125; Java1 解法2： Iterative， O（N） Time + O（1） Space123456789101112131415161718192021222324public class Solution &#123; public void connect(TreeLinkNode root) &#123; TreeLinkNode dummy = new TreeLinkNode(0); // point to the next level's first node TreeLinkNode prev = dummy; while (root != null) &#123; if (root.left != null) &#123; prev.next = root.left; prev = prev.next; &#125; if (root.right != null) &#123; prev.next = root.right; prev = prev.next; &#125; root = root.next; if (root == null) &#123; // end of current level, move to the next level root = dummy.next; prev = dummy; dummy.next = null; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Populating Next right pointers in each node (116)]]></title>
    <url>%2F2016%2F12%2F24%2F2016-12-24-leetcode-solution-Populating-Next-right-pointers-in-each-node-116%2F</url>
    <content type="text"><![CDATA[Given a binary tree struct TreeLinkNode { TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note: You may only use constant extra space.You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).For example,Given the following perfect binary tree, 1 / \ 2 3 / \ / \ 4 5 6 7After calling your function, the tree should look like: 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ / \ 4-&gt;5-&gt;6-&gt;7 -&gt; NULLShow Company TagsShow TagsShow Similar Problems 解法1： BFS, O(N) Time + O（N） Space按照题目意思，似乎是一层一层的要连起来，第一个反应就是用BFS， 按层遍历。遍历的时候最好是从右往左，这样头node可以指向prev，之后不停的更新prev。实现起来没有难度。C++123456789101112131415161718192021222324252627282930313233343536/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if (!root) &#123; return; &#125; queue&lt;TreeLinkNode*&gt; q; q.push(root); while(!q.empty()) &#123; int number = q.size(); TreeLinkNode* prev = NULL; for (int i = 0; i &lt; number; ++i) &#123; TreeLinkNode* cur = q.front(); q.pop(); cur-&gt;next = prev; prev = cur; if (cur-&gt;right) &#123; q.push(cur-&gt;right); &#125; if (cur-&gt;left) &#123; q.push(cur-&gt;left); &#125; &#125; &#125; return; &#125;&#125;; Java123456789101112131415161718192021222324252627282930public class Solution &#123; public void connect(TreeLinkNode root) &#123; if (root == null) &#123; return; &#125; Queue&lt;TreeLinkNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; int size = queue.size(); TreeLinkNode prev = null; for (int i = 0; i &lt; size; i++) &#123; TreeLinkNode current = queue.poll(); if (prev != null) &#123; prev.next = current; &#125; if (current.left != null) &#123; queue.offer(current.left); &#125; if (current.right != null) &#123; queue.offer(current.right); &#125; prev = current; &#125; &#125; return; &#125;&#125; 解法2： Recursive O(N) Time + O（1） Space实际上上面的解法是不符合空间复杂度要求的，要求是constant。用递归的办法可以解决。对于每一层，用当前的信息去connect下一层，再对left和right分别进行递归就可以了。12345678910111213141516public class Solution &#123; public void connect(TreeLinkNode root) &#123; if (root == null) &#123; return; &#125; if (root.left != null) &#123; root.left.next = root.right; if (root.next != null) &#123; root.right.next = root.next.left; &#125; &#125; connect(root.left); connect(root.right); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Minimum Depth of Binary Tree (111)]]></title>
    <url>%2F2016%2F12%2F24%2F2016-12-24-leetcode-solution-Minimum-Depth-of-Binary-Tree-111%2F</url>
    <content type="text"><![CDATA[Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. 解法1： BFS， O（N),典型的用BFS的题，按层遍历，只要找到一个为叶子的节点，则当前记录的层数一定是最小层。 用一个queue来完成BFS。C++用到了queue 的push(), front() 和pop()123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int minDepth(TreeNode* root) &#123; int count = 0; if (!root) &#123; return count; &#125; queue&lt;TreeNode*&gt; q; q.push(root); while (!q.empty()) &#123; ++count; int k = q.size(); for (int i = 0; i &lt; k; ++i) &#123; TreeNode* temp = q.front(); q.pop(); if (!temp-&gt;left &amp;&amp; !temp-&gt;right) &#123; return count; &#125; if (temp-&gt;left) &#123; q.push(temp-&gt;left); &#125; if (temp-&gt;right) &#123; q.push(temp-&gt;right); &#125; &#125; &#125; return count; &#125;&#125;; Java1 解法2： Recursive, Divide and Conquer, O(N)一个数的最小层数是min（leftMin， rightMin） + 1, 用分治法和递归解决， code可以做到很简洁。关于BFS和分治两者的复杂度分析，应该是一样的，参考九章的一个解答C++1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int minDepth(TreeNode* root) &#123; if (!root) &#123; return 0; &#125; return helper(root); &#125; int helper(TreeNode* root) &#123; if (!root) &#123; return INT_MAX; &#125; if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; return 1; &#125; return min(helper(root-&gt;left), helper(root-&gt;right)) + 1; &#125;&#125;;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Pascal's Triangle II (119)]]></title>
    <url>%2F2016%2F12%2F24%2F2016-12-24-leetcode-solution-Pascal-s-Triangle-II-119%2F</url>
    <content type="text"><![CDATA[Given an index k, return the kth row of the Pascal’s triangle. For example, given k = 3,Return [1,3,3,1]. Note:Could you optimize your algorithm to use only O(k) extra space? 解法1： 重复利用Array, O(k^2) Time + O（K） Space题目要求节省空间，想到的办法就是不停的修改当前的array。这里要注意的是： 修改array的时候要从后往前修改，这样在计算前面的数值的时候不会受到已经修改过的数值的影响。 在修改array的时候是从1到当前的最后一个。因为当修改完毕之后array的大小才会增加。如果不注意这一点会出现[1,1,1]这样的结果。C++1234567891011121314class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; res; res.push_back(1); for (int i = 0; i &lt; rowIndex; ++i) &#123; for (int j = res.size(); j &gt;= 1; --j) &#123; res[j] += res[j - 1]; &#125; res.push_back(1); &#125; return res; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Pascal's Triangle (118)]]></title>
    <url>%2F2016%2F12%2F24%2F2016-12-24-leetcode-solution-Pascal-s-Triangle-118%2F</url>
    <content type="text"><![CDATA[Given numRows, generate the first numRows of Pascal’s triangle. For example, given numRows = 5,Return [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 解法1： O（N^2) N 是numRows很基础的题，注意第i层的第j个字符是第i-1层的第j个数和第j-1个数之和就可以了。C++123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt;&gt; res; if (numRows == 0) &#123; return res; &#125; vector&lt;int&gt; x&#123;1&#125;; res.push_back(x); for (int i = 1; i &lt; numRows; ++i) &#123; vector&lt;int&gt; temp&#123;1&#125;; for (int j = 1; j &lt; i; ++j) &#123; temp.push_back(res[i - 1][j - 1] + res[i - 1][j]); &#125; temp.push_back(1); res.push_back(temp); &#125; return res; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Convert a Number to Hexadecimal (405)]]></title>
    <url>%2F2016%2F12%2F24%2F2016-12-24-leetcode-solution-Convert-a-Number-to-Hexadecimal-405%2F</url>
    <content type="text"><![CDATA[iven an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used. Note: All letters in hexadecimal (a-f) must be in lowercase.The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character ‘0’; otherwise, the first character in the hexadecimal string will not be the zero character.The given number is guaranteed to fit within the range of a 32-bit signed integer.You must not use any method provided by the library which converts/formats the number to hex directly.Example 1: Input:26 Output:“1a”Example 2: Input:-1 Output:“ffffffff” 解法1：16进制每一位表示4个bit的信息，4个bit可以表示0到15的数字，0~9用阿拉伯数字，10~15分别用a ~ f 表示。 那么基本思路就是每一次获取最右边的4位数，然后转化为16进制的数字。然后右移直到数字变为0。C++要注意的是C++ 中如果用+ 操作在string 和 string上，只能char或者string，所以如果是int则要转化为char再进行操作。12345678910111213141516171819202122class Solution &#123;public: string toHex(int num) &#123; if (num == 0) &#123; return "0"; &#125; string res = ""; int count = 0; while (num != 0 &amp;&amp; count &lt; 8) &#123; int temp = num &amp; 0xf; if (temp &lt; 10) &#123; res = to_string(temp) + res; &#125; else &#123; res = char('a' + temp - 10) + res; &#125; num = num &gt;&gt; 4; ++count; &#125; return res; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Math</tag>
        <tag>bit operator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Binary Search Tree Iterator (173)]]></title>
    <url>%2F2016%2F12%2F23%2F2016-12-23-leetcode-solution-Binary-Search-Tree-Iterator-173%2F</url>
    <content type="text"><![CDATA[Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. 解法1： Stack用一个stack先预存排序了的treenode， 每次要调用next（）和hasNext（）的时候，只需要对stack操作即可。C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class BSTIterator &#123;private: stack&lt;TreeNode*&gt; data;public: BSTIterator(TreeNode *root) &#123; traverse(root); &#125; void traverse(TreeNode* root) &#123; if (!root) &#123; return; &#125; if (!root-&gt;right &amp;&amp; !root-&gt;left) &#123; data.push(root); return; &#125; traverse(root-&gt;right); data.push(root); traverse(root-&gt;left); &#125; /** @return whether we have a next smallest number */ bool hasNext() &#123; return !data.empty(); &#125; /** @return the next smallest number */ int next() &#123; TreeNode* temp = data.top(); int res = temp-&gt;val; data.pop(); return res; &#125;&#125;;/** * Your BSTIterator will be called like this: * BSTIterator i = BSTIterator(root); * while (i.hasNext()) cout &lt;&lt; i.next(); */ Java1 解法2： Stack， 非递归的in order traversal实际上不需要预先存储排了序的treenode，而是在寻找最小的值的时候把经过的node用stack存起来。这里实际上考的是iterative的in order traversal C++12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class BSTIterator &#123;private: stack&lt;TreeNode*&gt; data; TreeNode* cur;public: BSTIterator(TreeNode *root) &#123; cur = root; &#125; /** @return whether we have a next smallest number */ bool hasNext() &#123; return cur || !data.empty(); &#125; /** @return the next smallest number */ int next() &#123; while (cur) &#123; data.push(cur); cur = cur-&gt;left; &#125; TreeNode* temp = data.top(); int res = temp-&gt;val; data.pop(); cur = temp-&gt;right; return res; &#125;&#125;;/** * Your BSTIterator will be called like this: * BSTIterator i = BSTIterator(root); * while (i.hasNext()) cout &lt;&lt; i.next(); */]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Find All Numbers Disappeared in an Array (448)]]></title>
    <url>%2F2016%2F12%2F22%2F2016-12-22-leetcode-solution-Find-All-Numbers-Disappeared-in-an-Array-448%2F</url>
    <content type="text"><![CDATA[Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: Input:[4,3,2,7,8,2,3,1] Output:[5,6] 解法1： O（N) Time + O(1) Space本题是用了替换的办法。由于提前知道数的范围是从1 ~ n， 那么我们可以试着把每一个数放到该存在的位置，也就是nums[i] = i + 1。 不停的调整每一个位置上的数，直到满足这个条件或者是和要调整的位置上的数相等。由于每一个数只visit一次，所以complexity是O（N）。比较tricky的是，在置换两个数的时候要特别小心，我一开始写了123int ex = nums[i];nums[i] = nums[nums[i] - 1];nums[nums[i] - 1] = nums[i];这是不对的，因为在第二步nums[i]的值已经换过了。等扫描结束一遍之后，再扫描一遍vector找出位置上的数和位置不同的数。C++123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123; int i = 0; while (i &lt; nums.size()) &#123; if (nums[i] - 1 != i) &#123; int temp = nums[nums[i] - 1]; if (temp == nums[i]) &#123; ++i; &#125; else &#123; nums[nums[i] - 1] = nums[i]; nums[i] = temp; &#125; &#125; else &#123; ++i; &#125; &#125; vector&lt;int&gt; res; for (int j = 0; j &lt; nums.size(); ++j) &#123; if (nums[j] - 1 != j) &#123; res.push_back(j + 1); &#125; &#125; return res; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Binary Tree Paths (257)]]></title>
    <url>%2F2016%2F12%2F22%2F2016-12-22-leetcode-solution-Binary-Tree-Paths-257%2F</url>
    <content type="text"><![CDATA[Given a binary tree, return all root-to-leaf paths. For example, given the following binary tree: 1 / \2 3 \ 5All root-to-leaf paths are: [“1-&gt;2-&gt;5”, “1-&gt;3”] 解法1： DFS， O（N）很标准的DFS的题目，要注意的是因为我们需要加入“-&gt;”， 所以写法上可以有两种办法。一个是helper函数的起始string是“”， 那么每次加一个node的时候要判断是否str还是空，是的话不加，不是则加箭头。另一个是一开始就赋值root-&gt;val， 这样每次碰到新node的时候一定需要加上”-&gt;”。写法上第二种办法更干净一些。C++1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; vector&lt;string&gt; res; if (!root) &#123; return res; &#125; helper(root, to_string(root-&gt;val), res); return res; &#125; void helper(TreeNode* root, string s, vector&lt;string&gt;&amp; res) &#123; if (!root) &#123; return; &#125; if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; res.push_back(s); return; &#125; if (root-&gt;left) &#123; helper(root-&gt;left, s + "-&gt;" + to_string(root-&gt;left-&gt;val), res); &#125; if (root-&gt;right) &#123; helper(root-&gt;right, s + "-&gt;" + to_string(root-&gt;right-&gt;val), res); &#125; return; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode解题: Lowest Common Ancestor of a Binary Tree (236)]]></title>
    <url>%2F2016%2F12%2F22%2F2016-12-22-leetcode-solution-Lowest-Common-Ancestor-of-a-Binary-Tree-236%2F</url>
    <content type="text"><![CDATA[Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).” _______3______ / \ ___5__ ___1__ / \ / \ 6 _2 0 8 / \ 7 4For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Show Company TagsShow TagsShow Similar Problems 解法1： O（N）这题和Lowest Common Ancestor of a Binary Search Tree (235)的不同之处在于这里的条件比较松，只知道是一个binary tree。所以当root不是其中一个node的时候，需要同时计算left和right是否有存在的LCA。那么递归的返回条件就是只要找到root和其中之一相等的时候，就返回当前的node。这样就会出现种情况，root 不是两个node的任何一个， LCA可以存在于left tree中 也可以存在于right tree中 也可以是当前的root（因为左右各含一个node）。对于1，2两种情况，其中一个tree会返回空值对于第三种情况，left和right的值都不同，以此就可以区分而得出我们想要的结果。 C++12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (root == NULL || root == p || root == q) &#123; return root; &#125; TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); if (left == NULL) &#123; return right; &#125; if (right == NULL) &#123; return left; &#125; return root; &#125;&#125;; Java12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null || root == p || root == q) &#123; return root; &#125; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if (left == null) &#123; return right; &#125; if (right == null) &#123; return left; &#125; return root; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Divide &amp; Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Factorial Trailing Zeroes (172)]]></title>
    <url>%2F2016%2F12%2F21%2F2016-12-21-leetcode-solution-Factorial-Trailing-Zeroes-172%2F</url>
    <content type="text"><![CDATA[Given an integer n, return the number of trailing zeroes in n!. Note: Your solution should be in logarithmic time complexity. 解法1： O（N）， N is number of 5一道老题了， 主要就是有一个5就会对应一个trailing zero， 题目要求的就变成从1到n有多少个数含有5的因子。C++1234567891011121314class Solution &#123;public: int trailingZeroes(int n) &#123; if (n &lt; 5) &#123; return 0; &#125; int count = 0; while (n &gt; 0) &#123; count += n / 5; n = n / 5; &#125; return count; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Palindrome Linked List (234)]]></title>
    <url>%2F2016%2F12%2F21%2F2016-12-21-leetcode-solution-Palindrome-Linked-List-234%2F</url>
    <content type="text"><![CDATA[Given a singly linked list, determine if it is a palindrome. Follow up:Could you do it in O(n) time and O(1) space? 解法1： O（N） Time + O（1） Space基本思路就是从中间断开，然后把其中一段reverse，再同时遍历判断两个字列是否一致。C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isPalindrome(ListNode* head) &#123; if (!head || !head-&gt;next) &#123; return true; &#125; int count = 0; ListNode* ptr = head; while (ptr) &#123; ++count; ptr = ptr-&gt;next; &#125; ptr = head; ListNode* preMidPtr = preMid(ptr); ListNode* right; if (count % 2 == 0) &#123; // even number right = preMidPtr-&gt;next; preMidPtr-&gt;next = NULL; &#125; else &#123; right = preMidPtr-&gt;next-&gt;next; preMidPtr-&gt;next = NULL; &#125; right = reverse(right); while (head &amp;&amp; right) &#123; if (head-&gt;val != right-&gt;val) &#123; return false; &#125; head = head-&gt;next; right = right-&gt;next; &#125; return head == NULL &amp;&amp; right == NULL; &#125; ListNode* preMid(ListNode* root) &#123; ListNode* fast = root-&gt;next; while (fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123; root = root-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return root; &#125; ListNode* reverse(ListNode* head) &#123; ListNode* prev = NULL; while (head) &#123; ListNode* temp = head-&gt;next; head-&gt;next = prev; prev = head; head = temp; &#125; return prev; &#125; &#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode解题: Count Complete Tree Nodes (222)]]></title>
    <url>%2F2016%2F12%2F21%2F2016-12-21-leetcode-solution-Count-Complete-Tree-Nodes-222%2F</url>
    <content type="text"><![CDATA[Given a complete binary tree, count the number of nodes. Definition of a complete binary tree from Wikipedia:In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. 解法1： O(logN * logN）这题参考了Discussion的解法， 用遍历的方法的话，复杂度是O（N）， 但并没有用到complete BT的性质，显然最后的结果是TLE。在巧妙的解法里，运用complete tree的一个性质是： 如果从一个root出发，最左面和最右面的高度一致的话，那么一定是一个complete tree，他的节点个数是pow(2, k) - 1, k是高度。这个的运算的复杂度是O(logN).如果高度不一致的话，那么可以对左右各做一次操作， 也就是一个递归操作。复杂度分析T（n) = T(n/2) + clogN = T（n/4) + clogN + c1(logN - 1) = … = T(1) + c[logN + logN - 1 + logN - 2 + … + 1] =&gt; O(logN logN) logN*logN是比N好很多的，比如1024， logN = 10， N = 1024， 显然这个解法的复杂度好很多。C++1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int countNodes(TreeNode* root) &#123; if (!root) &#123; return 0; &#125; int left = 0, right = 0; TreeNode* toleft = root, *toright = root; while (toleft) &#123;++left; toleft = toleft-&gt;left;&#125; while (toright) &#123;++right; toright = toright-&gt;right;&#125; if (left == right) return (1 &lt;&lt; left) - 1; return 1 + countNodes(root-&gt;left) + countNodes(root-&gt;right); &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Valid Palindrome (125)]]></title>
    <url>%2F2016%2F12%2F20%2F2016-12-20-leetcode-solution-Valid-Palindrome-125%2F</url>
    <content type="text"><![CDATA[Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. For example,“A man, a plan, a canal: Panama” is a palindrome.“race a car” is not a palindrome. Note:Have you consider that the string might be empty? This is a good question to ask during an interview. For the purpose of this problem, we define empty string as valid palindrome. Show Company TagsShow TagsShow Similar Problems 解法1： Two pointers, O(N)用双指针很简单。要注意的是要跳过非alphanumeric的数字，这里C++里面判断是否是alphanumeric的数字的时候是用的isalnum（x)。 转化为lowercase的时候用的是tolower（x)C++1234567891011121314151617181920212223class Solution &#123;public: bool isPalindrome(string s) &#123; if (s.empty()) &#123; return true; &#125; int i = 0, j = s.length() - 1; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; !isalnum(s[i])) &#123; ++i;&#125; while (i &lt; j &amp;&amp; !isalnum(s[j])) &#123; --j;&#125; if (i &lt; j) &#123; if (tolower(s[i]) != tolower(s[j])) &#123; return false; &#125; else &#123; ++i; --j; &#125; &#125; &#125; return true; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Valid Parenthese (20)]]></title>
    <url>%2F2016%2F12%2F20%2F2016-12-20-leetcode-solution-Valid-Parenthese-20%2F</url>
    <content type="text"><![CDATA[Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not. 解法1： Stack O（N） Space + O（N） Time主要考察stack的用法，用一个stack存储所有的左括号，每当遇到右括号的时候就取stack中寻找是否是match的左括号。C++123456789101112131415161718192021222324252627class Solution &#123;public: bool isValid(string s) &#123; if (s.empty()) &#123; return true; &#125; stack&lt;char&gt; st; for (auto c : s) &#123; if (c == '(' || c == '[' || c == '&#123;') &#123; st.push(c); &#125; else &#123; if (st.empty()) &#123; return false; &#125; else &#123; char top = st.top(); if ((top == '(' &amp;&amp; c == ')') || (top == '[' &amp;&amp; c == ']') || (top == '&#123;' &amp;&amp; c == '&#125;')) &#123; st.pop(); &#125; else &#123; return false; &#125; &#125; &#125; &#125; return st.empty(); &#125;&#125;; Java123456789101112131415161718192021222324252627282930public class Solution &#123; public boolean isValid(String s) &#123; if (s == null || s.isEmpty()) &#123; return true; &#125; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (char c: s.toCharArray()) &#123; if (c == '(' || c == '&#123;' || c == '[') &#123; stack.push(c); &#125; else &#123; if (stack.isEmpty()) &#123; return false; &#125; char top = stack.peek(); if (c == ')' &amp;&amp; top == '(') &#123; stack.pop(); &#125; else if (c == ']' &amp;&amp; top == '[') &#123; stack.pop(); &#125; else if (c == '&#125;' &amp;&amp; top == '&#123;') &#123; stack.pop(); &#125; else &#123; return false; &#125; &#125; &#125; return stack.isEmpty(); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Validate Binary Search Tree (98)]]></title>
    <url>%2F2016%2F12%2F20%2F2016-12-20-leetcode-solution-Validate-Binary-Search-Tree-98%2F</url>
    <content type="text"><![CDATA[Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key.The right subtree of a node contains only nodes with keys greater than the node’s key.Both the left and right subtrees must also be binary search trees.Example 1: 2 / \ 1 3Binary tree [2,1,3], return true.Example 2: 1 / \ 2 3Binary tree [1,2,3], return false. 解法1： DFS本题的思路在题意中已经给出来了。要validate一个BST，要满足的是left 和right都是valid BST,同时root的值要大于left的最大值，要小于right的最小值。这里就提示我们在进行遍历的时候要记录每一个子树的最大值和最小值。用一个辅助结构struct来记录max，min和是否是validate tree。 从左至右判断是否满足BST的条件。C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */struct resultSet &#123; int maxVal; int minVal; bool isValid; resultSet (int maxv, int minv, bool isv):maxVal(maxv),minVal(minv),isValid(isv)&#123;&#125;;&#125;;class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; if (root == NULL) &#123; return true; &#125; resultSet temp = helper(root); return temp.isValid; &#125; resultSet helper(TreeNode* root) &#123; if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; return resultSet(root-&gt;val, root-&gt;val, true); &#125; int maxVal = root-&gt;val; int minVal = root-&gt;val; if (root-&gt;left) &#123; resultSet left = helper(root-&gt;left); if (!left.isValid || root-&gt;val &lt;= left.maxVal) &#123; return resultSet(0, 0, false); &#125; maxVal = max(maxVal, left.maxVal); minVal = min(minVal, left.minVal); &#125; if (root-&gt;right) &#123; resultSet right = helper(root-&gt;right); if (!right.isValid || root-&gt;val &gt;= right.minVal) &#123; return resultSet(0, 0, false); &#125; maxVal = max(maxVal, right.maxVal); minVal = min(minVal, right.minVal); &#125; return resultSet(maxVal, minVal, true); &#125;&#125;; Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; class Node &#123; int min; int max; boolean isValid; public Node(int min, int max, boolean isValid) &#123; this.min = min; this.max = max; this.isValid = isValid; &#125; &#125;; public boolean isValidBST(TreeNode root) &#123; if (root == null) &#123; return true; &#125; Node res = helper(root); return res.isValid; &#125; private Node helper(TreeNode root) &#123; if (root == null) &#123; return null; &#125; if (root.left == null &amp;&amp; root.right == null) &#123; return new Node(root.val, root.val, true); &#125; Node left = helper(root.left); Node right = helper(root.right); // conquer if (left == null) &#123; if (!right.isValid || right.min &lt;= root.val) &#123; return new Node(-1, -1, false); &#125; else &#123; return new Node(root.val, right.max, true); &#125; &#125; else if (right == null) &#123; if (!left.isValid || left.max &gt;= root.val) &#123; return new Node(-1, -1, false); &#125; else &#123; return new Node(left.min, root.val, true); &#125; &#125; else &#123; if (!left.isValid || !right.isValid) return new Node(-1, -1, false); if (left.max &gt;= root.val || right.min &lt;= root.val) return new Node(-1, -1, false); return new Node(Math.min(left.min, root.val), Math.max(right.max, root.val), true); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Swap Nodes in Pairs (24)]]></title>
    <url>%2F2016%2F12%2F19%2F2016-12-19-leetcode-solution-Swap-Nodes-in-Pairs-24%2F</url>
    <content type="text"><![CDATA[Given a linked list, swap every two adjacent nodes and return its head. For example,Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 解法1： O(N), 基本的LinkedList操作调整后头节点不确定，用dummy node解决。然后就是很普通的node之间的对换。 1 -&gt; 2 -&gt; 3 -&gt; 4, 在换两个node之前，要记录剩下的list的头节点。 换好之后（假设两个node分别为first和second，那么就把first指向剩下的list的头节点)C++12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if (head == NULL || head-&gt;next == NULL) &#123; return head; &#125; ListNode* dummy = new ListNode(0); dummy-&gt;next = head; ListNode* ptr = dummy; while (ptr-&gt;next != NULL &amp;&amp; ptr-&gt;next-&gt;next != NULL) &#123; ListNode* first = ptr-&gt;next; ListNode* second = first-&gt;next; ListNode* remaining = second-&gt;next; ptr-&gt;next = second; second-&gt;next = first; first-&gt;next = remaining; ptr = first; &#125; ListNode* res = dummy-&gt;next; delete dummy; return res; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Hamming Distance (461)]]></title>
    <url>%2F2016%2F12%2F19%2F2016-12-19-leetcode-solution-Hamming-Distance-461%2F</url>
    <content type="text"><![CDATA[The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Note:0 ≤ x, y &lt; 231. Example: Input: x = 1, y = 4 Output: 2 Explanation:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑ The above arrows point to positions where the corresponding bits are different. 解法1： O(M), M is the number of bits in difference这题考察了两个基本操作，一个是XOR的消除操作。XOR两个数得出的数含有所有不一样bit，然后再统计set bit的个数就可以了。如果还记得在统计bit的题目里面的做法，用x &amp; (x - 1)消掉最高位的1直到x变为0为止。C++12345678910111213141516class Solution &#123;public: int hammingDistance(int x, int y) &#123; int temp = x ^ y; return numberOfBits(temp); &#125; int numberOfBits(int x) &#123; int count = 0; while (x != 0) &#123; ++count; x = x &amp; (x - 1); &#125; return count; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode解题: Convert Sorted Array to Binary Search Tree (108)]]></title>
    <url>%2F2016%2F12%2F19%2F2016-12-19-leetcode-solution-Convert-Sorted-Array-to-Binary-Search-Tree-108%2F</url>
    <content type="text"><![CDATA[Given an array where elements are sorted in ascending order, convert it to a height balanced BST. 解法1： Recursion很多Tree的问题都可以用Divide &amp; Conquer/递归的思想。这题也如此。要建立balanced tree，我们需要左边和右边的height尽可能相近。就考虑到选择中间作为root。之后就转化为把左array和右array转换的问题，这就是一个递归。 C++1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) &#123; return NULL; &#125; return helper(nums, 0, nums.size() - 1); &#125; TreeNode* helper(vector&lt;int&gt;&amp; nums, int start, int end) &#123; if (start &gt; end) &#123; return NULL; &#125; if (start == end) &#123; return new TreeNode(nums[start]); &#125; int middle = start + (end - start) / 2; TreeNode* root = new TreeNode(nums[middle]); TreeNode* left = helper(nums, start, middle - 1); TreeNode* right = helper(nums, middle + 1, end); root-&gt;left = left; root-&gt;right = right; return root; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Divide &amp; Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Remove Duplicates from Sorted Array (26)]]></title>
    <url>%2F2016%2F12%2F18%2F2016-12-18-leetcode-solution-Remove-Duplicates-from-Sorted-Array-26%2F</url>
    <content type="text"><![CDATA[Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. For example,Given input array nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length. 解法1：Two pointers思路和Remove elements一样，不一样的是two pointers指向的位置不同。这题由于是sorted，那么可以用一个指针指向插入的位置，只有碰到和前面不一样的数值的时候才更新他的值。最后由于是返回count，所以要注意是把第一个指针的数值+1.举例：1 2 3 3 4当1，2，3 都不一样的时候，slow的指针往前进。当碰到第二个3的时候，slow不变，当碰到4时，把4赋值给第二个3，也就是当前slow的位置。C++12345678910111213141516class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) &#123; return 0; &#125; int slow = 0; for (int i = 1; i &lt; nums.size(); ++i) &#123; if (nums[i] != nums[i -1]) &#123; nums[++slow] = nums[i]; &#125; &#125; return slow + 1; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Remove Element (27)]]></title>
    <url>%2F2016%2F12%2F18%2F2016-12-18-leetcode-solution-Remove-Element-27%2F</url>
    <content type="text"><![CDATA[Given an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example:Given input array nums = [3,2,2,3], val = 3 Your function should return length = 2, with the first two elements of nums being 2. Hint: Try two pointers.Did you use the property of “the order of elements can be changed”?What happens when the elements to remove are rare? 解法1：Two pointers用two pointers，back记录需要remove的起始的位置。front不停的往后扫描，当扫到不要remove的时候则前进，如果扫到需要remove的就和back指向的数值交换，back向前-1C++1234567891011121314151617181920212223class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; if (nums.empty()) &#123; return 0; &#125; int front = 0, back = nums.size() - 1; while (front &lt;= back) &#123; if (nums[front] != val) &#123; ++front; &#125; else &#123; int temp = nums[back]; nums[back] = nums[front]; nums[front] = temp; --back; &#125; &#125; return front; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Plus One (66)]]></title>
    <url>%2F2016%2F12%2F18%2F2016-12-18-leetcode-solution-Plus-One-66%2F</url>
    <content type="text"><![CDATA[Given a non-negative number represented as an array of digits, plus one to the number. The digits are stored such that the most significant digit is at the head of the list. 解法1：O(N)很基本的算carry，digit的方法 C++要注意c++ insert的用法是insert(iterator, obj)， 如果是在头部插入，可以用insert(it.begin(), obj).12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; if (digits.size() == 0) &#123; return digits; &#125; int carry = 0; int n = digits.size(); carry = (digits[n - 1] + 1) / 10; digits[n - 1] = (digits[n- 1] + 1) % 10; for (int i = n - 2; i &gt;= 0; --i) &#123; int temp = (digits[i] + carry) % 10; carry = (digits[i] + carry) / 10; digits[i] = temp; &#125; if (carry &gt; 0) &#123; digits.insert(digits.begin(), carry); &#125; return digits; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Power of Four (342)]]></title>
    <url>%2F2016%2F12%2F18%2F2016-12-18-leetcode-solution-Power-of-Four-342%2F</url>
    <content type="text"><![CDATA[Given an integer (signed 32 bits), write a function to check whether it is a power of 4. Example:Given num = 16, return true. Given num = 5, return false. Follow up: Could you solve it without loops/recursion? 解法1：log换底log4(x) == int, 运用log4(x) = log10(x)/log10(4)C++1234567class Solution &#123;public: bool isPowerOfFour(int num) &#123; double temp = log10(num) / log10(4); return temp == (int) temp; &#125;&#125;; Java1 解法2：power of two + math如果是4的次方数，那么-1之后一定能被3整除。要注意的是&amp;的优先级比==小，所以如果写成num &amp; (num - 1) == 0是不对的。C++123456class Solution &#123;public: bool isPowerOfFour(int num) &#123; return num &gt; 0 &amp;&amp; !(num &amp; (num - 1)) &amp;&amp; (num - 1) % 3 == 0; &#125;&#125;;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Reorder List (143)]]></title>
    <url>%2F2016%2F12%2F18%2F2016-12-18-leetcode-solution-Reorder-List-143%2F</url>
    <content type="text"><![CDATA[Given a singly linked list L: L0→L1→…→Ln-1→Ln,reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→… You must do this in-place without altering the nodes’ values. For example,Given {1,2,3,4}, reorder it to {1,4,2,3}. 解法1：Hashmap + two pointers O(N) Time with O(N) space用一个hashmap记录每一个node的位置，map的key是位置的坐标。然后用双指针重新把list按顺序连接起来。C++1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void reorderList(ListNode* head) &#123; if (head == NULL) &#123; return; &#125; unordered_map&lt;int, ListNode*&gt; map; int count = 0; while (head != NULL) &#123; ListNode* cur = head; head = head-&gt;next; cur-&gt;next = NULL; map.insert(&#123;count, cur&#125;); count++; &#125; ListNode* dummy = new ListNode(0); ListNode* tail = dummy; for (int i = 0, j = count - 1; i &lt;= j; ++i, --j) &#123; if (i == j) &#123; tail-&gt;next = map[i]; tail = tail-&gt;next; &#125; else &#123; tail-&gt;next = map[i]; tail = tail-&gt;next; tail-&gt;next = map[j]; tail = tail-&gt;next; &#125; &#125; ListNode* res = dummy-&gt;next; head = res; &#125;&#125;; Java1 解法2： findMiddle + Reverse O(N) Time + O(1) Space本题也可以用linkedlist的常用算法解决。第一步可以先找出list的中点，如果是偶数个如：1-&gt;2-&gt;3-4, 找出的是2，如果是奇数个：1-&gt;2-&gt;3-&gt;4-&gt;5, 找出的是3。第二步：找出以后对后半部分进行reverse操作。第三步：将右半部份merge到左半部分这种解法不像第一种解法需要额外的存储空间。C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void reorderList(ListNode* head) &#123; if (head == NULL || head-&gt;next == NULL) &#123; return; &#125; ListNode* preMiddle = findPreMiddle(head); ListNode* right = preMiddle-&gt;next; preMiddle-&gt;next = NULL; right = reverse(right); mergeToLeft(head, right); &#125; ListNode* findPreMiddle(ListNode* head) &#123; ListNode* slow = head; ListNode* fast = head-&gt;next; while (fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return slow; &#125; ListNode* reverse(ListNode* head) &#123; ListNode* prev = NULL; while (head != NULL) &#123; ListNode* temp = head-&gt;next; head-&gt;next = prev; prev =head; head = temp; &#125; return prev; &#125; void mergeToLeft(ListNode* left, ListNode* right) &#123; ListNode* curLeft; ListNode* curRight; while (left &amp;&amp; right) &#123; curLeft = left; left = left-&gt;next; curRight = right; right = right-&gt;next; curLeft-&gt;next = curRight; curRight-&gt;next = left; &#125; &#125;&#125;; Javalang: java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public void reorderList(ListNode head) &#123; if (head == null || head.next == null) return; // Merge + reverse ListNode middle = findMiddle(head); ListNode right = middle.next; middle.next = null; // break at the middle right = reverse(right); mergeToLeft(head, right); return; &#125; private ListNode findMiddle(ListNode head) &#123; ListNode slow = head, fast = head.next; while (fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; fast = fast.next.next; &#125; return slow; &#125; private void mergeToLeft(ListNode left, ListNode right) &#123; while (left != null &amp;&amp; right != null) &#123; ListNode leftNext = left.next; ListNode rightNext = right.next; left.next = right; right.next = leftNext; left = leftNext; right = rightNext; &#125; &#125; private ListNode reverse(ListNode head) &#123; ListNode prev = null; while (head != null) &#123; ListNode next = head.next; head.next = prev; prev = head; head = next; &#125; return prev; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Implement Queue using Stacks (232)]]></title>
    <url>%2F2016%2F12%2F17%2F2016-12-17-leetcode-solution-Implement-Queue-using-Stacks-232%2F</url>
    <content type="text"><![CDATA[Implement the following operations of a queue using stacks. push(x) – Push element x to the back of queue.pop() – Removes the element from in front of queue.peek() – Get the front element.empty() – Return whether the queue is empty.Notes:You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid.Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue). 解法1：Two Queuestack和queue的区别是前者是FILO, 后者是FIFO， 如果用另外一个stack去反倒回来就得到了queue一样的效果。实现起来，用一个buffer stack存储应该的顺序，peek和pop都应该从buffer中取，如果读取buffer的时候为空的话，则需要把数据从原stack移到buffer。C++1234567891011121314151617181920212223242526272829303132333435363738class Queue &#123;private: stack&lt;int&gt; mstack; stack&lt;int&gt; buffer;public: // Push element x to the back of queue. void push(int x) &#123; mstack.push(x); &#125; // Removes the element from in front of queue. void pop(void) &#123; if (buffer.empty()) &#123; while (!mstack.empty()) &#123; buffer.push(mstack.top()); mstack.pop(); &#125; &#125; buffer.pop(); &#125; // Get the front element. int peek(void) &#123; if (buffer.empty()) &#123; while (!mstack.empty()) &#123; buffer.push(mstack.top()); mstack.pop(); &#125; &#125; return buffer.top(); &#125; // Return whether the queue is empty. bool empty(void) &#123; return mstack.empty() &amp;&amp; buffer.empty(); &#125;&#125;; Java只有在push的时候，如果当前的stack里面存在元素的话，先把元素存在另外一个stack里面。然后把要push的元素push了之后再把buffer里面的元素放回stack。123456789101112131415161718192021222324252627282930313233343536373839404142434445class MyQueue &#123; /** Initialize your data structure here. */ Stack&lt;Integer&gt; stack; public MyQueue() &#123; stack = new Stack&lt;Integer&gt;(); &#125; /** Push element x to the back of queue. */ public void push(int x) &#123; Stack&lt;Integer&gt; temp = new Stack&lt;Integer&gt;(); while (!stack.isEmpty()) &#123; temp.push(stack.pop()); &#125; stack.push(x); while (!temp.isEmpty()) &#123; stack.push(temp.pop()); &#125; &#125; /** Removes the element from in front of queue and returns that element. */ public int pop() &#123; return stack.pop(); &#125; /** Get the front element. */ public int peek() &#123; return stack.peek(); &#125; /** Returns whether the queue is empty. */ public boolean empty() &#123; return stack.isEmpty(); &#125;&#125;/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Balanced Binary Tree (110)]]></title>
    <url>%2F2016%2F12%2F17%2F2016-12-17-leetcode-solution-Balanced-Binary-Tree-110%2F</url>
    <content type="text"><![CDATA[Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 解法1：按照定义，balanced是指left tree和right tree的max height的差值可以小于等于1，同时要满足left tree和right tree都是一个balanced tree。用返回一个resultSet的办法返回多值，（balanced，maxHeight). 要注意的是返回的时候root的height需要是max(leftHeight, rightHeight) + 1C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */struct resultSet &#123; bool isBalanced; int maxHeight; resultSet(bool b, int h): isBalanced(b), maxHeight(h) &#123;&#125;&#125;;class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; resultSet res = helper(root); return res.isBalanced; &#125; resultSet helper(TreeNode* root) &#123; if (root == NULL) &#123; return resultSet(true, 0); &#125; if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; return resultSet(true, 1); &#125; resultSet left = helper(root-&gt;left); if (!left.isBalanced) &#123; return resultSet(false, 0); &#125; resultSet right = helper(root-&gt;right); if (!right.isBalanced) &#123; return resultSet(false, 0); &#125; return resultSet(abs(left.maxHeight - right.maxHeight) &lt;= 1, max(left.maxHeight, right.maxHeight) + 1); &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Divide &amp; Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Binary Tree Level Order Traversal (102)]]></title>
    <url>%2F2016%2F12%2F17%2F2016-12-17-leetcode-solution-Binary-Tree-Level-Order-Traversal-102%2F</url>
    <content type="text"><![CDATA[Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example:Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7return its level order traversal as:[ [3], [9,20], [15,7]] 解法1：One Queue比较基础的BST算法，主要是掌握用一个queue和一个每层的计数器k来维护当前层的node个数C++12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if (root == NULL) &#123; return res; &#125; queue&lt;TreeNode*&gt; q; q.push(root); while (!q.empty()) &#123; int k = q.size(); vector&lt;int&gt; level; for (int i = 0; i &lt; k; ++i) &#123; TreeNode* node = q.front(); q.pop(); level.push_back(node-&gt;val); if (node-&gt;left) &#123; q.push(node-&gt;left); &#125; if (node-&gt;right) &#123; q.push(node-&gt;right); &#125; &#125; res.push_back(level); &#125; return res; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Partition List (86)]]></title>
    <url>%2F2016%2F12%2F17%2F2016-12-17-leetcode-solution-Partition-List-86%2F</url>
    <content type="text"><![CDATA[Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. For example,Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5. 解法1：Dummy Node, O(N) One pass这题比array的partition容易一些，主要用两个dummy node记录两个list，一个小于x，一个大于等于x。用一个head指针维护现在遍历到的node。最后将两个dummy连在一起就可以了。C++1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* partition(ListNode* head, int x) &#123; ListNode* left = new ListNode(0); ListNode* lefttail = left; ListNode* right = new ListNode(0); ListNode* righttail = right; while (head != NULL) &#123; ListNode* next = head-&gt;next; head-&gt;next = NULL; if (head-&gt;val &lt; x) &#123; lefttail-&gt;next = head; lefttail = lefttail-&gt;next; &#125; else &#123; righttail-&gt;next = head; righttail = righttail-&gt;next; &#125; head = next; &#125; lefttail-&gt;next = right-&gt;next; ListNode* res = left-&gt;next; delete left; delete right; return res; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Binary Tree Level Order Traversal II (107)]]></title>
    <url>%2F2016%2F12%2F16%2F2016-12-16-leetcode-solution-Binary-Tree-Level-Order-Traversal-II-107%2F</url>
    <content type="text"><![CDATA[Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root). For example:Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7return its bottom-up level order traversal as:[ [15,7], [9,20], [3]] 解法1：BST + Two container用按层遍历（one queue）的办法遍历得出每一层的vector，然后放入一个stack，最后按顺序读出vector中的值即可。C++1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if (!root) return res; stack&lt;vector&lt;int&gt;&gt; temp; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()) &#123; int k = q.size(); vector&lt;int&gt; level; for (int i = 0; i &lt; k; ++i) &#123; TreeNode* node = q.front(); q.pop(); level.push_back(node-&gt;val); if (node-&gt;left) &#123; q.push(node-&gt;left); &#125; if (node-&gt;right) &#123; q.push(node-&gt;right); &#125; &#125; temp.push(level); &#125; while (!temp.empty()) &#123; res.push_back(temp.top()); temp.pop(); &#125; return res; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Symmetric Tree (101)]]></title>
    <url>%2F2016%2F12%2F16%2F2016-12-16-leetcode-solution-Symmetric-Tree-101%2F</url>
    <content type="text"><![CDATA[Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \ 2 2 / \ / \3 4 4 3But the following [1,2,2,null,3,null,3] is not: 1 / \ 2 2 \ \ 3 3 Note: Bonus points if you could solve it both recursively and iteratively. 解法1：Recursive主要还是分治的思想，对称的意思就是left = right，实际上我们要比较的是left tree 和right tree。需要满足的条件是left.left = right.right &amp;&amp; left.right = right.left然后不停的递归下去就可以了。C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if (root == NULL) &#123; return true; &#125; if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) &#123; return true; &#125; return mirror(root-&gt;left, root-&gt;right); &#125; bool mirror(TreeNode* left, TreeNode* right) &#123; if (left == NULL &amp;&amp; right == NULL) &#123; return true; &#125; if (left != NULL &amp;&amp; right == NULL) &#123; return false; &#125; if (left == NULL &amp;&amp; right != NULL) &#123; return false; &#125; if (left-&gt;val != right-&gt;val) &#123; return false; &#125; bool leftChild = mirror(left-&gt;left, right-&gt;right); if (!leftChild) return false; bool rightChild = mirror(left-&gt;right, right-&gt;left); return rightChild; &#125;&#125;; 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if (root == null) &#123; return true; &#125; return isSymmetric(root.left, root.right); &#125; private boolean isSymmetric(TreeNode left, TreeNode right) &#123; if (left != null &amp;&amp; right == null) &#123; return false; &#125; if (left == null &amp;&amp; right != null) &#123; return false; &#125; if (left == null &amp;&amp; right == null) &#123; return true; &#125; if (left.val != right.val) return false; return isSymmetric(left.left, right.right) &amp;&amp; isSymmetric(left.right, right.left); &#125;&#125; 解法2：Iteratively非递归一般需要用额外的数据结构，这里可以想到的是用queue，然后做一个BFS（按层遍历）。和比较是否是same tree很像，唯一不一样的是这里left需要从左往右，而right需要从右往左。参考了喜唰唰的解法。C++12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if (!root) return true; queue&lt;TreeNode*&gt; left, right; left.push(root-&gt;left); right.push(root-&gt;right); while(!left.empty() &amp;&amp; !right.empty()) &#123; TreeNode* lchild = left.front(); TreeNode* rchild = right.front(); left.pop(); right.pop(); if (!lchild &amp;&amp; !rchild) continue; if (!lchild &amp;&amp; rchild) return false; if (lchild &amp;&amp; !rchild) return false; if (lchild-&gt;val != rchild-&gt;val) return false; left.push(lchild-&gt;left); left.push(lchild-&gt;right); right.push(rchild-&gt;right); right.push(rchild-&gt;left); &#125; if (!left.empty() || !right.empty()) &#123; return false; &#125; return true; &#125;&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if (root == null) return true; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); if ((root.left != null &amp;&amp; root.right == null) || (root.right != null &amp;&amp; root.left == null)) &#123; return false; &#125; if (root.left == null &amp;&amp; root.right == null) return true; queue.offer(root.left); queue.offer(root.right); while (!queue.isEmpty()) &#123; if (queue.size() % 2 != 0) return false; TreeNode left = queue.poll(); TreeNode right = queue.poll(); if ((left.left != null &amp;&amp; right.right == null) || (left.left == null &amp;&amp; right.right != null)) return false; if ((left.right != null &amp;&amp; right.left == null) || (left.right == null &amp;&amp; right.left != null)) return false; if (left.val != right.val) return false; if (left.left != null) &#123; queue.offer(left.left); queue.offer(right.right); &#125; if (left.right != null) &#123; queue.offer(left.right); queue.offer(right.left); &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>BST</tag>
        <tag>Divide &amp; Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Insertion Sort List (147)]]></title>
    <url>%2F2016%2F12%2F16%2F2016-12-16-leetcode-solution-Insertion-Sort-List-147%2F</url>
    <content type="text"><![CDATA[Sort a linked list using insertion sort. 解法1：Dummy Node, Insertion Sort O(N^2)这题一开始想不太清楚，但知道应该用dummy node。实际上，dummy node可以作为一个空的list，用一个指针（head）来记录当前想要插入的node，每一个node在dummy指向的list中找到位置后插入。这样想就比较清晰了。用到的指针有 cur 记录当前插入的node的指针 p 用来遍历已经排序好的dummy指向的那个list head 用来遍历原list直到end C++123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; if (head == NULL || head-&gt;next == NULL) &#123; return head; &#125; ListNode* dummy = new ListNode(0); // For each node, attach to dummy linked list while (head != NULL) &#123; ListNode* cur = head; head = head-&gt;next; ListNode* p = dummy; while (p-&gt;next &amp;&amp; p-&gt;next-&gt;val &lt;= cur-&gt;val) &#123; p = p-&gt;next; &#125; cur-&gt;next = p-&gt;next; p-&gt;next = cur; &#125; head = dummy-&gt;next; delete dummy; return head; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Linked List Cycle (141)]]></title>
    <url>%2F2016%2F12%2F15%2F2016-12-15-leetcode-solution-Linked-List-Cycle-141%2F</url>
    <content type="text"><![CDATA[Given a linked list, determine if it has a cycle in it. Follow up:Can you solve it without using extra space? 解法1：O(1) Space + O(N) Time, Two pointers此题初看可以用hashtable来解决，用一个指针一边跑一边放入hashtable，如果跑到见过的node⑩则知道有cycle。由于follow up中提到了不能用extra space，所以考虑经典的two pointers算法。快慢指针，一个走一步一个走两步，如果在走完之前相遇的话就有cycle。要注意的是输入的判定，如果为空list的话直接返回falseC++123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if (head == NULL) &#123; return false; &#125; ListNode* slow = head; ListNode* fast = head-&gt;next; while (fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if (slow == fast) &#123; return true; &#125; &#125; return false; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Two pointers</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Group Shifted Strings (249)]]></title>
    <url>%2F2016%2F12%2F15%2F2016-12-15-leetcode-solution-Group-Shifted-Strings-249%2F</url>
    <content type="text"><![CDATA[Given a string, we can “shift” each of its letter to its successive letter, for example: “abc” -&gt; “bcd”. We can keep “shifting” which forms the sequence: “abc” -&gt; “bcd” -&gt; … -&gt; “xyz”Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence. For example, given: [“abc”, “bcd”, “acef”, “xyz”, “az”, “ba”, “a”, “z”],A solution is: [ [“abc”,”bcd”,”xyz”], [“az”,”ba”], [“acef”], [“a”,”z”]] 解法1：Hash Function, Hash Table此题一看就是用hashtable的一道题，但难点在于什么是hashtable的key，换句话说，要构造出一个function，使得grouped string有相同的key。思考一下可以得出，如果将每个字符转化为和第一个字符的距离，变可以得出一样的key。这里要注意的是，difference可以是正也可以是负，那么就需要加上25或者是26之后再对26取余来做。C++涉及到了几个C++的syntax： access map value：iterator-&gt;second, iterator-&gt;first insert to the end of a vector: vector.push_back()12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupStrings(vector&lt;string&gt;&amp; strings) &#123; unordered_map&lt;string, vector&lt;string&gt;&gt; map; for (auto str: strings) &#123; string s = ""; for (auto i : str) &#123; s += std::to_string((i - str[0] + 26) % 26) + " "; &#125; if (map.find(s) != map.end()) &#123; map[s].push_back(str); &#125; else &#123; vector&lt;string&gt; v; v.push_back(str); map[s] = v; &#125; &#125; vector&lt;vector&lt;string&gt;&gt; res; for (auto i = map.begin(); i != map.end(); ++i) &#123; res.push_back(i-&gt;second); &#125; return res; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Hash table</tag>
        <tag>Hash function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Convert Sorted List to Binary Search Tree (109)]]></title>
    <url>%2F2016%2F12%2F15%2F2016-12-15-leetcode-solution-Convert-Sorted-List-to-Binary-Search-Tree-109%2F</url>
    <content type="text"><![CDATA[Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. 解法1：Divide and Conquer按照题意是要构造一个balanced的BST,那么root一定是sorted list的中间的一个点。所以想到了linkedlist求中间点的算法。如果中间点求到了，那么可以将原list分成左右两个子list，对于每一个子list做相应的操作，左面的list就是左子树，右面的list就是右子树。这是一种分治的思想C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *//** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* sortedListToBST(ListNode* head) &#123; if (head == NULL) &#123; return NULL; &#125; if (head-&gt;next == NULL) &#123; return new TreeNode(head-&gt;val); &#125; ListNode* preMiddle = findPreMiddle(head); ListNode* right = preMiddle-&gt;next-&gt;next; TreeNode* root = new TreeNode(preMiddle-&gt;next-&gt;val); // break left and right preMiddle-&gt;next-&gt;next = NULL; preMiddle-&gt;next = NULL; TreeNode* leftTree = sortedListToBST(head); TreeNode* rightTree = sortedListToBST(right); root-&gt;left = leftTree; root-&gt;right = rightTree; return root; &#125; ListNode* findPreMiddle(ListNode* head) &#123; if (head == NULL) &#123; return head; &#125; ListNode* slow = head; ListNode* fast = head-&gt;next; while (fast != NULL &amp;&amp; fast-&gt;next != NULL &amp;&amp; fast-&gt;next-&gt;next != NULL) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return slow; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Lowest Common Ancestor of a Binary Search Tree (235)]]></title>
    <url>%2F2016%2F12%2F14%2F2016-12-14-leetcode-solution-Lowest-Common-Ancestor-of-a-Binary-Search-Tree-235%2F</url>
    <content type="text"><![CDATA[Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).” ___6__/ \_2 _8/ \ / \0 _4 7 9 / \ 3 5For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. 解法1：Recursion这题有一个很重要的前提是这是一棵BST。并且隐含条件是一定存在对于给点的两个node的LCA。那么考虑两种情况，假设两个node的大小一个比root大一个比root小，则node分属于左右子树，LCA只可能是root如果两个node同属一边，则问题也等价于在左子树（假设node的val比root的小），套用递归的思想解决即可。C++12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (root == p || root == q) &#123; return root; &#125; if (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) &#123; return root; &#125; if (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) &#123; return root; &#125; if (p-&gt;val &lt; root-&gt;val) &#123; return lowestCommonAncestor(root-&gt;left, p, q); &#125; return lowestCommonAncestor(root-&gt;right, p, q); &#125;&#125;; Java12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == p || root == q) &#123; return root; &#125; if ((root.val &lt; p.val &amp;&amp; root.val &gt; q.val) || (root.val &gt; p.val &amp;&amp; root.val &lt; q.val)) &#123; return root; &#125; if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123; return lowestCommonAncestor(root.right, p, q); &#125; return lowestCommonAncestor(root.left, p, q); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Ugly Number (263)]]></title>
    <url>%2F2016%2F12%2F14%2F2016-12-14-leetcode-solution-Ugly-Number-263%2F</url>
    <content type="text"><![CDATA[Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7. Note that 1 is typically treated as an ugly number. 解法1：暴力法按照题意，ugly number一定是1，2，3，5几个数的乘积。那么用number不停的去整除2，3，5，如果发现不能整除，则不是ugly，如果能整除则继续直到为1或者出现不能整除的数为止。C++123456789101112131415161718192021class Solution &#123;public: bool isUgly(int num) &#123; if (num &lt;= 0) &#123; return false; &#125; while (num != 1) &#123; if (num %2 == 0) &#123; num /= 2; &#125; else if (num % 3 == 0) &#123; num /= 3; &#125; else if (num % 5 == 0) &#123; num /= 5; &#125; else &#123; return false; &#125; &#125; return true; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Reverse Linked List II (92)]]></title>
    <url>%2F2016%2F12%2F14%2F2016-12-14-leetcode-solution-Reverse-Linked-List-II-92%2F</url>
    <content type="text"><![CDATA[Reverse a linked list from position m to n. Do it in-place and in one-pass. For example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4, return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL. Note:Given m, n satisfy the following condition:1 ≤ m ≤ n ≤ length of list. 解法1：Two pointers, One Pass O(N)题目要求只能走一遍，所以考虑用双指针。同时需要考虑到的是，等reverse结束，我们的head是不确定的，在这种情况下我们考虑使用dummy node，将dummy node指向head，最后不管其中怎么变化，我们一定是返回dummy.next假设我们已经知道从node m 到node n需要reverse，那么reverse之后由于要并入原来的list，我们需要知道子list的head之前的那个node，以及子list的尾巴之后的那个node， 比如：1-&gt;2-&gt;3-&gt;4-&gt;5, if m = 2, n = 4那么我们需要记录指针位置1和指针位置5，当把2-&gt;3-&gt;4翻转过后把新的head和tail指向这两个节点就可以了。实现上维护two pointers和一个计数器，当right pointer移动到子list的head的时候，left pointer就自然而然的指向了前面的那个node，把子list的head记录为newtail，因为当reverse之后他会变成tail。然后开始reverse的过程，同时变更计数器，直到计数器等于n的值为止。这个时候我们就得到了新的head，记录下一个值便是我们要将newtail指向的位置。最后返回dummy.nextC++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseBetween(ListNode* head, int m, int n) &#123; if (m == n) &#123; return head; &#125; ListNode* dummy = new ListNode(0); dummy-&gt;next = head; ListNode* ptr0 = dummy; ListNode* newhead = NULL; ListNode* newtail = NULL; int count = 1; while (count &lt; m) &#123; ptr0 = ptr0-&gt;next; head = head-&gt;next; ++count; &#125; newtail = head; ListNode* prev = head; head = head-&gt;next; ++count; while (count &lt;= n) &#123; ListNode* temp = head-&gt;next; head-&gt;next = prev; prev = head; head = temp; ++count; &#125; newhead = prev; ptr0-&gt;next = newhead; newtail-&gt;next = head; return dummy-&gt;next; &#125;&#125;; Java1 解法2：Two pointers, One Pass O(N)解法1的思想比较直观，不过写起来比较繁琐。从discuss上看来的这个解法比较简洁。要注意的是其中有把一个子list反转的template需要记一下，很有用。1prev-&gt;A-&gt;B-&gt;C-&gt;res 对于上面这个list，要反转A到C，那么设start为A，then为B两个指针。prev不移动而移动start和then，每一次把start向后移动一位，并且把then指向的node接到prev之后就可以达到效果。代码是123456for (int i = 0; i &lt; n - ml; i++) &#123; start.next = then.next; then.next = prev.next; prev.next = then; then = start.next;&#125; 完整的代码就简洁多了。Java123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseBetween(ListNode head, int m, int n) &#123; if (m == n || head == null) &#123; return head; &#125; ListNode dummy = new ListNode(0); dummy.next = head; ListNode prev = dummy; for (int i = 0; i &lt; m - 1; i++) &#123; prev = prev.next; &#125; // prev points to the m nodes ListNode start = prev.next; ListNode then = start.next; for (int i = 0; i &lt; n - m; i++) &#123; start.next = then.next; then.next = prev.next; prev.next = then; then = start.next; &#125; return dummy.next; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题 : Path Sum III (437)]]></title>
    <url>%2F2016%2F12%2F13%2F2016-12-13-leetcode-solution-Path-Sum-III-437%2F</url>
    <content type="text"><![CDATA[You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000. Example: root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \ 5 -3 / \ \ 3 2 11 / \ \3 -2 1 Return 3. The paths that sum to 8 are: 5 -&gt; 3 5 -&gt; 2 -&gt; 1 -3 -&gt; 11 解法1：DFS / Recursion这题考察DFS的基本知识。因为考虑的是每一个从上到下的path，那么应该要想到要用DFS。对于每一个节点，如果包括自己，则可以递归运算left 和right，而要match的数则变成了sum - val。如果不包括自己，则直接运算left和right，最后将两个情况相加就是结果。实际上这里就是用了一个preorder遍历，回想一下preorder的算法：visit root;visit left;visit right;这里也一样：visit root =&gt; compute number of paths with root (dfs(root, sum))visit left =&gt; compute number of paths with left (pathSum(root-&gt;left, sum))visit right =&gt; compute number of paths with right (pathSum(root-&gt;right, sum)) C++123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int pathSum(TreeNode* root, int sum) &#123; if (root == NULL) &#123; return 0; &#125; int left = pathSum(root-&gt;left, sum); int right = pathSum(root-&gt;right, sum); return dfs(root, sum) + left + right; &#125; int dfs(TreeNode* root, int sum) &#123; int res = 0; if (root == NULL) &#123; return res; &#125; if (root-&gt;val == sum) &#123; res++; &#125; res += dfs(root-&gt;left, sum - root-&gt;val); res += dfs(root-&gt;right, sum - root-&gt;val); return res; &#125;&#125;; Java12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int pathSum(TreeNode root, int sum) &#123; if (root == null) &#123; return 0; &#125; int left = pathSum(root.left, sum); int right = pathSum(root.right, sum); // Count the number of paths starting from the current root int startingFromThisRoot = dfs(root, sum); return startingFromThisRoot + left + right; &#125; private int dfs(TreeNode root, int sum) &#123; int res = 0; if (root == null) return res; if (root.val == sum) ++res; res += dfs(root.left, sum - root.val); res += dfs(root.right, sum - root.val); return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Strobogrammatic Number (246)]]></title>
    <url>%2F2016%2F12%2F13%2F2016-12-13-leetcode-solution-Strobogrammatic-Number-246%2F</url>
    <content type="text"><![CDATA[A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Write a function to determine if a number is strobogrammatic. The number is represented as a string. For example, the numbers “69”, “88”, and “818” are all strobogrammatic. 解法1：HashMap, Two pointers, O(N)题目的意思是一个数倒过来之后和原数一样，那么满足这种性质的单个的数只有0，1，6，8，9. 其中6和9只能搭配使用.本题用一个hashmap来存储对应的关系可以使解法变得比较干净. 6-&gt;9, 9-&gt;6, 0，1，8 对应自己。用两个指针，从两边往中间扫描，只有经过映射后的数值相等的情况下颠倒才能保持原数。C++123456789101112131415161718192021class Solution &#123;public: bool isStrobogrammatic(string num) &#123; unordered_map&lt;char, char&gt; map; map['0'] = '0'; map['1'] = '1'; map['6'] = '9'; map['8'] = '8'; map['9'] = '6'; int left = 0, right = num.length() - 1; while (left &lt;= right) &#123; if (map[num[left]] != num[right]) &#123; return false; &#125; ++left; --right; &#125; return true; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Rotate List (61)]]></title>
    <url>%2F2016%2F12%2F13%2F2016-12-13-leetcode-solution-Rotate-List-61%2F</url>
    <content type="text"><![CDATA[Given a list, rotate the list to the right by k places, where k is non-negative. For example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL. 解法1：Two pointers, O(N)这题考的是Linkedlist的基本操作。可以容易看到只要把最后k个元素作为字串挪到list的头部即可。实际操作可以维护两个指针，同时向右移动，让左指针指向新的头部，右指针指向衔接的地方。要注意的操作就是k可能会大于linkedlist的长度，那么需要多一个取余操作。还有对输入的数据范围也需要进行判断，NULL linkedlist直接返回，取余后为0的k也直接返回原list。C++123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; int len = getLength(head); k = k % len; ListNode left = head; ListNode right = head; int count = 0; while (count &lt; k) &#123; right = right-&gt;next; ++count; &#125; while (right-&gt;next != NULL) &#123; left = left-&gt;next; right = right-&gt;next; &#125; ListNode* res = left-&gt;next; left-&gt;next = NULL; right-&gt;next = head; return res; &#125; int getLength(ListNode* head) &#123; int count = 0; while (head != NULL) &#123; ++count; head = head-&gt;next; &#125; return count; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode解题: happy number (202)]]></title>
    <url>%2F2016%2F12%2F12%2F2016-12-12-Leetcode-solution-happy-number-202%2F</url>
    <content type="text"><![CDATA[Write an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: 19 is a happy number 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 解法1：hashmap这里需要判断重复的情况，想到用hashmap来存储已经计算过的值。对每一个未访问过的数值，计算位数的平方和。C++123456789101112131415161718192021222324252627282930313233class Solution &#123;public: bool isHappy(int n) &#123; if (n &lt;= 0) &#123; return false; &#125; if (n == 1) &#123; return true; &#125; unordered_map&lt;int, bool&gt; map; while (n != 1) &#123; map[n] = true; int temp = digitSquareSum(n); if (map[temp]) &#123;return false;&#125; n = temp; &#125; return true; &#125; int digitSquareSum(int n) &#123; if (n == 0 || n == 1) &#123; return n; &#125; int sum = 0; while (n != 0) &#123; int digit = n % 10; sum += digit * digit; n /= 10; &#125; return sum; &#125;&#125;; Java1 解法2：观察规律看到别人的解法里有这么一个巧妙的方法：可以试试几个会出现loop的数，最后都会出现4。结论是：所有最终会有4的都不是happy number，这样我们就可以把额外的空间要求去除了。例子如下：1^2 + 1^2 = 22^2 = 44^2 = 161^2 + 6^2 = 373^2 + 7^2 = 585^2 + 8^2 = 898^2 + 9^2 = 1451^2 + 4^2 + 5^2 = 424^2 + 2^2 = 202^2 + 0^2 = 4 C++1234567891011121314class Solution &#123;public: bool isHappy(int n) &#123; while (n != 1 &amp;&amp; n != 4) &#123; int t = 0; while (n) &#123; t += (n % 10) * (n % 10); n /= 10; &#125; n = t; &#125; return n == 1; &#125;&#125;;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode解题: Power of Three (326)]]></title>
    <url>%2F2016%2F12%2F12%2F2016-12-12-Leetcode-Solution-Power-of-Three-326%2F</url>
    <content type="text"><![CDATA[Given an integer, write a function to determine if it is a power of three. Follow up:Could you do it without using any loop / recursion? 解法1：LoopC++12345678910111213141516class Solution &#123;public: bool isPowerOfThree(int n) &#123; if (n &lt; 1) return false; while ( n &gt;= 3) &#123; if (n % 3 != 0) &#123; return false; &#125; n = n / 3; &#125; if (n == 1) &#123; return true; &#125; return false; &#125;&#125;; Java1 解法2：Follow up如果一个数是3^x，那么以3为底数做log，结果一定是整数。运用log3(x) = log10(x) / log10(3)C++1234567class Solution &#123;public: bool isPowerOfThree(int n) &#123; double res = log10(n) / log10(3); return (res - (int)res) == 0; &#125;&#125;;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode解题: Add Two Numbers II (445)]]></title>
    <url>%2F2016%2F12%2F12%2F2016-12-12-Leetcode-Solution-Add-Two-Numbers-II-445%2F</url>
    <content type="text"><![CDATA[You are given two linked lists representing two non-negative numbers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Follow up:What if you cannot modify the input lists? In other words, reversing the lists is not allowed. Example: Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 8 -&gt; 0 -&gt; 7 解法1：Reverse + 两数相加因为list的头是最高位，我们要相加是从最低位开始加，所以如果能先反转的话比较容易做。分别reverse再求和，最后把结果list再reverse一下就可以了。C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; if (l1 == NULL) &#123; return l2; &#125; if (l2 == NULL) &#123; return l1; &#125; l1 = reverse(l1); l2 = reverse(l2); // normal algorithm ListNode* dummy = new ListNode(0); ListNode* tail = dummy; int carry = 0; while (l1 != NULL &amp;&amp; l2 != NULL) &#123; int temp = l1-&gt;val + l2-&gt;val + carry; int digit = temp % 10; carry = temp / 10; ListNode* node = new ListNode(digit); tail-&gt;next = node; tail = tail-&gt;next; l1 = l1-&gt;next; l2 = l2-&gt;next; &#125; while (l1 != NULL) &#123; int temp = l1-&gt;val + carry; ListNode* node = new ListNode(temp % 10); carry = temp / 10; tail-&gt;next = node; tail = tail-&gt;next; l1 = l1-&gt;next; &#125; while (l2 != NULL) &#123; int temp = l2-&gt;val + carry; ListNode* node = new ListNode(temp % 10); carry = temp / 10; tail-&gt;next = node; tail = tail-&gt;next; l2 = l2-&gt;next; &#125; if (carry != 0) &#123; ListNode* node = new ListNode(carry); tail-&gt;next = node; tail = tail-&gt;next; &#125; // reverse back ListNode* res = reverse(dummy-&gt;next); delete dummy; return res; &#125; ListNode* reverse(ListNode* head) &#123; ListNode* prev = NULL; while (head != NULL) &#123; ListNode* temp = head-&gt;next; head-&gt;next = prev; prev = head; head = temp; &#125; return prev; &#125;&#125;; Java1 解法2： Follow up O(N) Time and Space从list的最后加，如果不能反转，需要想到有一种数据结构是可以从后往前存储的，那就是stack。用两个stack保存每一个队列的node，然后往回加。C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; stack&lt;ListNode*&gt; left; stack&lt;ListNode*&gt; right; while (l1 != NULL) &#123; left.push(l1); l1 = l1-&gt;next; &#125; while (l2 != NULL) &#123; right.push(l2); l2 = l2-&gt;next; &#125; int carry = 0; ListNode* res = NULL; while (!left.empty() &amp;&amp; !right.empty()) &#123; ListNode* leftnode = left.top(); ListNode* rightnode = right.top(); int temp = leftnode-&gt;val + rightnode-&gt;val + carry; int digit = temp % 10; carry = temp / 10; ListNode* node = new ListNode(digit); node-&gt;next = res; res = node; left.pop(); right.pop(); &#125; while (!left.empty()) &#123; ListNode* leftnode = left.top(); int temp = leftnode-&gt;val + carry; int digit = temp % 10; carry = temp / 10; ListNode* node = new ListNode(digit); node-&gt;next = res; res = node; left.pop(); &#125; while (!right.empty()) &#123; ListNode* rightnode = right.top(); int temp = rightnode-&gt;val + carry; int digit = temp % 10; carry = temp / 10; ListNode* node = new ListNode(digit); node-&gt;next = res; res = node; right.pop(); &#125; if (carry != 0) &#123; ListNode* node = new ListNode(carry); node-&gt;next = res; res = node; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Remove Duplicates from Sorted List (83)]]></title>
    <url>%2F2016%2F12%2F06%2F2016-12-06-leetcode-solution-Remove-Duplicates-from-Sorted-List-83%2F</url>
    <content type="text"><![CDATA[Given a sorted linked list, delete all duplicates such that each element appear only once. For example,Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. Hide Tags 解法1：Two pointers O(N)用双指针，比较两node的值，如果相等，则前面的指针跳过下一个node（删除后一个node）。如果不相等，则两个指针同时向后移动直到尾部。C++123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if (head == NULL || head-&gt;next == NULL) &#123; return head; &#125; ListNode* res = head; ListNode* ptr = head-&gt;next; while (ptr != NULL) &#123; if (head-&gt;val == ptr-&gt;val) &#123; ListNode* temp = ptr; head-&gt;next = ptr-&gt;next; delete temp; ptr = head-&gt;next; &#125; else &#123; head = head-&gt;next; ptr = ptr-&gt;next; &#125; &#125; return res; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>基础算法</tag>
        <tag>Linkedlist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Merge Two Sorted List (21)]]></title>
    <url>%2F2016%2F12%2F06%2F2016-12-06-leetcode-solution-Merge-Two-Sorted-List-21%2F</url>
    <content type="text"><![CDATA[Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. 解法1：Dummy Node O(N + M)对于head不明确的linkedlist的题目，都考虑建立Dummy Node，然后返回Dummy-&gt;next的办法解决。C++用C++注意在最后需要delete掉dummy防止memory leak1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* dummy = new ListNode(0); ListNode* tail = dummy; while (l1 != NULL &amp;&amp; l2 != NULL) &#123; if (l1-&gt;val &lt;= l2-&gt;val) &#123; tail-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; tail-&gt;next = l2; l2 = l2-&gt;next; &#125; tail = tail-&gt;next; &#125; while (l1 != NULL) &#123; tail-&gt;next = l1; l1 = l1-&gt;next; tail = tail-&gt;next; &#125; while (l2 != NULL) &#123; tail-&gt;next = l2; l2 = l2-&gt;next; tail = tail-&gt;next; &#125; ListNode* res = dummy-&gt;next; delete dummy; return res; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Repeated Substring Pattern (459)]]></title>
    <url>%2F2016%2F12%2F06%2F2016-12-06-leetcode-solution-Repeated-Substring-Pattern-459%2F</url>
    <content type="text"><![CDATA[Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000. Example 1:Input: “abab” Output: True Explanation: It’s the substring “ab” twice.Example 2:Input: “aba” Output: FalseExample 3:Input: “abcabcabcabc” Output: True Explanation: It’s the substring “abc” four times. (And the substring “abcabc” twice.) 解法1：O(k * N), k是n的约数个数，n是字符串的长度由于要分成相同的几个字串相连，那么字串的长度一定是原字符串的一个约数。这种情况下，约数的个数是有限制的，1 到 n / 2。暴力解法，从n/2到1一个一个试，然后拼接出原字符长度比较。C++1234567891011121314151617181920class Solution &#123;public: bool repeatedSubstringPattern(string str) &#123; if (str.empty()) return false; int n = str.size(); for (int i = n / 2; i &gt;= 1; --i) &#123; if (n % i == 0) &#123; string sub = str.substr(0, i); string copy = ""; for (int j = 0; j &lt; (n / i); ++j) &#123; copy += sub; &#125; if (str.compare(copy) == 0) &#123; return true; &#125; &#125; &#125; return false; &#125;&#125;; Java1 解法2： KMP with O(N) Time本题还有KMP的解法，显然不是我想出来的。先把网上看到的解释贴在这里。用到的关于KMP的算法的详细说明。深深的怀疑面试会期望给出这个答案。。还有是关于本题的解释]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>KMP</tag>
        <tag>Unfinished</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Number of Segments in a String (434)]]></title>
    <url>%2F2016%2F12%2F06%2F2016-12-06-leetcode-solution-Number-of-Segments-in-a-String-434%2F</url>
    <content type="text"><![CDATA[Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters. Please note that the string does not contain any non-printable characters. Example: Input: “Hello, my name is John”Output: 5 解法1：O(N)按每一个segment的开头来判断一个segment的开始。 C++123456789101112class Solution &#123;public: int countSegments(string s) &#123; int res = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; if (s[i] != ' ' &amp;&amp; (i == 0 || s[i - 1] == ' ')) &#123; ++res; &#125; &#125; return res; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Number of Boomerangs (447)]]></title>
    <url>%2F2016%2F12%2F04%2F2016-12-04-leetcode-solution-Number-of-Boomerangs-447%2F</url>
    <content type="text"><![CDATA[Given n points in the plane that are all pairwise distinct, a “boomerang” is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters). Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive). Example:Input:[[0,0],[1,0],[2,0]] Output:2 Explanation:The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]] 解法1：O(N^2)排列组合的题。假设有a,b,c。如果bc和a的距离相等，那么可以产生abc或者acb两种排列。如果是bcd和a的距离相等，那么可以产生6种排列。对于有n个数和a相等的情况，总共的个数是n*(n-1)。那么问题就转化为，对于每一个pair作为a，计算每一种距离的pair的个数，然后再把总和相加就是答案。C++123456789101112131415161718192021222324class Solution &#123;public: int numberOfBoomerangs(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) &#123; if (points.size() &lt; 3) &#123; return 0; &#125; int res = 0; for (int i = 0; i &lt; points.size(); ++i) &#123; unordered_map&lt;int, int&gt; map; for (int j = 0; j &lt; points.size(); ++j) &#123; if (i == j) &#123; continue; &#125; int x = points[i].first - points[j].first; int y = points[i].second - points[j].second; ++map[x * x + y * y]; &#125; for (auto iter = map.begin(); iter != map.end(); ++iter) &#123; res += iter-&gt;second * (iter-&gt;second - 1); &#125; &#125; return res; &#125;&#125;; Java123456789101112131415161718192021222324252627282930class Solution &#123; public int numberOfBoomerangs(int[][] points) &#123; if (points == null || points.length == 0) &#123; return 0; &#125; if (points[0] == null || points[0].length == 0) &#123; return 0; &#125; int res = 0; // Do the calculation for (int i = 0; i &lt; points.length; i++) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); // record the count of each distance between two points for (int j = 0; j &lt; points.length; j++) &#123; if (i == j) continue; int x = points[i][0] - points[j][0]; int y = points[i][1] - points[j][1]; int dist = x * x + y * y; map.put(dist, map.getOrDefault(dist, 0) + 1); &#125; for (int key : map.keySet()) &#123; res += map.get(key) * (map.get(key) - 1); &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Roman to Integer (13)]]></title>
    <url>%2F2016%2F12%2F04%2F2016-12-04-leetcode-solution-Roman-to-Integer-13%2F</url>
    <content type="text"><![CDATA[Given a roman numeral, convert it to an integer.Input is guaranteed to be within the range from 1 to 3999. 解法1：O(N) TimeRoman to Integer 是较容易的。需要记忆的是几个关键的Roman字母和数值的对应关系。从后往前扫描，如果前面的数值比后面的数值小，则需要减去，否则加上。123| I | V | X | L | C | D | M ||---|---|----|---|---|---|--- || 1 | 5 | 10 |50 |100|500|1000| C++123456789101112131415161718192021class Solution &#123; public: int romanToInt(string s) &#123; if (s.empty()) &#123; return 0; &#125; int res = 0; res += romans[toupper(s[s.size() - 1])]; for (int i = s.size() - 2; i &gt;= 0; --i) &#123; if (romans[toupper(s[i])] &lt; romans[toupper(s[i + 1])]) &#123; res -= romans[toupper(s[i])]; &#125; else &#123; res += romans[toupper(s[i])]; &#125; &#125; return res; &#125; private: unordered_map&lt;char, int&gt; romans &#123;&#123;&apos;I&apos;,1&#125;,&#123;&apos;V&apos;,5&#125;,&#123;&apos;X&apos;,10&#125;, &#123;&apos;L&apos;,50&#125;, &#123;&apos;C&apos;, 100&#125;, &#123;&apos;D&apos;,500&#125;, &#123;&apos;M&apos;,1000&#125;&#125;;&#125; 123456789101112131415161718192021222324252627class Solution &#123; public int romanToInt(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); map.put('I', 1); map.put('V', 5); map.put('X', 10); map.put('L', 50); map.put('C', 100); map.put('D', 500); map.put('M', 1000); int res = 0; res += map.get(s.charAt(s.length() - 1)); for (int i = s.length() - 2; i &gt;= 0; i--) &#123; int current = map.get(s.charAt(i)); int last = map.get(s.charAt(i + 1)); if (current &lt; last) &#123; res -= current; &#125; else &#123; res += current; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Number of 1 Bits (191)]]></title>
    <url>%2F2016%2F12%2F04%2F2016-12-04-leetcode-solution-Number-of-1-Bits-191%2F</url>
    <content type="text"><![CDATA[Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight). For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3. 解法1：O(M) M is number of total set bits运用n &amp; (n -1)消掉最高位的set bit的思想，可以不停重复这个操作直到n变为0，这样的复杂度可以减少为所有1的个数C++123456789101112131415class Solution &#123;public: int hammingWeight(uint32_t n) &#123; if (n == 0) &#123; return 0; &#125; int count = 0; while (n != 0) &#123; ++count; n = n &amp; (n - 1); &#125; return count; &#125;&#125;; 解法2：O(N) N is number of total bits用右移的方法来判断每一位是否是1直到n变为0C++123456789101112class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int res = 0; while (n != 0) &#123; res += n &amp; 1; n = n &gt;&gt; 1; &#125; return res; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Add Strings (415)]]></title>
    <url>%2F2016%2F12%2F04%2F2016-12-04-leetcode-solution-Add-Strings-415%2F</url>
    <content type="text"><![CDATA[Given two non-negative numbers num1 and num2 represented as string, return the sum of num1 and num2. Note: The length of both num1 and num2 is &lt; 5100.Both num1 and num2 contains only digits 0-9.Both num1 and num2 does not contain any leading zero.You must not use any built-in BigInteger library or convert the inputs to integer directly.Show Company TagsShow TagsShow Similar Problems 解法1：Two pointers, O(N + M) Time经典的两数相加问题，主要的考察就是每一位上怎么计算digit和carry。digit = (temp + carry) % 10, carry = (temp + carry) / 10;容易忘记的几个点： 如果两个string的长度不相等，最后要遍历剩下较长的string 最后要判断carry是否为0，如果不是，要在string的最前面加上carry的值 C++C++ 里的几个用法： char&amp; to int: 只能用c - ‘0’这种办法 int to string: 在c++ 11里有std::to_string 的函数，用法为std::to_string(string&amp; s)1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: string addStrings(string num1, string num2) &#123; if (num1.empty()) &#123; return num2; &#125; if (num2.empty()) &#123; return num1; &#125; string res = ""; int carry = 0; int i, j; for (i = num1.size() - 1, j = num2.size() - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; --i, --j) &#123; int temp = num1[i] - '0' + num2[j] - '0'; int digit = (temp + carry) % 10; carry = (temp + carry) / 10; res = to_string(digit) + res; &#125; for (; i &gt;= 0; --i) &#123; int temp = num1[i] - '0'; int digit = (temp + carry) % 10; carry = (temp + carry) / 10; res = to_string(digit) + res; &#125; for (; j &gt;= 0; --j) &#123; int temp = num2[j] - '0'; int digit = (temp + carry) % 10; carry = (temp + carry) / 10; res = to_string(digit) + res; &#125; if (carry &gt; 0) &#123; res = to_string(carry) + res; &#125; return res; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Binary Watch (401)]]></title>
    <url>%2F2016%2F12%2F04%2F2016-12-04-leetcode-solution-Binary-Watch-401%2F</url>
    <content type="text"><![CDATA[A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right. For example, the above binary watch reads “3:25”. Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent. Example: Input: n = 1Return: [“1:00”, “2:00”, “4:00”, “8:00”, “0:01”, “0:02”, “0:04”, “0:08”, “0:16”, “0:32”]Note:The order of output does not matter.The hour must not contain a leading zero, for example “01:00” is not valid, it should be “1:00”.The minute must be consist of two digits and may contain a leading zero, for example “10:2” is not valid, it should be “10:02”. 解法1：Backtracking/Recursion好久没有写backtracking的题目了,搞了好久才搞出来。code也不一定简略但好歹是过了OA。基本思路就是建立两个vector存储可能的时针值和分针值，然后记录已经用过的时针值和分针值。要注意的是要去重，所以我用了一个unordered_set来记录当前所有的答案，如果有重复的则不插入。另外要判断时针和分针的有效性。C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: vector&lt;string&gt; readBinaryWatch(int num) &#123; if (num == 0) &#123; return vector&lt;string&gt; &#123;"0:00" &#125;; &#125; vector&lt;bool&gt; hour_used(hours.size(), false); vector&lt;bool&gt; minute_used(minutes.size(), false); unordered_set&lt;string&gt; resSet; vector&lt;string&gt; res; helper(num, 0, 0, hour_used, minute_used, resSet); for (auto iter = resSet.begin(); iter != resSet.end(); ++iter) &#123; res.emplace_back(*iter); &#125; std::sort(res.begin(), res.end()); return res; &#125; void helper(int num, int hour, int minute, vector&lt;bool&gt;&amp; hour_used, vector&lt;bool&gt;&amp; minute_used, unordered_set&lt;string&gt;&amp; res) &#123; // Termination condition if (hour &gt; 11 || minute &gt; 59) return; if (num == 0) &#123; string s; if (minute &lt; 10) &#123; s = to_string(hour) + ":0" + to_string(minute); &#125; else &#123; s = to_string(hour) + ":" + to_string(minute); &#125; if (res.find(s) == res.end()) &#123; res.emplace(s); &#125; return; &#125; for (int i = 0; i &lt; hours.size(); ++i) &#123; if (!hour_used[i]) &#123; hour_used[i] = true; helper(num - 1, hour + hours[i], minute, hour_used, minute_used, res); hour_used[i] = false; &#125; &#125; for (int i = 0; i &lt; minutes.size(); ++i) &#123; if (!minute_used[i]) &#123; minute_used[i] = true; helper(num -1, hour, minute + minutes[i], hour_used, minute_used, res); minute_used[i] = false; &#125; &#125; &#125;private: vector&lt;int&gt; hours &#123;1,2,4,8&#125;; vector&lt;int&gt; minutes &#123;1,2,4,8,16,32&#125;;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>DFS</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Power of Two (231)]]></title>
    <url>%2F2016%2F12%2F03%2F2016-12-03-leetcode-solution-Power-of-Two-231%2F</url>
    <content type="text"><![CDATA[Given an integer, write a function to determine if it is a power of two. 解法1：经典的算法，如果是pot，那么只有最高位为1，如果将此数减1之后再和原来的数取AND，结果一定为0.要注意的是要规避：1. 负数 2. 0这两种情况都不是power of twoC++123456789class Solution &#123;public: bool isPowerOfTwo(int n) &#123; if (n &lt;= 0) return false; return (n &amp; ( n - 1)) == 0; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Reverse Linked List (206)]]></title>
    <url>%2F2016%2F12%2F03%2F2016-12-03-leetcode-solution-Reverse-Linked-List-206%2F</url>
    <content type="text"><![CDATA[Reverse a singly linked list.A linked list can be reversed either iteratively or recursively. Could you implement both? 解法1：Iteratively经典的答案，没啥好说的。要背下来。C++123456789101112131415161718192021/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode* ptr = NULL; while (head != NULL) &#123; ListNode* temp = head-&gt;next; head-&gt;next = ptr; ptr = head; head = temp; &#125; return ptr; &#125;&#125;; Java1 解法2： RecursivelyC++123456789101112class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (head == NULL || head-&gt;next == NULL) &#123; return head; &#125; ListNode* newhead = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return newhead; &#125;&#125;;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>基础算法</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Intersection of Two Arrays II (350)]]></title>
    <url>%2F2016%2F12%2F03%2F2016-12-03-leetcode-solution-Intersection-of-Two-Arrays-II-350%2F</url>
    <content type="text"><![CDATA[Given two arrays, write a function to compute their intersection. Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2]. Note:Each element in the result should appear as many times as it shows in both arrays.The result can be in any order.Follow up:What if the given array is already sorted? How would you optimize your algorithm?What if nums1’s size is small compared to nums2’s size? Which algorithm is better?What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? 解法1：HashTable O(N) Space + O(N + M) Time将其中一个构建hashtable，记录每个数字出现的次数。扫描第二个数组，每当找到一样的次数大于0的数字则加入res，加入结束以后需要将hashtable中出现次数-1C++1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; res; unordered_map&lt;int, int&gt; map; for (int num: nums1) &#123; ++map[num]; &#125; for (int num : nums2) &#123; if (map[num] &gt; 0) &#123; res.emplace_back(num); --map[num]; &#125; &#125; return res; &#125;&#125;; Java1 Follow up：如果是已经排序了的数组，那么不需要用hashtable，可以用two pointers解决。简化到了O(N + M) TIME + O(1) Space对于follow up的回答：这个blog给了挺好的答案。C++12345678910111213141516171819class Solution &#123;pubic： vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; res; int ptr1 =0, ptr2 = 0; while (ptr1 &lt; nums1.size() &amp;&amp; ptr2 &lt; nums2.size()) &#123; if (nums1[ptr1] &lt; nums2[ptr2]) &#123; ++ptr1; &#125; else if (nums1[ptr1] &gt; nums2[ptr2]) &#123; ++ptr2; &#125; else &#123; res.emplace_back(nums1[ptr1]); ++ptr1; ++ptr2; &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Contains Duplicate (217)]]></title>
    <url>%2F2016%2F12%2F03%2F2016-12-03-leetcode-solution-Contains-Duplicate-217%2F</url>
    <content type="text"><![CDATA[Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. 解法1：Hashtable很直观的用Hashtable的题，对每一个int记录出现的次数，一但出现多余1则返回true。C++1234567891011class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; map; for (int num: nums) &#123; ++map[num]; if (map[num] &gt; 1) return true; &#125; return false; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Longest Palindrome (409)]]></title>
    <url>%2F2016%2F12%2F03%2F2016-12-03-leetcode-solution-Longest-Palindrome-409%2F</url>
    <content type="text"><![CDATA[Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example “Aa” is not considered a palindrome here. Note:Assume the length of given string will not exceed 1,010. Example: Input:“abccccdd” Output:7 Explanation:One longest palindrome that can be built is “dccaccd”, whose length is 7. 解法1：Hashtable统计每个字母的出现次数： 若字母出现偶数次，则直接累加至最终结果 若字母出现奇数次，则将其值-1之后累加至最终结果 若存在出现奇数次的字母，将最终结果+1C++12345678910111213141516171819202122232425class Solution &#123;public: int longestPalindrome(string s) &#123; unordered_map&lt;char, int&gt; map; for (char c: s) &#123; ++map[c]; &#125; int res = 0; int maxOdd = 0; int oddSum = 0; for (auto iter = map.begin(); iter != map.end(); ++iter) &#123; if (iter-&gt;second % 2 == 0) res+= iter-&gt;second; else &#123; maxOdd = max(iter-&gt;second, maxOdd); oddSum += iter-&gt;second - 1; &#125; &#125; if (maxOdd &gt; 0) &#123; oddSum++; &#125; res += oddSum; return res; &#125;&#125;; Java123456789101112131415161718192021222324252627class Solution &#123; public int longestPalindrome(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (char ch : s.toCharArray()) &#123; map.put(ch, map.getOrDefault(ch, 0) + 1); &#125; int res = 0; boolean oddFlag = false; for (char key : map.keySet()) &#123; if (map.get(key) % 2 == 0) &#123; res += map.get(key); &#125; else &#123; res += map.get(key) - 1; oddFlag = true; &#125; &#125; return oddFlag ? res + 1 : res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Majority Element (169)]]></title>
    <url>%2F2016%2F11%2F30%2F2016-11-30-leetcode-solution-Majority-Element-169%2F</url>
    <content type="text"><![CDATA[Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. 解法1：抵消的思路，O(N) Time + O(1) Space运用抵消的思路，如果有多余半数的一个数字，那么如果我们俩俩抵消不一样的数字，最后剩下来的一定是最多的那个数字。抵消的实现用一个计数器，当两个数字不一样的时候，计数器减少1，如果归0了则更改被选答案到当前选定的数字。C++123456789101112131415161718class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return 0; int count = 1; int result = nums[0]; for (int num: nums) &#123; if (num == result) ++count; else count--; if (count == 0) &#123; result = num; ++count; &#125; &#125; return result; &#125;&#125;; Java12345678910111213141516171819202122232425class Solution &#123; public int majorityElement(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int res = nums[0], count = 1; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] == res) &#123; count++; &#125; else &#123; count--; if (count == 0) &#123; res = nums[i]; count = 1; &#125; &#125; &#125; return res; &#125;&#125; 解法2：排序 O(NlogN)因为多数元素个数超过半数，那么排序之后，当中的元素一定是最多的元素。这个方法也能过OAC++123456789class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; std::sort(nums.begin(), nums.end()); return nums[nums.size() / 2]; &#125;&#125;;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>抵消</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Valid Anagram (242)]]></title>
    <url>%2F2016%2F11%2F30%2F2016-11-30-leetcode-solution-Valid-Anagram-242%2F</url>
    <content type="text"><![CDATA[Given two strings s and t, write a function to determine if t is an anagram of s. For example,s = “anagram”, t = “nagaram”, return true.s = “rat”, t = “car”, return false. Note:You may assume the string contains only lowercase alphabets. Follow up:What if the inputs contain unicode characters? How would you adapt your solution to such case? 解法1：Sort O(NlogN)先排序，然后看排过序的两个string是否一致。 C++主要是掌握一下两个c++里的用法:一个是对于字符串的排序。 std::sort(s.begin(), s.end())另一个是比较两个字符串用s1.compare(s2)的形式，当两个字符串相等时，返回0123456789class Solution &#123;public: bool isAnagram(string s, string t) &#123; std::sort(s.begin(), s.end()); std::sort(t.begin(), t.end()); return s.compare(t) == 0; &#125;&#125;; Java1 解法2：Hashtable O(N) time + O(N) Space统计其中一个字符串每个字符出现的次数，然后扫描另一个字符串来判断是否一致。如果都是a-z的小写字母，那就只需要一个大小为26的数组记录就可，如果出现了unicode，那么还是必须要用hashtable来解决。 C++1234567891011121314151617181920212223class Solution &#123;public: bool isAnagram(string s, string t) &#123; unordered_map&lt;char,int&gt; map; for (char c : s) &#123; ++map[c]; &#125; for (char c: t) &#123; --map[c]; if (map[c] &lt; 0) &#123; return false; &#125; &#125; // check if there's remaining for (auto iter = map.begin(); iter != map.end(); ++iter) &#123; if (iter-&gt;second != 0) &#123; return false; &#125; &#125; return true; &#125;&#125;; Java1 Follw up见解法2的讨论，主要是针对用hashtable这一种用法的follow up。]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: First Unique Character in a String (387)]]></title>
    <url>%2F2016%2F11%2F29%2F2016-11-29-leetcode-solution-First-Unique-Character-in-a-String-387%2F</url>
    <content type="text"><![CDATA[Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1. Examples: s = “leetcode”return 0. s = “loveleetcode”,return 2.Note: You may assume the string contain only lowercase letters. 解法1：HashTable思路是将字符串建立hashtable，其中存的是每一个字符出现的位置，如果出现超过1次则位置设置为-1，然后遍历hashtable找出最小的非-1的即可。C++12345678910111213141516171819202122class Solution &#123;public: int firstUniqChar(string s) &#123; unordered_map&lt;char, int&gt; map; for (int i = 0; i &lt; s.size(); ++i) &#123; if (map.find(s[i]) != map.end()) &#123; map[s[i]] = -1; &#125; else &#123; map[s[i]] = i; &#125; &#125; int res = s.size(); for (auto iter = map.begin(); iter != map.end(); ++iter) &#123; if (iter-&gt;second !=-1) &#123; res = min(res, iter-&gt;second); &#125; &#125; if (res == s.size()) return -1; else return res; &#125;&#125;; Java12345678910111213141516171819202122232425class Solution &#123; public int firstUniqChar(String s) &#123; if (s == null || s.length() == 0) &#123; return -1; &#125; Map&lt;Character, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; char ch = s.charAt(i); if (!map.containsKey(ch)) &#123; map.put(ch, new ArrayList&lt;Integer&gt;()); &#125; map.get(ch).add(i); &#125; int res = Integer.MAX_VALUE; for (char key : map.keySet()) &#123; if (map.get(key).size() == 1) &#123; res = Math.min(res, map.get(key).get(0)); &#125; &#125; return res == Integer.MAX_VALUE ? -1 : res; &#125;&#125; 解法2：HashTable上面的思路有点繁复，如果hashtable中存入每一个字符出现的次数，那么只需要重新扫描一遍字符串，找到第一个次数为1的就是所求的答案。C++123456789101112131415class Solution &#123;public: int firstUniqChar(string s) &#123; unordered_map&lt;char, int&gt; map; for (char c : s) &#123; ++map[c]; &#125; for (int i = 0; i &lt; s.size(); i++) &#123; if (map[s[i]] == 1) &#123; return i; &#125; &#125; return -1; &#125;&#125;;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>HashTable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Excel Sheet Column Number (171)]]></title>
    <url>%2F2016%2F11%2F29%2F2016-11-29-leetcode-solution-Excel-Sheet-Column-Number-171%2F</url>
    <content type="text"><![CDATA[Related to question Excel Sheet Column Title Given a column title as appear in an Excel sheet, return its corresponding column number. For example: A -&gt; 1 B -&gt; 2 C -&gt; 3 ... Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 解法1：O(N) 26进制到10进制转换26进制转换为10进制的算法。关键的一句就是res = res * 26 + (s[i] - ‘A’ + 1), 从高位向低位运算。往下一位时要把之前的结果乘以26。C++12345678910class Solution &#123;public: int titleToNumber(string s) &#123; int res = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; res = res * 26 + (s[i] - 'A' + 1); &#125; return res; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Meeting Rooms (252)]]></title>
    <url>%2F2016%2F11%2F29%2F2016-11-29-leetcode-solution-Meeting-Rooms-252%2F</url>
    <content type="text"><![CDATA[Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],…] (si &lt; ei), determine if a person could attend all meetings. For example,Given [[0, 30],[5, 10],[15, 20]],return false. 解法1：O(NlogN) Time考察的是对custom class排序的能力，我们只需要用标准的库函数，用上自己定义的比较函数就可以了。比较的时候后一个meeting的开始时间不能早于前一个会议的结束时间。C++123456789101112131415161718192021222324/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */bool compare(Interval left, Interval right) &#123; return left.start &lt; right.start;&#125;class Solution &#123;public: bool canAttendMeetings(vector&lt;Interval&gt;&amp; intervals) &#123; std::sort(intervals.begin(), intervals.end(), compare); for (int i = 1; i &lt; intervals.size(); i++) &#123; if (intervals[i].start &lt; intervals[i - 1].end) &#123; return false; &#125; &#125; return true; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Same Tree (100)]]></title>
    <url>%2F2016%2F11%2F28%2F2016-11-28-leetcode-solution-Same-Tree-100%2F</url>
    <content type="text"><![CDATA[Given two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. 解法1：递归 / 分治经典的二叉树的问题，用递归很容易解决。两个树相等首先是root的值要一样，然后左子树相等，右子树相等。终结条件是如果值不一样或者有一个root为空另一个不是空则结构不同。 C++1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSameTree(TreeNode* p, TreeNode* q) &#123; if (p == NULL &amp;&amp; q != NULL) &#123; return false; &#125; if (p != NULL &amp;&amp; q == NULL) &#123; return false; &#125; if (p == NULL &amp;&amp; q == NULL) &#123; return true; &#125; if (p-&gt; val != q-&gt;val) &#123; return false; &#125; bool left = isSameTree(p-&gt;left, q-&gt;left); if (!left) return false; bool right = isSameTree(p-&gt;right, q-&gt;right); return right; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Recursion</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Delete Node in a Linked List (237)]]></title>
    <url>%2F2016%2F11%2F28%2F2016-11-28-leetcode-solution-Delete-Node-in-a-Linked-List-237%2F</url>
    <content type="text"><![CDATA[Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function. 解法1：O(1) Time由于只给了当前node的指针，那么没办法得到前面一个节点的信息。只能换种思考方式。我们可以将下一个节点的数值拷贝过来然后删除下一个节点就可以。 C++要注意的是要删除下一个节点指针对应的object，否则会造成leak123456789101112131415161718192021/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void deleteNode(ListNode* node) &#123; if (node == NULL || node-&gt; next == NULL) &#123; return; &#125; node-&gt;val = node-&gt;next-&gt;val; ListNode* p = node-&gt;next; node-&gt;next = node-&gt;next-&gt;next; delete p; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Intersection of two arrays (349)]]></title>
    <url>%2F2016%2F11%2F28%2F2016-11-28-leetcode-solution-Intersection-of-two-arrays-349%2F</url>
    <content type="text"><![CDATA[Given two arrays, write a function to compute their intersection. Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2]. Note:Each element in the result must be unique.The result can be in any order. 解法1：Sort + Two pointers O(NlogN) Time + O(1) Space先考虑将两个数组排序，然后只需要维护两个指针，对于一样的数值就放入返回数组中。同时要考虑去重的情况。这点上九章的答案做的比我更简洁。C++123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; std::sort(nums1.begin(), nums1.end()); std::sort(nums2.begin(), nums2.end()); int ptr1 = 0; int ptr2 = 0; vector&lt;int&gt; res; while (ptr1 &lt; nums1.size() &amp;&amp; ptr2 &lt; nums2.size()) &#123; while (ptr1 &gt; 0 &amp;&amp; ptr1 &lt; nums1.size() &amp;&amp; nums1[ptr1] == nums1[ptr1-1]) ++ptr1; while (ptr2 &gt; 0 &amp;&amp; ptr2 &lt; nums2.size() &amp;&amp; nums2[ptr2] == nums2[ptr2 - 1]) ++ptr2; if (ptr1 == nums1.size()) break; if (ptr2 == nums2.size()) break; if (nums1[ptr1] &lt; nums2[ptr2]) &#123; ++ptr1; &#125; else if (nums1[ptr1] &gt; nums2[ptr2]) &#123; ++ptr2; &#125; else &#123; res.emplace_back(nums1[ptr1]); ++ptr1; ++ptr2; &#125; &#125; return res; &#125;&#125;; Java1 解法2： HashTable O(N) Time + O(N) Space先扫描第一个数组，建立hashtable，然后扫描第二个数组，同时维持一个结果的hashtable用来去重。C++用到了unordered_map’s iterate method.123unordered_map&lt;int, bool&gt; map; // define a mapmap.begin() 和 map.end() return iterator of the map, can be used likefor (auto a = map.begin(); a!= map.end(); a++) &#123;&#125; 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; unordered_map&lt;int, bool&gt; map; unordered_map&lt;int, bool&gt; res; for (int num: nums1) &#123; map[num] = true; &#125; for (int num: nums2) &#123; if (map[num] &amp;&amp; !res[num]) res[num] = true; &#125; // iterate over map vector&lt;int&gt; res_vector; for (auto iterator = res.begin(); iterator != res.end(); iterator++) &#123; if (iterator-&gt;second) &#123; res_vector.emplace_back(iterator-&gt;first); &#125; &#125; return res_vector; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Sum of Left Leaves (404)]]></title>
    <url>%2F2016%2F11%2F27%2F2016-11-27-leetcode-solution-Sum-of-Left-Leaves-404%2F</url>
    <content type="text"><![CDATA[Find the sum of all left leaves in a given binary tree. Example: 3 / \ 9 20 / \ 15 7 There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24. 解法1：Recursion O(N) Time二叉树很自然的想到用递归的办法解决。这里的难点是要记录每一个节点是否为Left child/right child，为此我们需要有一个helper函数来记录。根据OA的结果，root是算作非左子树的。C++1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int sumOfLeftLeaves(TreeNode* root) &#123; return helper(root, false); &#125; int helper(TreeNode* root, bool isleft) &#123; if (root == NULL) return 0; if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) &#123; return isleft? root-&gt;val: 0; &#125; int left = helper(root-&gt;left, true); int right = helper(root-&gt;right, false); return left + right; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Ransom Note (383)]]></title>
    <url>%2F2016%2F11%2F27%2F2016-11-27-leetcode-solution-Ransom-Note-383%2F</url>
    <content type="text"><![CDATA[Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false. Each letter in the magazine string can only be used once in your ransom note. Note:You may assume that both strings contain only lowercase letters. canConstruct(“a”, “b”) -&gt; falsecanConstruct(“aa”, “ab”) -&gt; falsecanConstruct(“aa”, “aab”) -&gt; true 解法1：O(N + M) Time with O(M) Space经典的用hashtable解决的字母问题，把magazine先hash算出每一个字母出现的次数，然后对ransomNote扫描碰到见过的字母则次数-1，直到所对应的字母的次数小于0（false）或者是可以扫描完所有的ransomNote的字母。C++1234567891011121314151617181920class Solution &#123;public: bool canConstruct(string ransomNote, string magazine) &#123; vector&lt;int&gt; map (26); for (int i = 0; i &lt; magazine.size(); ++i) &#123; ++map[magazine[i] - 'a']; &#125; for (int i = 0; i &lt; ransomNote.size(); ++i) &#123; if (map[ransomNote[i] - 'a'] &lt;= 0) &#123; return false; &#125; else &#123; --map[ransomNote[i] - 'a']; &#125; &#125; return true; &#125;&#125;; C++ with std::unordered_map12345678910111213141516171819class Solution &#123;public: bool canConstruct(string ransomNote, string magazine) &#123; unordered_map&lt;char, int&gt; map; for (int i = 0; i &lt; magazine.size(); ++i) &#123; map[magazine[i]]++; &#125; for (int i = 0; i &lt; ransomNote.size(); ++i) &#123; if (map[ransomNote[i]] == 0) &#123; return false; &#125; else &#123; --map[ransomNote[i]]; &#125; &#125; return true; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Minimum Moves to Equal Array Elements (453)]]></title>
    <url>%2F2016%2F11%2F27%2F2016-11-27-leetcode-solution-Minimum-Moves-to-Equal-Array-Elements-453%2F</url>
    <content type="text"><![CDATA[Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1. Example: Input:[1,2,3] Output:3 Explanation:Only three moves are needed (remember each move increments two elements): [1,2,3] =&gt; [2,3,3] =&gt; [3,4,3] =&gt; [4,4,4] 解法1：O(N)本题巧妙的办法是要想到等价的操作，将n-1个元素都+1等价于将1个元素-1，在选择+1的时候我们都是避开最大的元素，那么-1的时候就要选择最大的元素。那么问题就转化为了将元素全部转化为最小元素，需要多少步，每步减少一个元素的值。C++12345678910class Solution &#123;public: int minMoves(vector&lt;int&gt;&amp; nums) &#123; int minNum = INT_MAX; int count = 0; for (num : nums) minNum = min(minNum, num); for (num: nums) count += (num - minNum); return count; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Assign Cookies (455)]]></title>
    <url>%2F2016%2F11%2F27%2F2016-11-27-leetcode-solution-Assign-Cookies-455%2F</url>
    <content type="text"><![CDATA[Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &gt;= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number. Note:You may assume the greed factor is always positive.You cannot assign more than one cookie to one child. Example 1:Input: [1,2,3], [1,1] Output: 1 Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.You need to output 1.Example 2:Input: [1,2], [1,2,3] Output: 2 Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.You have 3 cookies and their sizes are big enough to gratify all of the children,You need to output 2. 解法1：O(nlogn + mlogm) 贪心如果两个array g和s都是从小到大排序的，那么基本思路就是把满足条件当中最小的一个cookie给孩子，然后再从剩下的cookie中挑选满足条件的最小的cookie给下一个孩子。这似乎就是一种贪心的思路。排序需要花费O(NlogN)的时间，两个数组分别排序。排序之后，维护两个指针分别在两个数组。遍历孩子的数组，直到cookie的数组已选完。用到线性的时间。所以整体的复杂度还是O(nlogn)的量级。C++用到了std::sort(vector.begin(), vector.end())12345678910111213141516171819202122class Solution &#123;public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; // sort two vectors std::sort(g.begin(), g.end()); std::sort(s.begin(), s.end()); int gPtr = 0; int sPtr = 0; int num = 0; for (; gPtr &lt; g.size() &amp;&amp; sPtr &lt; s.size(); ++gPtr) &#123; while (sPtr &lt; s.size() &amp;&amp; s[sPtr] &lt; g[gPtr]) ++sPtr; if (sPtr == s.size()) break; ++num; ++sPtr; &#125; return num; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Island Perimeter (463)]]></title>
    <url>%2F2016%2F11%2F27%2F2016-11-27-leetcode-solution-Island-Perimeter-463%2F</url>
    <content type="text"><![CDATA[You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island. Example:[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]] Answer: 16Explanation: The perimeter is the 16 yellow stripes in the image below: 解法1：O(N^2) Time一开始观察可以注意到边界上的岛屿需要特殊处理，每一个边界周长都有效。对于每一个岛屿，要判断每一条边界是否有效，如果是在grid的边界上则直接有效，否贼考虑是否上下左右为0，如果是则为有效边界。C++12345678910111213141516171819202122232425class Solution &#123;public: int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int perimeter = 0; int row = grid.size(); int col = grid[0].size(); for (int i = 0; i &lt; row; ++i) &#123; for (int j = 0; j &lt; col; ++j) &#123; // check left boundary if (grid[i][j] != 0) &#123; if (j == 0) ++perimeter; if (j == col - 1) ++perimeter; if (j != 0 &amp;&amp; grid[i][j - 1] == 0) ++perimeter; if (j != col - 1 &amp;&amp; grid[i][j + 1] == 0) ++perimeter; if (i == 0) ++perimeter; if (i == row - 1) ++perimeter; if (i != 0 &amp;&amp; grid[i - 1][j] == 0) ++perimeter; if (i != row - 1 &amp;&amp; grid[i + 1][j] == 0) ++perimeter; &#125; &#125; &#125; return perimeter; &#125;&#125;; Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[backup hexo blog]]></title>
    <url>%2F2016%2F11%2F13%2F2016-11-13-backup-hexo-blog%2F</url>
    <content type="text"><![CDATA[解法1：C++1 Java1]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Move Zeros (283)]]></title>
    <url>%2F2016%2F11%2F08%2F2016-11-08-leetcode-solution-Move-Zeros-283%2F</url>
    <content type="text"><![CDATA[Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements. For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0]. Note:You must do this in-place without making a copy of the array.Minimize the total number of operations. 解法1：双指针 O(N) time with O(1) space这题的思路很像Quick Sort里partition的思路，需要用到两个指针。一个指针用来traverse，另一个用来记录下一个非0的元素需要插入的位置。C++中有一个swap function，可以交换两个reference的值。C++1234567891011121314class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) &#123; return; &#125; for (int i = 0, j = 0; i &lt; nums.size(); i++) &#123; if (nums[i]) &#123; swap(nums[i], nums[j++]); &#125; &#125; &#125;&#125;; Java1234567891011121314151617public class Solution &#123; public void moveZeroes(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return; &#125; int j = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] != 0) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j++] = temp; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode解题: Invert Binary Tree (226)]]></title>
    <url>%2F2016%2F11%2F07%2F2016-11-07-Leetcode-solution-Invert-Binary-Tree-226%2F</url>
    <content type="text"><![CDATA[invert a binary tree. 4 / \ 2 7 / \ / \1 3 6 9to 4 / \ 7 2 / \ / \9 6 3 1 解法1：Recursion, Divide &amp; Conquer, O(N) time很典型的一个Divide &amp; Conquer题目，用递归的办法很简单。先对左子树invert，然后对右子树invert,最后交换左右子树即可。C++12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if (root == NULL) &#123; return root; &#125; invertTree(root-&gt;left); invertTree(root-&gt;right); TreeNode* temp = root-&gt;left; root-&gt;left = root-&gt;right; root-&gt;right = temp; return root; &#125;&#125;; Java1234567891011121314151617181920/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) return root; invertTree(root.left); invertTree(root.right); TreeNode temp = root.right; root.right = root.left; root.left = temp; return root; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Find the Difference (389)]]></title>
    <url>%2F2016%2F11%2F07%2F2016-11-07-leetcode-solution-Find-the-Difference-389%2F</url>
    <content type="text"><![CDATA[Given two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t. Example: Input:s = “abcd”t = “abcde” Output:e Explanation:‘e’ is the letter that was added. 解法1：O(N) Time Complexity with O(1) Space用Hash的思路，对短字符串建立Hash索引，然后长字符串里面每一个字符减一，最后如果发现出现负数次数的字符时则一定是多出来的那个字符。C++ 中注意unordered_map的用法，unordered_map::operator[] 对于不存在的元素会进行插入操作并初始化对应的map数值。Java取字符串中的字符的method是s.charAt(i)C++12345678910111213class Solution &#123;public: char findTheDifference(string s, string t) &#123; std::unordered_map&lt;char, int&gt; strmap; for (char c: s) ++strmap[c]; for (char c: t) &#123; --strmap[c]; if (strmap[c] &lt; 0) return c; &#125; return 0; &#125;&#125;; Java123456789101112131415161718public class Solution &#123; public char findTheDifference(String s, String t) &#123; int[] map = new int[26]; for (int i = 0; i &lt; s.length(); i++) &#123; map[s.charAt(i) - 'a']++; map[t.charAt(i) - 'a']--; &#125; map[t.charAt(t.length() - 1) - 'a']--; char res = 'a'; for (int i = 0; i &lt; 26; i++) &#123; if (map[i] &lt; 0) &#123; res += i; break; &#125; &#125; return res; &#125;&#125; 解法2：O(N) Time Complexity with O(1) Space找不同的题目可以尝试用抵消的思路。一个抵消的工具就是XOR，如果对每一个字符进行异或操作，由于相同的元素抵消，剩下的一定是不相同的那一个。C++123456789class Solution &#123;public: char findTheDifference(string s, string t) &#123; char res = 0; for (char c: s) res ^= c; for (char c: s) res ^= c; return res; &#125;&#125;;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Shortest Word Distance (243)]]></title>
    <url>%2F2016%2F11%2F07%2F2016-11-07-leetcode-solution-Shortest-Word-Distance-243%2F</url>
    <content type="text"><![CDATA[Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list. For example,Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”]. Given word1 = “coding”, word2 = “practice”, return 3.Given word1 = “makes”, word2 = “coding”, return 1. Note:You may assume that word1 does not equal to word2, and word1 and word2 are both in the list. 解法1：思路就是维护两个指针，一个记录上一次出现的word1的位置，另一个记录word2的位置。每次发现一个新位置的时候计算一下当前的距离并且更新最短距离。C++123456789101112131415161718192021class Solution &#123;public: int shortestDistance(vector&lt;string&gt;&amp; words, string word1, string word2) &#123; int iter1 = -1, iter2 = -1; int res = words.size(); for (int i = 0; i &lt; words.size(); i++) &#123; if (words[i] == word1) &#123; iter1 = i; if (iter2 != -1) &#123; res = std::min(res, iter1 - iter2); &#125; &#125; else if (words[i] == word2) &#123; iter2 = i; if (iter1 != -1) &#123; res = std::min(res, iter2 - iter1); &#125; &#125; &#125; return res; &#125;&#125;; Java123456789101112131415161718192021222324252627public class Solution &#123; public int shortestDistance(String[] words, String word1, String word2) &#123; if (words.length &lt; 2) &#123; return 0; &#125; int first = -1, second = -1; int res = Integer.MAX_VALUE; for (int i = 0; i &lt; words.length; i++) &#123; if (words[i].equals(word1)) &#123; first = i; if (second != -1) &#123; res = Math.min(res, Math.abs(second - first)); &#125; &#125; else if (words[i].equals(word2)) &#123; second = i; if (first != -1) &#123; res = Math.min(res, Math.abs(second - first)); &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Connect to remote MySQL server]]></title>
    <url>%2F2016%2F11%2F05%2F2016-11-05-Connect-to-remote-MySQL-server%2F</url>
    <content type="text"><![CDATA[家里有两台台式机，一台干脆专门用来下data，配置了一下MySQL,从另一台电脑上成功连接，把大概的步骤记录一下。 打开 3306 端口….MySQL的默认端口是3306,需要配置firewall来开放端口，如果是Windows机可以参考这篇文章。 建立远程连接的用户…. 添加用户 12CREATE USER 'myuser'@'localhost' IDENTIFIED BY 'mypass';CREATE USER 'myuser'@'%' IDENTIFIED BY 'mypass'; ….设定用户的权限 12GRANT ALL ON *.* TO 'myuser'@'localhost';GRANT ALL ON *.* TO 'myuser'@'%'; 连接 1mysql -u USERNAME -h HOST_IP -p 基本操作 123456// Show all databasesshow database;// Switch to a tableuse DATABASE_NAMME;// Show all tablesshow tables; Reference：http://stackoverflow.com/questions/16287559/mysql-adding-user-for-remote-accesshttp://stackoverflow.com/questions/15872543/access-remote-database-from-command-line]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Maximum Depth of Binary Tree (104)]]></title>
    <url>%2F2016%2F10%2F02%2F2016-10-02-leetcode-solution-Maximum-Depth-of-Binary-Tree-104%2F</url>
    <content type="text"><![CDATA[Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 解法1：Recursion with O(N) timeDivide and Conquer, 递归的思路，空Node的depth为0，任意一个Node的depth为左面和右面的最大的depth+1, i.e. maxDepth(i) = Max(maxDepth(left), maxDepth(right)) + 1注意C++中空值是NULL, java是nullC++1234567891011class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if (root == NULL) &#123; return 0; &#125; return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1; &#125;&#125;; Java123456789public class Solution &#123; public int maxDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; &#125;&#125; 解法2: Non-recursion我们只需要修改一个非递归的树的遍历算法就可以了，这篇文章详细讲了思路]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Recursion</tag>
        <tag>Divide and Conquer</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Single Number (136)]]></title>
    <url>%2F2016%2F10%2F02%2F2016-10-02-leetcode-solution-Single-Number-136%2F</url>
    <content type="text"><![CDATA[Given an array of integers, every element appears twice except for one. Find that single one. Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 解法1：O(N) time with O(1) space, N is the number of elements运用XOR是一个抵消运算符，A XOR A 出来是一个0，所以对所有的数字做XOR之后重复的都消掉了，只剩下单独的一个。C++中vector的method是vector.size(),和java中array的array.length注意区分。 C++12345678910class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int result = nums[0]; for (int i = 1; i &lt; nums.size(); i++) &#123; result ^= nums[i]; &#125; return result; &#125;&#125;; Java123456789public class Solution &#123; public int singleNumber(int[] nums) &#123; int result = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; result ^= nums[i]; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>Bit Manipulation</tag>
        <tag>XOR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Sum of Two Integers (371)]]></title>
    <url>%2F2016%2F10%2F02%2F2016-10-02-leetcode-solution-Sum-of-Two-Integers-371%2F</url>
    <content type="text"><![CDATA[Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -. Example:Given a = 1 and b = 2, return 3. 解法1：IterationXOR是一个不带进位的加法运算，进位的信息可以通过AND（与运算）再左移获得。可以有Recursion和Iteration两种写法C++123456789101112public class Solution &#123; public int getSum(int a, int b) &#123; while (b != 0) &#123; int c = a ^ b; int carry = (a &amp; b) &lt;&lt; 1; a = c; b = carry; &#125; return a; &#125;&#125; 解法2：RecursionC++1234567891011public class Solution &#123; public int getSum(int a, int b) &#123; if (b == 0) &#123; return a; // stop condition &#125; int c = a ^ b; int carry = (a &amp; b) &lt;&lt; 1; return getSum(c, carry); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Flip Game (293)]]></title>
    <url>%2F2016%2F10%2F02%2F2016-10-02-leetcode-solution-Flip-Game-293%2F</url>
    <content type="text"><![CDATA[You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two consecutive “++” into “–”. The game ends when a person can no longer make a move and therefore the other person will be the winner. Write a function to compute all possible states of the string after one valid move. For example, given s = “++++”, after one move, it may become one of the following states: [ “–++”, “+–+”, “++–”]If there is no valid move, return an empty list []. 解法1：DP with O(N) time, N = number of characters按顺序一个个查看是否连续的两个字符是’+’， 如果是则换，如果不是继续C++1234567891011121314151617181920class Solution &#123;public: vector&lt;string&gt; generatePossibleNextMoves(string s) &#123; vector&lt;string&gt; result; if (s.length() == 0) &#123; return result; &#125; for (int i = 0; i &lt; s.length() - 1; i++) &#123; if (s[i] == '+' &amp;&amp; s[i+1] == '+') &#123; string temp = s.substr(0); // or just string temp = s; temp[i] = '-'; temp[i + 1] = '-'; result.push_back(temp); &#125; &#125; return result; &#125;&#125;; Java12345678910111213141516171819public class Solution &#123; public List&lt;String&gt; generatePossibleNextMoves(String s) &#123; List&lt;String&gt; result = new ArrayList&lt;String&gt;(); if (s == null || s.length() == 0) &#123; return result; &#125; for (int i = 0; i &lt; s.length() - 1; i++) &#123; if (s.charAt(i) == '+' &amp;&amp; s.charAt(i + 1) == '+') &#123; StringBuffer temp = new StringBuffer(s); temp.setCharAt(i, '-'); temp.setCharAt(i + 1, '-'); result.add(temp.toString()); &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Palindrome Permutation (266)]]></title>
    <url>%2F2016%2F10%2F02%2F2016-10-02-leetcode-solution-Palindrome-Permutation-266%2F</url>
    <content type="text"><![CDATA[Given a string, determine if a permutation of the string could form a palindrome. For example,“code” -&gt; False, “aab” -&gt; True, “carerac” -&gt; True. 解法1：DP with O(N) time, N = number of charactersPalindrome分为even和odd两种情况，在even的时候，一定是每一个字母都出现偶数次。在odd的时候，有且仅有一个字母可出现奇数次。那么就可以统计每一个字母出现的次数，如果出现奇数次的字母的个数大于1，那么一定不能组成一个Palindrome，反之则可以。统计的时候需要一个HashMap来记录每一个字母的个数。C++lang: cpp12345678910111213141516171819202122232425class Solution &#123;public: bool canPermutePalindrome(string s) &#123; map&lt;char, int&gt; hmap; for (int i = 0; i &lt; s.length(); i++) &#123; if (hmap.count(s[i]) == 0) &#123; // not exist hmap.insert(std::pair&lt;char, int&gt;(s[i], 1)); &#125; else &#123; hmap[s[i]]++; &#125; &#125; // Iterate over map keys map&lt;char, int&gt;::iterator iter = hmap.begin(); map&lt;char, int&gt;::iterator iter_end = hmap.end(); int odd = 0; while (iter != iter_end) &#123; if (iter-&gt;second % 2 != 0) &#123; odd++; &#125; ++iter; &#125; return odd &lt; 2; &#125;&#125;; Javalang: java1234567891011121314151617181920212223242526public class Solution &#123; public boolean canPermutePalindrome(String s) &#123; if (s == null || s.length() == 0) &#123; return false; &#125; int size = s.length(); Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); for (int i = 0; i &lt; size; i++) &#123; if (map.containsKey(s.charAt(i))) &#123; map.put(s.charAt(i), map.get(s.charAt(i)) + 1); &#125; else &#123; map.put(s.charAt(i), 1); &#125; &#125; // Check for odd number int odd = 0; for (Character ch : map.keySet()) &#123; if (map.get(ch) % 2 != 0) &#123; odd++; &#125; &#125; return odd &lt; 2; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Nim Game (292)]]></title>
    <url>%2F2016%2F10%2F01%2F2016-10-01-leetcode-solution-Nim-Game-292%2F</url>
    <content type="text"><![CDATA[You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend. 解法1：DP with O(N) time, N is the number of input, Runtime Error思路就是去试几个不同的数，找出规律。自然的首先想到的是DP的算法，比如输入4，那么无论如何不能达到。如果是5，那么只要1可以，那么5就可以。似乎只需要看前面差4个数的结果。x[i] = x[i - 4]，但是当数据变大的时候会出现Runtime error。C++1234567891011121314151617class Solution &#123;public: bool canWinNim(int n) &#123; if (n &lt;= 0) &#123; return false; &#125; if (n &lt;= 3) &#123; return true; &#125; bool x[n + 1]; x[0] = false; x[1] = true; x[2] = true; x[3] = true; for (int i = 4; i &lt;= n; i++) &#123; x[i] = x[i - 4]; &#125; return x[n]; &#125;&#125; 解法2：O(1) Time with Math1,2,3 可以，4 false， 5，6，7 true, 8 false. 得出的结论是能除4的就不能赢。C++123456class Solution &#123;public: bool canWinNim(int n) &#123; return n % 4 != 0; &#125;&#125;;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Moving Average from Data Stream (346)]]></title>
    <url>%2F2016%2F10%2F01%2F2016-10-01-leetcode-solution-Moving-Average-from-Data-Stream-346%2F</url>
    <content type="text"><![CDATA[Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window. For example,MovingAverage m = new MovingAverage(3);m.next(1) = 1m.next(10) = (1 + 10) / 2m.next(3) = (1 + 10 + 3) / 3m.next(5) = (10 + 3 + 5) / 3 解法1：O(1) Computation and O(N) space需要考虑每次计算运用上次的结果，由于平均值是Sum / Size, 如果维护average的值的话不方便重复利用已经计算过的值，所以我们可以考虑维护一个当前的Sum. 最后需要计算average的时候就把sum除以当前的数字个数。 数据结构： 考虑使用queue, 用到的操作是queue.front(), queue.pop() 和queue.push(item) 123456789101112131415161718192021222324//C++ class MovingAverage &#123; private: queue&lt;int&gt; data; int sum; int msize; public: MovingAverage(int size) &#123; msize = size; sum = 0; &#125; double next(int val) &#123; if (data.size() == msize) &#123; sum -= data.front(); data.pop(); &#125; data.push(val); sum += val; return (double)sum / data.size(); &#125; &#125;;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Nested List Weight Sum (339)]]></title>
    <url>%2F2016%2F09%2F17%2F2016-09-17-leetcode-solution-Nested-List-Weight-Sum-339%2F</url>
    <content type="text"><![CDATA[Given a nested list of integers, return the sum of all integers in the list weighted by their depth. Each element is either an integer, or a list – whose elements may also be integers or other lists. Example 1:Given the list [[1,1],2,[1,1]], return 10. (four 1’s at depth 2, one 2 at depth 1) Example 2:Given the list [1,[4,[6]]], return 27. (one 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 42 + 63 = 27) 解法1：Recursion with O(N) time, N is number of total elements看到Nested，从构造上来说和递归的思路很一致。想到递归时每一次调用递归函数需要记录下当前的level。整体的思路是对每一个element, 如果是Integer的话，当前的结果应该是数值 * level, 然后继续，如果是Nested List，那么level + 1, 然后继续递归。123456789101112131415161718192021class Solution &#123;public: int depthSum(vector&lt;NestedInteger&gt;&amp; nestedList) &#123; return depthSumHelper(nestedList, 1); &#125; int depthSumHelper(vector&lt;NestedInteger&gt;&amp; nestedList, int depth) &#123; int sum = 0; for (int i = 0; i &lt; nestedList.size(); i++) &#123; if (nestedList[i].isInteger()) &#123; sum += nestedList[i].getInteger() * depth; &#125; else &#123; sum += depthSumHelper(nestedList[i].getList(), depth + 1); &#125; &#125; return sum; &#125;&#125;;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Coin Change (322)]]></title>
    <url>%2F2016%2F07%2F20%2F2016-07-20-leetcode-solution-Coin-Change-322%2F</url>
    <content type="text"><![CDATA[You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1:coins = [1, 2, 5], amount = 11return 3 (11 = 5 + 5 + 1) Example 2:coins = [2], amount = 3return -1. Note:You may assume that you have an infinite number of each kind of coin. 解法1： 找规律 + Memorization, One pass O(N) Time这题需要多写几个数出来找一下规律:如果我们把0到15的二进制表达式写出来，并且把对应的set bit的个数写出来，我们可以得到如下： 0 0000 01 0001 12 0010 1 3 0011 24 0100 15 0101 26 0110 2 7 0111 38 1000 19 1001 210 1010 211 1011 312 1100 213 1101 314 1110 315 1111 4 观察后联系hint,发现偶数X的bit数是X/2的bit数，奇数X的bit数是X/2的bit数+1，于是可以得到一个O(N)的算法1234567891011121314public int[] countBits(int num) &#123; int[] dp = new int[num + 1]; // dp[0] is 0 for (int i = 1; i &lt;= num; i++) &#123; if (i % 2 == 0) &#123; dp[i] = dp[i / 2]; &#125; else &#123; dp[i] = dp[i / 2] + 1; &#125; &#125; return dp;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: counting bits (338)]]></title>
    <url>%2F2016%2F07%2F20%2F2016-07-20-leetcode-solution-counting-bits-338%2F</url>
    <content type="text"><![CDATA[Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array. Example:For num = 5 you should return [0,1,1,2,1,2]. Follow up: It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?Space complexity should be O(n).Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.Hint: You should make use of what you have produced already.Divide the numbers in ranges like [2-3], [4-7], [8-15] and so on. And try to generate new range from previous.Or does the odd/even status of the number help you in calculating the number of 1s? 解法1： 找规律 + Memorization, One pass O(N) Time这题需要多写几个数出来找一下规律:如果我们把0到15的二进制表达式写出来，并且把对应的set bit的个数写出来，我们可以得到如下： 0 0000 01 0001 12 0010 1 3 0011 24 0100 15 0101 26 0110 2 7 0111 38 1000 19 1001 210 1010 211 1011 312 1100 213 1101 314 1110 315 1111 4 观察后联系hint,发现偶数X的bit数是X/2的bit数，奇数X的bit数是X/2的bit数+1，于是可以得到一个O(N)的算法1234567891011121314public int[] countBits(int num) &#123; int[] dp = new int[num + 1]; // dp[0] is 0 for (int i = 1; i &lt;= num; i++) &#123; if (i % 2 == 0) &#123; dp[i] = dp[i / 2]; &#125; else &#123; dp[i] = dp[i / 2] + 1; &#125; &#125; return dp;&#125; 解法2： 找规律 + Memorization, One pass O(N) Time另一种规律，我们使用i &amp; (i - 1) 来看对应的结果。 0 0000 0 N/A1 0001 1 00002 0010 1 0000 3 0011 2 00104 0100 1 00005 0101 2 01006 0110 2 0100 7 0111 3 01108 1000 1 00009 1001 2 100010 1010 2 100011 1011 3 101012 1100 2 100013 1101 3 110014 1110 3 110015 1111 4 1110 更加简化的一个规律是dp[i] = dp[i &amp; (i - 1)] + 1, 比如15, 15 &amp; 14 = ‘1110’， ’1110‘的bits是3，所以15的bits是4那么就可以得到如下的程序。这个程序更简短。12345678910public int[] countBits(int num) &#123; int[] dp = new int[num + 1]; // dp[0] is 0 for (int i = 1; i &lt;= num; i++) &#123; dp[i] = dp[i &amp; (i - 1)] + 1; &#125; return dp;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Perfect Squares (279)]]></title>
    <url>%2F2016%2F07%2F20%2F2016-07-20-leetcode-solution-Perfect-Squares-279%2F</url>
    <content type="text"><![CDATA[Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, …) which sum to n.For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9. 解法1：DP O(N^2) with O(N) 空间如果用暴力的方法想：对于一个数字N，我们可以从1开始试， 因为1是一个perfect square,那么求出N - 1的解，假设为X，则N的解就是X+1我们从1开始尝试所有可能的组合，然后求出了一系列的解之后挑选最小的值。但这样做的话复杂率特别高，应该是指数级的实际上可以发现，这里有很多overlapping的问题，比如我们求12的最小值，那么如果第一个选择的值是4，则剩下的为8.当我们在前面选择第一个值为2时，子问题变为寻找10 - 2 = 10的最小值，而当我们求10的最小值的时候可能已经求过了8的最小平方数。所以我们可以想到用dp/memorization的方法去解决这个问题。 建立dp数组dp[N], N是要求的数字，dp数组中存储的是对应的这个数字n，他的最小平方和数。 初始化,将所有perfect square的数字都设为1 对于非perfect square的数字，dp[i] = Min(dp[j] + dp[i - j], j = 1 … i / 2),也就是说,dp[12] = Min of (dp[1] + dp[11], dp[2] + dp[10], …)1234567891011121314151617181920212223242526272829public int numSquares(int n) &#123; if (n &lt; 0) &#123; return 0; &#125; if (n == 0 ) &#123; return 1; &#125; int[] dp = new int[n + 1]; for (int i = 1; i*i &lt;= n; i++) &#123; dp[i*i] = 1; &#125; for (int i = 2; i &lt;= n; i++) &#123; if (dp[i] != 1) &#123; int res = Integer.MAX_VALUE; for (int j = 1; j &lt;= i/2; j++) &#123; int temp = dp[j] + dp[i - j]; res = Math.min(temp, res); &#125; dp[i] = res; &#125; &#125; return dp[n];&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Minimum Path Sum (64)]]></title>
    <url>%2F2016%2F07%2F20%2F2016-07-20-leetcode-solution-Minimum-Path-Sum-64%2F</url>
    <content type="text"><![CDATA[Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.Note: You can only move either down or right at any point in time. 解法1：DP O(N^2) with O(N) 空间也是很直接的dp, dp[i][j]表示的是到(i,j)点的最小路径和。dp[i][j] = Min(dp[i - 1][j], dp[i][j -1]) + A[i][j]最后的结果便是dp[n - 1][m - 1], 用滚动数组节省内存空间1234567891011121314151617181920212223242526public int minPathSum(int[][] grid) &#123; if (grid == null || grid.length == 0) &#123; return 0; &#125; int nrow = grid.length; int ncol = grid[0].length; int[] dp = new int[ncol]; dp[0] = grid[0][0]; // Initialize the dp array for (int j = 1; j &lt; ncol; j++) &#123; dp[j] = dp[j - 1] + grid[0][j]; &#125; for (int i = 1; i &lt; nrow; i++) &#123; dp[0] += grid[i][0]; for (int j = 1; j &lt; ncol; j++) &#123; dp[j] = Math.min(dp[j], dp[j - 1]) + grid[i][j]; &#125; &#125; return dp[ncol - 1];&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Dynamic programming</tag>
        <tag>滚动数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Unique Paths II (63)]]></title>
    <url>%2F2016%2F07%2F20%2F2016-07-20-leetcode-solution-Unique-Paths-II-63%2F</url>
    <content type="text"><![CDATA[Follow up for “Unique Paths”: Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. For example,There is one obstacle in the middle of a 3x3 grid as illustrated below. [ [0,0,0], [0,1,0], [0,0,0]]The total number of unique paths is 2. Note: m and n will be at most 100. 解法1：DP O(N^2) with O(N) 空间是Unique Path的扩展，唯一区别是对于任意一个格子，要先判断是否为1，如果是1则有障碍物，在这种情况下，则到达这个点的办法为0。其他地方的计算还是依照dp[i][j] = dp[i -1][j] + dp[i][j - 1]，这里同样用了滚动数组节省空间。这题的坑是在： 一开始初始化数组的时候，对[0][i]的判断取决于[i][i - 1] 和那个格子是否有障碍物两个条件。不能仅根据当个格子来判断12345678910111213141516171819202122232425262728public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; if (obstacleGrid == null || obstacleGrid.length == 0) &#123; return 0; &#125; int nrow = obstacleGrid.length; int ncol = obstacleGrid[0].length; int[] dp = new int[ncol]; dp[0] = obstacleGrid[0][0] == 0?1:0; for (int j = 1; j &lt; ncol; j++) &#123; dp[j] = obstacleGrid[0][j] == 0?dp[j - 1]: 0; &#125; for (int i = 1; i &lt; nrow; i++) &#123; dp[0] = obstacleGrid[i][0] == 0?dp[0] : 0; for (int j = 1; j &lt; ncol; j++) &#123; if (obstacleGrid[i][j] == 0) &#123; dp[j] += dp[j - 1]; &#125; else &#123; dp[j] = 0; &#125; &#125; &#125; return dp[ncol - 1]; &#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Dynamic programming</tag>
        <tag>滚动数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Unique Paths (62)]]></title>
    <url>%2F2016%2F07%2F20%2F2016-07-20-leetcode-solution-Unique-Paths-62%2F</url>
    <content type="text"><![CDATA[A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? Note: m and n will be at most 100. 解法1：DP O(N^2) with O(N^2) 空间很直接的2维dp问题，对于任意一个点i,j,到达它的办法可以从上面过来，也可以从左面过来。所以总的办法数是dp[i][j] = dp[i - ][j] + dp[i][j -1]结果就是dp[m - 1][n - 1] Java1234567891011121314151617181920212223public int uniquePaths(int m, int n) &#123; if (m == 1 || n == 1) &#123; return 1; &#125; int[][] dp = new int[m][n]; for (int j = 0; j &lt; n; j++) &#123; dp[0][j] = 1; &#125; for (int i = 0; i &lt; m; i++) &#123; dp[i][0] = 1; &#125; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; dp[i][j] = dp[i -1][j] + dp[i][j - 1]; &#125; &#125; return dp[m - 1][n - 1];&#125; 解法2：DP O(N^2) with O(N) 空间和triangle相类似的思路，dp的过程是自上而下自左而右，那么可以用滚动数组来减少内存的使用。123456789101112131415161718public int uniquePaths(int m, int n) &#123; if (m == 1 || n == 1) &#123; return 1; &#125; int[] dp = new int[n]; for (int j = 0; j &lt; n; j++) &#123; dp[j] = 1; &#125; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; dp[j] += dp[j - 1]; // dp[j] initially stores the previous row's calculation &#125; &#125; return dp[n - 1];&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Dynamic programming</tag>
        <tag>滚动数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Triangle (120)]]></title>
    <url>%2F2016%2F07%2F20%2F2016-07-20-leetcode-solution-Triangle-120%2F</url>
    <content type="text"><![CDATA[Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle[ [2], [3,4], [6,5,7], [4,1,8,3]]The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note:Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. 解法1：DP O(N^2) with O(N^2) 空间123456789101112131415161718192021222324252627282930public int minimumTotal(List(List&lt;Integer&gt;&gt; triangle) &#123; if (triangle == null || triangle.size() == 0) &#123; return 0; &#125; int n = triangle.size(); // number of rows int[][] dp = new int[n][n]; for (int[] temp : dp) &#123; Arrays.fill(temp, Integer.MAX_VALUE); &#125; dp[0][0] = triangle.get(0).get(0); for (int i = 1; i &lt; n; i++) &#123; dp[i][0] = dp[i - 1][0] + triangle.get(i).get(0); for (int j = 1; j &lt;=i; j++) &#123; dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j]) + triangle.get(i).get(j); &#125; &#125; int res = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) &#123; res = Math.min(res, dp[n - 1][i]); &#125; return res;&#125; 解法2：DP O(N^2) with O(N) 空间观察上面的解法可以看到，我们的2维数组实际上只用到了上一行的信息，由此我们可以对内存做一个小优化而达到O(N)的空间。我们只保留上一行的每一个位置的最小值，需要一个大小为N的数组，N是总的行数，然后在计算中只要反复更新这个数组。也就是说dp[i] = Math.min(dp[i - 1], dp[i]) + A[j][i] j是现在计算到的行数123456789101112131415161718192021222324252627282930public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; if (triangle == null || triangle.size() == 0) &#123; return 0; &#125; int n = triangle.size(); // number of rows int[] dp = new int[n]; Arrays.fill(dp, Integer.MAX_VALUE); dp[0] = triangle.get(0).get(0); for (int i = 1; i &lt; n; i++) &#123; // i is the current row number for (int j = i; j &gt;= 0; j--) &#123; // 这里比较容易出错，j要从后往前更新，因为下一行的计算用到了上一行的[i - 1] 和[i]， // 需要先更新后面的才不会override前面的数据 // 同时下标使用的是j以此来模拟不同column的计算 dp[j] = Math.min(dp[j - 1], dp[j]) + triangle.get(i).get(j); &#125; &#125; int res = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) &#123; res = Math.min(res, dp[i]); &#125; return res;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Dynamic programming</tag>
        <tag>滚动数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Decode Ways (91)]]></title>
    <url>%2F2016%2F07%2F20%2F2016-07-20-leetcode-solution-decode-ways-91%2F</url>
    <content type="text"><![CDATA[A message containing letters from A-Z is being encoded to numbers using the following mapping: ‘A’ -&gt; 1‘B’ -&gt; 2…‘Z’ -&gt; 26Given an encoded message containing digits, determine the total number of ways to decode it. For example,Given encoded message “12”, it could be decoded as “AB” (1 2) or “L” (12). The number of ways decoding “12” is 2. 解法1：DP O(N) with O(1) 空间典型DP, dp数组表示前i个数字的# of decode ways. 那么对于dp[i], 他存在decode的办法有两种： 单独一个数字decode, 这种情况实际是dp[i -1] 和嵌挤一个数字拼成一个10 ~ 26 的数字decode, 这种情况的办法是dp[i - 2]但是要注意的是对于每一种可能的decode办法，有corner case需要考虑： 如果第i个数是0，那么只可能是dp[i - 2],并且要检查i - 1 和i拼成的数是否在10 ~ 26范围内, 比如120只可能是[1, 20]的分割 检查数是否在10 ~ 26范围内 1234567891011121314151617181920212223242526272829public int numDecodings(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; // empty string has no way of decoding &#125; int[] dp = new int[s.length()]; dp[0] = s.charAt(0) == '0'?0: 1; for (int i = 1; i &lt; s.length(); i++) &#123; if (s.charAt(i) != '0') &#123; dp[i] = dp[i - 1]; &#125; int temp = Integer.parseInt(s.substring(i - 1, i + 1)); if (temp &gt;= 10 &amp;&amp; temp &lt;= 26) &#123; if (i == 1) &#123; dp[i] += 1; &#125; else &#123; dp[i] += dp[i - 2]; &#125; &#125; if (dp[i] == 0) &#123; return 0; &#125; &#125; return dp[s.length() - 1]; &#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[量化金融面试知识点: Market Risk]]></title>
    <url>%2F2016%2F07%2F16%2F2016-07-16-Quant-Finance-Prep-market-risk%2F</url>
    <content type="text"><![CDATA[问题来源于一份Top 50 Questions related to Market Risk. 试着回答了一部分问题，希望对准备面试有所帮助。 Risk Measures How would you calculate Value at Risk (VaR)? There are three methods to calculate VaR. Delta-Normal Method (Parametric Method) Assume the distribution of underlying asset returns. Go back on time for over N years and collect asset returns’ data. Fit the data into the assumed distribution and calculate the VaR as the Xth percentile. For example, a one-day 5% VaR is just the 5th percentile of the underlying return’s distribution. Historical-Simulation Method Assume historical path will be a guidence of what will happen in the future Go back on time for over N years and collect portfolio’s data (close price). Each historical period is considered a scenario Given current portfolio’s value, forecast the next period’s value based on each scenario Once portfolio’s value is calculated for each period, calculate the sample Nth percentile as the VaR Monte-Carlo Method Assume a stochastic process for each market variable (distribution and parameters) parameters can be estimated from historical data Simulate the data path for all variables of interest Revalue the portfolio by the new market variables and calculate the value difference Calculate the Nth percentile as the VaR value. For example, we can assume all market variables changes are generated from a multivariate normal distribution Then each step will involve generating data from the multivariate distribution and revalue the portfolio based on that What’s wrong with VaR as a measurement of risk? It does not describe the loss on the left tail. When the return distribution is far from a normal distribution, it does not face real risk Example: short CDS of a 3% default rate with 0 recovery rate bond, 95% VaR is 0 (which doesn’t reflect the risk at all) It is not a coherent measure and is not sub-additive. It means when we combine two positions, we do not always have VaR(C) &lt;= VaR(A) + VaR(B) Example: two short CDS positions with 3% default rate and 0 recovery rate bond: one of the bond default rate is 1 - (1 - 3%)*(1 - 3%) = 5.9%, so VaR(C) &gt; Var(A) + VaR(B) This contradicts the idea that diversification reduces risks. What is non-Linear VaR? How would you calculate it? Non-linear VaR reflects that the portfolio contains nonlinear derivatives which the payoff or the response to the risk factor is non-linear. It is often calculate by using the monte carlo simulation of pricing model. What is the parametric method of calculating VaR? What are its advantages? The parametric method is the delta-normal method described in Q1. The advantage is it is simple to calculate. It just need to estimate the joint distribution and calculate the portfolio return’s distribution using either linear or nonlinear model. Non-linear model is called: Cornish-Fisher expansion (P448 on John Hull) What is the historical method of calculating VaR? What are its advantages? Second Method described in Q1. Advantage is it is a nonparametric method and the historical data determines the joint probability distribution of market variables. Why would you calculate VaR using Monte Carlo simulations? If the portfolio is consisting nonlinear derivatives, such as options, the return profile of the portfolio is non symmetric. VaR is very sensitive to the left tail of the distribution so in this case we need to use monte carlo simulation to better model the nonlinear characterics. What are the challenges in calculating VaR for a mixed portfolio? Nonlinearity? [NOT finished yet] What’s GVAR? How can you calculate it? GVAR = Global vector autoregression Model What is the one-day VaR of a $50m portfolio with a daily standard deviation of 2% at a 95% confidence level? What is the annualized VaR? One day VaR = 50m * 0.02 * 1.96 ~= 2m Annualized VaR = sqrt(252) * 2m = 16 * 2m = 32m What do you know about extreme value theory? A framework to study the tail behavior of a distribution https://en.wikipedia.org/wiki/Extreme_value_theory What is Expected Shortfall? How is it calculated? Why is it considered better than VaR? What are the disadvantages? Expected shortfall is also called conditional value at risk It measures the expected loss under a certain amount. It can be calculated by a list of scenarios. Each scenarios has the probability of occurrence and the return Given a threshold, calculate the probablity of each scenario that happen with odds less than the threshold Cacluate the expected (averaged) loss. Advantage： It is a coherent measure and a more complete measure of downside risk Reflect the sknewness (asymmetry) and kurtosis (fat tail) Disadvantage: It treats a large probability of small loss as equivalent to a small probability of large loss Difficult to forecast What is incremental default risk?Default risk incremental to what is calculated through the Value-at-risk model,which often does not adequately capture the risk associated with illiquid products. Yield Curve What are the uses of the yield curve?Yield curve depicts the relationship between bond yield and its maturities. It is used to: Forecasting interest rate Pricing bond Create strategies to boost total returns What’s the riskiest part of the yield curve?The riskiest part is either a flattening or steepening of the yield curve.It reflects yield changing among comparable bonds with different maturities. What does it mean for risk when the yield curve is inverted?When the yield curve is inverted, it is often viewed as an pending economic recession.In this case, people tend to have negative view in long term so the price of long term bond is bidding up. What is the discount factor? How would you calculate it?Discount factor is the present value of a unit of currency delivered at a future time T. What is convexity? How would you calculate it? Why is it important?Convexity is the second derivatives of bond price relative to the interest rate.Convexity measures the curvature of price-yield curve. It is a key aspect when measure interest rate risk. What’s the relationship between coupon rate and convexity?convexity decrease as coupon rate increase.Zero-coupon bond have the highest convexity compared to other bond with the same duration and yield to maturity. What’s the meaning of duration? Is it constant for all yields?Duration is the sentivity of bond price relative to interest rate. (First derivative)It is not constant for all yield since price-yield curve has curvature. What’s the meaning of partial duration?It’s also called key rate duration. It measures the bond price change relative to a set of rates with specific maturities.It does not assume parallel shift in yield curve. What are the limits of duration as a risk measure?It assumes the parallel shift in yield curve and it ignores the curvature. How would you decide which discount curve to use to value future cash flows from interest rate swaps? Questions on quantitative concepts: Can you explain the assumptions behind Black Scholes? What’s a volatility smile? Why does it occur? What are the implications for Black Scholes? What are the Greeks? How are the main Greeks derived? What do you know about jump processes? Should you use implied standard deviation or historical deviation to forecast volatility? Explain your choice. Hedging What is delta hedging? How would you hedge against a particular equity/bond under current market conditions? When can hedging an options position mean that you take on more risk? An option is at the money. How many shares of stock should you hold to hedge it? Questions on particular products: What is interest rate risk?The effect on your portfolio value when interest rate changes. What is reinvestment risk?If you have cash flow generated from your portfolio and the market interest rate is changing, you have the reinvestment risk.That means you may have to reinvest your proceedings at a lower/higher market preceding rate. How do interest rate risk and reinvestment risk interact?Reinvestment risk is more likely when interest rates are declining.Reinvestment risk affects the yield-to-maturity of a bond,which is calculated on the premise that all future coupon payments will be reinvested at the interest rate in effect when the bond was first purchased. Which bond has the greatest associated interest rate risk? A five year zero coupon bond? Or a five year bond that pays coupons?zero coupon bond has the highest duration and thus has the greatest interest rate risk. Which is more volatile, a 20-year zero coupon bond or a 20-year 4.5% coupon bond?20-year zero coupon bond. What are the risks inherent in an interest rate swap? Regulation How has Basel III changed the treatment of market risk? What the implications of Basel IIIs new trading book rules for market risk professionals? How could the Basel III treatment of trading books be improved? How will trading businesses change as a result of Basel III capital rules for banks’ trading books? What are the key requirements of the Basel stress testing framework? Are they sufficiently stringent? Which extreme events should stress tests be taking into consideration now? Why is Basel II blamed for precipitating the 2008 financial crisis?]]></content>
      <categories>
        <category>量化分析知识点</category>
      </categories>
      <tags>
        <tag>Risk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Hexo中用mathjax渲染数学公式]]></title>
    <url>%2F2016%2F07%2F16%2F2016-07-16-maupassant-hexo-with-mathjax%2F</url>
    <content type="text"><![CDATA[折腾了一晚上，还是没有搞定，研究了一下似乎是我用的theme: maupassant-hexo 暂时不支持mathjax.搜索了一圈发现这篇文章有解决办法，并且指出了一个人fork了maupassant-hexo并对它加入了支持。暂时还没有尝试，先记录下来。]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Mathjax</tag>
        <tag>Maupassant</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[量化金融面试知识点: 线性回归(Linear Regression)]]></title>
    <url>%2F2016%2F07%2F16%2F2016-07-16-Quant-Finance-Prep-Regression%2F</url>
    <content type="text"><![CDATA[现在公式暂时还不能正常显示，由于是这个issue等作者修好了我再来更新吧 Assumptions linearity of the conditional probability Strict exogeneity: Erros are uncorrelated with indepedent variables (X) If violated, it is called endogeneity No multicollinearity: All regressor variables are linearly independent Variance of erros should be constant: it is called homoscedasticity. If violated, it is called heteroscedasticity Errors have No serial correlation/autocorrelation Errors are normally distributed Errors are independent and identically distributed Estimation Model coefficients: $$\beta = (X^TX)^(-1)(X^TY)$$ variance of coefficients: Var(\beta|X) = ^(\sigmaerr^2)/((n - 1)s_x^2) More variance in the noise means \beta is more variable Larger sample variance means smaller variance of coefficients. It is because it’s much easier to estimate the coefficients Higher sampling frequency reduce variance Variance, Sum of Squares and R^2 TSS: total sum of squaresTSS = SUM of (Y_i - \overline{Y})^2It is the total variance in oberserved dependent variable Regression SS:RSS = SUM of (Y_fit - \overline{Y})^2total variance in fitted observed dependent variables Residual error SS:RESS = SUM of (Y_i - Y_fit)^2 R^2R^2 = 1 - ^(RESS/_TSS)R^2 is the sample covariance between Y and Y_fit Special case: Single X variableR^2 measures the sample covariance between Y and X Adjusted R^2R^2 increases with number of parametersAdjusted R^2 is adjusted by the degree of freedomadj-R^2 = 1 - ^RSS(n - p - 1)^(-1)/_(TSS(n - 1)^(-1)) Durbin-Watson TestTest if there is serial correlation in residuals/autocorrelationIf the p-value from the test is low, it indicates they are probably autocorrelation in noise ACFACF graph is used to look for potential serial correlation at a number of lags Testing Test if multiple coefficients are significant (not zero)F-test This can be used to compare two models that one of the model has a subset of variables Model Selection Criteria AIC &amp; BICThe smaller the error variance, the smaller AIC/BIC but it is penalized by number of variables R^2 Variance inflation factor (VIF) Measures how much the variance increases by including other predictor variables (test for multicollinearity) Calculate by runnning regression of X_j on X_1 … Xnand get R^2: VIF = ^1/(1 - R^2) Violation of Assumptions MulticollinearityIf two or more variables are strongly correlated, it brings in multicollinearity problem the standard error of coefficients increases It’s harder to seperate effects for correlated variables Estimated coefficients are highly sensitive to whether the correlated variables exists]]></content>
      <categories>
        <category>量化分析知识点</category>
      </categories>
      <tags>
        <tag>Statistics</tag>
        <tag>Regression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Edit Distance (72)]]></title>
    <url>%2F2016%2F07%2F13%2F2016-07-13-leetcode-solution-edit-distance-72%2F</url>
    <content type="text"><![CDATA[Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.) You have the following 3 operations permitted on a word: a) Insert a characterb) Delete a characterc) Replace a character 解法：DP with O(N^2) Time and O(N^2) Space双字符串统计min的问题，容易想到用DP解决。假设dp[i][j] 表示前i个字符和前j个字符的子串，convert substr1 to substr2的minimum steps.那么对于初始条件我们容易得到： dp[0][j] = j dp[i][0] = i这里表示的是，如果其中一个是空字符，那么你要么插入j个字符或者删除j个字符，任何一种情况都是j个操作当考虑状态方程的时候，要考虑i和j两位置上的字符是否相等，分两种情况:1 charAt(i) == charAt(j) 当最后比较的字符相同时，有三种情况/操作可能出现 1 可能最小值来自于i - 1和j - 1的匹配， 2 或者是i - 1转为j的匹配，那么就要加上1表示从i字符串删除一位变为i - 1字符串的操作。 3 也可能是把i匹配为j - 1的字符串，然后最后加上第j个字符(insert操作） dp[i][j] = Min(dp[i - 1][j - 1], dp[i - 1][j] + 1, dp[i][j - 1] + 1) 2 charAt(i) != charAt(j) 相类似于上面一种情况，唯一不同的是，dp[i - 1][j - 1]要加上1表示把第i位转化为第j位的操作 dp[i][j] = Min(dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1, dp[i][j - 1] + 1）123456789101112131415161718192021222324252627282930313233343536373839404142public int minDistance(String word1, String word2) &#123; // input validation if (word1 == null &amp;&amp; word2 == null) &#123; return 0; &#125; if (word1 == null) &#123; return word2.length(); &#125; if (word2 == null) &#123; return word1.length(); &#125; // DP int[][] dp = new int[word1.length() + 1][word2.length() + 1]; // initialize for (int i = 0; i &lt;= word1.length(); i++) &#123; dp[i][0] = i; &#125; for (int j = 0; j &lt;= word2.length(); j++) &#123; dp[0][j] = j; &#125; for (int i = 1; i &lt;= word1.length(); i++) &#123; for (int j = 1; j &lt;= word2.length(); j++) &#123; if (word1.charAt(i - 1) == word2.charAt(j - 1)) &#123; // make sure you get the index right, since we added 1 to the array, we need to subtract 1 // to get the index positions dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1]) + 1); &#125; else &#123; dp[i][j] = Math.min(dp[i - 1][j - 1] + 1, Math.min(dp[i - 1][j], dp[i][j - 1]) + 1); &#125; &#125; &#125; return dp[word1.length()][word2.length()];&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Unique Binary Search Trees (96)]]></title>
    <url>%2F2016%2F07%2F13%2F2016-07-13-leetcode-solution-unique-binary-search-trees%2F</url>
    <content type="text"><![CDATA[Given n, how many structurally unique BST’s (binary search trees) that store values 1…n? For example,Given n = 3, there are a total of 5 unique BST’s. 解法：DP with O(N^2) time and O(N) space通常count的问题也可以考虑用dp的方法求解。由于是binary search trees,那么首先要搞清楚的是binary search tree的结构： 1 root左边的所有节点一定比root小 2 root右边的所有节点一定比root大如果我们有N个数字可以选择，那么如果选择了一个i为root,则1 ~ （i -1)都必须在左子数，(i + 1) ~ N 都必须在右子数具体每一个子数有多少unique的排列则完全取决于node的个数。那么我们可以用memorization的思想，从1个node开始，存下每个node可能的排列个数，然后对每一个可能作为root的计算相应的子数的个数。对应的算法为O(N^2)的Time complexity举例，如果N = 3那么可以成为root的有1，2，3三个数当1作为root的时候，由于他是最小值，则剩下的2个数只能排放右边，故排列数为num(2)当2作为root的时候，比他小的数有一个，比他大的数有1个，分列左右两边，故排列数为num(1) * num(1)当3作为root的时候，同理1，他是最大值，排列数为num(1) * num(1)所以总的排列数是每个情况的相加,只要知道了num(1)和num(2)就可以求出num(3) 同时，这个问题也是Catalan Number的一个应用，具体可以看Wiki12345678910111213141516171819202122public int numTrees(int n) &#123; if (n &lt;= 0) &#123; return 1; // If no nodes, then just an empty tree, so 1 &#125; int[] dp = new int[n + 1]; dp[0] = 1; // empty tree dp[1] = 1; // single node tree for (int i = 2; i &lt;= n; i++) &#123; int sum = 0; for (int j = 1; j &lt;= i; j++) &#123; int left = j - 1; // number of left node int right = i - j; // number of right node sum += dp[left] * dp[right]; // multiply &#125; dp[i] = sum; &#125; return dp[n];&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Maximum Product Subarray (152)]]></title>
    <url>%2F2016%2F07%2F13%2F2016-07-13-leetcode-solution-Maximum-Product-Subarray-152%2F</url>
    <content type="text"><![CDATA[Find the contiguous subarray within an array (containing at least one number) which has the largest product. For example, given the array [2,3,-2,4],the contiguous subarray [2,3] has the largest product = 6. 解法：DP with O(N) time and O(1) space由于有负数的存在，有可能负负得正的情况出现，所以需要维护当前的最大值和最小值。最大值是max(A[i], min A[i], max A[i])同时对每一个新元素要update最大值和最小值。123456789101112131415161718192021public int maxProduct(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int min = nums[0]; int max = nums[0]; int res = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; int current_max = Math.max(max * nums[i], Math.max(min * nums[i], nums[i])); int current_min = Math.min(max * nums[i], Math.max(min * nums[i], nums[i])); res = Math.max(res, current_max); // 要注意的是max和min需要同时update,不能先update一个再update另一个，因为计算max和min的公式中用到了对方 max = current_max; min = current_min; &#125; return res;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Range Sum Query - immutable (303)]]></title>
    <url>%2F2016%2F07%2F13%2F2016-07-13-leetcode-solution-range-sum-query-immutable%2F</url>
    <content type="text"><![CDATA[Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Example:Given nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3Note:You may assume that the array does not change.There are many calls to sumRange function. 解法: Memorization/DP with O(1) time and O(N) space就是Subarray类题目的变形，求subarray sum首先要想到前缀和数组。维护一个cumulative sum,然后每次计算i到j的和的时候就是sum[j] - sum[i-1],花费时间是O(1)要注意的是下边界越界的处理。dp[i] = (k - 1) * (dp[i -1] + dp[i - 2])1234567891011121314151617181920212223242526272829303132333435363738public class NumArray &#123; int[] cumsum = null; public NumArray(int[] nums) &#123; // calculate the cumulative sum O(N) // exception handling if (nums == null || nums.length == 0) &#123; return; &#125; cumsum = new int[nums.length]; cumsum[0] = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; cumsum[i] = cumsum[i - 1] + nums[i]; &#125; &#125; public int sumRange(int i, int j) &#123; // Array access: O(1) if (cumsum == null) &#123; return 0; &#125; if (i == 0) &#123; return cumsum[j]; &#125; return cumsum[j] - cumsum[i - 1]; &#125;&#125;// Your NumArray object will be instantiated and called as such:// NumArray numArray = new NumArray(nums);// numArray.sumRange(0, 1);// numArray.sumRange(1, 2);]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Paint Fence (276)]]></title>
    <url>%2F2016%2F07%2F13%2F2016-07-13-leetcode-solution-Paint-Fence-276%2F</url>
    <content type="text"><![CDATA[There is a fence with n posts, each post can be painted with one of the k colors.You have to paint all the posts such that no more than two adjacent fence posts have the same color.Return the total number of ways you can paint the fence. 解法1: DP with O(N) time and O(1) space经典DP, dp[i]表示第i根柱子可能paint的方法数量。考虑三根柱子，如果第i根柱子和第i - 1根一样，那么一定和第i-2根不一样，所以这种情况有k - 1个颜色可选。同理，如果i和第i -2根一样，那必然和第i - 1根不一样，也是k - 1种颜色可选。dp[i] = (k - 1) * (dp[i -1] + dp[i - 2]) 12345678910111213141516171819202122public int numWays(int n, int k) &#123; if (n &lt;= 0) &#123; return 0; // If no fence exists, there is no way to paint it. &#125; // Corner case if (n == 1) &#123; return k; &#125; int[] dp = new int[]&#123;k, k * k, k * k&#125;; // initial value of dp[2] is set to be equal to dp[1]. for (int i = 3; i &lt;= n; i++) &#123; dp[2] = (k - 1) * (dp[0] + dp[1]); dp[0] = dp[1]; dp[1] = dp[2]; &#125; return dp[2]; &#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: House Robber(198)]]></title>
    <url>%2F2016%2F07%2F13%2F2016-07-13-leetcode-solution-house-robber%2F</url>
    <content type="text"><![CDATA[You are a professional robber planning to rob houses along a street.Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 解法1: DP with O(N) time and O(N) space应该考虑到是经典的DP问题，要求一个最大的解。那么首先dp数组的含义是dp[i]代表前i个房子能取得的最大值，考虑第i个房子，如果抢第i个房子，那么第i-1个房子一定不能取，所以最大的值是dp[i - 2] + A[i]如果不抢第i个房子，那么最大的值就是前一个房子能取得的最大值，状态方程dp[i] = max(dp[i - 1], dp[i - 2] + A[i])。这种考虑第i个数字取或者不取得思路在其他dp问题中也经常见到。 123456789101112131415161718192021public int rob(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; if (nums.length == 1) &#123; return nums[0]; &#125; // initialize int[] dp = new int[nums.length]; dp[0] = nums[0]; dp[1] = Math.max(dp[0], nums[1]); // dp transition for (int i = 2; i &lt; nums.length; i++) &#123; dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]); &#125; return dp[nums.length - 1];&#125; 解法1优化: DP with O(N) time and O(1) space实际上观察状态方程可以发现，我们只需要记录dp[i - 2], dp[i -1]两个数值，所以可以维护一个数组{A,B,C},前两个数字作为buffer，不停更新三个数字。123456789101112131415161718192021public int rob(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; if (nums.length == 1) &#123; return nums[0]; &#125; // initialize int[] dp = new int[]&#123;nums[0], Math.max(nums[0], nums[1]), Math.max(nums[0], nums[1])&#125;; // dp transition for (int i = 2; i &lt; nums.length; i++) &#123; dp[2] = Math.max(dp[1], dp[0] + nums[i]); dp[0] = dp[1]; dp[1] = dp[2]; &#125; return dp[2];&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Best time to buy and sell stock IV (188)]]></title>
    <url>%2F2016%2F07%2F08%2F2016-07-08-leetcode-note-Best-time-to-buy-and-sell-stock-IV%2F</url>
    <content type="text"><![CDATA[Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note:You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 解法:比较难想清楚的一题。需要用到两个dp matrix, 一个叫local, 一个叫globallocal[i][j] 表示的是前i天做j次操作，最后一次sell正好是i天时的最大利润global[i][j]表示的是前i天做j次操作，最大的利润那么答案就是global[N][k]local的递推关系是：local[i][j]可以是i-1天已经完成了j次交易，那么只要把最后一天的交易顺延，就得到了i天完成j次交易。另外一个可能是到i - 1天完成了j - 1次交易，那么只要再加上新加的一天的交易即可。global的递推关系是：global[i][j]是要么新一天的local maxi, 或者是前一天的global max 123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public int maxProfit(int k, int[] prices) &#123; if (prices == null || prices.length == 0) &#123; return 0; &#125; int n = prices.length; if (k &gt; n) &#123; return maxProfit_naive(prices); &#125; int[][] global = new int[n][k + 1]; int[][] local = new int[n][k + 1]; for (int i = 1; i &lt; n; i++) &#123; int diff = prices[i] - prices[i - 1]; for (int j = 1; j &lt;= k; j++) &#123; local[i][j] = Math.max(global[i - 1][j - 1] + diff, local[i - 1][j] + diff); global[i][j] = Math.max(local[i][j], global[i -1][j]); &#125; &#125; return global[n - 1][k]; &#125; private int maxProfit_naive(int[] prices) &#123; int sum = 0; for (int i = 1; i &lt; prices.length; i++) &#123; if (prices[i] &gt; prices[i - 1]) &#123; sum += prices[i] - prices[i - 1]; &#125; &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Dynamic programming</tag>
        <tag>局部最优和全局最优</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: best time to buy and sell stock III (123)]]></title>
    <url>%2F2016%2F07%2F08%2F2016-07-08-leetcode-note-best-time-to-buy-and-sell-stock-III%2F</url>
    <content type="text"><![CDATA[Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note:You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 解法1： Divide &amp; Conquer O(N^2) Time + O(N) Space思路是利用I的解题方法，对于一个(i,j)范围的数组，可以用O(N)的时间和O(1)的空间算出最大的利润那么可以将原数组分割为(0,i) + (i,length - 1)的两个数组，分别计算每个范围内的最大利润再相加。一共有N种分割方法，所以总的时间复杂度是O(N^2)这个解法lintcode可以AC,leetcode会TLE，所以需要改进这个解法，最好的是O(N) Time12345678910111213141516171819202122232425public int maxProfit(int[] prices) &#123; if (prices == null || prices.length == 0) &#123; return 0; &#125; int res = 0; for (int i = 0; i &lt; prices.length - 1; i++) &#123; int left = maxSingleTransition(prices, 0, i); int right = maxSingleTransition(prices, i, prices.length - 1); int sum = left + right; res = Math.max(res, sum); &#125; return res;&#125;private int maxSingleTransition(int[] prices, int start, int end) &#123; int min = prices[start]; int res = 0; for (int i = start; i &lt;= end; i++) &#123; res = Math.max(res, prices[i] - min); min = Math.min(min, prices[i]); &#125; return res;&#125; 解法2：两次DP，O(N) Time + O(N) Space思路还是类似于第一种解法，但是做了优化。计算(0,i)的时候实际可以运用(0,i-1)的结果。同样，计算(i,length - 1)的时候可以运用(i+1,length - 1)的结果。这就引出了用两个dp数组先记录下每一个区间的最大收益，然后再扫描一遍得到左右两个区间和的最大值。12345678910111213141516171819202122232425262728293031public int maxProfit(int[] prices) &#123; if (prices == null || prices.length == 0) &#123; return 0; &#125; int[] left = new int[prices.length]; int[] right = new int[prices.length]; // Scan from left int min = prices[0]; for (int i = 1; i &lt; prices.length; i++) &#123; left[i] = Math.max(left[i - 1], prices[i] - min); min = Math.min(min, prices[i]); &#125; // Scan from right int max = prices[prices.length - 1]; for (int i = prices.length - 2; i &gt;= 0; i--) &#123; right[i] = Math.max(right[i + 1], max - prices[i]); max = Math.max(max, prices[i]); &#125; // search for the largest sum int res = 0; for (int i = 0; i &lt; prices.length; i++) &#123; res = Math.max(res, left[i] + right[i]); &#125; return res;&#125; 解法３: 用交替的dp方程组12345678910111213141516171819class Solution &#123; public int maxProfit(int[] prices) &#123; if (prices == null || prices.length == 0) &#123; return 0; &#125; int t_i10 = 0, t_i11 = Integer.MIN_VALUE, t_i20 = 0, t_i21 = Integer.MIN_VALUE; for (int price : prices) &#123; t_i20 = Math.max(t_i20, t_i21 + price); t_i21 = Math.max(t_i21, t_i10 - price); t_i10 = Math.max(t_i10, t_i11 + price); t_i11 = Math.max(t_i11, -price); &#125; return t_i20; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Best time to buy and sell stock II （122）]]></title>
    <url>%2F2016%2F07%2F08%2F2016-07-08-leetcode-note-best-time-to-buy-and-sell-stock-II%2F</url>
    <content type="text"><![CDATA[Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like(ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time(ie, you must sell the stock before you buy again). 解法1：O(N)既然是可以交易任意多次，只要price[i] &gt; price[i - 1]我们就认为是一次合格的交易，那么最大的profit一定是所有positive profit的和。只要扫描一遍求出所有正差值的和即为答案这是一种greedy的思路。123456789101112131415public int maxProfit(int[] prices) &#123; if (prices == null || prices.length == 0) &#123; return 0; &#125; int profit = 0; for (int i = 1; i &lt; prices.length; i++) &#123; if (prices[i] &gt; prices[i - 1]) &#123; profit += prices[i] - prices[i - 1]; &#125; &#125; return profit;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Best Time to Buy and Sell Stock （121)]]></title>
    <url>%2F2016%2F07%2F07%2F2016-07-07-leetcode-solution-Best-Time-to-Buy-and-Sell-Stock%2F</url>
    <content type="text"><![CDATA[Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1:Input: [7, 1, 5, 3, 6, 4]Output: 5 max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)Example 2:Input: [7, 6, 4, 3, 1]Output: 0 In this case, no transaction is done, i.e. max profit = 0. 解法1：DP with O(N) 空间从左往右维护一个最小的price,那么转换方程就可以写成dp[i] = Math.max(dp[i - 1], price[i] - min),其中dp[i]表示的是前i个数中如果只能交易一次的最大利润，不一定要以i结尾。1234567891011121314151617public int maxProfit(int[] prices) &#123; if (prices == null || prices.length == 0) &#123; return 0; &#125; int[] profit = new int[prices.length]; int min = prices[0]; int res = 0; for (int i = 1; i &lt; prices.length; i++) &#123; profit[i] = Math.max(profit[i - 1], prices[i] - min); min = Math.min(min, prices[i]); res = Math.max(res, profit[i]); &#125; return res;&#125; 解法2：DP with O(1) 空间从左往右维护当前的最小值，并且计算每一个累积和和最小值的差，取最大的作为结果.这题用DP的思路是dp[i] = max(dp[i - 1], A[i] - min)， 所以就是也要维护一个min，实际上并不需要维护dp数组，只要不停更新min就可以了12345678910111213141516public int maxProfit(int[] prices) &#123; if (prices == null || prices.length == 0) &#123; return 0; &#125; int minPrice = prices[0]; int res = 0; for (int i = 0; i &lt; prices.length; i++) &#123; res = Math.max(prices[i] - minPrice, res); minPrice = Math.min(minPrice, prices[i]); &#125; return res;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题: Maximum Subarray (53)]]></title>
    <url>%2F2016%2F07%2F07%2F2016-07-07-leetcode-solution-Maximum-Subarray%2F</url>
    <content type="text"><![CDATA[Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [−2,1,−3,4,−1,2,1,−5,4],the contiguous subarray [4,−1,2,1] has the largest sum = 6.Practice 解法1：DP with O(N) 空间用经典的DP思想可以解决，dp数组存的是以i结尾的前i个数字的max subarray，那么可以得到这样的递推关系dp[i] = Max(dp[i - 1] + A[i], A[i])意思就是说以i结尾的最大的子数组和要么是自己，要么是前一个子数组和加上自己。可以写出如下的代码12345678910111213public int maxSubArray(int[] nums) &#123; int[] dp = new int[nums.length]; dp[0] = nums[0]; int max = dp[0]; for (int i = 1; i &lt; nums.length; i++) &#123; dp[i] = Math.max(nums[i], dp[i - 1] + nums[i]); max = Math.max(dp[i], max); &#125; return max;&#125; 解法1优化: DP with O(1) 空间观察上面的解法可以发现，实际上我们不需要维护一个数组来记录每一个点的最大和。我们可以只维护一个变量sum,来记录从0到i的和。如果sum一旦小于0，那么对下一个dp数值的计算一定用不上sum,所以此时可以设置为0. 代码如下123456789101112public int maxSubArray(int[] nums) &#123; int sum = 0; int max = Integer.MIN_VALUE; for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; max = Math.max(sum, max); if (sum &lt; 0) &#123; sum = 0; &#125; return max;&#125; 解法2: 前缀和数组的思路，O(N) time + O(1) space基本思想是：如果把数组中每一个元素都加起来，我们可以得到一个累积的和，那么这个问题实际上就变成了best time to buy and sell stock I的问题，从左至右寻找最小的mininum sum,然后将当前的sum和minSum相减再和全局的最大值比较得出结果。123456789101112131415public int maxSubArray(int[] nums) &#123; int sum = 0; int min = 0; int profit = nums[0]; for (int i = 0; i &lt; nums.length; i++) &#123; profit = Math.max(sum + nums[i] - min, profit); sum += nums[i]; min = Math.min(sum, min); &#125; return profit;&#125; 解法3：用Divide &amp; Conquer思想：O(NlogN)具体的思路是把原来的array一分为二，那么最大的子数组和一定是在1.左面的数组，2.右面的数组，3.跨越左面和右面的数组左面和右面用递归的方式计算。跨越中点的数组一定包含mid point,往右面扫描找出最大的，往左面扫描找出最大的，最后比较三个数得出结果。12345678910111213141516171819202122232425262728293031public int maxSubArray(int[] nums) &#123; return helper(nums, 0, nums.length - 1);&#125;public int helper(int[] A, int left, int right) &#123; if (left &gt;= right) &#123; return A[left]; &#125; // Divide into left and right array int mid = left + (right - left) / 2; int lmax = helper(A, left, mid - 1); int rmax = helper(A, mid + 1, right); // Merge and Conquer int mmax = A[mid]; int temp = mmax; // Scan to left for (int i = mid - 1; i &gt;= left; i--) &#123; temp += A[i]; mmax = Math.max(mmax, temp); &#125; // Scan to right temp = mmax; for (int i = mid + 1; i &lt;= right; i++) &#123; temp += A[i]; mmax = Math.max(mmax, temp); &#125; return Math.max(mmax, Math.max(lmax, rmax));&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Hexo搭blog系统]]></title>
    <url>%2F2016%2F04%2F11%2F2016-04-11-Blogging-with-Hexo%2F</url>
    <content type="text"><![CDATA[在看一个技术博客的时候无意间发现了博主使用的这个开源项目Hexo，它是一个基于Node.js的快速搭建blog的框架。觉得很好就拿来搭了现在的这个大提摩，搭建这个Hexo需要的步骤非常简单。 安装Hexo安装Hexo之前需要确保已经安装了Node.js和Git。安装Hexo时就可以按照官网执行：1$ npm install -g hexo-cli Deployer如果部署到github需要一个deployer1npm install hexo-deployer-git --save 大道至简的Theme我用的这个主题是一个博主fork过来专门用于Hexo的，个人觉得简单干净大气。安装也很简单123$ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant$ npm install hexo-renderer-jade --save$ npm install hexo-renderer-sass --save要注意的是这个安装方法中jade已经改名成pug了，不过对我们使用这个theme好像问题也不大。 其他反面，等慢慢体验多了有什么想记一笔的再写上来。 写博客和发布1$ hexo new post &quot;post-name&quot; 编辑分类(category)直接打开post文件，按照如下的格式修改即可12345678910---title: 显示的post的名字date: 2016-04-11 14:12:26category:- 技术总结- 在这里列举分类tags:- Hexo- 用这个方法加入tags--- 发布1hexo generate --deploy]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小提摩的大理想]]></title>
    <url>%2F2016%2F04%2F11%2F2016-04-11-My-first-blog%2F</url>
    <content type="text"><![CDATA[总是感觉自己想学的和已经学得东西都很多，却零零散散，开了这个blog，想整理一些自己的资料。在这里我会总结或者分享一些技术相关的文章，工作学习生活体会，还有投资理财，量化交易的心得等等。不务正业的时候也会分享一些自家的深夜料理，以小餐日料和中国家常菜为主，偶尔会有黑暗料理乱入。]]></content>
  </entry>
</search>
