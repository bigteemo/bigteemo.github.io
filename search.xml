<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[题型总结: 滑动窗口 Sliding Window]]></title>
      <url>/2017/09/10/Algorithm-Summary-Sliding-Window/</url>
      <content type="html"><![CDATA[<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>滑动窗口的问题可以解决一系列，有两个字符串，找一个字符串存在另一个字符串的某种性质的问题。<br>可以解决的问题参考同名<a href="http://bigteemo.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">tag</a>. 这里只是列举一下模板</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">SlidingWindow</span><span class="params">(String s, String p)</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 先建立一个map来存储p中的每一个字符出现的次数,etc</span></div><div class="line">  Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> ch: p.toCharArray()) &#123;</div><div class="line">    map.put(ch, ...)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 然后用两个左右指针，右指针遍历字符串s。同时需要维护一个变量count,</span></div><div class="line">  <span class="comment">// 这个变量的作用在于知晓需要找的性质是否找到之类的问题。</span></div><div class="line"></div><div class="line">  <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, count = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (end &lt; s.length()) &#123;</div><div class="line">    <span class="keyword">char</span> right = s.charAt(end);</div><div class="line"></div><div class="line">    <span class="comment">// 更新map中对应的数值, 同时需要更新count</span></div><div class="line">    <span class="comment">// count更新的条件取决于不同的题目。比如可以是所有的字符都出现过了。</span></div><div class="line">    <span class="keyword">if</span> (map.containsKey(right)) &#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">      <span class="keyword">if</span> (map.get(right) == <span class="number">0</span>) count--;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 查看寻找的条件是否已达到</span></div><div class="line">    <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">      <span class="comment">// 更新要求的答案</span></div><div class="line"></div><div class="line">      <span class="comment">// 更新count</span></div><div class="line"></div><div class="line">      start++;</div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 题型总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[294. Flip Game II]]></title>
      <url>/2017/08/17/2017-08-17-294-Flip-Game-II/</url>
      <content type="html"><![CDATA[<p>You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two consecutive “++” into “–”. The game ends when a person can no longer make a move and therefore the other person will be the winner.</p>
<p>Write a function to determine if the starting player can guarantee a win.</p>
<p>For example, given s = “++++”, return true. The starting player can guarantee a win by flipping the middle “++” to become “+–+”.</p>
<p>Follow up:<br>Derive your algorithm’s runtime complexity.</p>
<h3 id="解法1：DFS-O-N"><a href="#解法1：DFS-O-N" class="headerlink" title="解法1：DFS O(N!!)"></a>解法1：DFS O(N!!)</h3><p>每次尝试一个可以flip的位置，然后进行下一轮，如果下一轮的人不能获胜，则证明first player可以赢。<br>Time Complexity 按照这个人说的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">For the time complexity, here is what I thought, let&apos;s say the length of the input string s is n, there are at most n - 1 ways to replace &quot;++&quot; to &quot;--&quot; (imagine s is all &quot;+++...&quot;), once we replace one &quot;++&quot;, there are at most (n - 2) - 1 ways to do the replacement, it&apos;s a little bit like solving the N-Queens problem, the time complexity is (n - 1) x (n - 3) x (n - 5) x ..., so it&apos;s O(n!!), double factorial.</div></pre></td></tr></table></figure></p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法2：-DP"><a href="#解法2：-DP" class="headerlink" title="解法2： DP"></a>解法2： DP</h3><p>参考这篇：<a href="https://leetcode.com/problems/flip-game-ii/discuss/" target="_blank" rel="external">https://leetcode.com/problems/flip-game-ii/discuss/</a></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[379. Design Phone Directory]]></title>
      <url>/2017/08/17/2017-08-17-379-Design-Phone-Directory/</url>
      <content type="html"><![CDATA[<p>Design a Phone Directory which supports the following operations:</p>
<p>get: Provide a number which is not assigned to anyone.<br>check: Check if a number is available or not.<br>release: Recycle or release a number.<br>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// Init a phone directory containing a total of 3 numbers: 0, 1, and 2.</div><div class="line">PhoneDirectory directory = new PhoneDirectory(3);</div><div class="line"></div><div class="line">// It can return any available phone number. Here we assume it returns 0.</div><div class="line">directory.get();</div><div class="line"></div><div class="line">// Assume it returns 1.</div><div class="line">directory.get();</div><div class="line"></div><div class="line">// The number 2 is available, so return true.</div><div class="line">directory.check(2);</div><div class="line"></div><div class="line">// It returns 2, the only number that is left.</div><div class="line">directory.get();</div><div class="line"></div><div class="line">// The number 2 is no longer available, so return false.</div><div class="line">directory.check(2);</div><div class="line"></div><div class="line">// Release number 2 back to the pool.</div><div class="line">directory.release(2);</div><div class="line"></div><div class="line">// Number 2 is available again, return true.</div><div class="line">directory.check(2);</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>用一个hashset存储号码。get的时候用<code>directory.iterator().next()</code>来得到下一个数字。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneDirectory</span> </span>&#123;</div><div class="line"></div><div class="line">    HashSet&lt;Integer&gt; directory;</div><div class="line">    <span class="comment">/** Initialize your data structure here</span></div><div class="line"><span class="comment">        <span class="doctag">@param</span> maxNumbers - The maximum numbers that can be stored in the phone directory. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PhoneDirectory</span><span class="params">(<span class="keyword">int</span> maxNumbers)</span> </span>&#123;</div><div class="line">        directory = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxNumbers; i++) &#123;</div><div class="line">            directory.add(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Provide a number which is not assigned to anyone.</span></div><div class="line"><span class="comment">        <span class="doctag">@return</span> - Return an available number. Return -1 if none is available. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (directory.size() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> key = directory.iterator().next();</div><div class="line">        directory.remove(key);</div><div class="line">        <span class="keyword">return</span> key;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Check if a number is available or not. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> directory.contains(number);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Recycle or release a number. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</div><div class="line"></div><div class="line">        directory.add(number);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Your PhoneDirectory object will be instantiated and called as such:</span></div><div class="line"><span class="comment"> * PhoneDirectory obj = new PhoneDirectory(maxNumbers);</span></div><div class="line"><span class="comment"> * int param_1 = obj.get();</span></div><div class="line"><span class="comment"> * boolean param_2 = obj.check(number);</span></div><div class="line"><span class="comment"> * obj.release(number);</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[328. Odd Even Linked List]]></title>
      <url>/2017/08/17/2017-08-17-328-Odd-Even-Linked-List/</url>
      <content type="html"><![CDATA[<p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Example:</div><div class="line">Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL,</div><div class="line">return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL.</div></pre></td></tr></table></figure></p>
<p>Note:<br>The relative order inside both the even and odd groups should remain as it was in the input.<br>The first node is considered odd, the second node even and so on …</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>考虑1-&gt;2-&gt;3-&gt;4这个情况，实际上只需要修改成1-&gt;3-&gt;4,2-&gt;4就可以了，然后把odd指针往下移动一格，even指针往下移动一格就可以了。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * public class ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> head;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ListNode oddHead = head, evenHead = head.next;</div><div class="line">        ListNode odd = oddHead, even = evenHead;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (even != <span class="keyword">null</span> &amp;&amp; even.next != <span class="keyword">null</span>) &#123;</div><div class="line">            ListNode temp = even.next;</div><div class="line">            even.next = even.next.next; <span class="comment">// skip next odd following the current even</span></div><div class="line">            odd.next = temp;</div><div class="line">            odd = odd.next;</div><div class="line">            even = even.next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// odd point to the tail of the list</span></div><div class="line">        odd.next = evenHead;</div><div class="line">        <span class="keyword">return</span> oddHead;        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[148. Sort List]]></title>
      <url>/2017/08/17/2017-08-17-148-Sort-List/</url>
      <content type="html"><![CDATA[<p>Sort a linked list in O(n log n) time using constant space complexity.</p>
<h3 id="解法1：-Merge-Sort"><a href="#解法1：-Merge-Sort" class="headerlink" title="解法1： Merge Sort"></a>解法1： Merge Sort</h3><p>考察了几个基本算法：<br>linkedlist找中点<br>linkedlist merge</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * public class ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> head;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Cut into half, i.e. look for the middle point</span></div><div class="line">        ListNode slow = head, fast = head.next;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</div><div class="line">            slow = slow.next;</div><div class="line">            fast = fast.next.next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// break from the middle point</span></div><div class="line">        ListNode rightHead = slow.next;</div><div class="line">        slow.next = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Sort on each half</span></div><div class="line">        ListNode left = sortList(head);</div><div class="line">        ListNode right = sortList(rightHead);</div><div class="line"></div><div class="line">        <span class="comment">// Merge</span></div><div class="line">        <span class="keyword">return</span> merge(left, right);        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode left, ListNode right)</span> </span>&#123;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode tail = dummy;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (left.val &lt; right.val) &#123;</div><div class="line">                tail.next = left;</div><div class="line">                left = left.next;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                tail.next = right;</div><div class="line">                right = right.next;</div><div class="line">            &#125;</div><div class="line">            tail = tail.next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</div><div class="line">            tail.next = left;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</div><div class="line">            tail.next = right;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[82. Remove Duplicates from Sorted List II]]></title>
      <url>/2017/08/17/2017-08-17-82-Remove-Duplicates-from-Sorted-List-II/</url>
      <content type="html"><![CDATA[<p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p>
<p>For example,<br>Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.<br>Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>用dummy node解决。slow表示下一个插入位置。fast表示当前的元素。fast和它下一个元素相比，如果相同则跳过。<br>最后再按照两种情况分别处理，一个是slow指向的下一个元素就是fast，也就是说fast原来指向的数值是unique的，那么slow和fast都向前移动。<br>如果slow下一个元素和fast不同，那么需要跳过slow和fast当中的元素。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * public class ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> head;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        dummy.next = head;</div><div class="line"></div><div class="line">        ListNode slow = dummy, fast = head;</div><div class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.val == fast.next.val) &#123;</div><div class="line">                fast = fast.next;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (slow.next != fast) &#123;</div><div class="line">                slow.next = fast.next;  </div><div class="line">                fast = slow.next;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                slow = slow.next;</div><div class="line">                fast = fast.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[369. Plus One Linked List]]></title>
      <url>/2017/08/17/2017-08-17-369-Plus-One-Linked-List/</url>
      <content type="html"><![CDATA[<p>Given a non-negative integer represented as non-empty a singly linked list of digits, plus one to the integer.</p>
<p>You may assume the integer do not contain any leading zero, except the number 0 itself.</p>
<p>The digits are stored such that the most significant digit is at the head of the list.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">1-&gt;2-&gt;3</div><div class="line"></div><div class="line">Output:</div><div class="line">1-&gt;2-&gt;4</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>考察linkedlist基本功的一道题，先reverse再加1再reverse<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * public class ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">plusOne</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> head;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ListNode headReversed = reverse(head);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> carry = <span class="number">1</span>;</div><div class="line"></div><div class="line">        head = headReversed;</div><div class="line">        ListNode prev = head;</div><div class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</div><div class="line">            prev = head;</div><div class="line">            <span class="keyword">int</span> digit = (head.val + carry) % <span class="number">10</span>;</div><div class="line">            carry = (head.val + carry) / <span class="number">10</span>;</div><div class="line">            head.val = digit;</div><div class="line">            head = head.next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</div><div class="line">            ListNode temp = <span class="keyword">new</span> ListNode(carry);</div><div class="line">            prev.next = temp;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// reverse back to get the desired result</span></div><div class="line">        <span class="keyword">return</span> reverse(headReversed);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        ListNode prev = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</div><div class="line">            ListNode temp = head.next;</div><div class="line">            head.next = prev;</div><div class="line">            prev = head;</div><div class="line">            head = temp;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> prev;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[142. Linked List Cycle II]]></title>
      <url>/2017/08/17/2017-08-17-142-Linked-List-Cycle-II/</url>
      <content type="html"><![CDATA[<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>Note: Do not modify the linked list.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>一个老题。快慢两个指针，等相遇的时候slow继续往前走一个然后继续前行，fast回到原点然后一次一步直到再次相遇就是他们的交点。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * class ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) &#123;</span></div><div class="line"><span class="comment"> *         val = x;</span></div><div class="line"><span class="comment"> *         next = null;</span></div><div class="line"><span class="comment"> *     &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ListNode slow = head, fast = head.next;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (fast != slow) &#123;</div><div class="line">            <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            fast = fast.next.next;</div><div class="line">            slow = slow.next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        slow = slow.next;</div><div class="line">        fast = head;</div><div class="line">        <span class="keyword">while</span> (fast != slow) &#123;</div><div class="line">            fast = fast.next;</div><div class="line">            slow = slow.next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">return</span> fast;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[207. Course Schedule]]></title>
      <url>/2017/08/17/2017-08-17-207-Course-Schedule/</url>
      <content type="html"><![CDATA[<p>There are a total of n courses you have to take, labeled from 0 to n - 1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p>
<p>For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2, [[1,0]]</div></pre></td></tr></table></figure></p>
<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2, [[1,0],[0,1]]</div></pre></td></tr></table></figure></p>
<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</p>
<h3 id="解法1：有向图"><a href="#解法1：有向图" class="headerlink" title="解法1：有向图"></a>解法1：有向图</h3><p>这题和Course Schedule II的解法基本一样，就是判断有向图中是否有环。基本的入度出度的解法要掌握。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (prerequisites == <span class="keyword">null</span> || prerequisites.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// no circle in the graph + number of visited nodes == numCourses</span></div><div class="line">        <span class="keyword">int</span>[] ins = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</div><div class="line"></div><div class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, List&lt;Integer&gt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] pre : prerequisites) &#123;</div><div class="line">            <span class="keyword">if</span> (!map.containsKey(pre[<span class="number">1</span>])) &#123;</div><div class="line">                map.put(pre[<span class="number">1</span>], <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</div><div class="line">            &#125;</div><div class="line">            map.get(pre[<span class="number">1</span>]).add(pre[<span class="number">0</span>]);    <span class="comment">// because of no duplicate edges in the input prerequisities</span></div><div class="line">            ins[pre[<span class="number">0</span>]]++;  <span class="comment">// add the in-count for the node</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (ins[i] == <span class="number">0</span>) &#123;</div><div class="line">                queue.offer(i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> root = queue.poll();</div><div class="line">            <span class="keyword">if</span> (map.containsKey(root)) &#123;</div><div class="line">                List&lt;Integer&gt; children = map.get(root);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> child : children) &#123;</div><div class="line">                    ins[child] -= <span class="number">1</span>;</div><div class="line">                    <span class="keyword">if</span> (ins[child] == <span class="number">0</span>) &#123;</div><div class="line">                        queue.offer(child);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// check if there is non-zero ins</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (ins[i] != <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[210. Course Schedule II]]></title>
      <url>/2017/08/17/2017-08-17-210-Course-Schedule-II/</url>
      <content type="html"><![CDATA[<p>There are a total of n courses you have to take, labeled from 0 to n - 1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.</p>
<p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p>
<p>For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2, [[1,0]]</div></pre></td></tr></table></figure></p>
<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4, [[1,0],[2,0],[3,1],[3,2]]</div></pre></td></tr></table></figure></p>
<p>There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].</p>
<p>Note:<br>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.<br>You may assume that there are no duplicate edges in the input prerequisites.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Hints:</div><div class="line">This problem is equivalent to finding the topological order in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.</div><div class="line">Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.</div><div class="line">Topological sort could also be done via BFS.</div></pre></td></tr></table></figure>
<h3 id="解法1：有向图，-拓扑排序"><a href="#解法1：有向图，-拓扑排序" class="headerlink" title="解法1：有向图， 拓扑排序"></a>解法1：有向图， 拓扑排序</h3><p>有向图的问题用入度和出度解决的比较多。这题用BFS解决，push进queue的是所有入度为0的点。<br>如果有向图有环，则表示图中有互相依赖的课程存在。如果最后没有入度不为0的点，则说明是一个无环有向图。</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</div><div class="line">        <span class="keyword">if</span> (prerequisites == <span class="keyword">null</span> || prerequisites.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</div><div class="line">                res[i] = i;                </div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">w</div><div class="line">        <span class="comment">// Construct the graph</span></div><div class="line">        HashMap&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">int</span>[] ins = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] pre : prerequisites) &#123;</div><div class="line">            <span class="keyword">if</span> (!graph.containsKey(pre[<span class="number">1</span>])) &#123;</div><div class="line">                graph.put(pre[<span class="number">1</span>], <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</div><div class="line">            &#125;</div><div class="line">            graph.get(pre[<span class="number">1</span>]).add(pre[<span class="number">0</span>]);</div><div class="line">            ins[pre[<span class="number">0</span>]]++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (ins[i] == <span class="number">0</span>) &#123;</div><div class="line">                queue.offer(i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</div><div class="line">            <span class="keyword">int</span> root = queue.poll();</div><div class="line">            res[pos++] = root;</div><div class="line">            <span class="keyword">if</span> (graph.containsKey(root)) &#123;</div><div class="line">                List&lt;Integer&gt; subs = graph.get(root);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> sub : subs) &#123;</div><div class="line">                    ins[sub]--;</div><div class="line">                    <span class="keyword">if</span> (ins[sub] == <span class="number">0</span>) &#123;</div><div class="line">                        queue.offer(sub);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (ins[i] != <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[542. 01 Matrix]]></title>
      <url>/2017/08/17/2017-08-17-542-01-Matrix/</url>
      <content type="html"><![CDATA[<p>Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.</p>
<p>The distance between two adjacent cells is 1.<br>Example 1:<br>Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0 0 0</div><div class="line">0 1 0</div><div class="line">0 0 0</div></pre></td></tr></table></figure></p>
<p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0 0 0</div><div class="line">0 1 0</div><div class="line">0 0 0</div></pre></td></tr></table></figure></p>
<p>Example 2:<br>Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0 0 0</div><div class="line">0 1 0</div><div class="line">1 1 1</div></pre></td></tr></table></figure></p>
<p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0 0 0</div><div class="line">0 1 0</div><div class="line">1 2 1</div></pre></td></tr></table></figure></p>
<p>Note:<br>The number of elements of the given matrix will not exceed 10,000.<br>There are at least one 0 in the given matrix.<br>The cells are adjacent in only four directions: up, down, left and right.</p>
<h3 id="解法1：-BFS"><a href="#解法1：-BFS" class="headerlink" title="解法1： BFS"></a>解法1： BFS</h3><p>这题和那个continental divide的题的思路有点相似的地方。要反过来想问题会变简单。<br>题意是让我们计算每一个1距离最近的0的距离。如果反过来想，我们从每一个0出发，探查四周，如果当前距离比之前的距离要短，那么更新那个单元格的数值，同时把那个单元格加入到探查的路径中。如果距离要更长，则这一支不需要再探查了。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!--￼<span class="number">4</span>--&gt;</div><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[364. Nested List Weight Sum II]]></title>
      <url>/2017/08/17/2017-08-17-364-Nested-List-Weight-Sum-II/</url>
      <content type="html"><![CDATA[<p>Given a nested list of integers, return the sum of all integers in the list weighted by their depth.</p>
<p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p>
<p>Different from the previous question where weight is increasing from root to leaf, now the weight is defined from bottom up. i.e., the leaf level integers have weight 1, and the root level integers have the largest weight.</p>
<p>Example 1:<br>Given the list <code>[[1,1],2,[1,1]]</code>, return 8. (four 1’s at depth 1, one 2 at depth 2)</p>
<p>Example 2:<br>Given the list <code>[1,[4,[6]]]</code>, return 17. (one 1 at depth 3, one 4 at depth 2, and one 6 at depth 1; 1<em>3 + 4</em>2 + 6*1 = 17)</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>一个递归的办法就可以解决。因为weight现在是从bottom到top，所以要先计算出maxdepth。这一步也需要用递归完成。<br>然后把depth作为一个参数pass到每一层就可以了。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depthSumInverse</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nestedList == <span class="keyword">null</span> || nestedList.size() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// get the max sum;</span></div><div class="line">        <span class="keyword">int</span> maxDepth = getMaxDepth(nestedList);</div><div class="line">        <span class="keyword">return</span> helper(nestedList, maxDepth);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxDepth</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;    </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nestedList.size(); i++) &#123;</div><div class="line">            NestedInteger item = nestedList.get(i);</div><div class="line">            <span class="keyword">if</span> (item.isInteger()) &#123;</div><div class="line">                max = Math.max(max, <span class="number">1</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                max = Math.max(max, getMaxDepth(item.getList()) + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;    </div><div class="line">        <span class="keyword">return</span> max;        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(List&lt;NestedInteger&gt; nestedList, <span class="keyword">int</span> depth)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nestedList.size(); i++) &#123;</div><div class="line">            NestedInteger item = nestedList.get(i);</div><div class="line">            <span class="keyword">if</span> (item.isInteger()) &#123;</div><div class="line">                sum += depth * item.getInteger();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                sum += helper(item.getList(), depth - <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[417. Pacific Atlantic Water Flow]]></title>
      <url>/2017/08/13/2017-08-13-417-Pacific-Atlantic-Water-Flow/</url>
      <content type="html"><![CDATA[<p>Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the “Pacific ocean” touches the left and top edges of the matrix and the “Atlantic ocean” touches the right and bottom edges.</p>
<p>Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.</p>
<p>Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.</p>
<p>Note:<br>The order of returned grid coordinates does not matter.<br>Both m and n are less than 150.<br>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Given the following 5x5 matrix:</div><div class="line"></div><div class="line">  Pacific ~   ~   ~   ~   ~</div><div class="line">       ~  1   2   2   3  (5) *</div><div class="line">       ~  3   2   3  (4) (4) *</div><div class="line">       ~  2   4  (5)  3   1  *</div><div class="line">       ~ (6) (7)  1   4   5  *</div><div class="line">       ~ (5)  1   1   2   4  *</div><div class="line">          *   *   *   *   * Atlantic</div><div class="line"></div><div class="line">Return:</div><div class="line"></div><div class="line">[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).</div></pre></td></tr></table></figure></p>
<h3 id="解法1：-DFS-两次"><a href="#解法1：-DFS-两次" class="headerlink" title="解法1： DFS 两次"></a>解法1： DFS 两次</h3><p>也是反向思维。似乎要分别判断能flow到atlantic和pacific的cell。边界上的点是确定的，所以可以从这几个点开始。逆向思维–&gt;让水从边界开始往内陆”流”，只要海拔越来越高就可以。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!--￼<span class="number">1</span>--&gt;</div><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[323. Number of Connected Components in an Undirected Graph]]></title>
      <url>/2017/08/13/2017-08-13-323-Number-of-Connected-Components-in-an-Undirected-Graph/</url>
      <content type="html"><![CDATA[<p>Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0          3</div><div class="line">|          |</div><div class="line">1 --- 2    4</div></pre></td></tr></table></figure></p>
<p>Given n = 5 and edges = [[0, 1], [1, 2], [3, 4]], return 2.</p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0           4</div><div class="line">|           |</div><div class="line">1 --- 2 --- 3</div></pre></td></tr></table></figure></p>
<p>Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]], return 1.</p>
<p>Note:<br>You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.</p>
<h3 id="解法1：Union-Find"><a href="#解法1：Union-Find" class="headerlink" title="解法1：Union-Find"></a>解法1：Union-Find</h3><p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countComponents</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] root = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">            root[i] = i;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</div><div class="line">            <span class="keyword">int</span> root1 = find(root, edge[<span class="number">0</span>]);</div><div class="line">            <span class="keyword">int</span> root2 = find(root, edge[<span class="number">1</span>]);</div><div class="line">            <span class="keyword">if</span> (root1 != root2) &#123;</div><div class="line">                root[root1] = root2;</div><div class="line">                n--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> n;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] root, <span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (root[id] != id) &#123;</div><div class="line">            id = root[id];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> id;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法2：DFS"><a href="#解法2：DFS" class="headerlink" title="解法2：DFS"></a>解法2：DFS</h3><p>DFS统计visited的node的个数的一种办法是，维护visited的set，每次执行一次dfs，然后到下一个节点如果没有visit过就++count。最后count就是总的visited的分隔的group的个数。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countComponents</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (edges == <span class="keyword">null</span> || edges.length == <span class="number">0</span> || edges[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> n;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, List&lt;Integer&gt;&gt;();    <span class="comment">// store the edges</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</div><div class="line">            <span class="keyword">if</span> (!map.containsKey(edge[<span class="number">0</span>])) &#123;</div><div class="line">                map.put(edge[<span class="number">0</span>], <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</div><div class="line">            &#125;</div><div class="line">            map.get(edge[<span class="number">0</span>]).add(edge[<span class="number">1</span>]);</div><div class="line">            <span class="keyword">if</span> (!map.containsKey(edge[<span class="number">1</span>])) &#123;</div><div class="line">                map.put(edge[<span class="number">1</span>], <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</div><div class="line">            &#125;</div><div class="line">            map.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;Integer&gt;();  <span class="comment">// visited nodes</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (!visited.contains(i)) &#123;</div><div class="line">                count++;</div><div class="line">                dfs(visited, i, map);             </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Set&lt;Integer&gt; visited, <span class="keyword">int</span> current, Map&lt;Integer, List&lt;Integer&gt;&gt; map)</span> </span>&#123;</div><div class="line">        visited.add(current);   <span class="comment">// add to visited node list</span></div><div class="line">        <span class="keyword">if</span> (!map.containsKey(current)) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        List&lt;Integer&gt; list = map.get(current);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> node : list) &#123;</div><div class="line">            <span class="keyword">if</span> (!visited.contains(node)) &#123;</div><div class="line">                dfs(visited, node, map);            </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[439. Tenary Expression Parser]]></title>
      <url>/2017/08/13/2017-08-13-439-Tenary-Expression-Parser/</url>
      <content type="html"><![CDATA[<p>Given a string representing arbitrarily nested ternary expressions, calculate the result of the expression. You can always assume that the given expression is valid and only consists of digits 0-9, ?, :, T and F (T and F represent True and False respectively).</p>
<p>Note:</p>
<p>The length of the given string is ≤ 10000.<br>Each number will contain only one digit.<br>The conditional expressions group right-to-left (as usual in most languages).<br>The condition will always be either T or F. That is, the condition will never be a digit.<br>The result of the expression will always evaluate to either a digit 0-9, T or F.<br>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Input: &quot;T?2:3&quot;</div><div class="line"></div><div class="line">Output: &quot;2&quot;</div><div class="line"></div><div class="line">Explanation: If true, then result is 2; otherwise result is 3.</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Input: &quot;F?1:T?4:5&quot;</div><div class="line"></div><div class="line">Output: &quot;4&quot;</div><div class="line"></div><div class="line">Explanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:</div><div class="line"></div><div class="line">             &quot;(F ? 1 : (T ? 4 : 5))&quot;                   &quot;(F ? 1 : (T ? 4 : 5))&quot;</div><div class="line">          -&gt; &quot;(F ? 1 : 4)&quot;                 or       -&gt; &quot;(T ? 4 : 5)&quot;</div><div class="line">          -&gt; &quot;4&quot;                                    -&gt; &quot;4&quot;</div></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Input: &quot;T?T?F:5:3&quot;</div><div class="line"></div><div class="line">Output: &quot;F&quot;</div><div class="line"></div><div class="line">Explanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:</div><div class="line"></div><div class="line">             &quot;(T ? (T ? F : 5) : 3)&quot;                   &quot;(T ? (T ? F : 5) : 3)&quot;</div><div class="line">          -&gt; &quot;(T ? F : 3)&quot;                 or       -&gt; &quot;(T ? F : 5)&quot;</div><div class="line">          -&gt; &quot;F&quot;                                    -&gt; &quot;F&quot;</div></pre></td></tr></table></figure></p>
<h3 id="解法1：-Stack"><a href="#解法1：-Stack" class="headerlink" title="解法1： Stack"></a>解法1： Stack</h3><p>打破传统思维，从后往前扫描放入stack<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">parseTernary</span><span class="params">(String expression)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (expression == <span class="keyword">null</span> || expression.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = expression.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">char</span> current = expression.charAt(i);</div><div class="line">            <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; stack.peek() == <span class="string">'?'</span>) &#123;</div><div class="line">                stack.pop();    <span class="comment">// get ride of ?</span></div><div class="line">                <span class="keyword">char</span> left = stack.pop();</div><div class="line">                stack.pop();</div><div class="line">                <span class="keyword">char</span> right = stack.pop();</div><div class="line">                <span class="keyword">if</span> (current == <span class="string">'T'</span>) &#123;</div><div class="line">                    stack.push(left);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    stack.push(right);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                stack.push(current);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> String.valueOf(stack.peek());</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[473. Matchsticks to Square]]></title>
      <url>/2017/08/13/2017-08-13-473-Matchsticks-to-Square/</url>
      <content type="html"><![CDATA[<p>Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.</p>
<p>Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.</p>
<p>Example 1:<br>Input: [1,1,2,2,2]<br>Output: true</p>
<p>Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.<br>Example 2:<br>Input: [3,3,3,3,4]<br>Output: false</p>
<p>Explanation: You cannot find a way to form a square with all the matchsticks.<br>Note:<br>The length sum of the given matchsticks is in the range of 0 to 10^9.<br>The length of the given matchstick array will not exceed 15.</p>
<h3 id="解法1：DFS"><a href="#解法1：DFS" class="headerlink" title="解法1：DFS"></a>解法1：DFS</h3><p>首先，如果能摆成正方形，正方形的边长是确定的。也就是所有的数加起来/4。然后就是运行一个DFS。核心思想是，用一个数组代表每一个边长，然后尝试不同的组合，终结条件是每条边长都是target。<br>这里有一个优化是需要先对所有火柴递减排列：原因是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Sorting the input array DESC will make the DFS process run much faster. Reason behind this is we always try to put the next matchstick in the first subset. If there is no solution, trying a longer matchstick first will get to negative conclusion earlier. Following is the updated code. Runtime is improved from more than 1000ms to around 40ms. A big improvement.</div></pre></td></tr></table></figure></p>
<p>也就是说，如果一个组合不能成功拼成正方形的话，先用长的可以更快的得到false的结论，而不用多循环好多次来得到这个结论。这样运行速度就加快了。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">makesquare</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">4</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</div><div class="line">            sum += num;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (sum % <span class="number">4</span> != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> target = sum / <span class="number">4</span>;   <span class="comment">// this is the length of square</span></div><div class="line"></div><div class="line">        Arrays.sort(nums);  <span class="comment">// sort the nums descending</span></div><div class="line">        reverse(nums);</div><div class="line">        <span class="keyword">int</span>[] sides = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</div><div class="line"></div><div class="line">        <span class="keyword">return</span> dfs(sides, nums, <span class="number">0</span>, target);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</div><div class="line">            <span class="keyword">int</span> temp = nums[i];</div><div class="line">            nums[i] = nums[j];</div><div class="line">            nums[j] = temp;</div><div class="line">            i++;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] sides, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> pos, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (pos == nums.length) &#123;</div><div class="line">            <span class="keyword">if</span> (sides[<span class="number">0</span>] == target &amp;&amp; sides[<span class="number">1</span>] == target &amp;&amp; sides[<span class="number">2</span>] == target) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (sides[i] + nums[pos] &gt; target) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            sides[i] += nums[pos];</div><div class="line">            <span class="keyword">boolean</span> temp = dfs(sides, nums, pos + <span class="number">1</span>, target);</div><div class="line">            <span class="keyword">if</span> (temp) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            sides[i] -= nums[pos];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[356. Line Reflection]]></title>
      <url>/2017/08/13/2017-08-13-356-Line-Reflection/</url>
      <content type="html"><![CDATA[<p>Given n points on a 2D plane, find if there is such a line parallel to y-axis that reflect the given points.</p>
<p>Example 1:<br>Given points = [[1,1],[-1,1]], return true.</p>
<p>Example 2:<br>Given points = [[1,1],[-1,-1]], return false.</p>
<p>Follow up:<br>Could you do better than O(n2)?</p>
<h3 id="解法1：O-N-Time-O-N-Space"><a href="#解法1：O-N-Time-O-N-Space" class="headerlink" title="解法1：O(N) Time + O(N) Space"></a>解法1：O(N) Time + O(N) Space</h3><p>这题的题意是对于N个给定的点，找一下是否存在一条平行与y轴的线，使得所有点都对称与此条线。<br>那么怎么确定这条平行的线是关键。<br>如果点都是对称存在的，那么最左面的点和最右面的点当中的线就是平行于y轴的对称线。所有其他的点都必须以此为基准。<br>用一个set存储每一个点，并且找出最左最右两个点。找出以后，对于每一个点，检查他的对称点是否在set中。<br>放入set的时候用到了Arrays.hashCode(int[])的function。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReflected</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (points == <span class="keyword">null</span> || points.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> xmin = Integer.MAX_VALUE, xmax = Integer.MIN_VALUE;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] point : points) &#123;</div><div class="line">            xmin = Math.min(xmin, point[<span class="number">0</span>]);</div><div class="line">            xmax = Math.max(xmax, point[<span class="number">0</span>]);</div><div class="line">            set.add(Arrays.hashCode(point));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> sum = xmin + xmax;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] point : points) &#123;</div><div class="line">            <span class="keyword">if</span> (!set.contains(Arrays.hashCode(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; sum - point[<span class="number">0</span>], point[<span class="number">1</span>]&#125;))) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[525. Contiguous Array]]></title>
      <url>/2017/08/13/2017-08-13-525-Contiguous-Array/</url>
      <content type="html"><![CDATA[<p>Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input: [0,1]</div><div class="line">Output: 2</div><div class="line">Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input: [0,1,0]</div><div class="line">Output: 2</div><div class="line">Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.</div></pre></td></tr></table></figure></p>
<p>Note: The length of the given binary array will not exceed 50,000.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>很好的一题，用到了2sum = zero的特殊解法（用hashmap）， 也用到了变换条件使得题目变得更有利。<br>把0变成-1的话这题的条件就变成找一个continuous array使得加和为1并且最长。<br>加和为0很好办，看sum是否出现过，如果出现过，更新最长距离。要注意初始条件，第一个点是设成map.put(0, -1)<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</div><div class="line">                nums[i] = -<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</div><div class="line">        map.put(<span class="number">0</span>, -<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            sum += nums[i];</div><div class="line">            <span class="keyword">if</span> (map.containsKey(sum)) &#123;</div><div class="line">                <span class="comment">// prefix sum exists, meaning sum[i, j] = 0 =&gt; equal number of 1 and 0 (now -1)</span></div><div class="line">                max = Math.max(max, i - map.get(sum));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                map.put(sum, i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> max;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[554. Brick Wall]]></title>
      <url>/2017/08/13/2017-08-13-554-Brick-Wall/</url>
      <content type="html"><![CDATA[<p>There is a brick wall in front of you. The wall is rectangular and has several rows of bricks. The bricks have the same height but different width. You want to draw a vertical line from the top to the bottom and cross the least bricks.</p>
<p>The brick wall is represented by a list of rows. Each row is a list of integers representing the width of each brick in this row from left to right.</p>
<p>If your line go through the edge of a brick, then the brick is not considered as crossed. You need to find out how to draw the line to cross the least bricks and return the number of crossed bricks.</p>
<p>You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">[[1,2,2,1],</div><div class="line"> [3,1,2],</div><div class="line"> [1,3,2],</div><div class="line"> [2,4],</div><div class="line"> [3,1,2],</div><div class="line"> [1,3,1,1]]</div><div class="line">Output: 2</div><div class="line">Explanation:</div></pre></td></tr></table></figure></p>
<p><img src="https://leetcode.com/static/images/problemset/brick_wall.png" alt="picture "></p>
<p>Note:<br>The width sum of bricks in different rows are the same and won’t exceed INT_MAX.<br>The number of bricks in each row is in range [1,10,000]. The height of wall is in range [1,10,000]. Total number of bricks of the wall won’t exceed 20,000.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>自己想的很复杂，模模糊糊的有一个轮廓。<br>答案给的很brilliant， 就是说我们yaocut的位置一定是在砖块对齐最多的位置。这个位置是most common right position of bricks<br>要注意循环的时候是到size() - 1, 为的是避免右面的边界。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[645. Set Mismatch]]></title>
      <url>/2017/08/13/2017-08-13-645-Set-Mismatch/</url>
      <content type="html"><![CDATA[<p>The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number.</p>
<p>Given an array nums representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: nums = [1,2,2,4]</div><div class="line">Output: [2,3]</div></pre></td></tr></table></figure></p>
<p>Note:<br>The given array size will in the range [2, 10000].<br>The given array’s numbers won’t have any order.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findErrorNums(<span class="keyword">int</span>[] nums) &#123;</div><div class="line"></div><div class="line"></div><div class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</div><div class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span> (map.get(num) &gt; <span class="number">1</span>) &#123;</div><div class="line">                res[<span class="number">0</span>] = num;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (!map.containsKey(i)) &#123;</div><div class="line">                res[<span class="number">1</span>] = i;</div><div class="line">                <span class="keyword">return</span> res;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[347. Top K Frequent Elements]]></title>
      <url>/2017/08/13/2017-08-13-347-Top-K-Frequent-Elements/</url>
      <content type="html"><![CDATA[<p>Given a non-empty array of integers, return the k most frequent elements.</p>
<p>For example,<br>Given [1,1,1,2,2,3] and k = 2, return [1,2].</p>
<p>Note:<br>You may assume k is always valid, 1 ? k ? number of unique elements.<br>Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size.</p>
<h3 id="解法1：-heap"><a href="#解法1：-heap" class="headerlink" title="解法1： heap"></a>解法1： heap</h3><p>比较直接的写法就是用heap，不过还有一种bucket sort的办法似乎更快，可以做到O(N)<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br>有一个Java8的compare写法可以掌握一下(a,b) -&gt; a.getValue() - b.getValue()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// map with keySet</span></div><div class="line">        <span class="comment">// [1,1,1,2,2,3]</span></div><div class="line"></div><div class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</div><div class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Put each elements into priorityqueue</span></div><div class="line"></div><div class="line"></div><div class="line">        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b) -&gt; a.getValue() - b.getValue());</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</div><div class="line">            queue.offer(entry);</div><div class="line">            <span class="keyword">if</span> (queue.size() &gt; k) &#123;</div><div class="line">                queue.poll();   <span class="comment">// poll the smallest entry based on the frequency</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</div><div class="line">            res.add(queue.poll().getKey());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[166. Fraction to Recurring Decimal]]></title>
      <url>/2017/08/13/2017-08-13-166-Fraction-to-Recurring-Decimal/</url>
      <content type="html"><![CDATA[<p>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.</p>
<p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>
<p>For example,</p>
<p>Given numerator = 1, denominator = 2, return “0.5”.<br>Given numerator = 2, denominator = 1, return “2”.<br>Given numerator = 2, denominator = 3, return “0.(6)”.<br>Credits:</p>
<h3 id="解法1：HashMap"><a href="#解法1：HashMap" class="headerlink" title="解法1：HashMap"></a>解法1：HashMap</h3><p>能写成分数的一定是有理数，有理数一定是有限的或者是无限循环小数。<br>先计算整数部分，然后看余数是否为0。如果不是零，那么把每一个数放入map中，记录他们出现的位置。然后乘以10再取余，</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (numerator == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        sb.append(((numerator &gt; <span class="number">0</span>) ^ (denominator &gt; <span class="number">0</span>)) ? <span class="string">"-"</span> : <span class="string">""</span>);</div><div class="line"></div><div class="line">        <span class="keyword">long</span> num = Math.abs((<span class="keyword">long</span>)numerator);</div><div class="line">        <span class="keyword">long</span> den = Math.abs((<span class="keyword">long</span>)denominator);</div><div class="line"></div><div class="line">        <span class="comment">// Get integral part</span></div><div class="line">        sb.append(num / den);</div><div class="line">        num %= den;</div><div class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> sb.toString();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// process fraction</span></div><div class="line">        Map&lt;Long, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Long, Integer&gt;();    <span class="comment">// Record the position that each digit exist</span></div><div class="line"></div><div class="line">        sb.append(<span class="string">"."</span>);</div><div class="line">        map.put(num, sb.length());</div><div class="line">        <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</div><div class="line">            num *= <span class="number">10</span>;</div><div class="line">            sb.append(num / den);</div><div class="line">            num %= den;</div><div class="line">            <span class="keyword">if</span> (map.containsKey(num)) &#123;</div><div class="line">                <span class="keyword">int</span> index = map.get(num);</div><div class="line">                sb.insert(index, <span class="string">"("</span>);</div><div class="line">                sb.append(<span class="string">")"</span>);</div><div class="line">                <span class="keyword">break</span>;  <span class="comment">// end the search</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                map.put(num, sb.length());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[325. Maximum Size Subarray Sum Eqauls K]]></title>
      <url>/2017/08/13/2017-08-13-325-Maximum-Size-Subarray-Sum-Eqauls-K/</url>
      <content type="html"><![CDATA[<p>Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn’t one, return 0 instead.</p>
<p>Note:<br>The sum of the entire nums array is guaranteed to fit within the 32-bit signed integer range.</p>
<p>Example 1:<br>Given nums = [1, -1, 5, -2, 3], k = 3,<br>return 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longest)</p>
<p>Example 2:<br>Given nums = [-2, -1, 2, 1], k = 1,<br>return 2. (because the subarray [-1, 2] sums to 1 and is the longest)</p>
<p>Follow Up:<br>Can you do it in O(n) time?</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>用prefix sum数组解决， 用一个map记录每一个accumulate sum对应的位置。然后线性扫描一遍加和数组，对于没有见过的数直接加入map，对于见过的就可以判断是否存在dp[i] - k, 注意。这题没有说是否有duplicate，实际是可能的，而我们push进map的都是第一次出现的位置，这样保证了如果找到一个解，一定是最长的一个subarray。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArrayLen</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">            dp[i] = dp[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</div><div class="line">        map.put(<span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// don't forget to put this into hashmap</span></div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">            <span class="keyword">int</span> remain = dp[i] - k;</div><div class="line">            <span class="keyword">if</span> (map.containsKey(remain)) &#123;</div><div class="line">                max = Math.max(max, i - map.get(remain));</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (!map.containsKey(dp[i])) &#123;</div><div class="line">                map.put(dp[i], i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[244. Shortest Word Distance II]]></title>
      <url>/2017/08/13/2017-08-13-244-Shortest-Word-Distance-II/</url>
      <content type="html"><![CDATA[<p>This is a follow up of Shortest Word Distance. The only difference is now you are given the list of words and your method will be called repeatedly many times with different parameters. How would you optimize it?</p>
<p>Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list.</p>
<p>For example,<br>Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”].</p>
<p>Given word1 = “coding”, word2 = “practice”, return 3.<br>Given word1 = “makes”, word2 = “coding”, return 1.</p>
<p>Note:<br>You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>先用hashmap没有疑问，之后在map中寻找最近的一对pair的时候可以用O(m+n)的复杂度解决，诀窍就是two pointers<br>按照大小顺序移动两个pointer</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordDistance</span> </span>&#123;</div><div class="line"></div><div class="line">    HashMap&lt;String, List&lt;Integer&gt;&gt; map = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordDistance</span><span class="params">(String[] words)</span> </span>&#123;</div><div class="line">        map = <span class="keyword">new</span> HashMap&lt;String, List&lt;Integer&gt;&gt;();   </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</div><div class="line">            String word = words[i];</div><div class="line">            <span class="keyword">if</span> (!map.containsKey(word)) &#123;</div><div class="line">                map.put(word, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</div><div class="line">            &#125;</div><div class="line">            map.get(word).add(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortest</span><span class="params">(String word1, String word2)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; index1 = map.get(word1);</div><div class="line">        List&lt;Integer&gt; index2 = map.get(word2);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt; index1.size() &amp;&amp; j &lt; index2.size()) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> ii = index1.get(i);</div><div class="line">            <span class="keyword">int</span> jj = index2.get(j);</div><div class="line"></div><div class="line">            res = Math.min(res, Math.abs(jj - ii));</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (ii &lt; jj) &#123;</div><div class="line">                i++;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Your WordDistance object will be instantiated and called as such:</span></div><div class="line"><span class="comment"> * WordDistance obj = new WordDistance(words);</span></div><div class="line"><span class="comment"> * int param_1 = obj.shortest(word1,word2);</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[314. Binary Tree Vertical Order Traversal]]></title>
      <url>/2017/08/13/2017-08-13-314-Binary-Tree-Vertical-Order-Traversal/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, return the vertical order traversal of its nodes’ values. (ie, from top to bottom, column by column).</p>
<p>If two nodes are in the same row and column, the order should be from left to right.</p>
<p>Examples:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Given binary tree [3,9,20,null,null,15,7],</div><div class="line">   3</div><div class="line">  /\</div><div class="line"> /  \</div><div class="line"> 9  20</div><div class="line">    /\</div><div class="line">   /  \</div><div class="line">  15   7</div></pre></td></tr></table></figure></p>
<p>return its vertical order traversal as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [9],</div><div class="line">  [3,15],</div><div class="line">  [20],</div><div class="line">  [7]</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>Given binary tree [3,9,8,4,0,1,7],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    3</div><div class="line">   /\</div><div class="line">  /  \</div><div class="line">  9   8</div><div class="line"> /\  /\</div><div class="line">/  \/  \</div><div class="line">4  01   7</div></pre></td></tr></table></figure></p>
<p>return its vertical order traversal as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [4],</div><div class="line">  [9],</div><div class="line">  [3,0,1],</div><div class="line">  [8],</div><div class="line">  [7]</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>Given binary tree [3,9,8,4,0,1,7,null,null,null,2,5] (0’s right child is 2 and 1’s left child is 5),<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">    3</div><div class="line">   /\</div><div class="line">  /  \</div><div class="line">  9   8</div><div class="line"> /\  /\</div><div class="line">/  \/  \</div><div class="line">4  01   7</div><div class="line">   /\</div><div class="line">  /  \</div><div class="line">  5   2</div></pre></td></tr></table></figure></p>
<p>return its vertical order traversal as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [4],</div><div class="line">  [9,5],</div><div class="line">  [3,0,1],</div><div class="line">  [8,2],</div><div class="line">  [7]</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>一种BFS的增强用法<br>在每次push一个node到一个queue的同时，维护另外一个queue，记录相对应的node的信息<br>用一个hashmap记录每一个col对应的答案。<br>然后min，max记录col的范围，之后把map里的数字再按顺序读取就可以了<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; verticalOrder(TreeNode root) &#123;</div><div class="line"></div><div class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();  <span class="comment">// record each column's result</span></div><div class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;(); <span class="comment">// used for bfs search</span></div><div class="line">        Queue&lt;Integer&gt; column = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();  <span class="comment">// used for bfs search, update each node's column number</span></div><div class="line"></div><div class="line">        queue.offer(root);</div><div class="line">        column.offer(<span class="number">0</span>);</div><div class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</div><div class="line">            TreeNode current = queue.poll();</div><div class="line">            <span class="keyword">int</span> col = column.poll();</div><div class="line"></div><div class="line">            min = Math.min(col, min);</div><div class="line">            max = Math.max(col, max);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!map.containsKey(col)) &#123;</div><div class="line">                map.put(col, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            map.get(col).add(current.val);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (current.left != <span class="keyword">null</span>) &#123;</div><div class="line">                queue.offer(current.left);</div><div class="line">                column.offer(col - <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (current.right != <span class="keyword">null</span>) &#123;</div><div class="line">                queue.offer(current.right);</div><div class="line">                column.offer(col + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = min; i &lt;= max; i++) &#123;</div><div class="line">            res.add(map.get(i));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[50. Pow(x,n)]]></title>
      <url>/2017/08/13/2017-08-13-50-Pow-x-n/</url>
      <content type="html"><![CDATA[<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>很简洁的一个写法，用了divide&amp;conquer的思想<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">double</span> temp = myPow(x, n / <span class="number">2</span>);</div><div class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> temp * temp;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">return</span> temp * temp * x;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> temp * temp / x;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[454. 4Sum II]]></title>
      <url>/2017/08/13/2017-08-13-454-4Sum-II/</url>
      <content type="html"><![CDATA[<p>Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.</p>
<p>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">A = [ 1, 2]</div><div class="line">B = [-2,-1]</div><div class="line">C = [-1, 2]</div><div class="line">D = [ 0, 2]</div><div class="line"></div><div class="line">Output:</div><div class="line">2</div><div class="line"></div><div class="line">Explanation:</div><div class="line">The two tuples are:</div><div class="line">1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</div><div class="line">2. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</div></pre></td></tr></table></figure></p>
<h3 id="解法1-O-N-2"><a href="#解法1-O-N-2" class="headerlink" title="解法1: O(N^2)"></a>解法1: O(N^2)</h3><p>就是two sum的解法<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// N^3logN</span></div><div class="line">        <span class="keyword">if</span> (A.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> n = A.length;</div><div class="line">        <span class="comment">// O(N^2)</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</div><div class="line">                <span class="keyword">int</span> sum = A[i] + B[j];</div><div class="line">                map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</div><div class="line">                <span class="keyword">int</span> sum = C[i] + D[j];</div><div class="line">                <span class="keyword">if</span> (map.containsKey(<span class="number">0</span> - sum)) &#123;</div><div class="line">                    count += map.get(<span class="number">0</span> - sum);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[275. H-Index II]]></title>
      <url>/2017/08/13/2017-08-13-275-H-Index-II/</url>
      <content type="html"><![CDATA[<p>Follow up for H-Index: What if the citations array is sorted in ascending order? Could you optimize your algorithm?</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (citations == <span class="keyword">null</span> || citations.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> end = citations.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> n = citations.length;</div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end) &#123;</div><div class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> (citations[mid] &gt;= n - mid) &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (citations[start] &gt;= n - start) &#123;</div><div class="line">            <span class="keyword">return</span> n - start;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (citations[end] &gt;= n - end) &#123;</div><div class="line">            <span class="keyword">return</span> n - end;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> n - end - <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[378. Kth Smallest Element in a Sorted Matrix]]></title>
      <url>/2017/08/13/2017-08-13-378-Kth-Smallest-Element-in-a-Sorted-Matrix/</url>
      <content type="html"><![CDATA[<p>Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p>
<p>Note that it is the kth smallest element in the sorted order, not the kth distinct element.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">matrix = [</div><div class="line">   [ 1,  5,  9],</div><div class="line">   [10, 11, 13],</div><div class="line">   [12, 13, 15]</div><div class="line">],</div><div class="line">k = 8,</div><div class="line"></div><div class="line">return 13.</div></pre></td></tr></table></figure></p>
<p>Note:<br>You may assume k is always valid, 1 ? k ? n2.</p>
<h3 id="解法1：Heap"><a href="#解法1：Heap" class="headerlink" title="解法1：Heap"></a>解法1：Heap</h3><p>用heap的思想，先把第一排或者第一列放入queue中，然后操作k-1次，每一次拿出一个元素，并且把他下面一行的元素也推入queue中。最后在堆顶的就是所求的答案。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        PriorityQueue&lt;Tuple&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Tuple&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Tuple left, Tuple right)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> left.val - right.val;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> row = matrix.length;</div><div class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</div><div class="line">            queue.offer(<span class="keyword">new</span> Tuple(<span class="number">0</span>, j, matrix[<span class="number">0</span>][j]));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; k - <span class="number">1</span> ; count++) &#123;</div><div class="line">            Tuple temp = queue.poll();</div><div class="line">            <span class="keyword">if</span> (temp.x == row - <span class="number">1</span>) <span class="keyword">continue</span>;</div><div class="line">            queue.offer(<span class="keyword">new</span> Tuple(temp.x + <span class="number">1</span>, temp.y, matrix[temp.x + <span class="number">1</span>][temp.y]));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> queue.poll().val;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Tuple</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> x;</div><div class="line">        <span class="keyword">int</span> y;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Tuple</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.x = x;</div><div class="line">            <span class="keyword">this</span>.y = y;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="解法2：Range-version-of-Binary-Search-Time-Complexity-O-NlogM"><a href="#解法2：Range-version-of-Binary-Search-Time-Complexity-O-NlogM" class="headerlink" title="解法2：Range version of Binary Search, Time Complexity O(NlogM)"></a>解法2：Range version of Binary Search, Time Complexity O(NlogM)</h3><p>先确定最小值和最大值，知道了范围以后。找出中间点，然后统计有多少数小于他的值，如果总数小于k那么知道k个数一定在右半边。以此类推<br>O(NlogM): N是行数，M是search range = max - min<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> n = matrix.length;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> low = matrix[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> high = matrix[n - <span class="number">1</span>][n - <span class="number">1</span>] + <span class="number">1</span>;   <span class="comment">// [low, high)</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</div><div class="line">            <span class="keyword">int</span> mid = low + (high - low ) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">int</span> count = <span class="number">0</span>, j = matrix[<span class="number">0</span>].length - <span class="number">1</span>; <span class="comment">// seach from the end of the column</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</div><div class="line">                <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; matrix[i][j] &gt; mid) j--;</div><div class="line">                count += (j + <span class="number">1</span>);   <span class="comment">// calcualte in this row, how many elements are smaller than mid</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (count &lt; k) &#123;</div><div class="line">                low = mid + <span class="number">1</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                high = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> low;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[436. Find Right Interval]]></title>
      <url>/2017/07/23/2017-07-23-436-Find-Right-Interval/</url>
      <content type="html"><![CDATA[<p>Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the “right” of i.</p>
<p>For any interval i, you need to store the minimum interval j’s index, which means that the interval j has the minimum start point to build the “right” relationship for interval i. If the interval j doesn’t exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.</p>
<p>Note:</p>
<p>   You may assume the interval’s end point is always bigger than its start point.<br>   You may assume none of these intervals have the same start point.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Input: [ [1,2] ]</div><div class="line"></div><div class="line">Output: [-1]</div><div class="line"></div><div class="line">Explanation: There is only one interval in the collection, so it outputs -1.</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Input: [ [3,4], [2,3], [1,2] ]</div><div class="line"></div><div class="line">Output: [-1, 0, 1]</div><div class="line"></div><div class="line">Explanation: There is no satisfied &quot;right&quot; interval for [3,4].</div><div class="line">For [2,3], the interval [3,4] has minimum-&quot;right&quot; start point;</div><div class="line">For [1,2], the interval [2,3] has minimum-&quot;right&quot; start point.</div></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Input: [ [1,4], [2,3], [3,4] ]</div><div class="line"></div><div class="line">Output: [-1, 2, -1]</div><div class="line"></div><div class="line">Explanation: There is no satisfied &quot;right&quot; interval for [1,4] and [3,4].</div><div class="line">For [2,3], the interval [3,4] has minimum-&quot;right&quot; start point.</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>这里遇到了一种binarysearch的用法，题目要求需要返回原始的index，而又有点像binarysearch<br>可以先用hashmap记录每一个当前的index，再对数组进行排序<br>排好序之后得到结果了再取map中找寻原始的index。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for an interval.</span></div><div class="line"><span class="comment"> * public class Interval &#123;</span></div><div class="line"><span class="comment"> *     int start;</span></div><div class="line"><span class="comment"> *     int end;</span></div><div class="line"><span class="comment"> *     Interval() &#123; start = 0; end = 0; &#125;</span></div><div class="line"><span class="comment"> *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findRightInterval(Interval[] intervals) &#123;</div><div class="line"></div><div class="line">        HashMap&lt;Integer, Integer&gt; startMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</div><div class="line"></div><div class="line">        List&lt;Integer&gt; starts = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</div><div class="line">            startMap.put(intervals[i].start, i);</div><div class="line">            starts.add(intervals[i].start);</div><div class="line">        &#125;        </div><div class="line"></div><div class="line">        Collections.sort(starts);   <span class="comment">// sort the array of start</span></div><div class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[starts.size()];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</div><div class="line">            <span class="keyword">int</span> end = intervals[i].end;</div><div class="line">            <span class="keyword">int</span> temp = binarySearch(starts, end);</div><div class="line">            <span class="keyword">if</span> (temp == -<span class="number">1</span>) &#123;</div><div class="line">                res[i] = -<span class="number">1</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                res[i] = startMap.get(starts.get(temp));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="comment">// find first that is larger than end</span></div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = list.size() - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end) &#123;</div><div class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> (list.get(mid) &lt; target) &#123;</div><div class="line">                start = mid;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (list.get(start) &gt;= target) &#123;</div><div class="line">            <span class="keyword">return</span> start;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (list.get(end) &gt;= target) &#123;</div><div class="line">            <span class="keyword">return</span> end;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// didn't find a start that is larger than target</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[H-Index]]></title>
      <url>/2017/07/23/2017-07-23-274-H-Index/</url>
      <content type="html"><![CDATA[<p>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p>
<p>According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.”</p>
<p>For example, given citations = [3, 0, 6, 1, 5], which means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, his h-index is 3.</p>
<p>Note: If there are several possible values for h, the maximum one is taken as the h-index.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>要注意h的范围是在[0, N]之间。<br>只需要用一个array记录每一个数字出现的次数，对于数字大于等于N的记录在N<br>最后从后往前，累加所有的次数，当count &gt;= i的时候说明就是我们要求的h-index<br><a href="https://discuss.leetcode.com/topic/40765/java-bucket-sort-o-n-solution-with-detail-explanation/2" target="_blank" rel="external">https://discuss.leetcode.com/topic/40765/java-bucket-sort-o-n-solution-with-detail-explanation/2</a><br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (citations == <span class="keyword">null</span> || citations.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Arrays.sort(citations);</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; citations.length; i++) &#123;</div><div class="line">            <span class="keyword">int</span> curr = Math.min(citations[i], citations.length - i);    <span class="comment">// [1,4,5]</span></div><div class="line">            max = Math.max(max, curr);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[311. Sparse Matrix Multiplication]]></title>
      <url>/2017/07/23/2017-07-23-311-Sparse-Matrix-Multiplication/</url>
      <content type="html"><![CDATA[<p>Given two sparse matrices A and B, return the result of AB.</p>
<p>You may assume that A’s column number is equal to B’s row number.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">A = [</div><div class="line">  [ 1, 0, 0],</div><div class="line">  [-1, 0, 3]</div><div class="line">]</div><div class="line"></div><div class="line">B = [</div><div class="line">  [ 7, 0, 0 ],</div><div class="line">  [ 0, 0, 0 ],</div><div class="line">  [ 0, 0, 1 ]</div><div class="line">]</div><div class="line"></div><div class="line"></div><div class="line">     |  1 0 0 |   | 7 0 0 |   |  7 0 0 |</div><div class="line">AB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |</div><div class="line">                  | 0 0 1 |</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>只要存下非0的数即可，然后遍历每一对非0的pair，看是否col=row，然后加和到对应的单元格里。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] multiply(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> row_a = A.length;</div><div class="line">        <span class="keyword">int</span> col_a = A[<span class="number">0</span>].length;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> row_b = B.length;</div><div class="line">        <span class="keyword">int</span> col_b = B[<span class="number">0</span>].length;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[row_a][col_b];    <span class="comment">// store the result</span></div><div class="line"></div><div class="line">        <span class="comment">// res[i][j] = sum (A[i][k] .* B[k][j]) ...</span></div><div class="line">        HashMap&lt;Integer, Integer&gt; a = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</div><div class="line">        HashMap&lt;Integer, Integer&gt; b = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row_a; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col_a; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (A[i][j] != <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">int</span> index = i*col_a + j;</div><div class="line">                    a.put(index, A[i][j]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row_b; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col_b; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (B[i][j] != <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">int</span> index = i*col_b + j;</div><div class="line">                    b.put(index, B[i][j]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index_a : a.keySet()) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index_b : b.keySet()) &#123;</div><div class="line">                <span class="keyword">if</span> (index_a % col_a == index_b / col_b) &#123;</div><div class="line">                    res[index_a / col_a][index_b % col_b] += a.get(index_a) * b.get(index_b);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[288. Unique Word Abbreviation]]></title>
      <url>/2017/07/23/2017-07-23-288-Unique-Word-Abbreviation/</url>
      <content type="html"><![CDATA[<p>An abbreviation of a word follows the form <first letter=""><number><last letter="">. Below are some examples of word abbreviations:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">a) it                      --&gt; it    (no abbreviation)</div><div class="line"></div><div class="line">     1</div><div class="line">b) d|o|g                   --&gt; d1g</div><div class="line"></div><div class="line">              1    1  1</div><div class="line">     1---5----0----5--8</div><div class="line">c) i|nternationalizatio|n  --&gt; i18n</div><div class="line"></div><div class="line">              1</div><div class="line">     1---5----0</div><div class="line">d) l|ocalizatio|n          --&gt; l10n</div></pre></td></tr></table></figure></last></number></first></p>
<p>Assume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary. A word’s abbreviation is unique if no other word from the dictionary has the same abbreviation.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Given dictionary = [ &quot;deer&quot;, &quot;door&quot;, &quot;cake&quot;, &quot;card&quot; ]</div><div class="line"></div><div class="line">isUnique(&quot;dear&quot;) -&gt;</div><div class="line">false</div><div class="line"></div><div class="line">isUnique(&quot;cart&quot;) -&gt;</div><div class="line">true</div><div class="line"></div><div class="line">isUnique(&quot;cane&quot;) -&gt;</div><div class="line">false</div><div class="line"></div><div class="line">isUnique(&quot;make&quot;) -&gt;</div><div class="line">true</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>莫名其妙的一题。。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidWordAbbr</span> </span>&#123;</div><div class="line"></div><div class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">null</span>;</div><div class="line">    HashMap&lt;String, Integer&gt; countMap = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ValidWordAbbr</span><span class="params">(String[] dictionary)</span> </span>&#123;</div><div class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        countMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (String str : dictionary) &#123;</div><div class="line">            String abbr = getAbbr(str);</div><div class="line">            map.put(abbr, map.getOrDefault(abbr, <span class="number">0</span>) + <span class="number">1</span>);</div><div class="line">            countMap.put(str, countMap.getOrDefault(str, <span class="number">0</span>) + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getAbbr</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (str.length() &lt;= <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> str;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> str.substring(<span class="number">0</span>, <span class="number">1</span>) + Integer.toString(str.length() - <span class="number">2</span>) + str.substring(str.length() - <span class="number">1</span>, str.length());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String word)</span> </span>&#123;</div><div class="line">        String key = getAbbr(word);</div><div class="line">        <span class="keyword">int</span> abbrCount = map.getOrDefault(key, <span class="number">0</span>);</div><div class="line">        <span class="keyword">int</span> count = countMap.getOrDefault(word, <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> abbrCount &lt;= count;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Your ValidWordAbbr object will be instantiated and called as such:</span></div><div class="line"><span class="comment"> * ValidWordAbbr obj = new ValidWordAbbr(dictionary);</span></div><div class="line"><span class="comment"> * boolean param_1 = obj.isUnique(word);</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[623. Add One Row to Tree]]></title>
      <url>/2017/07/23/2017-07-23-623-Add-One-Row-to-Tree/</url>
      <content type="html"><![CDATA[<p>Given the root of a binary tree, then value v and depth d, you need to add a row of nodes with value v at the given depth d. The root node is at depth 1.</p>
<p>The adding rule is: given a positive integer depth d, for each NOT null tree nodes N in depth d-1, create two tree nodes with value v as N’s left subtree root and right subtree root. And N’s original left subtree should be the left subtree of the new left subtree root, its original right subtree should be the right subtree of the new right subtree root. If depth d is 1 that means there is no depth d-1 at all, then create a tree node with value v as the new root of the whole original tree, and the original tree is the new root’s left subtree.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">A binary tree as following:</div><div class="line">       4</div><div class="line">     /   \</div><div class="line">    2     6</div><div class="line">   / \   /</div><div class="line">  3   1 5   </div><div class="line"></div><div class="line">v = 1</div><div class="line"></div><div class="line">d = 2</div><div class="line"></div><div class="line">Output:</div><div class="line">       4</div><div class="line">      / \</div><div class="line">     1   1</div><div class="line">    /     \</div><div class="line">   2       6</div><div class="line">  / \     /</div><div class="line"> 3   1   5</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">A binary tree as following:</div><div class="line">      4</div><div class="line">     /   </div><div class="line">    2    </div><div class="line">   / \   </div><div class="line">  3   1    </div><div class="line"></div><div class="line">v = 1</div><div class="line"></div><div class="line">d = 3</div><div class="line"></div><div class="line">Output:</div><div class="line">      4</div><div class="line">     /   </div><div class="line">    2</div><div class="line">   / \    </div><div class="line">  1   1</div><div class="line"> /     \  </div><div class="line">3       1</div></pre></td></tr></table></figure></p>
<p>Note:</p>
<pre><code>The given d is in range [1, maximum depth of the given tree + 1].
The given binary tree has at least one tree node.
</code></pre><h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>先用bfs找到要加的层的上一层。然后对每一个node加上新的node，然后把原来的left assign给left，rightassign给right<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">addOneRow</span><span class="params">(TreeNode root, <span class="keyword">int</span> v, <span class="keyword">int</span> d)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// do a level order traversal</span></div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (d == <span class="number">1</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(v);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> depth = <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (d == <span class="number">1</span>) &#123;</div><div class="line">            TreeNode root_new = <span class="keyword">new</span> TreeNode(v);</div><div class="line">            root_new.left = root;</div><div class="line">            <span class="keyword">return</span> root_new;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</div><div class="line">        queue.offer(root);</div><div class="line"></div><div class="line">        <span class="comment">// do level order traversal until reach the level right before depth</span></div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; depth &lt; d - <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">int</span> size = queue.size();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">                TreeNode current = queue.poll();</div><div class="line">                <span class="keyword">if</span> (current.left != <span class="keyword">null</span>) &#123;</div><div class="line">                    queue.offer(current.left);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (current.right != <span class="keyword">null</span>) &#123;</div><div class="line">                    queue.offer(current.right);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            depth++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// depth == d - 1</span></div><div class="line">        <span class="comment">// queue contains all the nodes that is point to depth</span></div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</div><div class="line">            TreeNode current = queue.poll();</div><div class="line">            TreeNode left = current.left;   <span class="comment">// original left</span></div><div class="line">            TreeNode right = current.right; <span class="comment">// original right</span></div><div class="line">            TreeNode left_new = <span class="keyword">new</span> TreeNode(v);    <span class="comment">// new left</span></div><div class="line">            TreeNode right_new = <span class="keyword">new</span> TreeNode(v);</div><div class="line">            current.left = left_new;</div><div class="line">            current.right = right_new;</div><div class="line">            left_new.left = left;</div><div class="line">            right_new.right = right;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> root;        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[582. Kill Process]]></title>
      <url>/2017/07/23/2017-07-23-582-Kill-Process/</url>
      <content type="html"><![CDATA[<p>Given n processes, each process has a unique PID (process id) and its PPID (parent process id).</p>
<p>Each process only has one parent process, but may have one or more children processes. This is just like a tree structure. Only one process has PPID that is 0, which means this process has no parent process. All the PIDs will be distinct positive integers.</p>
<p>We use two list of integers to represent a list of processes, where the first list contains PID for each process and the second list contains the corresponding PPID.</p>
<p>Now given the two lists, and a PID representing a process you want to kill, return a list of PIDs of processes that will be killed in the end. You should assume that when a process is killed, all its children processes will be killed. No order is required for the final answer.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">pid =  [1, 3, 10, 5]</div><div class="line">ppid = [3, 0, 5, 3]</div><div class="line">kill = 5</div><div class="line">Output: [5,10]</div><div class="line">Explanation:</div><div class="line">           3</div><div class="line">         /   \</div><div class="line">        1     5</div><div class="line">             /</div><div class="line">            10</div><div class="line">Kill 5 will also kill 10.</div></pre></td></tr></table></figure></p>
<p>Note:</p>
<pre><code>The given kill id is guaranteed to be one of the given PIDs.
n &gt;= 1.
</code></pre><h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>先把问题条件转化为一个图，然后对图做一个BFS就可以了。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">killProcess</span><span class="params">(List&lt;Integer&gt; pid, List&lt;Integer&gt; ppid, <span class="keyword">int</span> kill)</span> </span>&#123;</div><div class="line"></div><div class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        <span class="keyword">if</span> (pid == <span class="keyword">null</span> || ppid == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (pid.size() != ppid.size()) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Convert to a graph</span></div><div class="line">        HashMap&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, List&lt;Integer&gt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pid.size(); i++) &#123;</div><div class="line">            <span class="keyword">int</span> child  = pid.get(i);</div><div class="line">            <span class="keyword">int</span> parent = ppid.get(i);</div><div class="line">            <span class="keyword">if</span> (!map.containsKey(parent)) &#123;</div><div class="line">                List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">                temp.add(child);</div><div class="line">                map.put(parent, temp);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                map.get(parent).add(child);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// do a bfs on the graph to get all childs</span></div><div class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</div><div class="line">        queue.offer(kill);</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</div><div class="line">            <span class="keyword">int</span> size = queue.size();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">                <span class="keyword">int</span> id = queue.poll();</div><div class="line">                res.add(id);</div><div class="line">                List&lt;Integer&gt; children = map.get(id);</div><div class="line">                <span class="keyword">if</span> (children != <span class="keyword">null</span>) &#123; <span class="comment">// important! check if there exists children</span></div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> c : children) &#123;</div><div class="line">                        queue.offer(c);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[549. Binary Tree Longest Consecutive Sequence II]]></title>
      <url>/2017/07/23/2017-07-23-549-Binary-Tree-Longest-Consecutive-Sequence-II/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, you need to find the length of Longest Consecutive Path in Binary Tree.</p>
<p>Especially, this path can be either increasing or decreasing. For example, [1,2,3,4] and [4,3,2,1] are both considered valid, but the path [1,2,4,3] is not valid. On the other hand, the path can be in the child-Parent-child order, where not necessarily be parent-child order.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">        1</div><div class="line">       / \</div><div class="line">      2   3</div><div class="line">Output: 2</div><div class="line">Explanation: The longest consecutive path is [1, 2] or [2, 1].</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">        2</div><div class="line">       / \</div><div class="line">      1   3</div><div class="line">Output: 3</div><div class="line">Explanation: The longest consecutive path is [1, 2, 3] or [3, 2, 1].</div></pre></td></tr></table></figure></p>
<p>Note: All the values of tree nodes are in the range of [-1e7, 1e7].</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>要先想想思路<br>一个node，返回已他为起点的最长的decreasing和increasing<br>那通过root的最长的一个path一定是increase + decrease - 1, 减1是去掉一次root<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] temp = helper(root);</div><div class="line">        <span class="keyword">return</span> max;        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] helper(TreeNode root) &#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> increase = <span class="number">1</span>, decrease = <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">int</span>[] left = helper(root.left);</div><div class="line">            <span class="keyword">if</span> (root.val == root.left.val + <span class="number">1</span>) &#123;</div><div class="line">                decrease = left[<span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val == root.left.val -<span class="number">1</span>) &#123;</div><div class="line">                increase = left[<span class="number">0</span>] + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">int</span>[] right = helper(root.right);</div><div class="line">            <span class="keyword">if</span> (root.val == root.right.val + <span class="number">1</span>) &#123;</div><div class="line">                decrease = Math.max(decrease, right[<span class="number">1</span>] + <span class="number">1</span>);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val == root.right.val -<span class="number">1</span>) &#123;</div><div class="line">                increase = Math.max(increase, right[<span class="number">0</span>] + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        max = Math.max(max, decrease + increase -<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;increase, decrease&#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[333. Largest BST Subtree]]></title>
      <url>/2017/07/23/2017-07-23-333-Largest-BST-Subtree/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, find the largest subtree which is a Binary Search Tree (BST), where largest means subtree with largest number of nodes in it.</p>
<p>Note:<br>A subtree must include all of its descendants.<br>Here’s an example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   10</div><div class="line">   / \</div><div class="line">  5  15</div><div class="line"> / \   \</div><div class="line">1   8   7</div></pre></td></tr></table></figure></p>
<p>The Largest BST Subtree in this case is the highlighted one.<br>The return value is the subtree’s size, which is 3.</p>
<p>Follow up:<br>Can you figure out ways to solve it with O(n) time complexity?</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NodeInfo</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> isBST;</div><div class="line">        <span class="keyword">int</span> count;</div><div class="line">        <span class="keyword">int</span> max;</div><div class="line">        <span class="keyword">int</span> min;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NodeInfo</span> <span class="params">(<span class="keyword">boolean</span> isBST, <span class="keyword">int</span> count, <span class="keyword">int</span> max, <span class="keyword">int</span> min)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.isBST = isBST;</div><div class="line">            <span class="keyword">this</span>.count = count;</div><div class="line">            <span class="keyword">this</span>.max = max;</div><div class="line">            <span class="keyword">this</span>.min = min;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;   <span class="comment">// Store the final result</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestBSTSubtree</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        NodeInfo dummy = helper(root);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> NodeInfo <span class="title">helper</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NodeInfo(<span class="keyword">true</span>, <span class="number">0</span>, Integer.MIN_VALUE, Integer.MAX_VALUE);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        NodeInfo left = helper(root.left);</div><div class="line">        NodeInfo right = helper(root.right);</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> isBST = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span> (root.val &gt; left.max &amp;&amp; root.val &lt; right.min) &#123;</div><div class="line">            isBST = left.isBST &amp;&amp; right.isBST;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> count = left.count + right.count + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (isBST) &#123;</div><div class="line">            res = Math.max(res, count);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> max = Math.max(left.max, Math.max(right.max, root.val));</div><div class="line">        <span class="keyword">int</span> min = Math.min(left.min, Math.min(right.min, root.val));</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NodeInfo(isBST, count, max, min);        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[255. Verify Preorder Sequence in Binary Search Tree]]></title>
      <url>/2017/07/23/2017-07-23-255-Verify-Preorder-Sequence-in-Binary-Search-Tree/</url>
      <content type="html"><![CDATA[<p>Given an array of numbers, verify whether it is the correct preorder traversal sequence of a binary search tree.</p>
<p>You may assume each number in the sequence is unique.</p>
<p>Follow up:<br>Could you do it using only constant space complexity?</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>吃透了bst的性质就好做了：<br>第一个数字是root，之后找出所有比他大的和所有比他小的范围。<br>对large 和small分别做递归。<br>要注意如果left &gt; right return true<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPreorder</span><span class="params">(<span class="keyword">int</span>[] preorder)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (preorder == <span class="keyword">null</span> || preorder.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;   </div><div class="line"></div><div class="line">        <span class="keyword">return</span> helper(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (left == right) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// root is the first one</span></div><div class="line">        <span class="keyword">int</span> root = preorder[left];</div><div class="line"></div><div class="line">        <span class="comment">// check [left, right] find first index that is larger than root</span></div><div class="line">        <span class="keyword">int</span> i = left + <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (;i &lt;= right; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (preorder[i] &gt; root) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (i &gt; right) &#123;</div><div class="line">            <span class="keyword">return</span> helper(preorder, left + <span class="number">1</span>, right);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (i == right) &#123;</div><div class="line">            <span class="keyword">return</span> helper(preorder, left + <span class="number">1</span>, right - <span class="number">1</span>);   </div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// check if [i, right] has one element that is smaller than root</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= right; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (preorder[j] &lt; root) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> helper(preorder, left + <span class="number">1</span>, i - <span class="number">1</span>) &amp;&amp; helper(preorder, i, right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[298. Binary Tree Longest Consecutive Sequence]]></title>
      <url>/2017/07/23/2017-07-23-298-Binary-Tree-Longest-Consecutive-Sequence/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, find the length of the longest consecutive sequence path.</p>
<p>The path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive path need to be from parent to child (cannot be the reverse).</p>
<p>For example,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line"> \</div><div class="line">  3</div><div class="line"> / \</div><div class="line">2   4</div><div class="line">     \</div><div class="line">      5</div></pre></td></tr></table></figure></p>
<p>Longest consecutive sequence path is 3-4-5, so return 3.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  2</div><div class="line">   \</div><div class="line">    3</div><div class="line">   /</div><div class="line">  2    </div><div class="line"> /</div><div class="line">1</div></pre></td></tr></table></figure></p>
<p>Longest consecutive sequence path is 2-3,not3-2-1, so return 2.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>用一个全局变量来存储答案，然后递归遍历数就可以了。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        helper(root, <span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> max;        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            max = Math.max(max, count);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        max = Math.max(max, count);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (root.left.val == root.val + <span class="number">1</span>) &#123;</div><div class="line">                helper(root.left, count + <span class="number">1</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                helper(root.left, <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (root.right.val == root.val + <span class="number">1</span>) &#123;</div><div class="line">                helper(root.right, count + <span class="number">1</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                helper(root.right, <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[250. Count Univalue Subtrees]]></title>
      <url>/2017/07/23/2017-07-23-250-Count-Univalue-Subtrees/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, count the number of uni-value subtrees.</p>
<p>A Uni-value subtree means all nodes of the subtree have the same value.</p>
<p>For example:<br>Given binary tree,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    5</div><div class="line">   / \</div><div class="line">  1   5</div><div class="line"> / \   \</div><div class="line">5   5   5</div></pre></td></tr></table></figure></p>
<p>return 4.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>用Divide &amp; Conquer<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countUnivalSubtrees</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        helper(root);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">boolean</span> left = helper(root.left);</div><div class="line">        <span class="keyword">boolean</span> right = helper(root.right);</div><div class="line">        <span class="keyword">if</span> (left &amp;&amp; right) &#123;</div><div class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.left.val != root.val) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span> &amp;&amp; root.right.val != root.val) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            ++res;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;            </div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[285. Inorder Successor in BST]]></title>
      <url>/2017/07/23/2017-07-23-285-Inorder-Successor-in-BST/</url>
      <content type="html"><![CDATA[<p>Given a binary search tree and a node in it, find the in-order successor of that node in the BST.</p>
<p>Note: If the given node has no in-order successor in the tree, return null.</p>
<h3 id="解法1：-O-N-Space"><a href="#解法1：-O-N-Space" class="headerlink" title="解法1： O(N) Space"></a>解法1： O(N) Space</h3><p>最直观的方法，就是先做一遍in order, 存起来，然后找出来目标node前一个node即可。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">inorderSuccessor</span><span class="params">(TreeNode root, TreeNode p)</span> </span>&#123;</div><div class="line">        List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || p == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        helper(root, list);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</div><div class="line">            <span class="keyword">if</span> (list.get(i) == p) &#123;</div><div class="line">                <span class="keyword">if</span> (i == list.size() - <span class="number">1</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">return</span> list.get(i + <span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;TreeNode&gt; list)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        helper(root.left, list);</div><div class="line">        list.add(root);</div><div class="line">        helper(root.right, list);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法2：-O-1-Space"><a href="#解法2：-O-1-Space" class="headerlink" title="解法2： O(1) Space"></a>解法2： O(1) Space</h3><figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line"></div><div class="line">    TreeNode prev = null;</div><div class="line">    TreeNode res = null;</div><div class="line">    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) &#123;</div><div class="line"></div><div class="line">        if (root == null || p == null) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        helper(root, p);</div><div class="line"></div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void helper(TreeNode root, TreeNode p) &#123;</div><div class="line">        if (root == null) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        helper(root.left, p);</div><div class="line">        if (prev == p) &#123;</div><div class="line">            res = root;</div><div class="line">            prev = root;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        prev = root;</div><div class="line">        helper(root.right, p);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[312. Burst Balloons]]></title>
      <url>/2017/07/23/2017-07-23-312-Burst-Balloons/</url>
      <content type="html"><![CDATA[<p>Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] <em> nums[i] </em> nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent.</p>
<p>Find the maximum coins you can collect by bursting the balloons wisely.</p>
<p>Note:<br>(1) You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them.<br>(2) 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100</p>
<p>Example:</p>
<p>Given [3, 1, 5, 8]</p>
<p>Return 167<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> nums = [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []</div><div class="line">coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n]; <span class="comment">// record the largest coin for a burst between [i, j]</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; len++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt;= n - len; start++) &#123;</div><div class="line">                <span class="keyword">int</span> end = start + len - <span class="number">1</span>;</div><div class="line">                <span class="comment">// dp[start][end]</span></div><div class="line">                <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</div><div class="line">                    <span class="keyword">int</span> coins = <span class="number">0</span>;</div><div class="line">                    coins = nums[i] * (start == <span class="number">0</span> ? <span class="number">1</span> : nums[start - <span class="number">1</span>]) * (end == n - <span class="number">1</span> ? <span class="number">1</span> : nums[end + <span class="number">1</span>]);</div><div class="line">                    <span class="comment">// burst nums[i]</span></div><div class="line">                    <span class="keyword">if</span> (i != start) &#123;</div><div class="line">                        coins += dp[start][i - <span class="number">1</span>];</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (i != end) &#123;</div><div class="line">                        coins += dp[i + <span class="number">1</span>][end];</div><div class="line">                    &#125;</div><div class="line">                    max = Math.max(max, coins);</div><div class="line">                &#125;</div><div class="line">                dp[start][end] = max;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[376. Wiggle Subsequence]]></title>
      <url>/2017/07/23/2017-07-23-376-Wiggle-Subsequence/</url>
      <content type="html"><![CDATA[<p>A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.</p>
<p>For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.</p>
<p>Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.</p>
<p>Examples:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Input: [1,7,4,9,2,5]</div><div class="line">Output: 6</div><div class="line">The entire sequence is a wiggle sequence.</div><div class="line"></div><div class="line">Input: [1,17,5,10,13,15,10,5,16,8]</div><div class="line">Output: 7</div><div class="line">There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].</div><div class="line"></div><div class="line">Input: [1,2,3,4,5,6,7,8,9]</div><div class="line">Output: 2</div></pre></td></tr></table></figure></p>
<h3 id="解法1：两次dp"><a href="#解法1：两次dp" class="headerlink" title="解法1：两次dp"></a>解法1：两次dp</h3><p>两次dp的思想很巧妙，用up和down两个数组记录到当前位置，最后相邻的两个是up的最长wiggle sequence或者是最后相邻两个是down的最长wiggle sequence。<br>那么只要交替更新一下每一个dp array就可以了。<br>似乎这和minmax类的题目很类似， 比如Predict the winner，也是用两个相互影响的dp数组来完成。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> nums.length;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        <span class="keyword">int</span>[] up = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        <span class="keyword">int</span>[] down = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line"></div><div class="line">        up[<span class="number">0</span>] = <span class="number">1</span>; down[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</div><div class="line">                up[i] = down[i - <span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">                down[i] = down[i - <span class="number">1</span>];</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</div><div class="line">                down[i] = up[i - <span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">                up[i] = up[i - <span class="number">1</span>];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                up[i] = up[i - <span class="number">1</span>];</div><div class="line">                down[i] = down[i - <span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> Math.max(up[n - <span class="number">1</span>], down[n - <span class="number">1</span>]);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> MinMax </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[474. Ones and Zeros]]></title>
      <url>/2017/07/23/2017-07-23-474-Ones-and-Zeros/</url>
      <content type="html"><![CDATA[<p>In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.</p>
<p>For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.</p>
<p>Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.</p>
<p>Note:</p>
<pre><code>The given numbers of 0s and 1s will both not exceed 100
The size of given string array won&apos;t exceed 600.
</code></pre><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Input: Array = &#123;&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, m = 5, n = 3</div><div class="line">Output: 4</div><div class="line"></div><div class="line">Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Input: Array = &#123;&quot;10&quot;, &quot;0&quot;, &quot;1&quot;&#125;, m = 1, n = 1</div><div class="line">Output: 2</div><div class="line"></div><div class="line">Explanation: You could form &quot;10&quot;, but then you&apos;d have nothing left. Better form &quot;0&quot; and &quot;1&quot;.</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>这个的解释还算可以,来自于leetcode discuss:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">The idea is to build up the solution for 0..m zeros and 0..n ones, from only knowing 1 string, 2 strings, ..., up to n strings.</div><div class="line"></div><div class="line">For example, for array = &#123;&quot;10&quot;, &quot;0&quot;, &quot;1&quot;&#125;, m = 1, n = 1.</div><div class="line"></div><div class="line">    for first string &quot;10&quot;:</div><div class="line">        zero = 0, one = 0</div><div class="line">        zero = 1, one = 0</div><div class="line">        zero = 0, one = 1</div><div class="line">        zero = 1, one = 1, can form &quot;10&quot; [+1]</div><div class="line">    continue on the second string &quot;0&quot;, with previous knowledge of string &quot;10&quot;:</div><div class="line">        zero = 0, one = 0</div><div class="line">        zero = 1, one = 0, can form &quot;0&quot; [+1]</div><div class="line">        zero = 0, one = 1</div><div class="line">        zero = 1, one = 1, can form &quot;0&quot; [+1] or 1 string (&quot;10&quot;), known from previous string</div><div class="line">    continue on the last string &quot;1&quot;, with previous knowledge of strings &quot;10&quot; and &quot;0&quot;:</div><div class="line">        zero = 0, one = 0</div><div class="line">        zero = 1, one = 0, can&apos;t form &quot;1&quot;, but we know it can form 1 string (&quot;0&quot;) from previous set of strings</div><div class="line">        zero = 0, one = 1, can form &quot;1&quot; (+1)</div><div class="line">        zero = 1, one = 1, (can form &quot;1&quot; and 1 more string (&quot;0&quot;) with zero = 1, one = 0, known from previous set of strings) or (1 string (&quot;10&quot;), known from previous set of strings)</div><div class="line"></div><div class="line">Hence, at the end, we know that with zero = 1, one = 1, with string &quot;10&quot;, &quot;0&quot;, and &quot;1&quot;, the maximum number of strings we can form is 2.</div></pre></td></tr></table></figure></p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span> (String str : strs) &#123;</div><div class="line">            <span class="keyword">int</span>[] count = count(str);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= count[<span class="number">0</span>]; i--) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= count[<span class="number">1</span>]; j--) &#123;</div><div class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i - count[<span class="number">0</span>]][j - count[<span class="number">1</span>]] + <span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[m][n];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] count(String s) &#123;</div><div class="line">	<span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">	<span class="keyword">char</span>[] array = s.toCharArray();</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</div><div class="line">	    result[i - <span class="string">'0'</span>]++;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法2：-背包解法"><a href="#解法2：-背包解法" class="headerlink" title="解法2： 背包解法"></a>解法2： 背包解法</h3><p>此题实际上是一个背包问题，背包问题的本质是：<br>求一个最大或者最小，给定一定的限定条件。这里的限定条件是有限的0和1。<br>背包就构建一个n维数组，dp[i][j][k]表示前i个数，用jk两个限定条件所能达到的最大结果。</p>
<figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int findMaxForm(String[] strs, int m, int n) &#123;</div><div class="line"></div><div class="line">        if (strs == null || strs.length == 0) &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int strn = strs.length;</div><div class="line">        int[][][] dp = new int[strn + 1][m + 1][n + 1];</div><div class="line">        // dp[l][i][j] means up to first l strings, with m zeros and n ones, the max number of strings it can form</div><div class="line">        // do[l][i][j] = Math.max(dp[l - 1][i - zero[l]][j - zero[l][i - ones]] + 1, dp[l - 1][i][j]）；</div><div class="line"></div><div class="line">        for (int l = 1; l &lt;= strn; l++) &#123;</div><div class="line">            int[] current = count(strs[l - 1]);   // count current number of zeros and ones</div><div class="line">            for (int i = 0; i &lt;= m; i++) &#123;</div><div class="line">                for (int j = 0; j &lt;= n; j++) &#123;</div><div class="line">                    if (i &gt;= current[0] &amp;&amp; j &gt;= current[1]) &#123;</div><div class="line">                        dp[l][i][j] = Math.max(dp[l][i][j], dp[l - 1][i - current[0]][j - current[1]] + 1);</div><div class="line">                    &#125;</div><div class="line">                    dp[l][i][j] = Math.max(dp[l][i][j], dp[l - 1][i][j]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return dp[strn][m][n];</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    private int[] count(String str) &#123;</div><div class="line">        // count number of ones and zeros in the string</div><div class="line">        int[] res = new int[2];</div><div class="line">        for (int i = 0; i &lt; str.length(); i++) &#123;</div><div class="line">            if (str.charAt(i) == &apos;0&apos;) &#123;</div><div class="line">                res[0]++;</div><div class="line">            &#125; else &#123;</div><div class="line">                res[1]++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> 0-1 Knapsack </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[464. Can I Win]]></title>
      <url>/2017/07/23/2017-07-23-464-Can-I-Win/</url>
      <content type="html"><![CDATA[<p>In the “100 game,” two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins.</p>
<p>What if we change the game so that players cannot re-use integers?</p>
<p>For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total &gt;= 100.</p>
<p>Given an integer maxChoosableInteger and another integer desiredTotal, determine if the first player to move can force a win, assuming both players play optimally.</p>
<p>You can always assume that maxChoosableInteger will not be larger than 20 and desiredTotal will not be larger than 300.</p>
<p>Example<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">maxChoosableInteger = 10</div><div class="line">desiredTotal = 11</div><div class="line"></div><div class="line">Output:</div><div class="line">false</div><div class="line"></div><div class="line">Explanation:</div><div class="line">No matter which integer the first player choose, the first player will lose.</div><div class="line">The first player can choose an integer from 1 up to 10.</div><div class="line">If the first player choose 1, the second player can only choose integers from 2 up to 10.</div><div class="line">The second player will win by choosing 10 and get a total = 11, which is &gt;= desiredTotal.</div><div class="line">Same with other integers chosen by the first player, the second player will always win.</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>当dp不太好想的时候考虑用一下memorization来减少复杂度。<br>这题粗暴思路就是一个dfs，来判断对于一组数是否能win。<br>那么我们可以把当前数字使用情况转变成一个key来存储起来。<br>转成key的思路是把每一位数字如果没被用过变为0，用过了变为1.<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Boolean&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Boolean&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canIWin</span><span class="params">(<span class="keyword">int</span> maxChoosableInteger, <span class="keyword">int</span> desiredTotal)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> sum = (<span class="number">1</span> + maxChoosableInteger) * maxChoosableInteger / <span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span> (sum &lt; desiredTotal) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (maxChoosableInteger &gt;= desiredTotal) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[maxChoosableInteger + <span class="number">1</span>];</div><div class="line"></div><div class="line">        <span class="keyword">return</span> helper(used, desiredTotal, maxChoosableInteger);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">boolean</span>[] used, <span class="keyword">int</span> desiredTotal, <span class="keyword">int</span> max)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (desiredTotal &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> key = transform(used);</div><div class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</div><div class="line">            <span class="keyword">return</span> map.get(key);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (!used[i]) &#123;</div><div class="line">                used[i] = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">boolean</span> sub = helper(used, desiredTotal - i, max);</div><div class="line">                used[i] = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">if</span> (!sub) &#123;</div><div class="line">                    map.put(key, <span class="keyword">true</span>);</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        map.put(key, <span class="keyword">false</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">transform</span><span class="params">(<span class="keyword">boolean</span>[] used)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">boolean</span> i : used) &#123;</div><div class="line">            num &lt;&lt;= <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (i) &#123;</div><div class="line">                num |= <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> num;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[467. Unique Substrings in Wraparound String]]></title>
      <url>/2017/07/23/2017-07-23-467-Unique-Substrings-in-Wraparound-String/</url>
      <content type="html"><![CDATA[<p>Consider the string s to be the infinite wraparound string of “abcdefghijklmnopqrstuvwxyz”, so s will look like this: “…zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd….”.</p>
<p>Now we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s.</p>
<p>Note: p consists of only lowercase English letters and the size of p might be over 10000.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Input: &quot;a&quot;</div><div class="line">Output: 1</div><div class="line"></div><div class="line">Explanation: Only the substring &quot;a&quot; of string &quot;a&quot; is in the string s.</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input: &quot;cac&quot;</div><div class="line">Output: 2</div><div class="line">Explanation: There are two substrings &quot;a&quot;, &quot;c&quot; of string &quot;cac&quot; in the string s.</div></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input: &quot;zab&quot;</div><div class="line">Output: 6</div><div class="line">Explanation: There are six substrings &quot;z&quot;, &quot;a&quot;, &quot;b&quot;, &quot;za&quot;, &quot;ab&quot;, &quot;zab&quot; of string &quot;zab&quot; in the string s.</div></pre></td></tr></table></figure></p>
<h3 id="解法1"><a href="#解法1" class="headerlink" title="解法1:"></a>解法1:</h3><p>又是维护一个running local optimal，然后再更新最终答案的题目。<br>这里是把p中以每一个字符结尾的最长子串加入到hashmap中。<br>之后再得出一个加和就可以了。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findSubstringInWraproundString</span><span class="params">(String p)</span> </span>&#123;</div><div class="line"></div><div class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i++) &#123;</div><div class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (p.charAt(i) - p.charAt(i -<span class="number">1</span>) == <span class="number">1</span> || p.charAt(i) - p.charAt(i - <span class="number">1</span>) == -<span class="number">25</span>)) &#123;</div><div class="line">                maxLen++;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                maxLen = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            map.put(p.charAt(i), Math.max(map.getOrDefault(p.charAt(i), <span class="number">0</span>), maxLen));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> key : map.keySet()) &#123;</div><div class="line">            sum += map.get(key);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> sum;        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[103. Binary Tree Zigzag Level Order Traversal]]></title>
      <url>/2017/07/23/2017-07-23-103-Binary-Tree-Zigzag-Level-Order-Traversal/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  3</div><div class="line"> / \</div><div class="line">9  20</div><div class="line">  /  \</div><div class="line"> 15   7</div></pre></td></tr></table></figure></p>
<p>return its zigzag level order traversal as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [3],</div><div class="line">  [20,9],</div><div class="line">  [15,7]</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h3 id="解法1：BFS"><a href="#解法1：BFS" class="headerlink" title="解法1：BFS"></a>解法1：BFS</h3><p>BFS 然后reverse间隔行就可以了。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</div><div class="line"></div><div class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</div><div class="line"></div><div class="line">        queue.offer(root);</div><div class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</div><div class="line">            <span class="keyword">int</span> size = queue.size();</div><div class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">                TreeNode current = queue.poll();</div><div class="line">                temp.add(current.val);</div><div class="line">                <span class="keyword">if</span> (current.left != <span class="keyword">null</span>) &#123;</div><div class="line">                    queue.offer(current.left);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (current.right != <span class="keyword">null</span>) &#123;</div><div class="line">                    queue.offer(current.right);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (level % <span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// reverse the temp</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = temp.size() - <span class="number">1</span>; i &lt; j; i++, j--) &#123;</div><div class="line">                    <span class="keyword">int</span> buffer = temp.get(i);</div><div class="line">                    temp.set(i, temp.get(j));</div><div class="line">                    temp.set(j, buffer);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            res.add(temp);</div><div class="line">            level++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[144. Binary Tree Preorder Traversal]]></title>
      <url>/2017/07/23/2017-07-23-144-Binary-Tree-Preorder-Traversal/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree {1,#,2,3},<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line"> \</div><div class="line">  2</div><div class="line"> /</div><div class="line">3</div></pre></td></tr></table></figure></p>
<p>return [1,2,3].</p>
<p>Note: Recursive solution is trivial, could you do it iteratively?</p>
<h3 id="解法1：Iterative-version-用stack"><a href="#解法1：Iterative-version-用stack" class="headerlink" title="解法1：Iterative version 用stack"></a>解法1：Iterative version 用stack</h3><p>递归的就不写了，实在太简单。<br>用stack的方法的关键点在于，每一条路劲在探寻最左元素的时候，要把所有的parent node都push到stack中。<br>如果当前的路径到头了之后，从stack里pop出上一个parent，然后移步到右边。<br>注意终止条件是需要node！= null同时stack不为空。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</div><div class="line"></div><div class="line">        TreeNode current = root;</div><div class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// push all left nodes into stack</span></div><div class="line">            <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</div><div class="line">                res.add(current.val);</div><div class="line">                stack.push(current);</div><div class="line">                current = current.left;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</div><div class="line">                TreeNode temp = stack.pop();</div><div class="line">                current = temp.right;   <span class="comment">// move to the right cell</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[413. Arithmetic Slices]]></title>
      <url>/2017/07/23/2017-07-23-413-Arithmetic-Slices/</url>
      <content type="html"><![CDATA[<p>A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.</p>
<p>For example, these are arithmetic sequence:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1, 3, 5, 7, 9</div><div class="line">7, 7, 7, 7</div><div class="line">3, -1, -5, -9</div></pre></td></tr></table></figure></p>
<p>The following sequence is not arithmetic.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1, 1, 2, 5, 7</div></pre></td></tr></table></figure></p>
<p>A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 &lt;= P &lt; Q &lt; N.</p>
<p>A slice (P, Q) of array A is called arithmetic if the sequence:<br>A[P], A[p + 1], …, A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 &lt; Q.</p>
<p>The function should return the number of arithmetic slices in the array A.</p>
<p>Example:</p>
<p>A = [1, 2, 3, 4]</p>
<p>return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// 找规律发现是一个fibb sequence</span></div><div class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>, sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; A.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (A[i] - A[i - <span class="number">1</span>] == A[i - <span class="number">1</span>] - A[i - <span class="number">2</span>]) &#123;</div><div class="line">                curr += <span class="number">1</span>;</div><div class="line">                sum += curr;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                curr = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[392. Is Subsequence]]></title>
      <url>/2017/07/23/2017-07-23-392-Is-Subsequence/</url>
      <content type="html"><![CDATA[<p>Given a string s and a string t, check if s is subsequence of t.</p>
<p>You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (&lt;=100).</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ace” is a subsequence of “abcde” while “aec” is not).</p>
<p>Example 1:<br>s = “abc”, t = “ahbgdc”</p>
<p>Return true.</p>
<p>Example 2:<br>s = “axc”, t = “ahbgdc”</p>
<p>Return false.</p>
<p>Follow up:<br>If there are lots of incoming S, say S1, S2, … , Sk where k &gt;= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?</p>
<h3 id="解法1：O-N-解法"><a href="#解法1：O-N-解法" class="headerlink" title="解法1：O(N) 解法"></a>解法1：O(N) 解法</h3><p>用两个指针一前一后的分别指向string的位置。如果两个字符相等就同前进，如果不相等，那么只前进target的指针，因为subsequence可以要求是不连续的。<br>然后判断一下s的指针时候到尾巴了就可以了。如果t到尾巴了还没有结果，则说明答案是false。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((s == <span class="keyword">null</span> &amp;&amp; t == <span class="keyword">null</span>) || (s.length() == <span class="number">0</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (s.length() &gt; t.length()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (j &lt; t.length()) &#123;</div><div class="line">            <span class="keyword">if</span> (t.charAt(j) == s.charAt(i)) &#123;</div><div class="line">                i++;</div><div class="line">                <span class="keyword">if</span> (i == s.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[486. Predict the Winner]]></title>
      <url>/2017/07/23/2017-07-23-486-Predict-the-Winner/</url>
      <content type="html"><![CDATA[<p>Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.</p>
<p>Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Input: [1, 5, 2]</div><div class="line">Output: False</div><div class="line">Explanation: Initially, player 1 can choose between 1 and 2.</div><div class="line">If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2).</div><div class="line">So, final score of player 1 is 1 + 2 = 3, and player 2 is 5.</div><div class="line">Hence, player 1 will never be the winner and you need to return False.</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Input: [1, 5, 233, 7]</div><div class="line">Output: True</div><div class="line">Explanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.</div><div class="line">Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.</div></pre></td></tr></table></figure></p>
<p>Note:</p>
<pre><code>1 &lt;= length of the array &lt;= 20.
Any scores in the given array are non-negative integers and will not exceed 10,000,000.
If the scores of both players are equal, then player 1 is still the winner.
</code></pre><h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>是同时维护两个dp而相互update的一类题目。<br>用max，min分别表示对于[i,j]范围的一组数，先手的player能取到的最大和最小值。<br>要注意： min对于[i,i]就为0<br>max对于[i,j]的递推公式是，如果取尾巴，那么再取下一步一定是取[i, j -1]的最小值。<br>如果取头部，那么再取一定是取[i - 1, j]的最小值。<br>min对于[i, j]的递推公式是，当对手取了[i]或者[j]之后，剩下的矩阵取一个最大值.<br>要注意更新矩阵的时候是按对角线更新。</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line"></div><div class="line">        <span class="comment">// max and min points if the array is [i, j]</span></div><div class="line">        <span class="keyword">int</span>[][] max = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</div><div class="line">        <span class="keyword">int</span>[][] min = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">            max[i][i] = nums[i];</div><div class="line">            min[i][i] = <span class="number">0</span>;  <span class="comment">// min is player gets nothing</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Need to fill the dp matrix diagonally</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> diff = <span class="number">1</span>; diff &lt; n; diff++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; n - diff; start++) &#123;</div><div class="line">                <span class="keyword">int</span> end = start + diff;</div><div class="line">                max[start][end] = Math.max(nums[end] + min[start][end - <span class="number">1</span>], nums[start] + min[start + <span class="number">1</span>][end]);</div><div class="line">                min[start][end] = Math.min(max[start][end - <span class="number">1</span>], max[start + <span class="number">1</span>][end]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Check which player gets higher score</span></div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</div><div class="line">            sum += num;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> max[<span class="number">0</span>][n - <span class="number">1</span>] &gt;= sum - max[<span class="number">0</span>][n - <span class="number">1</span>];</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> MinMax </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[494. Target Sum]]></title>
      <url>/2017/07/23/2017-07-23-494-Target-Sum/</url>
      <content type="html"><![CDATA[<p>You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.</p>
<p>Find out how many ways to assign symbols to make sum of integers equal to target S.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Input: nums is [1, 1, 1, 1, 1], S is 3.</div><div class="line">Output: 5</div><div class="line">Explanation:</div><div class="line"></div><div class="line">-1+1+1+1+1 = 3</div><div class="line">+1-1+1+1+1 = 3</div><div class="line">+1+1-1+1+1 = 3</div><div class="line">+1+1+1-1+1 = 3</div><div class="line">+1+1+1+1-1 = 3</div><div class="line"></div><div class="line">There are 5 ways to assign symbols to make the sum of nums be target 3.</div></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>   The length of the given array is positive and will not exceed 20.<br>   The sum of elements in the given array will not exceed 1000.<br>   Your output answer is guaranteed to be fitted in a 32-bit integer.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>用dfs + memo的想法来解决。<br>用一个map来记录对于一个子数组和一个相对应的和，有多少种方法可以计算出相对应的和。<br>然后进行dfs遍历，对于每一个元素，有+和-两种办法加和到总和之中，然后再进行下一步遍历。<br>直到遍历到数组的最后一个，只需要判断最后一个元素是否是所剩和的+/-就可。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// key will be pos and targetSum</span></div><div class="line">    HashMap&lt;List&lt;Integer&gt;, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> dfs(nums, <span class="number">0</span>, S);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> pos, <span class="keyword">int</span> S)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; key = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(pos, S));</div><div class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</div><div class="line">            <span class="keyword">return</span> map.get(key);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (pos == nums.length - <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (nums[pos] == S) &#123;</div><div class="line">                res++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (nums[pos] == S * (-<span class="number">1</span>)) &#123;</div><div class="line">                res++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        res += dfs(nums, pos + <span class="number">1</span>, S - nums[pos]);</div><div class="line">        res += dfs(nums, pos + <span class="number">1</span>, S + nums[pos]);</div><div class="line">        map.put(key, res);  </div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[523. Continuous Subarray Sum]]></title>
      <url>/2017/07/23/2017-07-23-523-Continuous-Subarray-Sum/</url>
      <content type="html"><![CDATA[<p>Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input: [23, 2, 4, 6, 7],  k=6</div><div class="line">Output: True</div><div class="line">Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input: [23, 2, 6, 4, 7],  k=6</div><div class="line">Output: True</div><div class="line">Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.</div></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>   The length of the array won’t exceed 10,000.<br>   You may assume the sum of all the numbers is in the range of a signed 32-bit integer.</p>
<h3 id="解法1：O-N-2"><a href="#解法1：O-N-2" class="headerlink" title="解法1：O(N^2)"></a>解法1：O(N^2)</h3><p>Subarray Sum的题目考虑用prefix sum解决，先计算每一个prefix sum，然后再遍历每一个subarray来寻找满足条件的最大答案。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// prefix sum</span></div><div class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</div><div class="line">            dp[i] = dp[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// check if there is a sum - prefix that is n * k</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++) &#123;</div><div class="line">                <span class="keyword">int</span> temp = dp[i] - dp[j];</div><div class="line">                <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; temp == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k != <span class="number">0</span> &amp;&amp; temp % k == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[638. Shopping Offers]]></title>
      <url>/2017/07/23/2017-07-23-638-Shopping-Offers/</url>
      <content type="html"><![CDATA[<p>In LeetCode Store, there are some kinds of items to sell. Each item has a price.</p>
<p>However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.</p>
<p>You are given the each item’s price, a set of special offers, and the number we need to buy for each item. The job is to output the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers.</p>
<p>Each special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer.</p>
<p>You could use any of special offers as many times as you want.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Input: [2,5], [[3,0,5],[1,2,10]], [3,2]</div><div class="line">Output: 14</div><div class="line">Explanation:</div><div class="line">There are two kinds of items, A and B. Their prices are $2 and $5 respectively.</div><div class="line">In special offer 1, you can pay $5 for 3A and 0B</div><div class="line">In special offer 2, you can pay $10 for 1A and 2B.</div><div class="line">You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Input: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1]</div><div class="line">Output: 11</div><div class="line">Explanation:</div><div class="line">The price of A is $2, and $3 for B, $4 for C.</div><div class="line">You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C.</div><div class="line">You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C.</div><div class="line">You cannot add more items, though only $9 for 2A ,2B and 1C.</div></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>   There are at most 6 kinds of items, 100 special offers.<br>   For each item, you need to buy at most 6 of them.<br>   You are not allowed to buy more items than you want, even if that would lower the overall price.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>用了一个DFS + memo的做法，基本思路是去尝试每一个deal，当needs全都满足的时候更新一下最小的cost。<br>要注意的是用一个memo table去记录已经探寻过的一种needs对应的cost。<br>同时对每一个needs要考虑是否不用任何一个deal，就是说对于每个商品单独相加花费更少。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    Map&lt;List&lt;Integer&gt;, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shoppingOffers</span><span class="params">(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> res = dfs(price, special, needs);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (map.containsKey(needs)) &#123;</div><div class="line">            <span class="keyword">return</span> map.get(needs);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> fulfilledStatus = fulfilled(needs);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (fulfilledStatus == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (fulfilledStatus == -<span class="number">1</span>) &#123;</div><div class="line">            <span class="comment">// Invalid Move;</span></div><div class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; deal : special) &#123;</div><div class="line">            List&lt;Integer&gt; updatedNeeds = useDeal(needs, deal);</div><div class="line">            <span class="keyword">if</span> (updatedNeeds != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">int</span> temp = dfs(price, special, updatedNeeds);</div><div class="line">                min = Math.min(min, temp + deal.get(deal.size() - <span class="number">1</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// check if needs can be fulfilled with single purchases</span></div><div class="line">        min = Math.min(min, useNoDeal(price, needs));</div><div class="line">        map.put(needs, min);</div><div class="line">        <span class="keyword">return</span> min;        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">useNoDeal</span><span class="params">(List&lt;Integer&gt; price, List&lt;Integer&gt; needs)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; price.size(); i++) &#123;</div><div class="line">            sum += price.get(i) * needs.get(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">useDeal</span><span class="params">(List&lt;Integer&gt; needs, List&lt;Integer&gt; deal)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; needs.size(); i++) &#123;</div><div class="line">            <span class="keyword">int</span> left = needs.get(i) - deal.get(i);</div><div class="line">            <span class="keyword">if</span> (left &lt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            res.add(left);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">fulfilled</span><span class="params">(List&lt;Integer&gt; needs)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> need : needs) &#123;</div><div class="line">            <span class="keyword">if</span> (need &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (need &lt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[361. Bomb Enemy]]></title>
      <url>/2017/07/17/2017-07-17-361-Bomb-Enemy/</url>
      <content type="html"><![CDATA[<p>Given a 2D grid, each cell is either a wall ‘W’, an enemy ‘E’ or empty ‘0’ (the number zero), return the maximum enemies you can kill using one bomb.<br>The bomb kills all the enemies in the same row and column from the planted point until it hits the wall since the wall is too strong to be destroyed.<br>Note that you can only put the bomb at an empty cell.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">For the given grid</div><div class="line"></div><div class="line">0 E 0 0</div><div class="line">E 0 W E</div><div class="line">0 E 0 0</div><div class="line"></div><div class="line">return 3. (Placing a bomb at (1,1) kills 3 enemies)</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxKilledEnemies</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> m = grid.length;</div><div class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span> rowCount = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[] colCount = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (j == <span class="number">0</span> || grid[i][j - <span class="number">1</span>] == <span class="string">'W'</span>) &#123;</div><div class="line">                    rowCount = <span class="number">0</span>;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; n &amp;&amp; grid[i][k] != <span class="string">'W'</span>;k++) &#123;</div><div class="line">                        rowCount += grid[i][k] == <span class="string">'E'</span> ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || grid[i - <span class="number">1</span>][j] == <span class="string">'W'</span>) &#123;</div><div class="line">                    colCount[j] = <span class="number">0</span>;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; m &amp;&amp; grid[k][j] != <span class="string">'W'</span>; k++) &#123;</div><div class="line">                        colCount[j] += (grid[k][j] == <span class="string">'E'</span> ? <span class="number">1</span> : <span class="number">0</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'0'</span>) &#123;</div><div class="line">                    res = Math.max(res, rowCount + colCount[j]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[604. Design Compressed String Iterator]]></title>
      <url>/2017/07/17/2017-07-17-604-Design-Compressed-String-Iterator/</url>
      <content type="html"><![CDATA[<p>Design and implement a data structure for a compressed string iterator. It should support the following operations: next and hasNext.</p>
<p>The given compressed string will be in the form of each letter followed by a positive integer representing the number of this letter existing in the original uncompressed string.</p>
<p>next() - if the original string still has uncompressed characters, return the next letter; Otherwise return a white space.<br>hasNext() - Judge whether there is any letter needs to be uncompressed.</p>
<p>Note:<br>Please remember to RESET your class variables declared in StringIterator, as static/class variables are persisted across multiple test cases. Please see here for more details.</p>
<p>Example:</p>
<p>StringIterator iterator = new StringIterator(“L1e2t1C1o1d1e1”);</p>
<p>iterator.next(); // return ‘L’<br>iterator.next(); // return ‘e’<br>iterator.next(); // return ‘e’<br>iterator.next(); // return ‘t’<br>iterator.next(); // return ‘C’<br>iterator.next(); // return ‘o’<br>iterator.next(); // return ‘d’<br>iterator.hasNext(); // return true<br>iterator.next(); // return ‘e’<br>iterator.hasNext(); // return false<br>iterator.next(); // return ‘ ‘</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>思路比较好想。用一个count记录当前字符还剩下的个数，另一个用pos记录在compressedString里面扫描到的位置。<br>要注意的是在判断hasNext的时候要check count！=0<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIterator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line">    <span class="keyword">char</span> prev = <span class="string">' '</span>;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    String data = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringIterator</span><span class="params">(String compressedString)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.data = compressedString;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!hasNext()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">' '</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">            prev = data.charAt(pos++);</div><div class="line">            <span class="keyword">int</span> tempCount = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span> (pos &lt; data.length() &amp;&amp; Character.isDigit(data.charAt(pos))) &#123;</div><div class="line">                tempCount = tempCount * <span class="number">10</span> + data.charAt(pos) - <span class="string">'0'</span>;</div><div class="line">                pos++;</div><div class="line">            &#125;</div><div class="line">            count = tempCount;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        count--;</div><div class="line">        <span class="keyword">return</span> prev;        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> pos &lt; data.length() || count != <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Your StringIterator object will be instantiated and called as such:</span></div><div class="line"><span class="comment"> * StringIterator obj = new StringIterator(compressedString);</span></div><div class="line"><span class="comment"> * char param_1 = obj.next();</span></div><div class="line"><span class="comment"> * boolean param_2 = obj.hasNext();</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[594. Longest Harmonious Subsequence]]></title>
      <url>/2017/07/17/2017-07-17-594-Longest-Harmonious-Subsequence/</url>
      <content type="html"><![CDATA[<p>We define a harmonious array is an array where the difference between its maximum value and its minimum value is exactly 1.</p>
<p>Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input: [1,3,2,2,5,2,3,7]</div><div class="line">Output: 5</div><div class="line">Explanation: The longest harmonious subsequence is [3,2,2,2,3].</div></pre></td></tr></table></figure></p>
<p>Note: The length of the input array will not exceed 20,000.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>对于subsequence的题目，经常会用到two pointer，一种是从两头像中间靠拢，另一种是前后两个指针按照条件和数字的变化不停的移动。这题就属于后者。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLHS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Arrays.sort(nums);</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (right &lt; nums.length) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[right] - nums[left] &gt; <span class="number">1</span>) &#123;</div><div class="line">                left++;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[right] - nums[left] &lt; <span class="number">1</span>) &#123;</div><div class="line">                right++;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                right++;</div><div class="line">                <span class="comment">// update the max length of the subarray</span></div><div class="line">                res = Math.max(res, right - left);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[598. Range Addition II]]></title>
      <url>/2017/07/17/2017-07-17-598-Range-Addition-II/</url>
      <content type="html"><![CDATA[<p>Given an m * n matrix M initialized with all 0’s and several update operations.</p>
<p>Operations are represented by a 2D array, and each operation is represented by an array with two positive integers a and b, which means M[i][j] should be added by one for all 0 &lt;= i &lt; a and 0 &lt;= j &lt; b.</p>
<p>You need to count and return the number of maximum integers in the matrix after performing all the operations.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">m = 3, n = 3</div><div class="line">operations = [[2,2],[3,3]]</div><div class="line">Output: 4</div><div class="line">Explanation:</div><div class="line">Initially, M =</div><div class="line">[[0, 0, 0],</div><div class="line"> [0, 0, 0],</div><div class="line"> [0, 0, 0]]</div><div class="line"></div><div class="line">After performing [2,2], M =</div><div class="line">[[1, 1, 0],</div><div class="line"> [1, 1, 0],</div><div class="line"> [0, 0, 0]]</div><div class="line"></div><div class="line">After performing [3,3], M =</div><div class="line">[[2, 2, 1],</div><div class="line"> [2, 2, 1],</div><div class="line"> [1, 1, 1]]</div><div class="line"></div><div class="line">So the maximum integer in M is 2, and there are four of it in M. So return 4.</div></pre></td></tr></table></figure></p>
<p>Note:</p>
<pre><code>The range of m and n is [1,40000].
The range of a is [1,m], and the range of b is [1,n].
The range of operations size won&apos;t exceed 10,000.
</code></pre><h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>思想很巧妙，拥有最大值的数组一定是执行操作最多的。操作共享的最小范围就是row和col分别的最小值。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[599. Minimum Index Sum of Two Lists]]></title>
      <url>/2017/07/17/2017-07-17-599-Minimum-Index-Sum-of-Two-Lists/</url>
      <content type="html"><![CDATA[<p>Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.</p>
<p>You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]</div><div class="line">[&quot;Piatti&quot;, &quot;The Grill at Torrey Pines&quot;, &quot;Hungry Hunter Steakhouse&quot;, &quot;Shogun&quot;]</div><div class="line">Output: [&quot;Shogun&quot;]</div><div class="line">Explanation: The only restaurant they both like is &quot;Shogun&quot;.</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]</div><div class="line">[&quot;KFC&quot;, &quot;Shogun&quot;, &quot;Burger King&quot;]</div><div class="line">Output: [&quot;Shogun&quot;]</div><div class="line">Explanation: The restaurant they both like and have the least index sum is &quot;Shogun&quot; with index sum 1 (0+1).</div></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>   The length of both lists will be in the range of [1, 1000].<br>   The length of strings in both lists will be in the range of [1, 30].<br>   The index is starting from 0 to the list length minus 1.<br>   No duplicates in both lists.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>用一个hashtable记录每一个restaurant出现的位置，当出现之前出现过的string的时候更新答案。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> String[] findRestaurant(String[] list1, String[] list2) &#123;</div><div class="line"></div><div class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (list1 == <span class="keyword">null</span> || list2 == <span class="keyword">null</span> || list1.length == <span class="number">0</span> || list2.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list1.length; i++) &#123;</div><div class="line">            map.put(list1[i], i);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list2.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (map.containsKey(list2[i])) &#123;</div><div class="line">                <span class="keyword">int</span> index = map.get(list2[i]);</div><div class="line">                <span class="keyword">if</span> (index + i == min) &#123;</div><div class="line">                    res.add(list2[i]);</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index + i &lt; min) &#123;</div><div class="line">                    res.clear();</div><div class="line">                    res.add(list2[i]);</div><div class="line">                    min = index + i;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String[] array = <span class="keyword">new</span> String[res.size()];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++) &#123;</div><div class="line">            array[i] = res.get(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> array;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[213. House Robber II]]></title>
      <url>/2017/07/17/2017-07-17-213-House-Robber-II/</url>
      <content type="html"><![CDATA[<p>Note: This is an extension of House Robber.</p>
<p>After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>两次dp, 每次只考虑头或者尾之中的一个, i.e. [0, n - 1]或者[1, n].<br>然后找出对应的最大的值就可以了<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line"></div><div class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];    <span class="comment">// forward looking</span></div><div class="line">        <span class="keyword">int</span> res = dp[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</div><div class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], nums[i] + (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>));</div><div class="line">            res = Math.max(dp[i], res);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// backward looking</span></div><div class="line">        dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">        dp[nums.length - <span class="number">1</span>] = nums[nums.length - <span class="number">1</span>];</div><div class="line">        res = Math.max(res, dp[nums.length - <span class="number">1</span>]);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">            dp[i] = Math.max(dp[i + <span class="number">1</span>], nums[i] + (i &lt; nums.length - <span class="number">2</span> ? dp[i + <span class="number">2</span>] : <span class="number">0</span>));</div><div class="line">            res = Math.max(res, dp[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[375. Guess Number Higher or Lower II]]></title>
      <url>/2017/07/17/2017-07-17-375-Guess-Number-Higher-or-Lower-II/</url>
      <content type="html"><![CDATA[<p>We are playing the Guess Game. The game is as follows:</p>
<p>I pick a number from 1 to n. You have to guess which number I picked.</p>
<p>Every time you guess wrong, I’ll tell you whether the number I picked is higher or lower.</p>
<p>However, when you guess a particular number x, and you guess wrong, you pay $x. You win the game when you guess the number I picked.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">n = 10, I pick 8.</div><div class="line"></div><div class="line">First round:  You guess 5, I tell you that it&apos;s higher. You pay $5.</div><div class="line">Second round: You guess 7, I tell you that it&apos;s higher. You pay $7.</div><div class="line">Third round:  You guess 9, I tell you that it&apos;s lower. You pay $9.</div><div class="line"></div><div class="line">Game over. 8 is the number I picked.</div><div class="line"></div><div class="line">You end up paying $5 + $7 + $9 = $21.</div></pre></td></tr></table></figure></p>
<p>Given a particular n ≥ 1, find out how much money you need to have to guarantee a win.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>试着去选择每一个数作为猜测的答案，然后分为左边和右边分别考虑。<br>用一个dp记录子问题的结果，dp数组只需要按照对角线填充就可以了。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoneyAmount</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>]; <span class="comment">// dp[i][j] is [i,j] costs</span></div><div class="line"></div><div class="line">        <span class="comment">// Fill the upper triangle from mid to top right</span></div><div class="line"></div><div class="line">        <span class="comment">// len is the count of numbers in this range</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">1</span>; start &lt;= n - len + <span class="number">1</span>; start++) &#123;</div><div class="line">                <span class="keyword">int</span> temp = Integer.MAX_VALUE;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> pivot = start; pivot &lt;= start + len - <span class="number">1</span>; pivot++) &#123;</div><div class="line">                    temp = Math.min(temp, pivot + Math.max(dp[start][pivot - <span class="number">1</span>], (pivot == start + len - <span class="number">1</span> ? <span class="number">0</span> : dp[pivot + <span class="number">1</span>][start + len - <span class="number">1</span>])));</div><div class="line">                &#125;</div><div class="line">                dp[start][start + len - <span class="number">1</span>] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];      </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[357. Count Numbers with Unique Digits]]></title>
      <url>/2017/07/17/2017-07-17-357-Count-Numbers-with-Unique-Digits/</url>
      <content type="html"><![CDATA[<p>Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x &lt; 10n.</p>
<p>Example:<br>Given n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x &lt; 100, excluding [11,22,33,44,55,66,77,88,99])</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>一个排列组合的题目，注意一位的数有10种选择，而大于一位的数第一位只有9种。<br>用一个数组或者一个变量prev记录之前的结果简化运算。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">10</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</div><div class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        dp[<span class="number">1</span>] = <span class="number">10</span>;</div><div class="line">        dp[<span class="number">2</span>] = <span class="number">81</span>;</div><div class="line"></div><div class="line">        sum += dp[<span class="number">1</span>] + dp[<span class="number">2</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</div><div class="line">            dp[i] = dp[i - <span class="number">1</span>] * (<span class="number">9</span> - i + <span class="number">2</span>);           </div><div class="line">            sum += dp[i];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[530. Minimum Absolute Difference in BST]]></title>
      <url>/2017/07/15/2017-07-15-530-Minimum-Absolute-Difference-in-BST/</url>
      <content type="html"><![CDATA[<p>Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line"></div><div class="line">   1</div><div class="line">    \</div><div class="line">     3</div><div class="line">    /</div><div class="line">   2</div><div class="line"></div><div class="line">Output:</div><div class="line">1</div><div class="line"></div><div class="line">Explanation:</div><div class="line">The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).</div></pre></td></tr></table></figure></p>
<p>Note: There are at least two nodes in this BST.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>in-order的traversal是一个排序过后的数组，用一个prev记录上一次访问过的node，然后相邻的比较一下。<br>用一个global variable寄存<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">    TreeNode prev = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// bst in order traversal is a sorted array</span></div><div class="line">        <span class="comment">// Record the prev node and current node</span></div><div class="line">        <span class="comment">// Calculate the difference and compare with global min</span></div><div class="line">        inorder(root);</div><div class="line">        <span class="keyword">return</span> min;        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        inorder(root.left);</div><div class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</div><div class="line">            min = Math.min(min, Math.abs(prev.val - root.val));</div><div class="line">        &#125;</div><div class="line">        prev = root;</div><div class="line">        inorder(root.right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[507. Perfect Number]]></title>
      <url>/2017/07/15/2017-07-15-507-Perfect-Number/</url>
      <content type="html"><![CDATA[<p>We define the Perfect Number is a positive integer that is equal to the sum of all its positive divisors except itself.<br>Now, given an integer n, write a function that returns true when it is a perfect number and false when it is not.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input: 28</div><div class="line">Output: True</div><div class="line">Explanation: 28 = 1 + 2 + 4 + 7 + 14</div></pre></td></tr></table></figure></p>
<p>Note: The input number n will not exceed 100,000,000. (1e8)</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>每一个divisor都有对应的另外一个divisor， 每次找到一个小的divisor之后对应的大的divisor就成为了新的边界，因为不会再出现比大的divisor再大的没遇见的divisor。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPerfectNumber</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> right = num;</div><div class="line">        <span class="keyword">while</span> ( i &lt; right) &#123;</div><div class="line">            <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</div><div class="line">                sum += i;</div><div class="line">                sum += (num / i);   <span class="comment">// the other side,</span></div><div class="line">            &#125;</div><div class="line">            right = num / i;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> sum == num &amp;&amp; num != <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[543. Diameter of Binary Tree]]></title>
      <url>/2017/07/15/2017-07-15-543-Diameter-of-Binary-Tree/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</p>
<p>Example:<br>Given a binary tree<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    1</div><div class="line">   / \</div><div class="line">  2   3</div><div class="line"> / \     </div><div class="line">4   5</div></pre></td></tr></table></figure></p>
<p>Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</p>
<p>Note: The length of path between two nodes is represented by the number of edges between them.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>用一个function计算每一个node的max path， 然后对每一个node更新最大的diameter，每一个node的diameter是left + right。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> diameter = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> temp = helper(root);</div><div class="line">        <span class="keyword">return</span> diameter;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="comment">// Use this function to calculate the longest path rooted at "root"</span></div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> left = helper(root.left);</div><div class="line">        <span class="keyword">int</span> right = helper(root.right);</div><div class="line"></div><div class="line">        <span class="comment">// Update the longest path</span></div><div class="line">        diameter = Math.max(diameter, left + right);</div><div class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;   <span class="comment">// Update the longest path rooted at root</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[563. Binary Tree Tilt]]></title>
      <url>/2017/07/15/2017-07-15-563-Binary-Tree-Tilt/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, return the tilt of the whole tree.</p>
<p>The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.</p>
<p>The tilt of the whole tree is defined as the sum of all nodes’ tilt.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">         1</div><div class="line">       /   \</div><div class="line">      2     3</div><div class="line">Output: 1</div><div class="line">Explanation:</div><div class="line">Tilt of node 2 : 0</div><div class="line">Tilt of node 3 : 0</div><div class="line">Tilt of node 1 : |2-3| = 1</div><div class="line">Tilt of binary tree : 0 + 0 + 1 = 1</div></pre></td></tr></table></figure></p>
<p>Note:</p>
<pre><code>The sum of node values in any subtree won&apos;t exceed the range of 32-bit integer.
All the tilt values won&apos;t exceed the range of 32-bit integer.
</code></pre><h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>对每一个node计算一个total sum,同时也计算出当前node的sum，然后再把这个sum加入到结果中就可以了。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> totalTilt = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTilt</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> temp = helper(root);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> totalTilt;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> root.val;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> left = helper(root.left);</div><div class="line">        <span class="keyword">int</span> right = helper(root.right);</div><div class="line"></div><div class="line">        totalTilt += Math.abs(left - right);    <span class="comment">// update the total tilt</span></div><div class="line">        <span class="keyword">return</span> left + right + root.val; <span class="comment">// return total sum</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[479. Largest Palindrome Product]]></title>
      <url>/2017/07/15/2017-07-15-479-Largest-Palindrome-Product/</url>
      <content type="html"><![CDATA[<p>Find the largest palindrome made from the product of two n-digit numbers.</p>
<p>Since the result could be very large, you should return the largest palindrome mod 1337.</p>
<p>Example:</p>
<p>Input: 2</p>
<p>Output: 987</p>
<p>Explanation: 99 x 91 = 9009, 9009 % 1337 = 987</p>
<p>Note:</p>
<p>The range of n is [1,8].</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>这题不认为是简单题。。。<br>主要的思路是，对于一个n位的数字，最大的数字就是pow(10, n) - 1, 那么可以从这个数字开始，计算出最大的可能的乘积。<br>这就确定了我们搜索的上边界，那么如果把这个数分成左右两半，我们可以把左面的数看成是乘积左面的上边界然后遍历他，直到左面的数小于n个数字。<br>然后每次对左面的数减1，看是否能构造成两个满足是palindrome的数。<br>对于拆分成左右两个数，用到了left = prod / mod 和right = prod % mod的办法，其中mod = pow(10, n)<br>也就是说，对于2位的数，最大可能乘积为4位，那么pow(10,2) = 100，4位的 mod 100可以得到后面两位，左面同理。<br>对于每一个left的数，构造出一个palindrome的数，然后去看是否满足这个数能被其中一个数整除（范围是[i, prod/i]),其中i从maxNumber开始。</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestPalindrome</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">9</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> base = <span class="number">1337</span>;</div><div class="line">        <span class="keyword">int</span> mod = (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, n);</div><div class="line">        <span class="keyword">int</span> maxNumber = (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, n) - <span class="number">1</span>;   <span class="comment">// Start from maxNumber and traverse until a result is found</span></div><div class="line">        <span class="keyword">long</span> prod = (<span class="keyword">long</span>)maxNumber * (<span class="keyword">long</span>)maxNumber;</div><div class="line">        <span class="comment">// To split prod into left half and right half</span></div><div class="line">        <span class="keyword">int</span> left = (<span class="keyword">int</span>)(prod / mod);  </div><div class="line">        <span class="keyword">int</span> right = (<span class="keyword">int</span>)(prod % mod);</div><div class="line">        <span class="keyword">if</span> (left == reverse(right)) <span class="keyword">return</span> (<span class="keyword">int</span>)(prod % base);</div><div class="line">        left--;</div><div class="line">        prod = (<span class="keyword">long</span>)left * (<span class="keyword">long</span>)mod + (<span class="keyword">long</span>)reverse(left);</div><div class="line">        <span class="comment">// Traverse from left to min</span></div><div class="line">        <span class="keyword">while</span> (left != mod / <span class="number">10</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = maxNumber; i &gt; prod / i; i--) &#123;</div><div class="line">                <span class="keyword">if</span> (prod % i == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> (<span class="keyword">int</span>)(prod % base);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            left--;</div><div class="line">            prod = (<span class="keyword">long</span>)left * (<span class="keyword">long</span>)mod + (<span class="keyword">long</span>)reverse(left);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(prod % base);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> x = n;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</div><div class="line">            res = res * <span class="number">10</span> + (x % <span class="number">10</span>);</div><div class="line">            x /= <span class="number">10</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[475. Heaters]]></title>
      <url>/2017/07/15/2017-07-15-475-Heaters/</url>
      <content type="html"><![CDATA[<p>Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses.</p>
<p>Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.</p>
<p>So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.</p>
<p>Note:</p>
<pre><code>Numbers of houses and heaters you are given are non-negative and will not exceed 25000.
Positions of houses and heaters you are given are non-negative and will not exceed 10^9.
As long as a house is in the heaters&apos; warm radius range, it can be warmed.
All the heaters follow your radius standard and the warm radius will the same.
</code></pre><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input: [1,2,3],[2]</div><div class="line">Output: 1</div><div class="line">Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input: [1,2,3,4],[1,4]</div><div class="line">Output: 1</div><div class="line">Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>Array的题目需要总结一下常见的思路。<br>一般看到array想想：是否需要排序？可以使用双指针？是否可以dp?<br>这题的思路是，要覆盖所有的房子，那么每一个房子要知道离他最近的heater在哪里。<br>我们找出所有房子对应的最近的heater的距离，然后再取最大的距离就是我们所求的最小的radius。<br>我们可以对heaters排序，然后找寻对于每一个house最近的heaters，这里有一点greedy的思想，就是如果i…j对于房子A不是最近的heater，那么对于一个排在房子A之后的房子B，他们也一定不是最近的heaters。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRadius</span><span class="params">(<span class="keyword">int</span>[] houses, <span class="keyword">int</span>[] heaters)</span> </span>&#123;</div><div class="line"></div><div class="line">        Arrays.sort(houses);</div><div class="line">        Arrays.sort(heaters);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> house: houses) &#123;</div><div class="line">            <span class="keyword">while</span> (i &lt; heaters.length - <span class="number">1</span> &amp;&amp; Math.abs(heaters[i] - house) &gt;= Math.abs(heaters[i + <span class="number">1</span>] - house)) &#123;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            res = Math.max(res, Math.abs(heaters[i] - house));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Two pointers </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[400. Nth Digit]]></title>
      <url>/2017/07/15/2017-07-15-400-Nth-Digit/</url>
      <content type="html"><![CDATA[<p>Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …</p>
<p>Note:<br>n is positive and will fit within the range of a 32-bit signed integer (n &lt; 231).</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">3</div><div class="line"></div><div class="line">Output:</div><div class="line">3</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">11</div><div class="line"></div><div class="line">Output:</div><div class="line">0</div></pre></td></tr></table></figure></p>
<p>Explanation:<br>The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, … is a 0, which is part of the number 10.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>不太喜欢这种风格的题。。。<br>基本思路是：<br>1 digit =&gt; 9 numbers<br>2 digits =&gt; 90 numbers<br>3 digits =&gt; 900 numbers<br>以此类推。</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> n=m; <span class="comment">// convert int to long</span></div><div class="line">        <span class="keyword">long</span> start=<span class="number">1</span>,  len=<span class="number">1</span>,  count=<span class="number">9</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(n&gt;len*count)&#123;</div><div class="line">            n=n-len*count;</div><div class="line">            len++;</div><div class="line">            count=count*<span class="number">10</span>;</div><div class="line">            start=start*<span class="number">10</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// identify the number</span></div><div class="line">        start = start + (n-<span class="number">1</span>)/len;</div><div class="line"></div><div class="line">        <span class="comment">// identify the digit</span></div><div class="line">        <span class="keyword">return</span> String.valueOf(start).charAt((<span class="keyword">int</span>)((n-<span class="number">1</span>)%len))-<span class="string">'0'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[367. Valid Perfect Square]]></title>
      <url>/2017/07/15/2017-07-15-367-Valid-Perfect-Square/</url>
      <content type="html"><![CDATA[<p>Given a positive integer num, write a function which returns True if num is a perfect square else False.</p>
<p>Note: Do not use any built-in library function such as sqrt.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: 16</div><div class="line">Returns: True</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: 14</div><div class="line">Returns: False</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>基本的binarySearch， 要用一个long来防止overflow.<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> start = <span class="number">1</span>, end = num;</div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end) &#123;</div><div class="line">            <span class="keyword">long</span> mid = start + (end - start) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">long</span> temp = mid * mid;</div><div class="line">            <span class="keyword">if</span> (temp &lt; num) &#123;</div><div class="line">                start = mid;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp &gt; num) &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (end * end == num || start * start == num) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[170. Two Sum III - Data structure design]]></title>
      <url>/2017/07/15/2017-07-15-170-Two-Sum-III-Data-structure-design/</url>
      <content type="html"><![CDATA[<p>Design and implement a TwoSum class. It should support the following operations: add and find.</p>
<p>add - Add the number to an internal data structure.<br>find - Find if there exists any pair of numbers which sum is equal to the value.</p>
<p>For example,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">add(1); add(3); add(5);</div><div class="line">find(4) -&gt; true</div><div class="line">find(7) -&gt; false</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>要注意一些细节。需要排除找到的数字不是自己，所以要统计每一个数字出现的次数。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoSum</span><span class="params">()</span> </span>&#123;</div><div class="line">        map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Add the number to an internal data structure.. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</div><div class="line">        map.put(number, map.getOrDefault(number, <span class="number">0</span>) + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Find if there exists any pair of numbers which sum is equal to the value. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> key : map.keySet()) &#123;</div><div class="line">            <span class="keyword">int</span> target = value - key;</div><div class="line">            <span class="keyword">if</span> (target == key &amp;&amp; map.get(key) &gt; <span class="number">1</span> ) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target != key &amp;&amp; map.containsKey(target)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;   </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Your TwoSum object will be instantiated and called as such:</span></div><div class="line"><span class="comment"> * TwoSum obj = new TwoSum();</span></div><div class="line"><span class="comment"> * obj.add(number);</span></div><div class="line"><span class="comment"> * boolean param_2 = obj.find(value);</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[168. Excel Sheet Column Title]]></title>
      <url>/2017/07/15/2017-07-15-168-Excel-Sheet-Column-Title/</url>
      <content type="html"><![CDATA[<p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>
<p>For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1 -&gt; A</div><div class="line">2 -&gt; B</div><div class="line">3 -&gt; C</div><div class="line">...</div><div class="line">26 -&gt; Z</div><div class="line">27 -&gt; AA</div><div class="line">28 -&gt; AB</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>这题做起来有点拗，主要的点就在于那个n–<br>同时java里面char + integer是返回一个integer，所以需要用(char)去cast一下。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</div><div class="line">            n--;    <span class="comment">// key to success!</span></div><div class="line">            builder.append((<span class="keyword">char</span>)(<span class="string">'A'</span> + n % <span class="number">26</span>));            </div><div class="line">            n /= <span class="number">26</span>;</div><div class="line">        &#125;   </div><div class="line">        <span class="keyword">return</span> builder.reverse().toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[576. Out of Boundary Paths]]></title>
      <url>/2017/07/13/2017-07-13-576-Out-of-Boundary-Paths/</url>
      <content type="html"><![CDATA[<p>There is an m by n grid with a ball. Given the start coordinate (i,j) of the ball, you can move the ball to adjacent cell or cross the grid boundary in four directions (up, down, left, right). However, you can at most move N times. Find out the number of paths to move the ball out of grid boundary. The answer may be very large, return it after mod 109 + 7.</p>
<p>Example 1:</p>
<p>Input:m = 2, n = 2, N = 2, i = 0, j = 0<br>Output: 6<br>Explanation:<br><img src="https://leetcode.com/static/images/problemset/out_of_boundary_paths_1.png" alt="1"></p>
<p>Example 2:</p>
<p>Input:m = 1, n = 3, N = 3, i = 0, j = 1<br>Output: 12<br>Explanation:<br><img src="https://leetcode.com/static/images/problemset/out_of_boundary_paths_2.png" alt="2"><br>Note:</p>
<pre><code>Once you move the ball out of boundary, you cannot move it back.
The length and height of the grid is in range [1,50].
N is in range [0,50].
</code></pre><h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>比较喜欢memorization的这个解法。<br>最直观的思路就是对于每一个位置，用递归像4个方向搜索是否能到边界之外。如果可以则返回1.<br>而每一个节点的数值是所有方向相加。但对于每一个位置(i,j)，和一定剩余的步数k, 这个组合在搜索的过程中会出现多次，所以用一个矩阵来记录下中间结果。</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M=<span class="number">1000000007</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> N, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[][][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n][N + <span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; k++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; n; l++) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt;= N; p++) &#123;</div><div class="line">                    memo[k][l][p] = -<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> helper(m, n, N, i, j, memo);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> N, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][][] memo)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (i == m || j == n || i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (memo[i][j][N] != -<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> memo[i][j][N];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        memo[i][j][N] = ((helper(m, n, N - <span class="number">1</span>, i + <span class="number">1</span>, j, memo) + helper(m, n, N - <span class="number">1</span>, i - <span class="number">1</span>, j, memo))%M + (helper(m, n, N - <span class="number">1</span>, i, j + <span class="number">1</span>, memo) + helper(m, n, N - <span class="number">1</span>, i, j - <span class="number">1</span>, memo))%M)%M;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> memo[i][j][N];</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[15. Read N Characters Given Read4 II - Call multiple times]]></title>
      <url>/2017/07/13/2017-07-13-15-Read-N-Characters-Given-Read4-II-Call-multiple-times/</url>
      <content type="html"><![CDATA[<p>The API: int read4(char *buf) reads 4 characters at a time from a file.</p>
<p>The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.</p>
<p>By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.</p>
<p>Note:<br>The read function may be called multiple times.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>这题其实针对的是在I中的解法里的一个问题，就是多读的buf会被扔掉。<br>这里因为要call multiple times,那么不能扔掉多读的，而是要存起来。<br>存起来的办法就是建一个queue,先读queue里的数，如果有多的就放回到queue里。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* The read4 API is defined in the parent class Reader4.</span></div><div class="line"><span class="comment">      int read4(char[] buf); */</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">Reader4</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> buf Destination buffer</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> n   Maximum number of characters to read</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span>    The number of characters read</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    Queue&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] buf, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; !queue.isEmpty()) &#123;</div><div class="line">            buf[i++] = queue.poll();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// i points to the next inserting position</span></div><div class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</div><div class="line">            <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>];</div><div class="line">            <span class="keyword">int</span> len = read4(buffer);</div><div class="line">            <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (; j &lt; len &amp;&amp; i &lt; n; j++) &#123;</div><div class="line">                buf[i++] = buffer[j];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span> (j &lt; len) &#123;</div><div class="line">                queue.offer(buffer[j++]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> i;        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[68. Text Justification]]></title>
      <url>/2017/07/13/2017-07-13-68-Text-Justification/</url>
      <content type="html"><![CDATA[<p>Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.</p>
<p>You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ‘ ‘ when necessary so that each line has exactly L characters.</p>
<p>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</p>
<p>For the last line of text, it should be left justified and no extra space is inserted between words.</p>
<p>For example,<br>words: [“This”, “is”, “an”, “example”, “of”, “text”, “justification.”]<br>L: 16.</p>
<p>Return the formatted lines as:</p>
<p>[<br>  “This    is    an”,<br>  “example  of text”,<br>  “justification.  “<br>]</p>
<p>Note: Each word is guaranteed not to exceed L in length.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>此题不难，也没有什么考点，可能就是考察编程能力和细心程度把。<br>思路大体就是先找出来每一行有哪些words,然后在分布空格。<br>分布空格的时候要从后往前分布，保证比较均匀且较多的空格在左面。<br>对于最后一行的处理要注意补齐空格。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fullJustify</span><span class="params">(String[] words, <span class="keyword">int</span> maxWidth)</span> </span>&#123;</div><div class="line"></div><div class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        <span class="keyword">if</span> (words.length == <span class="number">0</span> || maxWidth &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">// coding skill and detail-oriented mindset</span></div><div class="line">        <span class="keyword">int</span> currentLen = <span class="number">0</span>;</div><div class="line">        List&lt;String&gt; line = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        <span class="keyword">while</span> (i &lt; words.length) &#123;</div><div class="line">            <span class="comment">// need to know if it is the start of a line</span></div><div class="line">            <span class="keyword">if</span> ((line.isEmpty() ) || currentLen + <span class="number">1</span> + words[i].length() &lt;= maxWidth)             &#123;</div><div class="line">                currentLen += (line.isEmpty() ? <span class="number">0</span> : <span class="number">1</span> ) + words[i].length();    <span class="comment">// add a space</span></div><div class="line">                line.add(words[i]);</div><div class="line">                i++;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// Convert current line into a string and push into res</span></div><div class="line">                res.add(justifyLine(line, maxWidth));</div><div class="line">                line = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">                currentLen = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// treat last line</span></div><div class="line">        <span class="keyword">if</span> (!line.isEmpty()) &#123;</div><div class="line">            String lastLine = String.join(<span class="string">" "</span>, line);</div><div class="line">            <span class="keyword">if</span> (lastLine.length() &lt; maxWidth) &#123;</div><div class="line">                <span class="keyword">int</span> spaces = maxWidth - lastLine.length();</div><div class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; spaces; i++) &#123;</div><div class="line">                    lastLine += <span class="string">" "</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            res.add(lastLine);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">justifyLine</span><span class="params">(List&lt;String&gt; words, <span class="keyword">int</span> maxWidth)</span> </span>&#123;</div><div class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (String s : words) &#123;</div><div class="line">            len += s.length();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> spaces = maxWidth - len;</div><div class="line">        <span class="keyword">if</span> (words.size() == <span class="number">1</span>) &#123;</div><div class="line">            builder.append(words.get(<span class="number">0</span>));</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= spaces; i++) &#123;</div><div class="line">                builder.append(<span class="string">" "</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// distribute evenly</span></div><div class="line">            List&lt;String&gt; temp = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = words.size() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">                <span class="keyword">int</span> average = spaces / i;</div><div class="line">                temp.add(words.get(i));</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; average; s++) &#123;</div><div class="line">                    temp.add(<span class="string">" "</span>);</div><div class="line">                &#125;</div><div class="line">                spaces -= average;                </div><div class="line">            &#125;</div><div class="line">            <span class="comment">// append last word</span></div><div class="line">            temp.add(words.get(<span class="number">0</span>));</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = temp.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">                builder.append(temp.get(i));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> builder.toString();</div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[44. Wildcard Matching]]></title>
      <url>/2017/07/13/2017-07-13-44-Wildcard-Matching/</url>
      <content type="html"><![CDATA[<p>Implement wildcard pattern matching with support for ‘?’ and ‘*’.</p>
<p>‘?’ Matches any single character.<br>‘*’ Matches any sequence of characters (including the empty sequence).</p>
<p>The matching should cover the entire input string (not partial).</p>
<p>The function prototype should be:<br>bool isMatch(const char <em>s, const char </em>p)</p>
<p>Some examples:<br>isMatch(“aa”,”a”) ? false<br>isMatch(“aa”,”aa”) ? true<br>isMatch(“aaa”,”aa”) ? false<br>isMatch(“aa”, “<em>“) ? true<br>isMatch(“aa”, “a</em>“) ? true<br>isMatch(“ab”, “?<em>“) ? true<br>isMatch(“aab”, “c</em>a*b”) ? false</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>这题的关键在于对于*的处理。<br>DP 不能过OJ<br>two pointers可以，关键思路是碰到＊先从match 0个字符开始，往后继续match，如果发现不match了那就试着match 1个字符，以此类推。<br>最后要注意是否pattern还只剩＊<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> &amp;&amp; p == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> ss = <span class="number">0</span>, pp = <span class="number">0</span>, starIndex = -<span class="number">1</span>, match = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (ss &lt; s.length()) &#123;</div><div class="line">            <span class="keyword">if</span> (pp &lt; p.length() &amp;&amp; (s.charAt(ss) == p.charAt(pp) || p.charAt(pp) == <span class="string">'?'</span>)) &#123;</div><div class="line">                ss++;</div><div class="line">                pp++;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pp &lt; p.length() &amp;&amp; p.charAt(pp) == <span class="string">'*'</span>) &#123;</div><div class="line">                starIndex = pp;</div><div class="line">                match = ss;</div><div class="line">                pp++;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (starIndex != -<span class="number">1</span>) &#123;</div><div class="line">                pp = starIndex + <span class="number">1</span>;</div><div class="line">                match++;</div><div class="line">                ss = match;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (pp &lt; p.length() &amp;&amp; p.charAt(pp) == <span class="string">'*'</span>) &#123;</div><div class="line">            pp++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> pp == p.length();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[501. Find Mode in Binary Search Tree]]></title>
      <url>/2017/07/13/2017-07-13-501-Find-Mode-in-Binary-Search-Tree/</url>
      <content type="html"><![CDATA[<p>Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.</p>
<p>Assume a BST is defined as follows:</p>
<pre><code>The left subtree of a node contains only nodes with keys less than or equal to the node&apos;s key.
The right subtree of a node contains only nodes with keys greater than or equal to the node&apos;s key.
Both the left and right subtrees must also be binary search trees.
</code></pre><p>For example:<br>Given BST [1,null,2,2],</p>
<p>   1<br>    \<br>     2<br>    /<br>   2</p>
<p>return [2].</p>
<p>Note: If a tree has more than one mode, you can return them in any order.</p>
<p>Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).</p>
<h3 id="解法1：In-order-traversal"><a href="#解法1：In-order-traversal" class="headerlink" title="解法1：In-order traversal"></a>解法1：In-order traversal</h3><p>这题如果要求可以用extra space 的话很简单，用一个hashmap存储每一个出现的次数就可以了。<br>现在不能用extra space,那么根据bst的性质，一个中序遍历可以得到一个排序的数组。<br>对于这个排序数组，我们维护一个prev表示上一个节点，如果两个节点一样，我们更新count,如果不一样，则把当前的count和max相比，如果比max大则更新max并设置count为1.</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    TreeNode prev = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> max = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findMode(TreeNode root) &#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        TreeNode prev = <span class="keyword">null</span>;</div><div class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        traverse(root, res);</div><div class="line">        <span class="keyword">int</span>[] resArray = <span class="keyword">new</span> <span class="keyword">int</span>[res.size()];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++) &#123;</div><div class="line">            resArray[i] = res.get(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> resArray;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        traverse(root.left, res);</div><div class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (root.val == prev.val) &#123;</div><div class="line">                count++;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                count = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (count &gt; max) &#123;</div><div class="line">            res.clear();</div><div class="line">            max = count;</div><div class="line">            res.add(root.val);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == max) &#123;</div><div class="line">            res.add(root.val);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        prev = root;</div><div class="line">        traverse(root.right, res);        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> In-order-traversal </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[637. Average of Levels in Binary Tree]]></title>
      <url>/2017/07/13/2017-07-13-637-Average-of-Levels-in-Binary-TRee/</url>
      <content type="html"><![CDATA[<p>Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">    3</div><div class="line">   / \</div><div class="line">  9  20</div><div class="line">    /  \</div><div class="line">   15   7</div><div class="line">Output: [3, 14.5, 11]</div><div class="line"></div><div class="line">Explanation:</div><div class="line">The average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].</div></pre></td></tr></table></figure></p>
<p>Note:</p>
<pre><code>The range of node&apos;s value is in the range of 32-bit signed integer.
</code></pre><h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>一个bfs解决问题。<br>要注意的是当中的加和可能会overflow，要用long。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line"></div><div class="line">        List&lt;Double&gt; res = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</div><div class="line"></div><div class="line">        queue.offer(root);</div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</div><div class="line">            <span class="keyword">int</span> size = queue.size();</div><div class="line">            <span class="keyword">long</span> sum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">                TreeNode current = queue.poll();</div><div class="line">                sum += current.val;</div><div class="line">                <span class="keyword">if</span> (current.left != <span class="keyword">null</span>) &#123;</div><div class="line">                    queue.offer(current.left);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (current.right != <span class="keyword">null</span>) &#123;</div><div class="line">                    queue.offer(current.right);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            res.add((<span class="keyword">double</span>)sum / size);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[368. Largest Divisible Subset]]></title>
      <url>/2017/07/13/2017-07-13-368-Largest-Divisible-Subset/</url>
      <content type="html"><![CDATA[<p>Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0.</p>
<p>If there are multiple solutions, return any subset is fine.</p>
<p>Example 1:</p>
<p>nums: [1,2,3]</p>
<p>Result: [1,2] (of course, [1,3] will also be ok)</p>
<p>Example 2:</p>
<p>nums: [1,2,4,8]</p>
<p>Result: [1,2,4,8]</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>思路是：<br>if a &lt; b then a % b != 0 for all a , b &gt; 0<br>所以只需要对与一个数，只要从大往小找小于他的数即可。<br>第二步：<br>先把数组排序，便于分析。<br>对于排好序的数组，我们可以计算出对于每一个数字，数组中存在的可以整除他的数的最大个数。<br>这可以用一个dp完成。<br>统计出最大的个数的同时，如果我们维护另外一个数组，记录能被整除且sequence最长的那个数的index，就能在之后把整条链提取出来。</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestDivisibleSubset</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line"></div><div class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Arrays.sort(nums);          <span class="comment">// sort the array first</span></div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        <span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[n];   <span class="comment">// index stores the corresponding next item in the longest subsequence</span></div><div class="line"></div><div class="line">        Arrays.fill(dp, <span class="number">1</span>);</div><div class="line">        Arrays.fill(index, -<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> maxIndex = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</div><div class="line">                <span class="keyword">if</span> (nums[i] % nums[j] == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (dp[j] + <span class="number">1</span> &gt; dp[i]) &#123;</div><div class="line">                        dp[i] = dp[j] + <span class="number">1</span>;  <span class="comment">// update the dp array</span></div><div class="line">                        index[i] = j;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (dp[i] &gt; max) &#123;</div><div class="line">                max = dp[i];</div><div class="line">                maxIndex = i;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// maxIndex</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = maxIndex; i != -<span class="number">1</span>; i = index[i]) &#123;</div><div class="line">            res.add(nums[i]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[572. Subtree of Another Tree]]></title>
      <url>/2017/07/13/2017-07-13-572-Subtree-of-Another-Tree/</url>
      <content type="html"><![CDATA[<p>Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node’s descendants. The tree s could also be considered as a subtree of itself.</p>
<p>Example 1:<br>Given tree s:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    3</div><div class="line">   / \</div><div class="line">  4   5</div><div class="line"> / \</div><div class="line">1   2</div><div class="line"></div><div class="line">Given tree t:</div><div class="line"></div><div class="line">  4</div><div class="line"> / \</div><div class="line">1   2</div></pre></td></tr></table></figure></p>
<p>Return true, because t has the same structure and node values with a subtree of s.</p>
<p>Example 2:<br>Given tree s:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">    3</div><div class="line">   / \</div><div class="line">  4   5</div><div class="line"> / \</div><div class="line">1   2</div><div class="line">   /</div><div class="line">  0</div><div class="line"></div><div class="line">Given tree t:</div><div class="line"></div><div class="line">  4</div><div class="line"> / \</div><div class="line">1   2</div></pre></td></tr></table></figure></p>
<p>Return false.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>很简单的一个递归算法。如果当前节点数值一样，那么先判断是否identical,如果不是，考虑left, 考虑right是否和target tree存在subset关系。</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> &amp;&amp; t == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="keyword">null</span> || t == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (s.val == t.val) &#123;</div><div class="line">            <span class="keyword">if</span> (identical(s, t)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> isSubtree(s.left, t) || isSubtree(s.right, t);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">identical</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> &amp;&amp; t == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="keyword">null</span> || t == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (s.val != t.val) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> identical(s.left, t.left) &amp;&amp; identical(s.right, t.right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[115. Distinct Subsequences]]></title>
      <url>/2017/07/13/2017-07-13-115-Distinct-Subsequences/</url>
      <content type="html"><![CDATA[<p>Given a string S and a string T, count the number of distinct subsequences of S which equals T.</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABCDE” while “AEC” is not).</p>
<p>Here is an example:<br>S = “rabbbit”, T = “rabbit”</p>
<p>Return 3.</p>
<h3 id="解法1：O-NM"><a href="#解法1：O-NM" class="headerlink" title="解法1：O(NM)"></a>解法1：O(NM)</h3><p>dp[i][j]表示的是s[0,i]和t[0,j]的匹配答案。<br>递推关系可以分为s[i] == t[j] 和不等的两种情况<br>如果相等，那么既可以是包括i, 那么就是需要知道(i-1,j-1)的结果；也可以是不包括j, 那么就需要知道(i -1, j)的结果<br>如果不相等，只要(i - 1, j)就可以了。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> n = s.length();</div><div class="line">        <span class="keyword">int</span> m = t.length();</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</div><div class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) &#123;</div><div class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> dp[n][m];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[377. Combination Sum IV]]></title>
      <url>/2017/07/13/2017-07-13-377-Combination-Sum-IV/</url>
      <content type="html"><![CDATA[<p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">nums = [1, 2, 3]</div><div class="line">target = 4</div><div class="line"></div><div class="line">The possible combination ways are:</div><div class="line">(1, 1, 1, 1)</div><div class="line">(1, 1, 2)</div><div class="line">(1, 2, 1)</div><div class="line">(1, 3)</div><div class="line">(2, 1, 1)</div><div class="line">(2, 2)</div><div class="line">(3, 1)</div></pre></td></tr></table></figure></p>
<p>Note that different sequences are counted as different combinations.</p>
<p>Therefore the output is 7.</p>
<p>Follow up:<br>What if negative numbers are allowed in the given array?<br>How does it change the problem?<br>What limitation we need to add to the question to allow negative numbers?</p>
<h3 id="解法1：O-N-解法"><a href="#解法1：O-N-解法" class="headerlink" title="解法1：O(N) 解法　"></a>解法1：O(N) 解法　</h3><p>dp[i]表示的是target为i时一共的解法。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</div><div class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= target; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</div><div class="line">                <span class="keyword">if</span> (i &gt;= num) &#123;</div><div class="line">                    dp[i] += dp[i - num];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> dp[target];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[300. Longest Increasing Subsequence]]></title>
      <url>/2017/07/11/2017-07-11-300-Longest-Increasing-Subsequence/</url>
      <content type="html"><![CDATA[<p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<p>For example,<br>Given [10, 9, 2, 5, 3, 7, 101, 18],<br>The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.</p>
<p>Your algorithm should run in O(n2) complexity.</p>
<p>Follow up: Could you improve it to O(n log n) time complexity?</p>
<h3 id="解法1：O-N-2"><a href="#解法1：O-N-2" class="headerlink" title="解法1：O(N^2)"></a>解法1：O(N^2)</h3><p>经典dp,　dp[i]是到第ｉ个数字的最大递增subsequence, 那么dp[i] = Max(dp[k1], dp[k2], dp[k3]…) + 1, nums[i] &gt; nums[kn]</p>
<p>C+,<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            dp[i] = <span class="number">1</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</div><div class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            res = Math.max(res, dp[i]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法2：O-NlogN"><a href="#解法2：O-NlogN" class="headerlink" title="解法2：O(NlogN)"></a>解法2：O(NlogN)</h3><p>解释参考leetcode 的答案解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">In this approach, we scan the array from left to right. We also make use of a dpdpdp array initialized with all 0&apos;s. This dpdpdp array is meant to store the increasing subsequence formed by including the currently encountered element. While traversing the numsnumsnums array, we keep on filling the dpdpdp array with the elements encountered so far. For the element corresponding to the jthj^&#123;th&#125;j​th​​ index (nums[j]nums[j]nums[j]), we determine its correct position in the dpdpdp array(say ithi^&#123;th&#125;i​th​​ index) by making use of Binary Search(which can be used since the dpdpdp array is storing increasing subsequence) and also insert it at the correct position. An important point to be noted is that for Binary Search, we consider only that portion of the dpdpdp array in which we have made the updations by inserting some elements at their correct positions(which remains always sorted). Thus, only the elements upto the ithi^&#123;th&#125;i​th​​ index in the dpdpdp array can determine the position of the current element in it. Since, the element enters its correct position(iii) in an ascending order in the dpdpdp array, the subsequence formed so far in it is surely an increasing subsequence. Whenever this position index iii becomes equal to the length of the LIS formed so far(lenlenlen), it means, we need to update the lenlenlen as len=len+1len = len + 1len=len+1.</div><div class="line"></div><div class="line">Note: dpdpdp array does not result in longest increasing subsequence, but length of dpdpdp array will give you length of LIS.</div><div class="line"></div><div class="line">Consider the example:</div><div class="line"></div><div class="line">input: [0, 8, 4, 12, 2]</div><div class="line"></div><div class="line">dp: [0]</div><div class="line"></div><div class="line">dp: [0, 8]</div><div class="line"></div><div class="line">dp: [0, 4]</div><div class="line"></div><div class="line">dp: [0, 4, 12]</div><div class="line"></div><div class="line">dp: [0 , 2, 12] which is not the longest increasing subsequence, but length of dpdpdp array results in length of Longest Increasing Subsequence.</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int lengthOfLIS(int[] nums) &#123;</div><div class="line">        int[] dp = new int[nums.length];</div><div class="line">        int len = 0;</div><div class="line">        for (int num : nums) &#123;</div><div class="line">            int i = Arrays.binarySearch(dp, 0, len, num);</div><div class="line">            if (i &lt; 0) &#123;</div><div class="line">                i = -(i + 1);</div><div class="line">            &#125;</div><div class="line">            dp[i] = num;</div><div class="line">            if (i == len) &#123;</div><div class="line">                len++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return len;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[351. Android Unlock Patterns]]></title>
      <url>/2017/07/11/2017-07-11-351-Android-Unlock-Patterns/</url>
      <content type="html"><![CDATA[<p>Given an Android 3x3 key lock screen and two integers m and n, where 1 ≤ m ≤ n ≤ 9, count the total number of unlock patterns of the Android lock screen, which consist of minimum of m keys and maximum n keys.</p>
<p>Rules for a valid pattern:</p>
<p>   Each pattern must connect at least m keys and at most n keys.<br>   All the keys must be distinct.<br>   If the line connecting two consecutive keys in the pattern passes through any other keys, the other keys must have previously selected in the pattern. No jumps through non selected key is allowed.<br>   The order of keys used matters.<br><img src="https://leetcode.com/static/images/problemset/android-unlock.png" alt="alt text"><br>Explanation:</p>
<p>| 1 | 2 | 3 |<br>| 4 | 5 | 6 |<br>| 7 | 8 | 9 |</p>
<p>Invalid move: 4 - 1 - 3 - 6<br>Line 1 - 3 passes through key 2 which had not been selected in the pattern.</p>
<p>Invalid move: 4 - 1 - 9 - 2<br>Line 1 - 9 passes through key 5 which had not been selected in the pattern.</p>
<p>Valid move: 2 - 4 - 1 - 3 - 6<br>Line 1 - 3 is valid because it passes through key 2, which had been selected in the pattern</p>
<p>Valid move: 6 - 5 - 4 - 1 - 9 - 2<br>Line 1 - 9 is valid because it passes through key 5, which had been selected in the pattern.</p>
<p>Example:<br>Given m = 1, n = 1, return 9.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>这题一拿到感觉是dp或者是dfs的题目。用dp想不出状态方程看来只能用dfs试一下。<br>dfs的话最核心的思想就是每次往目标前进一步，如果成功则再继续探寻。<br>这个问题的一部是要看上一步和当前一步是否构成一个合适的movement.<br>一定是：<br>１．　相邻的<br>２．　对线的<br>３．　不相邻但是当中的数字已经被访问过了</p>
<p>那么用一个数组维护访问过的数字，同时维护一个上次访问的数字和当前的数字，以便判断一个move是否合适。<br>对于每一个数字进行dfs遍历，每前进一步就把所剩的步数－１．<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfPatterns</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt;= n; i++) &#123;</div><div class="line">            <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>]; <span class="comment">// initialize the array</span></div><div class="line">            sum += dfs(visited, -<span class="number">1</span>, i);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidMove</span><span class="params">(<span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> last, <span class="keyword">int</span> current)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (visited[current]) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (last == -<span class="number">1</span>) &#123;</div><div class="line">            <span class="comment">// First move, always true</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((last + current) % <span class="number">2</span> == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> row_last = last / <span class="number">3</span>;</div><div class="line">        <span class="keyword">int</span> row_current = current / <span class="number">3</span>;</div><div class="line">        <span class="keyword">int</span> col_last = last % <span class="number">3</span>;</div><div class="line">        <span class="keyword">int</span> col_current = current % <span class="number">3</span>;</div><div class="line"></div><div class="line"><span class="comment">//         if (row_last == row_current &amp;&amp; (Math.abs(col_last - col_current) == 1)) &#123;</span></div><div class="line"><span class="comment">//             return true;</span></div><div class="line"><span class="comment">//         &#125;</span></div><div class="line"></div><div class="line"><span class="comment">//         if (col_last == col_current &amp;&amp; (Math.abs(row_last - row_current) == 1)) &#123;</span></div><div class="line"><span class="comment">//             return true;</span></div><div class="line"><span class="comment">//         &#125;</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> mid = (last + current) / <span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span> (mid == <span class="number">4</span>) &#123;</div><div class="line">            <span class="keyword">return</span> visited[mid];    <span class="comment">// diagonal</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (row_last != row_current &amp;&amp; col_last != col_current) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> visited[mid];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> last, <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">        <span class="comment">// last is the last visited number</span></div><div class="line">        <span class="comment">// len is the remaining length of required key string</span></div><div class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// record the sum</span></div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</div><div class="line">            <span class="comment">// Move from last to i</span></div><div class="line">            <span class="keyword">if</span> (isValidMove(visited, last, i)) &#123;</div><div class="line">                visited[i] = <span class="keyword">true</span>;</div><div class="line">                sum += dfs(visited, i, len - <span class="number">1</span>);</div><div class="line">                visited[i] = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[30. Substring with Concatenation of All Words]]></title>
      <url>/2017/07/11/2017-07-11-30-Substring-with-Concatenation-of-All-Words/</url>
      <content type="html"><![CDATA[<p>You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.</p>
<p>For example, given:<br>s: “barfoothefoobarman”<br>words: [“foo”, “bar”]</p>
<p>You should return the indices: [0,9].<br>(order does not matter).</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>也是滑动窗口的思路，第一层循环是对于起始点的遍历。起始点可以从0到word的长度－１。<br>之后就是一个词一个词的向右进。同时统计每一个词出现的次数。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</div><div class="line"></div><div class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (words == <span class="keyword">null</span> || words.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        Map&lt;String, Integer&gt; currentMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (String word : words) &#123;</div><div class="line">            map.put(word, map.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> len = s.length();</div><div class="line">        <span class="keyword">int</span> N = words.length;</div><div class="line">        <span class="keyword">int</span> M = words[<span class="number">0</span>].length();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</div><div class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">            <span class="keyword">int</span> start = i;  <span class="comment">// record the start index of the substring</span></div><div class="line">            <span class="keyword">int</span> left = start, right = left + M;</div><div class="line">            <span class="keyword">while</span> (right &lt;= len) &#123;</div><div class="line">                String current = s.substring(left, right);</div><div class="line">                <span class="keyword">if</span> (map.containsKey(current)) &#123;</div><div class="line">                    currentMap.put(current, currentMap.getOrDefault(current, <span class="number">0</span>) + <span class="number">1</span>);</div><div class="line">                    <span class="keyword">if</span> (currentMap.get(current) &lt;= map.get(current)) count++;    <span class="comment">// find a matched word</span></div><div class="line">                    <span class="keyword">while</span> (currentMap.get(current) &gt; map.get(current)) &#123;</div><div class="line">                        String temp = s.substring(start, start + M);</div><div class="line">                        currentMap.put(temp, currentMap.get(temp) - <span class="number">1</span>);</div><div class="line">                        start += M; <span class="comment">// update the start of the substring</span></div><div class="line">                        <span class="keyword">if</span> (currentMap.get(temp) &lt; map.get(temp)) count--;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (count == N) &#123;</div><div class="line">                        res.add(start);</div><div class="line">                        String temp = s.substring(start, start + M);</div><div class="line">                        currentMap.put(temp, currentMap.get(temp) - <span class="number">1</span>);</div><div class="line">                        count--;</div><div class="line">                        start += M; <span class="comment">// update the start of the substring</span></div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    count = <span class="number">0</span>;</div><div class="line">                    currentMap.clear();</div><div class="line">                    start = right;</div><div class="line">                &#125;</div><div class="line">                left = right;</div><div class="line">                right += M;</div><div class="line">            &#125;</div><div class="line">            currentMap.clear();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[340. Longest Substring with At Most k Distinct Characters]]></title>
      <url>/2017/07/11/2017-07-11-340-Longest-Substring-with-At-Most-k-Distinct-Characters/</url>
      <content type="html"><![CDATA[<p>Given a string, find the length of the longest substring T that contains at most k distinct characters.</p>
<p>For example, Given s = “eceba” and k = 2,</p>
<p>T is “ece” which its length is 3.</p>
<h3 id="解法1：O-N"><a href="#解法1：O-N" class="headerlink" title="解法1：O(N)"></a>解法1：O(N)</h3><p>滑动窗口的解法。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line"></div><div class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, start = <span class="number">0</span>, end = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (end &lt; s.length()) &#123;</div><div class="line">            <span class="keyword">char</span> current = s.charAt(end);</div><div class="line">            map.put(current, map.getOrDefault(current, <span class="number">0</span>) + <span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span> (map.get(current) == <span class="number">1</span>) &#123;</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">            end++;  <span class="comment">// move 1 position forward</span></div><div class="line">            <span class="keyword">while</span> (count &gt; k) &#123;</div><div class="line">                <span class="keyword">char</span> prev = s.charAt(start);</div><div class="line">                map.put(prev, map.get(prev) - <span class="number">1</span>);</div><div class="line">                <span class="keyword">if</span> (map.get(prev) == <span class="number">0</span>) &#123;</div><div class="line">                    count--;</div><div class="line">                &#125;</div><div class="line">                start++;</div><div class="line">            &#125;</div><div class="line">            res = Math.max(res, end - start);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[159. Longest Substring with At Most Two Distinct Characters]]></title>
      <url>/2017/07/11/2017-07-11-159-Longest-Substring-with-At-Most-Two-Distinct-Characters/</url>
      <content type="html"><![CDATA[<p>Given a string, find the length of the longest substring T that contains at most 2 distinct characters.</p>
<p>For example, Given s = “eceba”,</p>
<p>T is “ece” which its length is 3.</p>
<h3 id="解法1：O-N"><a href="#解法1：O-N" class="headerlink" title="解法1：O(N)"></a>解法1：O(N)</h3><p>这题是sliding window的一个例题。要掌握一下模板。这题和另一题at most k distinct characters的解法一致。<br>主要的思路就是维护一个hashmap存取每一个元素出现的次数，如果为１的话，就说明是新入的元素，总个数要＋１<br>同时维护一个start指针来标记左面的边界，每次找到一个符合标准的答案时，更新最长的长度。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(String s)</span> </span>&#123;</div><div class="line"></div><div class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, start = <span class="number">0</span>, end = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (end &lt; s.length()) &#123;</div><div class="line">            <span class="keyword">char</span> current = s.charAt(end);</div><div class="line">            map.put(current, map.getOrDefault(current, <span class="number">0</span>) + <span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span> (map.get(current) == <span class="number">1</span>) &#123;</div><div class="line">                <span class="comment">// new character</span></div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">            end++;  <span class="comment">// move end 1 position forward</span></div><div class="line">            <span class="keyword">while</span> (count &gt; <span class="number">2</span>) &#123;</div><div class="line">                <span class="keyword">char</span> prev = s.charAt(start);</div><div class="line">                map.put(prev, map.get(prev) -<span class="number">1</span> );</div><div class="line">                <span class="keyword">if</span> (map.get(prev) == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">// Removed one character</span></div><div class="line">                    count--;</div><div class="line">                &#125;</div><div class="line">                start++;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            res = Math.max(res, end - start);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[221. Maximal Square]]></title>
      <url>/2017/07/10/2017-07-10-221-Maximal-Square/</url>
      <content type="html"><![CDATA[<p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p>
<p>For example, given the following matrix:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1 0 1 0 0</div><div class="line">1 0 1 1 1</div><div class="line">1 1 1 1 1</div><div class="line">1 0 0 1 0</div></pre></td></tr></table></figure></p>
<p>Return 4.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>诀窍在于dp[i][j] 表示以(i,j)为底的正方形的边长。<br>dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1, if matrix[i][j] == 1,<br>画一下图就比较清楚。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> row = matrix.length;</div><div class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</div><div class="line"></div><div class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = matrix[<span class="number">0</span>][<span class="number">0</span>] - <span class="string">'0'</span> == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> res = dp[<span class="number">0</span>][<span class="number">0</span>];    <span class="comment">// record the final result</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] - <span class="string">'0'</span> == <span class="number">1</span>) &#123;</div><div class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span>;</div><div class="line">                res = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] - <span class="string">'0'</span> == <span class="number">1</span>) &#123;</div><div class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">                res = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (matrix[i][j] - <span class="string">'0'</span> == <span class="number">0</span>) &#123;</div><div class="line">                    dp[i][j] = <span class="number">0</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]),dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                res = Math.max(res, dp[i][j] * dp[i][j]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[264. Ugly Number II]]></title>
      <url>/2017/07/10/2017-07-10-264-Ugly-Number-II/</url>
      <content type="html"><![CDATA[<p>Write a program to find the n-th ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.</p>
<p>Note that 1 is typically treated as an ugly number, and n does not exceed 1690.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> d1 = <span class="number">2</span>, d2 = <span class="number">3</span>, d3 = <span class="number">5</span>;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span>; p &lt; n; p++) &#123;</div><div class="line">            <span class="keyword">int</span> res = Math.min(Math.min(d1, d2), d3);</div><div class="line">            dp[p] = res;</div><div class="line">            <span class="keyword">if</span> (d1 == res) &#123;</div><div class="line">                d1 = <span class="number">2</span> * dp[++i];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (d2 == res) &#123;</div><div class="line">                d2 = <span class="number">3</span> * dp[++j];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (d3 == res) &#123;</div><div class="line">                d3 = <span class="number">5</span> * dp[++k];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[256. Paint House]]></title>
      <url>/2017/07/10/2017-07-10-256-Paint-House/</url>
      <content type="html"><![CDATA[<p>There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.</p>
<p>The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on… Find the minimum cost to paint all houses.</p>
<p>Note:<br>All costs are positive integers.</p>
<h3 id="解法1：O-N-K-Time"><a href="#解法1：O-N-K-Time" class="headerlink" title="解法1：O(N*K) Time"></a>解法1：O(N*K) Time</h3><p>N是房子的数量，K是房子的颜色数。<br>经典dp, dp[i][j] 表示前i个房子的最小cost,当第i个房子涂得颜色是j。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (costs.length == <span class="number">0</span> || costs[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> n = costs.length;</div><div class="line">        <span class="keyword">int</span> col = costs[<span class="number">0</span>].length;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][col];   <span class="comment">// first i houses painted and ith house painted with jth color</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col;j++) &#123;</div><div class="line">            dp[<span class="number">0</span>][j] = costs[<span class="number">0</span>][j];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</div><div class="line">                <span class="keyword">int</span> temp = Integer.MAX_VALUE;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; col; k++) &#123;</div><div class="line">                    <span class="keyword">if</span> (k != j) &#123;</div><div class="line">                        temp = Math.min(temp, dp[i - <span class="number">1</span>][k]);    </div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                dp[i][j] = costs[i][j] + temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</div><div class="line">            res = Math.min(res, dp[n - <span class="number">1</span>][j]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[591. Tag Validator]]></title>
      <url>/2017/07/10/2017-07-10-591-Tag-Validator/</url>
      <content type="html"><![CDATA[<p>Given a string representing a code snippet, you need to implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold:</p>
<pre><code>The code must be wrapped in a valid closed tag. Otherwise, the code is invalid.
A closed tag (not necessarily valid) has exactly the following format : &lt;TAG_NAME&gt;TAG_CONTENT&lt;/TAG_NAME&gt;. Among them, &lt;TAG_NAME&gt; is the start tag, and &lt;/TAG_NAME&gt; is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid.
A valid TAG_NAME only contain upper-case letters, and has length in range [1,9]. Otherwise, the TAG_NAME is invalid.
A valid TAG_CONTENT may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched &lt;, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the TAG_CONTENT is invalid.
A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.
A &lt; is unmatched if you cannot find a subsequent &gt;. And when you find a &lt; or &lt;/, all the subsequent characters until the next &gt; should be parsed as TAG_NAME (not necessarily valid).
The cdata has the following format : &lt;![CDATA[CDATA_CONTENT]]&gt;. The range of CDATA_CONTENT is defined as the characters between &lt;![CDATA[ and the first subsequent ]]&gt;.
CDATA_CONTENT may contain any characters. The function of cdata is to forbid the validator to parse CDATA_CONTENT, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters.
</code></pre><p>Valid Code Examples:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">Input: &quot;&lt;DIV&gt;This is the first line &lt;![CDATA[&lt;div&gt;]]&gt;&lt;/DIV&gt;&quot;</div><div class="line"></div><div class="line">Output: True</div><div class="line"></div><div class="line">Explanation:</div><div class="line"></div><div class="line">The code is wrapped in a closed tag : &lt;DIV&gt; and &lt;/DIV&gt;.</div><div class="line"></div><div class="line">The TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata.</div><div class="line"></div><div class="line">Although CDATA_CONTENT has unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as tag.</div><div class="line"></div><div class="line">So TAG_CONTENT is valid, and then the code is valid. Thus return true.</div><div class="line"></div><div class="line"></div><div class="line">Input: &quot;&lt;DIV&gt;&gt;&gt;  ![cdata[]] &lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&gt;]&lt;/DIV&gt;&quot;</div><div class="line"></div><div class="line">Output: True</div><div class="line"></div><div class="line">Explanation:</div><div class="line"></div><div class="line">We first separate the code into : start_tag|tag_content|end_tag.</div><div class="line"></div><div class="line">start_tag -&gt; &quot;&lt;DIV&gt;&quot;</div><div class="line"></div><div class="line">end_tag -&gt; &quot;&lt;/DIV&gt;&quot;</div><div class="line"></div><div class="line">tag_content could also be separated into : text1|cdata|text2.</div><div class="line"></div><div class="line">text1 -&gt; &quot;&gt;&gt;  ![cdata[]] &quot;</div><div class="line"></div><div class="line">cdata -&gt; &quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;&quot;, where the CDATA_CONTENT is &quot;&lt;div&gt;]&gt;&quot;</div><div class="line"></div><div class="line">text2 -&gt; &quot;]]&gt;&gt;]&quot;</div><div class="line"></div><div class="line"></div><div class="line">The reason why start_tag is NOT &quot;&lt;DIV&gt;&gt;&gt;&quot; is because of the rule 6.</div><div class="line">The reason why cdata is NOT &quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&quot; is because of the rule 7.</div></pre></td></tr></table></figure></p>
<p>Invalid Code Examples:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Input: &quot;&lt;A&gt;  &lt;B&gt; &lt;/A&gt;   &lt;/B&gt;&quot;</div><div class="line">Output: False</div><div class="line">Explanation: Unbalanced. If &quot;&lt;A&gt;&quot; is closed, then &quot;&lt;B&gt;&quot; must be unmatched, and vice versa.</div><div class="line"></div><div class="line">Input: &quot;&lt;DIV&gt;  div tag is not closed  &lt;DIV&gt;&quot;</div><div class="line">Output: False</div><div class="line"></div><div class="line">Input: &quot;&lt;DIV&gt;  unmatched &lt;  &lt;/DIV&gt;&quot;</div><div class="line">Output: False</div><div class="line"></div><div class="line">Input: &quot;&lt;DIV&gt; closed tags with invalid tag name  &lt;b&gt;123&lt;/b&gt; &lt;/DIV&gt;&quot;</div><div class="line">Output: False</div><div class="line"></div><div class="line">Input: &quot;&lt;DIV&gt; unmatched tags with invalid tag name  &lt;/1234567890&gt; and &lt;CDATA[[]]&gt;  &lt;/DIV&gt;&quot;</div><div class="line">Output: False</div><div class="line"></div><div class="line">Input: &quot;&lt;DIV&gt;  unmatched start tag &lt;B&gt;  and unmatched end tag &lt;/C&gt;  &lt;/DIV&gt;&quot;</div><div class="line">Output: False</div></pre></td></tr></table></figure></p>
<p>Note:</p>
<pre><code>For simplicity, you could assume the input code (including the any characters mentioned above) only contain letters, digits, &apos;&lt;&apos;,&apos;&gt;&apos;,&apos;/&apos;,&apos;!&apos;,&apos;[&apos;,&apos;]&apos; and &apos; &apos;.
</code></pre><h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>此题比较繁琐，题目也巨长。实际上并不是很难。<br>主要要先总结一下要求：<br>字符串一定是以tag开头和结尾<br>tag的名字要符合：　<br>１．　１－　９个字符之内<br>２．　只能是upper case letters<br>３．　需要两两配对<br>４．　&lt;!出现的话一定需要match ＣＤＡＴＡ</p>
<p>然后对于每一个tag,用一个stack去记录上一个tag的顺序即可。</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String code)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// It should start with &lt; and end with &gt;</span></div><div class="line">        <span class="keyword">if</span> (code == <span class="keyword">null</span> || code.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (code.charAt(<span class="number">0</span>) != <span class="string">'&lt;'</span> || code.charAt(code.length() - <span class="number">1</span>) != <span class="string">'&gt;'</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> tagExist = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; code.length(); i++) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (stack.isEmpty() &amp;&amp; tagExist) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> last = -<span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (code.charAt(i) == <span class="string">'&lt;'</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; code.charAt(i + <span class="number">1</span>) == <span class="string">'!'</span>) &#123;</div><div class="line">                    last = code.indexOf(<span class="string">"]]&gt;"</span>, i + <span class="number">1</span>);</div><div class="line">                    <span class="keyword">if</span> (last == -<span class="number">1</span> || !isValidCdata(code.substring(i + <span class="number">2</span>, last))) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">boolean</span> close = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">if</span> (code.charAt(i + <span class="number">1</span>) == <span class="string">'/'</span>) &#123;</div><div class="line">                        close = <span class="keyword">true</span>;</div><div class="line">                        i++;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    last = code.indexOf(<span class="string">"&gt;"</span>, i+<span class="number">1</span>);</div><div class="line">                    <span class="keyword">if</span> (last == -<span class="number">1</span> || !isValidTagName(code.substring(i + <span class="number">1</span>, last))) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (close) &#123;</div><div class="line">                        <span class="keyword">if</span> (stack.isEmpty() || !stack.peek().equals(code.substring(i + <span class="number">1</span>, last))) &#123;</div><div class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            stack.pop();</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        tagExist = <span class="keyword">true</span>;</div><div class="line">                        stack.push(code.substring(i + <span class="number">1</span>, last));</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                i = last;   <span class="comment">// move i to the end of the tag</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> stack.isEmpty() &amp;&amp; tagExist;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidCdata</span><span class="params">(String content)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> tag = content.indexOf(<span class="string">"[CDATA["</span>);</div><div class="line">        <span class="keyword">return</span> tag == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidTagName</span><span class="params">(String tag)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len = tag.length();</div><div class="line">        <span class="keyword">if</span> (len &lt; <span class="number">1</span> || len &gt; <span class="number">9</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (tag.charAt(i) &lt; <span class="string">'A'</span> || tag.charAt(i) &gt; <span class="string">'Z'</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[32. Longest Valid Parentheses]]></title>
      <url>/2017/07/10/2017-07-10-32-Longest-Valid-Parentheses/</url>
      <content type="html"><![CDATA[<p>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</p>
<p>For “(()”, the longest valid parentheses substring is “()”, which has length = 2.</p>
<p>Another example is “)()())”, where the longest valid parentheses substring is “()()”, which has length = 4.</p>
<h3 id="解法1：DP-O-N-Time-O-N-Space"><a href="#解法1：DP-O-N-Time-O-N-Space" class="headerlink" title="解法1：DP　O(N) Time + O(N) Space"></a>解法1：DP　O(N) Time + O(N) Space</h3><p>此题有多种解法。DP只是其中一种。<br>只有在碰到)的时候才需要去计算当前配对括号长度。<br>状态方程的解释是：<br>如果在)之前的符号是(，那么最长的合法字符串长度就是(之前的合法长度＋２<br>如果之前的符号是), dp[i - 1]代表了如果i - 1结尾的合法的最长长度，那么如果在dp[i - 1]之前的那个字符是（，<br>当前的合法长度就可以等于dp[i - 1] + dp[i - dp[i - 1] - 2]　＋　２<br>由此可以写出状态方程。</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</div><div class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">')'</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">'('</span>) &#123;</div><div class="line">                    dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;  <span class="comment">// add () to dp[i - 2]</span></div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">')'</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (i - dp[i -<span class="number">1</span>] &gt;= <span class="number">1</span> &amp;&amp; s.charAt(i - dp[i - <span class="number">1</span>] - <span class="number">1</span>) == <span class="string">'('</span>) &#123;</div><div class="line">                        dp[i] = dp[i - <span class="number">1</span>] + (i - dp[i - <span class="number">1</span>] &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;    </div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                res = Math.max(dp[i], res);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[522. Longest Uncommon Subsequence II]]></title>
      <url>/2017/07/09/2017-07-09-522-Longest-Uncommon-Subsequence-II/</url>
      <content type="html"><![CDATA[<p>Given a list of strings, you need to find the longest uncommon subsequence among them. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.</p>
<p>A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.</p>
<p>The input will be a list of strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn’t exist, return -1.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: &quot;aba&quot;, &quot;cdc&quot;, &quot;eae&quot;</div><div class="line">Output: 3</div></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>   All the given strings’ lengths will not exceed 10.<br>   The length of the given list will be in the range of [2, 50].</p>
<h3 id="解法1：O-N-2-X"><a href="#解法1：O-N-2-X" class="headerlink" title="解法1：O(N^2 * X)"></a>解法1：O(N^2 * X)</h3><p>x is the average length of strings. N is the number of strings<br>这题的关键在于substring的定义要注意，和平时遇到的substring定义不同。<br>这里的substring是可以提取不连续的字符组成。<br>分析一下可以发现，如果存在答案的话，那么uncommon subsequence 一定是其中某一个string，那么就把每一个string和其他的相比，看是否为其他的substring，如果不是，那么更新最大值。</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLUSlength</span><span class="params">(String[] strs)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> res = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; strs.length; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (j != i) &#123;</div><div class="line">                    <span class="keyword">if</span> (isSubString(strs[i], strs[j])) &#123;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (j == strs.length) &#123;</div><div class="line">                res = Math.max(res, strs[i].length());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSubString</span><span class="params">(String x, String y)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// By definition, the substring can be derived by deleting some characters</span></div><div class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; y.length() &amp;&amp; j &lt; x.length(); i++)</div><div class="line">            <span class="keyword">if</span> (x.charAt(j) == y.charAt(i))</div><div class="line">                j++;</div><div class="line">        <span class="keyword">return</span> j == x.length();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[539. Minimum Time Difference]]></title>
      <url>/2017/07/08/2017-07-08-539-Minimum-Time-Difference/</url>
      <content type="html"><![CDATA[<p>Given a list of 24-hour clock time points in “Hour:Minutes” format, find the minimum minutes difference between any two time points in the list.</p>
<p>Example 1:</p>
<p>Input: [“23:59”,”00:00”]<br>Output: 1</p>
<p>Note:</p>
<pre><code>The number of time points in the given list is at least 2 and won&apos;t exceed 20000.
The input time is legal and ranges from 00:00 to 23:59.
</code></pre><h3 id="解法1：-O-NlogN"><a href="#解法1：-O-NlogN" class="headerlink" title="解法1： O(NlogN)"></a>解法1： O(NlogN)</h3><p>很直观的就是把array转化为分钟数的数组，然后两两比较，同时别忘了比较头和尾巴。</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinDifference</span><span class="params">(List&lt;String&gt; timePoints)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (timePoints == <span class="keyword">null</span> || timePoints.size() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] times = <span class="keyword">new</span> <span class="keyword">int</span>[timePoints.size()];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; timePoints.size(); i++) &#123;</div><div class="line">            <span class="keyword">int</span> seperator = timePoints.get(i).indexOf(<span class="string">":"</span>);</div><div class="line">            <span class="keyword">int</span> hour = Integer.parseInt(timePoints.get(i).substring(<span class="number">0</span>, seperator));</div><div class="line">            <span class="keyword">int</span> minute = Integer.parseInt(timePoints.get(i).substring(seperator + <span class="number">1</span>));</div><div class="line">            times[i] = hour * <span class="number">60</span> + minute;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Arrays.sort(times);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">int</span> time24 = <span class="number">24</span> * <span class="number">60</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times.length - <span class="number">1</span>; i++) &#123;</div><div class="line">            res = Math.min(res, Math.min(Math.abs(time24 + times[i] - times[i + <span class="number">1</span>]), Math.abs(times[i+<span class="number">1</span>] - times[i])));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        res = Math.min(res, Math.min(Math.abs(time24 + times[<span class="number">0</span>] - times[times.length - <span class="number">1</span>]), Math.abs(times[<span class="number">0</span>] - times[times.length - <span class="number">1</span>])));</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法2：-O-N"><a href="#解法2：-O-N" class="headerlink" title="解法2： O(N)"></a>解法2： O(N)</h3><p>借鉴了bucket sort 的解法，因为这里分钟数的总个数是固定的。可以用一个60 * 24 = 1440的数组来记录每一个分钟数是否出现。<br>如果一个分钟数出现两次，那么最小值一定是0.<br>同时需要维护一个first和last来记录第一个和最后一个出现过的分钟数。<br>最后比较一下相邻出现过的分钟数以及头尾就可以了。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[555. Split Concatenated Strings]]></title>
      <url>/2017/07/08/2017-07-08-555-Split-Concatenated-Strings/</url>
      <content type="html"><![CDATA[<p>Given a list of strings, you could concatenate these strings together into a loop, where for each string you could choose to reverse it or not. Among all the possible loops, you need to find the lexicographically biggest string after cutting the loop, which will make the looped string into a regular one.</p>
<p>Specifically, to find the lexicographically biggest string, you need to experience two phases:</p>
<pre><code>Concatenate all the strings into a loop, where you can reverse some strings or not and connect them in the same order as given.
Cut and make one breakpoint in any place of the loop, which will make the looped string into a regular one starting from the character at the cutpoint.
</code></pre><p>And your job is to find the lexicographically biggest one among all the possible regular strings.</p>
<p>Example:</p>
<p>Input: “abc”, “xyz”<br>Output: “zyxcba”<br>Explanation: You can get the looped string “-abcxyz-“, “-abczyx-“, “-cbaxyz-“, “-cbazyx-“,<br>where ‘-‘ represents the looped status.<br>The answer string came from the fourth looped one,<br>where you could cut from the middle character ‘a’ and get “zyxcba”.</p>
<p>Note:</p>
<pre><code>The input strings will only contain lowercase letters.
The total length of all the strings will not over 1,000.
</code></pre><h3 id="解法1：O-N-2"><a href="#解法1：O-N-2" class="headerlink" title="解法1：O(N^2)　"></a>解法1：O(N^2)　</h3><p>此题参考了leetcode的解法：<br><figure class="highlight plain"><figcaption><span>order to understand how this solution works, firstly we'll look at some of the properties of the transformation involved. The first point to note is that the relative ordering of the strings doesn't change after applying the transformations(i.e. reversing and applying cuts).</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">The second property will be explained taking the help of an example. Consider the given list of strings: [s1,s2,s3,..,sj,..sn][s_1, s_2, s_3,..,s_j,..s_n][s​1​​,s​2​​,s​3​​,..,s​j​​,..s​n​​]. Now, assume that we choose sjs_js​j​​ to be the string on which the current cut is placed leading to the formation of two substrings from sjs_js​j​​, namely, say sjpres_&#123;jpre&#125;s​jpre​​, sjposts_&#123;jpost&#125;s​jpost​​. Thus, the concatenated string formed by such a cut will be: [sjpost,sj+1,...,sn,s1rev,s2rev,..,s(jpre)rev][s_&#123;jpost&#125;, s_&#123;j+1&#125;,..., s_n, s_&#123;1rev&#125;, s_&#123;2rev&#125;,.., s_&#123;(jpre)rev&#125;][s​jpost​​,s​j+1​​,...,s​n​​,s​1rev​​,s​2rev​​,..,s​(jpre)rev​​]. Here, sirevs_&#123;irev&#125;s​irev​​ means the reversed sis_is​i​​ string.</div><div class="line"></div><div class="line">The concatenated string formed follows the same pattern irrespective of where the cut is placed in sjs_js​j​​. But still, the relative ordering of the strings persists, even if we include the reverse operation as well.</div><div class="line"></div><div class="line">Now, if we consider only a single cut for the time being, in string sjs_js​j​​(not reversed) as discussed above, and allow for the reverse operation among the remaining strings, the lexicographically largest concatenated string will be given by: [sjpost,max(sj+1,s(j+1)rev),...,max(sn,s(n)rev),max(s1,s(1)rev),...,s(jpre)rev][s_&#123;jpost&#125;, \text&#123;max&#125;(s_&#123;j+1&#125;,s_&#123;(j+1)rev&#125;) ,..., \text&#123;max&#125;(s_&#123;n&#125;,s_&#123;(n)rev&#125;), \text&#123;max&#125;(s_&#123;1&#125;,s_&#123;(1)rev&#125;), ..., s_&#123;(jpre)rev&#125;][s​jpost​​,max(s​j+1​​,s​(j+1)rev​​),...,max(s​n​​,s​(n)rev​​),max(s​1​​,s​(1)rev​​),...,s​(jpre)rev​​]. Here, max\text&#123;max&#125;max refers to the lexicographic maximum operation.</div><div class="line"></div><div class="line">Thus, if a particular string sjs_js​j​​ is finalized for the cut, the largest lexicographic concatenated string is dependent only on whether the string sjs_js​j​​ is reversed or not, and also on the position of the cut. This happens because the reverse/not reverse operation for the rest of the strings is fixed for a chosen sjs_js​j​​ as shown above and thus, doesn&apos;t impact the final result.</div><div class="line"></div><div class="line">Based on the above observations, we follow the given procedure. For every given string, we replace the string with the lexicographically larger string out of the original string and the reversed one. After this, we pick up every new string(chosen as the string on which the cuts will be applied), and apply a cut at all the positions of the currently picked string and form the full concantenated string keeping the rest of the newly formed strings intact. We also reverse the current string and follow the same process. While doing this, we keep a track of the largest lexicographic string found so far.</div></pre></td></tr></table></figure></p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">splitLoopedString</span><span class="params">(String[] strs)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</div><div class="line">            String rev = <span class="keyword">new</span> StringBuilder(strs[i]).reverse().toString();</div><div class="line">            <span class="keyword">if</span> (strs[i].compareTo(rev) &lt; <span class="number">0</span>) &#123;</div><div class="line">                strs[i] = rev;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String res = <span class="string">""</span>;    <span class="comment">// store results</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</div><div class="line">            String rev = <span class="keyword">new</span> StringBuilder(strs[i]).reverse().toString();</div><div class="line">            <span class="keyword">for</span> (String str : <span class="keyword">new</span> String[] &#123;strs[i], rev&#125;) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; str.length(); k++) &#123;</div><div class="line">                    <span class="comment">// get the head</span></div><div class="line">                    StringBuilder builder = <span class="keyword">new</span> StringBuilder(str.substring(k));</div><div class="line">                    <span class="comment">// append i + 1 to n strings</span></div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; strs.length; j++) &#123;</div><div class="line">                        builder.append(strs[j]);</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// append 0 to i -1 strings</span></div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</div><div class="line">                        builder.append(strs[j]);</div><div class="line">                    &#125;</div><div class="line">                    builder.append(str.substring(<span class="number">0</span>, k));</div><div class="line">                    <span class="keyword">if</span> (builder.toString().compareTo(res) &gt; <span class="number">0</span>) &#123;</div><div class="line">                        <span class="comment">// lexi order</span></div><div class="line">                        res = builder.toString();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[609. Find Duplicate File in System]]></title>
      <url>/2017/07/06/2017-07-06-609-Find-Duplicate-File-in-System/</url>
      <content type="html"><![CDATA[<p>Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths.</p>
<p>A group of duplicate files consists of at least two files that have exactly the same content.</p>
<p>A single directory info string in the input list has the following format:</p>
<p>“root/d1/d2/…/dm f1.txt(f1_content) f2.txt(f2_content) … fn.txt(fn_content)”</p>
<p>It means there are n files (f1.txt, f2.txt … fn.txt with content f1_content, f2_content … fn_content, respectively) in directory root/d1/d2/…/dm. Note that n &gt;= 1 and m &gt;= 0. If m = 0, it means the directory is just the root directory.</p>
<p>The output is a list of group of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:</p>
<p>“directory_path/file_name.txt”</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">[&quot;root/a 1.txt(abcd) 2.txt(efgh)&quot;, &quot;root/c 3.txt(abcd)&quot;, &quot;root/c/d 4.txt(efgh)&quot;, &quot;root 4.txt(efgh)&quot;]</div><div class="line">Output:  </div><div class="line">[[&quot;root/a/2.txt&quot;,&quot;root/c/d/4.txt&quot;,&quot;root/4.txt&quot;],[&quot;root/a/1.txt&quot;,&quot;root/c/3.txt&quot;]]</div></pre></td></tr></table></figure></p>
<p>Note:</p>
<pre><code>No order is required for the final output.
You may assume the directory name, file name and file content only has letters and digits, and the length of file content is in the range of [1,50].
The number of files given is in the range of [1,20000].
You may assume no files or directories share the same name in the same directory.
You may assume each given directory info represents a unique directory. Directory path and file info are separated by a single blank space.
</code></pre><p>Follow-up beyond contest:</p>
<pre><code>Imagine you are given a real file system, how will you search files? DFS or BFS?
If the file content is very large (GB level), how will you modify your solution?
If you can only read the file by 1kb each time, how will you modify your solution?
What is the time complexity of your modified solution? What is the most time-consuming part and memory consuming part of it? How to optimize?
How to make sure the duplicated files you find are not false positive?
</code></pre><h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>没有难点，就是按部就班的把这个paths转换成为hashmap, 以content作为key.<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findDuplicate(String[] paths) &#123;</div><div class="line"></div><div class="line">        HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</div><div class="line">        <span class="keyword">for</span> (String path : paths) &#123;</div><div class="line">            String[] temp = path.split(<span class="string">" "</span>);</div><div class="line">            String path_root = temp[<span class="number">0</span>] + <span class="string">"/"</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; temp.length; i++) &#123;</div><div class="line">                <span class="comment">// seperate contents from string</span></div><div class="line">                <span class="keyword">int</span> leftBracket = temp[i].indexOf(<span class="string">"("</span>);</div><div class="line">                String fileName = temp[i].substring(<span class="number">0</span>, leftBracket);</div><div class="line">                String content = temp[i].substring(leftBracket + <span class="number">1</span>, temp[i].length() - <span class="number">1</span>);  <span class="comment">// get rid of the last bracket in the string</span></div><div class="line">                String fullFileName = path_root + fileName;</div><div class="line">                <span class="keyword">if</span> (map.containsKey(content)) &#123;</div><div class="line">                    map.get(content).add(fullFileName);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    List&lt;String&gt; files = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">                    files.add(fullFileName);</div><div class="line">                    map.put(content, files);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</div><div class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</div><div class="line">            List&lt;String&gt; files = map.get(key);</div><div class="line">            <span class="keyword">if</span> (files.size() &gt; <span class="number">1</span>) &#123;</div><div class="line">                res.add(files);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[468. Validate IP Address]]></title>
      <url>/2017/07/06/2017-07-06-468-Validate-IP-Address/</url>
      <content type="html"><![CDATA[<p>Write a function to check whether an input string is a valid IPv4 address or IPv6 address or neither.</p>
<p>IPv4 addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots (“.”), e.g.,172.16.254.1;</p>
<p>Besides, leading zeros in the IPv4 is invalid. For example, the address 172.16.254.01 is invalid.</p>
<p>IPv6 addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (“:”). For example, the address 2001:0db8:85a3:0000:0000:8a2e:0370:7334 is a valid one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so 2001:db8:85a3:0:0:8A2E:0370:7334 is also a valid IPv6 address(Omit leading zeros and using upper cases).</p>
<p>However, we don’t replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, 2001:0db8:85a3::8A2E:0370:7334 is an invalid IPv6 address.</p>
<p>Besides, extra leading zeros in the IPv6 is also invalid. For example, the address 02001:0db8:85a3:0000:0000:8a2e:0370:7334 is invalid.</p>
<p>Note: You may assume there is no extra space or special characters in the input string.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Input: &quot;172.16.254.1&quot;</div><div class="line"></div><div class="line">Output: &quot;IPv4&quot;</div><div class="line"></div><div class="line">Explanation: This is a valid IPv4 address, return &quot;IPv4&quot;.</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Input: &quot;2001:0db8:85a3:0:0:8A2E:0370:7334&quot;</div><div class="line"></div><div class="line">Output: &quot;IPv6&quot;</div><div class="line"></div><div class="line">Explanation: This is a valid IPv6 address, return &quot;IPv6&quot;.</div></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Input: &quot;256.256.256.256&quot;</div><div class="line"></div><div class="line">Output: &quot;Neither&quot;</div><div class="line"></div><div class="line">Explanation: This is neither a IPv4 address nor a IPv6 address.</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">validIPAddress</span><span class="params">(String IP)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (IP == <span class="keyword">null</span> || IP.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"Neither"</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (IP.contains(<span class="string">":"</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> IPV6(IP) ? <span class="string">"IPv6"</span> : <span class="string">"Neither"</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> IPV4(IP) ? <span class="string">"IPv4"</span> : <span class="string">"Neither"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">IPV6</span><span class="params">(String ip)</span> </span>&#123;</div><div class="line">        String[] temp = ip.split(<span class="string">":"</span>,-<span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (temp.length != <span class="number">8</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (String element : temp) &#123;</div><div class="line">            <span class="keyword">if</span> (element.isEmpty() || element.length() &gt; <span class="number">4</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;element.length();i++)&#123;</div><div class="line">                <span class="keyword">char</span> ch = element.charAt(i);</div><div class="line">                <span class="keyword">if</span>(!((ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) || (ch&gt;=<span class="string">'a'</span> &amp;&amp; ch&lt;=<span class="string">'f'</span>) || (ch&gt;=<span class="string">'A'</span> &amp;&amp;ch&lt;=<span class="string">'F'</span>))) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">IPV4</span><span class="params">(String ip)</span> </span>&#123;</div><div class="line">        String[] temp = ip.split(<span class="string">"\\."</span>,-<span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (temp.length != <span class="number">4</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (String element : temp) &#123;</div><div class="line">            <span class="keyword">if</span> (element.isEmpty()) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (element.length() &gt; <span class="number">1</span> &amp;&amp; element.charAt(<span class="number">0</span>) == <span class="string">'0'</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;   <span class="comment">// leading zero is invalid</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (element.length() &gt; <span class="number">3</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (element.compareTo(<span class="string">"0"</span>) &lt; <span class="number">0</span> || element.compareTo(<span class="string">"255"</span>) &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[556. Next Great Element III]]></title>
      <url>/2017/07/06/2017-07-06-556-Next-Great-Element-III/</url>
      <content type="html"><![CDATA[<p>Given a positive 32-bit integer n, you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive 32-bit integer exists, you need to return -1.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: 12</div><div class="line">Output: 21</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: 21</div><div class="line">Output: -1</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>用next permutation的算法来解，先把n转换成一个数字的数组，然后接下的算法就是一致的了。<br>要注意的是算出来的答案可能会overflow,所以要判断一下是否overflow。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextGreaterElement</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> len = (<span class="keyword">int</span>)Math.log10(n) + <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span>[] digits = <span class="keyword">new</span> <span class="keyword">int</span>[len];</div><div class="line"></div><div class="line">        <span class="keyword">int</span> i = len - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</div><div class="line">            digits[i--] = n % <span class="number">10</span>;</div><div class="line">            n /= <span class="number">10</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Use the next permutation algorithm</span></div><div class="line">        <span class="keyword">int</span> pivot = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">if</span> (digits[i] &lt; digits[i + <span class="number">1</span>]) &#123;</div><div class="line">                pivot = i;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (pivot == -<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (i = len - <span class="number">1</span>; i &gt; pivot; i--) &#123;</div><div class="line">            <span class="keyword">if</span> (digits[i] &gt; digits[pivot]) &#123;</div><div class="line">                <span class="keyword">int</span> temp = digits[i];</div><div class="line">                digits[i] = digits[pivot];</div><div class="line">                digits[pivot] = temp;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> j;</div><div class="line">        <span class="keyword">for</span> (i = pivot + <span class="number">1</span>, j = len - <span class="number">1</span>; i &lt; j; i++,j--) &#123;</div><div class="line">            <span class="keyword">int</span> temp = digits[i];</div><div class="line">            digits[i] = digits[j];</div><div class="line">            digits[j] = temp;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// combine</span></div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="number">10</span> || (res == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; res % <span class="number">10</span> &gt; Integer.MAX_VALUE % <span class="number">10</span>)) &#123;</div><div class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            res = res * <span class="number">10</span> + digits[i];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[271. Encode and Decode Strings]]></title>
      <url>/2017/07/06/2017-07-06-271-Encode-and-Decode-Strings/</url>
      <content type="html"><![CDATA[<p>Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings.</p>
<p>Machine 1 (sender) has the function:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">string encode(vector&lt;string&gt; strs) &#123;</div><div class="line"> // ... your code</div><div class="line"> return encoded_string;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Machine 2 (receiver) has the function:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vector&lt;string&gt; decode(string s) &#123;</div><div class="line"> //... your code</div><div class="line"> return strs;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>So Machine 1 does:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">string encoded_string = encode(strs);</div></pre></td></tr></table></figure></p>
<p>and Machine 2 does:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vector&lt;string&gt; strs2 = decode(encoded_string);</div></pre></td></tr></table></figure></p>
<p>strs2 in Machine 2 should be the same as strs in Machine 1.</p>
<p>Implement the encode and decode methods.</p>
<p>Note:</p>
<p>   The string may contain any possible characters out of 256 valid ascii characters. Your algorithm should be generalized enough to work on any possible characters.<br>   Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.<br>   Do not rely on any library method such as eval or serialize methods. You should implement your own encode/decode algorithm.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>把每一个string里的字符转换成ascii码，用一个＃分隔。同时每一个字符串间用，分隔。<br>要注意的是，在decode的时候可能会出现,,的情况，所以要用string.split(pattern, -1)来保留所有的empty string</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// Encodes a list of strings to a single string.</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encode</span><span class="params">(List&lt;String&gt; strs)</span> </span>&#123;</div><div class="line">       StringBuilder builder = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span> (String str : strs) &#123;</div><div class="line">            <span class="keyword">char</span>[] chars = str.toCharArray();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</div><div class="line">                builder.append(<span class="string">""</span> + Integer.toString((<span class="keyword">int</span>)c));</div><div class="line">                builder.append(<span class="string">"#"</span>);</div><div class="line">            &#125;</div><div class="line">            builder.append(<span class="string">","</span>);</div><div class="line">            <span class="comment">// if (!str.length() == 0) &#123;</span></div><div class="line">            <span class="comment">//     builder.append("#");</span></div><div class="line">            <span class="comment">// &#125;</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> builder.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Decodes a single string to a list of strings.</span></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">decode</span><span class="params">(String s)</span> </span>&#123;</div><div class="line"></div><div class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isEmpty()) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String[] components = s.substring(<span class="number">0</span>, s.length() - <span class="number">1</span>).split(<span class="string">","</span>,-<span class="number">1</span>);    <span class="comment">// Remove the "," at the end of the string</span></div><div class="line">        <span class="keyword">for</span> (String element : components) &#123;</div><div class="line">            StringBuilder builder = <span class="keyword">new</span> StringBuilder();</div><div class="line">            String[] codes = element.split(<span class="string">"#"</span>);</div><div class="line">            <span class="keyword">for</span> (String code : codes) &#123;</div><div class="line">                <span class="keyword">if</span> (!code.isEmpty()) &#123;</div><div class="line">                    builder.append((<span class="keyword">char</span>)Integer.parseInt(code));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            res.add(builder.length() == <span class="number">0</span> ? <span class="string">""</span> : builder.toString());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></div><div class="line"><span class="comment">// Codec codec = new Codec();</span></div><div class="line"><span class="comment">// codec.decode(codec.encode(strs));</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[227. Basic Calculator II]]></title>
      <url>/2017/07/06/2017-07-06-227-Basic-Calculator-II/</url>
      <content type="html"><![CDATA[<p>Implement a basic calculator to evaluate a simple expression string.</p>
<p>The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero.</p>
<p>You may assume that the given expression is always valid.</p>
<p>Some examples:</p>
<p>“3+2*2” = 7<br>“ 3/2 “ = 1<br>“ 3+5 / 2 “ = 5</p>
<p>Note: Do not use the eval built-in library function.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>用一个stack来存储中间结果。遇上×，／的时候计算之前的操作，遇上＋／－的时候只有在之前的操作为同一优先级的时候才计算。<br>写的比较繁琐，不如leetcode上的答案好。答案里不需要有stack, 用一个preVal来记录上一个计算的结果，只有当当前操作为加或者减的时候才需要把上一次更新的结果并入最终的结果。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</div><div class="line"></div><div class="line">        Stack&lt;Integer&gt; operands = <span class="keyword">new</span> Stack&lt;Integer&gt;();</div><div class="line">        Stack&lt;String&gt; operators = <span class="keyword">new</span> Stack&lt;String&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt; s.length()) &#123;</div><div class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span>) &#123;</div><div class="line">                i++;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'+'</span> || s.charAt(i) == <span class="string">'-'</span>)&#123;</div><div class="line">                <span class="keyword">if</span> (!operators.empty()) &#123;</div><div class="line">                    <span class="keyword">int</span> right = operands.pop();</div><div class="line">                    <span class="keyword">int</span> left = operands.pop();</div><div class="line">                    String last = operators.pop();</div><div class="line">                    <span class="keyword">if</span> (last.equals(<span class="string">"+"</span>)) &#123;</div><div class="line">                        operands.push(left + right);</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (last.equals(<span class="string">"-"</span>)) &#123;</div><div class="line">                        operands.push(left - right);</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (last.equals(<span class="string">"*"</span>)) &#123;</div><div class="line">                        operands.push(left * right);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        operands.push(left / right);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                operators.push(s.substring(i, i + <span class="number">1</span>));</div><div class="line">                i++;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'*'</span> || s.charAt(i) == <span class="string">'/'</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (!operators.empty()) &#123;</div><div class="line">                    String last = operators.peek();</div><div class="line">                    <span class="keyword">if</span> (last.equals(<span class="string">"*"</span>)) &#123;</div><div class="line">                        operators.pop();</div><div class="line">                        <span class="keyword">int</span> right = operands.pop();</div><div class="line">                        <span class="keyword">int</span> left = operands.pop();</div><div class="line">                        operands.push(left * right);</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (last.equals(<span class="string">"/"</span>)) &#123;</div><div class="line">                        operators.pop();</div><div class="line">                        <span class="keyword">int</span> right = operands.pop();</div><div class="line">                        <span class="keyword">int</span> left = operands.pop();</div><div class="line">                        operands.push(left / right);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                operators.push(s.substring(i, i + <span class="number">1</span>));</div><div class="line">                i++;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">int</span> j = i + <span class="number">1</span>;</div><div class="line">                <span class="keyword">while</span> (j &lt; s.length() &amp;&amp; s.charAt(j) &gt;= <span class="string">'0'</span> &amp;&amp; s.charAt(j) &lt;= <span class="string">'9'</span>) &#123;</div><div class="line">                    j++;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">int</span> element = Integer.parseInt(s.substring(i, j));</div><div class="line">                <span class="comment">// check if there is valid * or / operators</span></div><div class="line">                <span class="keyword">if</span> (!operators.empty()) &#123;</div><div class="line">                    <span class="keyword">if</span> (operators.peek().equals(<span class="string">"*"</span>)) &#123;</div><div class="line">                        operators.pop();</div><div class="line">                        <span class="keyword">int</span> left = operands.pop();</div><div class="line">                        operands.push(left * element);</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operators.peek().equals(<span class="string">"/"</span>)) &#123;</div><div class="line">                        operators.pop();</div><div class="line">                        <span class="keyword">int</span> left = operands.pop();</div><div class="line">                        operands.push(left / element);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        operands.push(element);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    operands.push(element);                </div><div class="line">                &#125;</div><div class="line">                i = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// empty operators until it is empty</span></div><div class="line">        <span class="keyword">while</span> (!operators.empty()) &#123;</div><div class="line">            String operator = operators.pop();</div><div class="line">            <span class="keyword">int</span> right = operands.pop();</div><div class="line">            <span class="keyword">int</span> left = operands.pop();</div><div class="line">            <span class="keyword">if</span> (operator.equals(<span class="string">"*"</span>)) &#123;</div><div class="line">                operands.push(left * right);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operator.equals(<span class="string">"/"</span>)) &#123;</div><div class="line">                operands.push(left / right);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operator.equals(<span class="string">"+"</span>)) &#123;</div><div class="line">                operands.push(left + right);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                operands.push(left - right);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> operands.pop();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>###解法２：　###<br>答案来自与leetcode<br>Java<br><figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public int calculate(String s) &#123;</div><div class="line">    if (s == null) return 0;</div><div class="line">    s = s.trim().replaceAll(&quot; +&quot;, &quot;&quot;);</div><div class="line">    int length = s.length();</div><div class="line"></div><div class="line">    int res = 0;</div><div class="line">    long preVal = 0; // initial preVal is 0</div><div class="line">    char sign = &apos;+&apos;; // initial sign is +</div><div class="line">    int i = 0;</div><div class="line">    while (i &lt; length) &#123;</div><div class="line">        long curVal = 0;</div><div class="line">        while (i &lt; length &amp;&amp; (int)s.charAt(i) &lt;= 57 &amp;&amp; (int)s.charAt(i) &gt;= 48) &#123; // int</div><div class="line">            curVal = curVal*10 + (s.charAt(i) - &apos;0&apos;);</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        if (sign == &apos;+&apos;) &#123;</div><div class="line">            res += preVal;  // update res</div><div class="line">            preVal = curVal;</div><div class="line">        &#125; else if (sign == &apos;-&apos;) &#123;</div><div class="line">            res += preVal;  // update res</div><div class="line">            preVal = -curVal;</div><div class="line">        &#125; else if (sign == &apos;*&apos;) &#123;</div><div class="line">            preVal = preVal * curVal; // not update res, combine preVal &amp; curVal and keep loop</div><div class="line">        &#125; else if (sign == &apos;/&apos;) &#123;</div><div class="line">            preVal = preVal / curVal; // not update res, combine preVal &amp; curVal and keep loop</div><div class="line">        &#125;</div><div class="line">        if (i &lt; length) &#123; // getting new sign</div><div class="line">            sign = s.charAt(i);</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    res += preVal;</div><div class="line">    return res;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[161. One Edit Distance]]></title>
      <url>/2017/07/06/2017-07-06-161-One-Edit-Distance/</url>
      <content type="html"><![CDATA[<p>Given two strings S and T, determine if they are both one edit distance apart.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>这题一开始如果用dp做的话需要O(MN)的复杂度，TLE了。那么一定有更简便的方法。<br>这里呢用到了edit distance的性质。对于edit distance为１的两个string,只可能存在下面三种情况。<br>长度相等 =&gt; 有且仅有一个字符不一样<br>长度不相等，　那么如果删掉左面string的一个字符或者是右面的一个字符。<br>最后还要比较一下两者的长度是否只差１。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOneEditDistance</span><span class="params">(String s, String t)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> m = s.length(), n = t.length();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.min(m, n); i++) &#123;</div><div class="line">            <span class="keyword">if</span> (s.charAt(i) != t.charAt(i)) &#123;</div><div class="line">                <span class="keyword">if</span> (m == n) &#123;</div><div class="line">                    <span class="keyword">return</span> s.substring(i+<span class="number">1</span>).equals(t.substring(i+<span class="number">1</span>));</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m &gt; n) &#123;</div><div class="line">                    <span class="keyword">return</span> s.substring(i+<span class="number">1</span>).equals(t.substring(i));</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">return</span> s.substring(i).equals(t.substring(i+<span class="number">1</span>));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> Math.abs(m - n) == <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[553. Optimal Division]]></title>
      <url>/2017/07/05/2017-07-05-553-Optimal-Division/</url>
      <content type="html"><![CDATA[<p>Given a list of positive integers, the adjacent integers will perform the float division. For example, [2,3,4] -&gt; 2 / 3 / 4.</p>
<p>However, you can add any number of parenthesis at any position to change the priority of operations. You should find out how to add parenthesis to get the maximum result, and return the corresponding expression in string format. Your expression should NOT contain redundant parenthesis.</p>
<p>Example:<br>Input: [1000,100,10,2]<br>Output: “1000/(100/10/2)”<br>Explanation:<br>1000/(100/10/2) = 1000/((100/10)/2) = 200<br>However, the bold parenthesis in “1000/((100/10)/2)” are redundant,<br>since they don’t influence the operation priority. So you should return “1000/(100/10/2)”.</p>
<p>Other cases:<br>1000/(100/10)/2 = 50<br>1000/(100/(10/2)) = 50<br>1000/100/10/2 = 0.5<br>1000/100/(10/2) = 2<br>Note:</p>
<p>The length of the input array is [1, 10].<br>Elements in the given array will be in range [2, 1000].<br>There is only one optimal division for each test case.</p>
<h3 id="解法1：O-N-3"><a href="#解法1：O-N-3" class="headerlink" title="解法1：O(N^3)"></a>解法1：O(N^3)</h3><p>这题的数学解法比较无聊，也不觉得对锻炼思路有帮助。倒是这个divide &amp; conquer的解法很清楚明白。题目一拿到比较懵，如果细细思考可以想到。要得到最大值，需要dividend最大,divisor最小。那么就可以不停的尝试分割的位置，然后维护每一个子段的最大最小值以及产生最大最小值分割的括号摆放字符串。这里就需要用一个辅助class。<br>同时为了减少time complexity, 用一个二维数组做memorization来记录每一个子串的中间结果。</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</div><div class="line">        <span class="keyword">float</span> max_val, min_val;</div><div class="line">        String min_str, max_str;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">optimalDivision</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        T[][] memo = <span class="keyword">new</span> T[nums.length][nums.length];</div><div class="line">        T t = optimal(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, <span class="string">""</span>, memo);</div><div class="line">        <span class="keyword">return</span> t.max_str;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">optimal</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, String res, T[][] memo)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (memo[start][end] != <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> memo[start][end];</div><div class="line">        T t = <span class="keyword">new</span> T();</div><div class="line">        <span class="keyword">if</span> (start == end) &#123;</div><div class="line">            t.max_val = nums[start];</div><div class="line">            t.min_val = nums[start];</div><div class="line">            t.min_str = <span class="string">""</span> + nums[start];</div><div class="line">            t.max_str = <span class="string">""</span> + nums[start];</div><div class="line">            memo[start][end] = t;</div><div class="line">            <span class="keyword">return</span> t;</div><div class="line">        &#125;</div><div class="line">        t.min_val = Float.MAX_VALUE;</div><div class="line">        t.max_val = Float.MIN_VALUE;</div><div class="line">        t.min_str = t.max_str = <span class="string">""</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</div><div class="line">            T left = optimal(nums, start, i, <span class="string">""</span>, memo);</div><div class="line">            T right = optimal(nums, i + <span class="number">1</span>, end, <span class="string">""</span>, memo);</div><div class="line">            <span class="keyword">if</span> (t.min_val &gt; left.min_val / right.max_val) &#123;</div><div class="line">                t.min_val = left.min_val / right.max_val;</div><div class="line">                t.min_str = left.min_str + <span class="string">"/"</span> + (i + <span class="number">1</span> != end ? <span class="string">"("</span> : <span class="string">""</span>) + right.max_str + (i + <span class="number">1</span> != end ? <span class="string">")"</span> : <span class="string">""</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (t.max_val &lt; left.max_val / right.min_val) &#123;</div><div class="line">                t.max_val = left.max_val / right.min_val;</div><div class="line">                t.max_str = left.max_str + <span class="string">"/"</span> + (i + <span class="number">1</span> != end ? <span class="string">"("</span> : <span class="string">""</span>) + right.min_str + (i + <span class="number">1</span> != end ? <span class="string">")"</span> : <span class="string">""</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        memo[start][end] = t;</div><div class="line">        <span class="keyword">return</span> t;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Divide &amp; Conquer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[165. Compare Version Numbers]]></title>
      <url>/2017/07/05/2017-07-05-165-Compare-Version-Numbers/</url>
      <content type="html"><![CDATA[<p>Compare two version numbers version1 and version2.<br>If version1 &gt; version2 return 1, if version1 &lt; version2 return -1, otherwise return 0.</p>
<p>You may assume that the version strings are non-empty and contain only digits and the . character.<br>The . character does not represent a decimal point and is used to separate number sequences.<br>For instance, 2.5 is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision.</p>
<p>Here is an example of version numbers ordering:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0.1 &lt; 1.1 &lt; 1.2 &lt; 13.37</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>应该算简单题。要注意的一点是java里string.split(regex), 如果是特殊字符比如”.”的时候，要注意escape。然后每一位比较，如果有一个字符串比较短，就把他对应的位看成是0。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(String version1, String version2)</span> </span>&#123;</div><div class="line"></div><div class="line">        String[] v1 = version1.split(<span class="string">"\\."</span>);</div><div class="line">        String[] v2 = version2.split(<span class="string">"\\."</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =  <span class="number">0</span>; i &lt; Math.max(v1.length, v2.length); i++) &#123;</div><div class="line">             <span class="keyword">int</span> v1number = i &lt; v1.length ? Integer.parseInt(v1[i]) : <span class="number">0</span>;</div><div class="line">            <span class="keyword">int</span> v2number = i &lt; v2.length ? Integer.parseInt(v2[i]) : <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (v1number &gt; v2number) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v1number &lt; v2number) &#123;</div><div class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[544. Output Contest Matches]]></title>
      <url>/2017/07/05/2017-07-05-544-Output-Contest-Matches/</url>
      <content type="html"><![CDATA[<p>During the NBA playoffs, we always arrange the rather strong team to play with the rather weak team, like make the rank 1 team play with the rank nth team, which is a good strategy to make the contest more interesting. Now, you’re given n teams, you need to output their final contest matches in the form of a string.</p>
<p>The n teams are given in the form of positive integers from 1 to n, which represents their initial rank. (Rank 1 is the strongest team and Rank n is the weakest team.) We’ll use parentheses(‘(‘, ‘)’) and commas(‘,’) to represent the contest team pairing - parentheses(‘(‘ , ‘)’) for pairing and commas(‘,’) for partition. During the pairing process in each round, you always need to follow the strategy of making the rather strong one pair with the rather weak one.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Input: 2</div><div class="line">Output: (1,2)</div><div class="line">Explanation:</div><div class="line">Initially, we have the team 1 and the team 2, placed like: 1,2.</div><div class="line">Then we pair the team (1,2) together with &apos;(&apos;, &apos;)&apos; and &apos;,&apos;, which is the final answer.</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Input: 4</div><div class="line">Output: ((1,4),(2,3))</div><div class="line">Explanation:</div><div class="line">In the first round, we pair the team 1 and 4, the team 2 and 3 together, as we need to make the strong team and weak team together.</div><div class="line">And we got (1,4),(2,3).</div><div class="line">In the second round, the winners of (1,4) and (2,3) need to play again to generate the final winner, so you need to add the paratheses outside them.</div><div class="line">And we got the final answer ((1,4),(2,3)).</div></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Input: 8</div><div class="line">Output: (((1,8),(4,5)),((2,7),(3,6)))</div><div class="line">Explanation:</div><div class="line">First round: (1,8),(2,7),(3,6),(4,5)</div><div class="line">Second round: ((1,8),(4,5)),((2,7),(3,6))</div><div class="line">Third round: (((1,8),(4,5)),((2,7),(3,6)))</div><div class="line">Since the third round will generate the final winner, you need to output the answer (((1,8),(4,5)),((2,7),(3,6))).</div></pre></td></tr></table></figure></p>
<p>Note:<br>The n is in range [2, 212].<br>We ensure that the input n can be converted into the form 2k, where k is a positive integer.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>题目一开始没理解。主要的思路就是每次缩短1/2，把排名第一的组合和排名最后的组合放在一起。<br>用递归或者是iteration都可以做。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findContestMatch</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"></div><div class="line">        List&lt;String&gt; matches = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">            matches.add(<span class="string">""</span> + i);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (matches.size() != <span class="number">1</span>) &#123;</div><div class="line">            List&lt;String&gt; round = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matches.size() / <span class="number">2</span>; i++) &#123;</div><div class="line">                round.add(<span class="string">"("</span> + matches.get(i) + <span class="string">","</span> + matches.get(matches.size() - <span class="number">1</span> -i) + <span class="string">")"</span>);</div><div class="line">            &#125;</div><div class="line">            matches = round;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> matches.get(<span class="number">0</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[635. Design Log Storage System]]></title>
      <url>/2017/07/05/2017-07-05-635-Design-Log-Storage-System/</url>
      <content type="html"><![CDATA[<p>You are given several logs that each log contains a unique id and timestamp. Timestamp is a string that has the following format: Year:Month:Day:Hour:Minute:Second, for example, 2017:01:01:23:59:59. All domains are zero-padded decimal numbers.</p>
<p>Design a log storage system to implement the following functions:</p>
<p>void Put(int id, string timestamp): Given a log’s unique id and timestamp, store the log in your storage system.</p>
<p>int[] Retrieve(String start, String end, String granularity): Return the id of logs whose timestamps are within the range from start to end. Start and end all have the same format as timestamp. However, granularity means the time level for consideration. For example, start = “2017:01:01:23:59:59”, end = “2017:01:02:23:59:59”, granularity = “Day”, it means that we need to find the logs within the range from Jan. 1st 2017 to Jan. 2nd 2017.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">put(1, &quot;2017:01:01:23:59:59&quot;);</div><div class="line">put(2, &quot;2017:01:01:22:59:59&quot;);</div><div class="line">put(3, &quot;2016:01:01:00:00:00&quot;);</div><div class="line">retrieve(&quot;2016:01:01:01:01:01&quot;,&quot;2017:01:01:23:00:00&quot;,&quot;Year&quot;); // return [1,2,3], because you need to return all logs within 2016 and 2017.</div><div class="line">retrieve(&quot;2016:01:01:01:01:01&quot;,&quot;2017:01:01:23:00:00&quot;,&quot;Hour&quot;); // return [1,2], because you need to return all logs start from 2016:01:01:01 to 2017:01:01:23, where log 3 is left outside the range.</div></pre></td></tr></table></figure></p>
<p>Note:<br>There will be at most 300 operations of Put or Retrieve.<br>Year ranges from [2000,2017]. Hour ranges from [00,23].<br>Output for Retrieve has no order required.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>用一个hashmap来存储log,这题的考点主要在retrieve上。retrieve的时候可以按照gra来截取相关的子串，然后和start, end直接比较大小就可以。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogSystem</span> </span>&#123;</div><div class="line"></div><div class="line">    HashMap&lt;Integer, String&gt; map;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogSystem</span><span class="params">()</span> </span>&#123;</div><div class="line">        map = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> id, String timestamp)</span> </span>&#123;</div><div class="line">        map.put(id, timestamp);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">retrieve</span><span class="params">(String s, String e, String gra)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</div><div class="line">        <span class="keyword">switch</span> (gra) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="string">"Year"</span>:</div><div class="line">                x = <span class="number">4</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"Month"</span>:</div><div class="line">                x = <span class="number">7</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"Day"</span>:</div><div class="line">                x = <span class="number">10</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"Hour"</span>:</div><div class="line">                x = <span class="number">13</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"Minute"</span>:</div><div class="line">                x = <span class="number">16</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"Second"</span>:</div><div class="line">                x = <span class="number">19</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        String start = s.substring(<span class="number">0</span>, x);</div><div class="line">        String end = e.substring(<span class="number">0</span>, x);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> id : map.keySet()) &#123;</div><div class="line">            String record = map.get(id).substring(<span class="number">0</span>,x);</div><div class="line">            <span class="keyword">if</span> (record.compareTo(start) &gt;= <span class="number">0</span> &amp;&amp; record.compareTo(end) &lt;= <span class="number">0</span>) &#123;</div><div class="line">                res.add(id);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Your LogSystem object will be instantiated and called as such:</span></div><div class="line"><span class="comment"> * LogSystem obj = new LogSystem();</span></div><div class="line"><span class="comment"> * obj.put(id,timestamp);</span></div><div class="line"><span class="comment"> * List&lt;Integer&gt; param_2 = obj.retrieve(s,e,gra);</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[583. Delete Operation for Two String]]></title>
      <url>/2017/07/05/2017-07-05-583-Delete-Operation-for-Two-String/</url>
      <content type="html"><![CDATA[<p>Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input: &quot;sea&quot;, &quot;eat&quot;</div><div class="line">Output: 2</div><div class="line">Explanation: You need one step to make &quot;sea&quot; to &quot;ea&quot; and another step to make &quot;eat&quot; to &quot;ea&quot;.</div></pre></td></tr></table></figure></p>
<p>Note:<br>The length of given words won’t exceed 500.<br>Characters in given words can only be lower-case letters.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>这题和edit distance的思路一样。用二维dp即可解决。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> m = word1.length();</div><div class="line">        <span class="keyword">int</span> n = word2.length();</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</div><div class="line"></div><div class="line">        <span class="comment">// first row</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</div><div class="line">            dp[<span class="number">0</span>][i] = i;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// first col</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</div><div class="line">            dp[i][<span class="number">0</span>] = i;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</div><div class="line">                    dp[i][j] = Math.min(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, Math.min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j - <span class="number">1</span>]));</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    dp[i][j] = Math.min(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, Math.min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> dp[m][n];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[616. Add Bold Tag in String]]></title>
      <url>/2017/07/05/2017-07-05-616-Add-Bold-Tag-in-String/</url>
      <content type="html"><![CDATA[<p>Given a string s and a list of strings dict, you need to add a closed pair of bold tag <b> and </b> to wrap the substrings in s that exist in dict. If two such substrings overlap, you need to wrap them together by only one pair of closed bold tag. Also, if two substrings wrapped by bold tags are consecutive, you need to combine them.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">s = &quot;abcxyz123&quot;</div><div class="line">dict = [&quot;abc&quot;,&quot;123&quot;]</div><div class="line">Output:</div><div class="line">&quot;&lt;b&gt;abc&lt;/b&gt;xyz&lt;b&gt;123&lt;/b&gt;&quot;</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">s = &quot;aaabbcc&quot;</div><div class="line">dict = [&quot;aaa&quot;,&quot;aab&quot;,&quot;bc&quot;]</div><div class="line">Output:</div><div class="line">&quot;&lt;b&gt;aaabbc&lt;/b&gt;c&quot;</div></pre></td></tr></table></figure></p>
<p>Note:<br>The given dict won’t contain duplicates, and its length won’t exceed 100.<br>All the strings in input have length in range [1, 1000].</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>这题可以分成两个部分，第一个部分是找出来所有在字典中出现的词。<br>这一步可以遍历字典，按照每一个词的长度来遍历原字符串来找出出现的位置。可以用一个array来存储每一个词出现的(start, end)。<br>然后问题就变成，要把这些pair先merge一下，然后头尾加上tag即可。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addBoldTag</span><span class="params">(String s, String[] dict)</span> </span>&#123;</div><div class="line"></div><div class="line">        List&lt;<span class="keyword">int</span>[]&gt; pairs = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (String d : dict) &#123;</div><div class="line">            <span class="keyword">int</span> len = d.length();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.length() - len; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (d.equals(s.substring(i, i + len))) &#123;</div><div class="line">                    pairs.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i,i + len - <span class="number">1</span>&#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        Collections.sort(pairs, (a, b) -&gt; a[<span class="number">0</span>] == b[<span class="number">0</span>] ? a[<span class="number">1</span>] - b[<span class="number">1</span>] : a[<span class="number">0</span>] - b[<span class="number">0</span>]);</div><div class="line"></div><div class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pairs.size(); i++) &#123;</div><div class="line">            builder.append(s.substring(prev, pairs.get(i)[<span class="number">0</span>]));</div><div class="line">            <span class="comment">// Merge intervals</span></div><div class="line">            <span class="keyword">int</span> start = pairs.get(i)[<span class="number">0</span>];</div><div class="line">            <span class="keyword">int</span> end = pairs.get(i)[<span class="number">1</span>];</div><div class="line">            <span class="keyword">while</span> (i &lt; pairs.size() - <span class="number">1</span> &amp;&amp; pairs.get(i + <span class="number">1</span>)[<span class="number">0</span>] &lt;= end + <span class="number">1</span>) &#123;</div><div class="line">                end = Math.max(end, pairs.get(i + <span class="number">1</span>)[<span class="number">1</span>]);</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            builder.append(<span class="string">"&lt;b&gt;"</span> + s.substring(start, end + <span class="number">1</span>) + <span class="string">"&lt;/b&gt;"</span>);</div><div class="line">            prev = end + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        builder.append(s.substring(prev, s.length()));</div><div class="line"></div><div class="line">        <span class="keyword">return</span> builder.toString();        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[43. Multiply Strings]]></title>
      <url>/2017/07/02/2017-07-02-43-Multiply-Strings/</url>
      <content type="html"><![CDATA[<p>Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2.</p>
<p>Note:</p>
<pre><code>The length of both num1 and num2 is &lt; 110.
Both num1 and num2 contains only digits 0-9.
Both num1 and num2 does not contain any leading zero.
You must not use any built-in BigInteger library or convert the inputs to integer directly.
</code></pre><h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>按位相乘，注意把中间结果要存储在一个res[length1 + length2]的数组里。<br>然后从后往前扫描，比较容易错的是对应的res的数组的位置。要特别注意一下。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (num1.length() == <span class="number">0</span> || num2.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] digits = <span class="keyword">new</span> <span class="keyword">int</span>[num1.length() + num2.length()];</div><div class="line">        <span class="comment">// Start from the last digit in num2, i.e. the bottom one</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num2.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">int</span> carry = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = num1.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</div><div class="line">                <span class="keyword">int</span> temp = carry + (num1.charAt(j) - <span class="string">'0'</span>)*(num2.charAt(i) - <span class="string">'0'</span>) + digits[num2.length() - <span class="number">1</span> - i + num1.length() - <span class="number">1</span> -j];</div><div class="line">                digits[num2.length() - <span class="number">1</span> - i + num1.length() - <span class="number">1</span> -j] = temp % <span class="number">10</span>;</div><div class="line">                carry = temp / <span class="number">10</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</div><div class="line">                digits[num1.length() + num2.length() - <span class="number">1</span> - i] = carry;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = digits.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</div><div class="line">            <span class="keyword">int</span> temp = digits[i];</div><div class="line">            digits[i] = digits[j];</div><div class="line">            digits[j] = temp;</div><div class="line">            i++;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; digits.length; k++) &#123;</div><div class="line">            <span class="keyword">if</span> (builder.length() == <span class="number">0</span> &amp;&amp; digits[k] == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            builder.append(digits[k]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (builder.length() == <span class="number">0</span>) &#123;</div><div class="line">            builder.append(<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> builder.toString();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[22. Generate Parentheses]]></title>
      <url>/2017/07/02/2017-07-02-22-Generate-Parentheses/</url>
      <content type="html"><![CDATA[<p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given n = 3, a solution set is:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line"> &quot;((()))&quot;,</div><div class="line"> &quot;(()())&quot;,</div><div class="line"> &quot;(())()&quot;,</div><div class="line"> &quot;()(())&quot;,</div><div class="line"> &quot;()()()&quot;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>比较经典的DFS题目,dfs的思想要掌握<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line"></div><div class="line">        helper(<span class="string">""</span>, res, n, n);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(String current, List&lt;String&gt; res, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</div><div class="line">            res.add(current);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</div><div class="line">            helper(current + <span class="string">"("</span>, res, left - <span class="number">1</span>, right);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (right &gt; <span class="number">0</span> &amp;&amp; left &lt; right) &#123;</div><div class="line">            helper(current + <span class="string">")"</span>, res, left, right - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[151. Reverse Words in a String]]></title>
      <url>/2017/07/02/2017-07-02-151-Reverse-Words-in-a-String/</url>
      <content type="html"><![CDATA[<p>Given an input string, reverse the string word by word.</p>
<p>For example,<br>Given s = “the sky is blue”,<br>return “blue is sky the”.</p>
<p>Update (2015-02-12):<br>For C programmers: Try to solve it in-place in O(1) space.</p>
<p>Clarification:</p>
<pre><code>What constitutes a word?
A sequence of non-space characters constitutes a word.
Could the input string contain leading or trailing spaces?
Yes. However, your reversed string should not contain leading or trailing spaces.
How about multiple spaces between two words?
Reduce them to a single space in the reversed string.
</code></pre><h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>用一个stack来存储每一个找出来的word，然后再一个个pop出来同时加上space<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> s;</div><div class="line">        &#125;</div><div class="line">        Stack&lt;String&gt; words = <span class="keyword">new</span> Stack&lt;String&gt;();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt; s.length()) &#123;</div><div class="line">            <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; s.charAt(i) == <span class="string">' '</span>) &#123;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            j = i + <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (j &lt; s.length() &amp;&amp; s.charAt(j) != <span class="string">' '</span>) &#123;</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (i &lt; s.length()) &#123;</div><div class="line">                words.push(s.substring(i, j));</div><div class="line">            &#125;</div><div class="line">            i = j;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (!words.empty()) &#123;</div><div class="line">            builder.append(words.pop());</div><div class="line">            builder.append(<span class="string">' '</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (builder.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">            builder.setLength(builder.length() - <span class="number">1</span>);        </div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> builder.toString();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[6. ZigZag Conversion]]></title>
      <url>/2017/07/02/2017-07-02-6-ZigZag-Conversion/</url>
      <content type="html"><![CDATA[<p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">P   A   H   N</div><div class="line">A P L S I I G</div><div class="line">Y   I   R</div></pre></td></tr></table></figure></p>
<p>And then read line by line: “PAHNAPLSIIGYIR”</p>
<p>Write the code that will take a string and make this conversion given a number of rows:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">string convert(string text, int nRows);</div></pre></td></tr></table></figure></p>
<p>convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”.</p>
<h3 id="解法1：O-N-Time-O-N-Space"><a href="#解法1：O-N-Time-O-N-Space" class="headerlink" title="解法1：O(N) Time + O(N) Space"></a>解法1：O(N) Time + O(N) Space</h3><p>这题的数学解法很难想，也比较花时间。很直观的做法倒是不错。就每一行用一个stringbuilder，然后一行行的塞。先从上往下，再从下往上斜着填。<br>当所有数字填满了之后把stringbuilder连起来就可以了。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</div><div class="line"></div><div class="line">        StringBuilder[] builders = <span class="keyword">new</span> StringBuilder[numRows];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</div><div class="line">            builders[i] = <span class="keyword">new</span> StringBuilder();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (pos &lt; s.length()) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows &amp;&amp; pos &lt; s.length(); i++) &#123;</div><div class="line">                builders[i].append(s.charAt(pos++));</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = numRows - <span class="number">2</span>; i &gt;= <span class="number">1</span> &amp;&amp; pos &lt; s.length(); i--) &#123;</div><div class="line">                builders[i].append(s.charAt(pos++));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numRows; i++) &#123;</div><div class="line">            builders[<span class="number">0</span>].append(builders[i]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> builders[<span class="number">0</span>].toString();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[521. Longest Uncommon Subsequence I]]></title>
      <url>/2017/07/02/2017-07-02-521-Longest-Uncommon-Subsequence-I/</url>
      <content type="html"><![CDATA[<p>Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.</p>
<p>A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.</p>
<p>The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn’t exist, return -1.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Input: &quot;aba&quot;, &quot;cdc&quot;</div><div class="line">Output: 3</div><div class="line">Explanation: The longest uncommon subsequence is &quot;aba&quot; (or &quot;cdc&quot;),</div><div class="line">because &quot;aba&quot; is a subsequence of &quot;aba&quot;,</div><div class="line">but not a subsequence of any other strings in the group of two strings.</div></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>   Both strings’ lengths will not exceed 100.<br>   Only letters from a ~ z will appear in input strings.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLUSlength</span><span class="params">(String a, String b)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (a.equals(b)) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> Math.max(a.length(), b.length());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[551. Student Attendance Record I]]></title>
      <url>/2017/07/02/2017-07-02-551-Student-Attendance-Record-I/</url>
      <content type="html"><![CDATA[<p>You are given a string representing an attendance record for a student. The record only contains the following three characters:</p>
<pre><code>&apos;A&apos; : Absent.
&apos;L&apos; : Late.
&apos;P&apos; : Present.
</code></pre><p>A student could be rewarded if his attendance record doesn’t contain more than one ‘A’ (absent) or more than two continuous ‘L’ (late).</p>
<p>You need to return whether the student could be rewarded according to his attendance record.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: &quot;PPALLP&quot;</div><div class="line">Output: True</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: &quot;PPALLL&quot;</div><div class="line">Output: False</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkRecord</span><span class="params">(String s)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> aCount = <span class="number">0</span>, lCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</div><div class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'A'</span>) &#123;</div><div class="line">                aCount++;</div><div class="line">                lCount = <span class="number">0</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'L'</span>) &#123;</div><div class="line">                lCount++;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                lCount = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (aCount &gt; <span class="number">1</span> || lCount &gt; <span class="number">2</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[606. Construct String from Binary Tree]]></title>
      <url>/2017/07/02/2017-07-02-606-Construct-String-from-Binary-Tree/</url>
      <content type="html"><![CDATA[<p>You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way.</p>
<p>The null node needs to be represented by empty parenthesis pair “()”. And you need to omit all the empty parenthesis pairs that don’t affect the one-to-one mapping relationship between the string and the original binary tree.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Input: Binary tree: [1,2,3,4]</div><div class="line">       1</div><div class="line">     /   \</div><div class="line">    2     3</div><div class="line">   /    </div><div class="line">  4     </div><div class="line"></div><div class="line">Output: &quot;1(2(4))(3)&quot;</div><div class="line"></div><div class="line">Explanation: Originallay it needs to be &quot;1(2(4)())(3()())&quot;,</div><div class="line">but you need to omit all the unnecessary empty parenthesis pairs.</div><div class="line">And it will be &quot;1(2(4))(3)&quot;.</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Input: Binary tree: [1,2,3,null,4]</div><div class="line">       1</div><div class="line">     /   \</div><div class="line">    2     3</div><div class="line">     \  </div><div class="line">      4</div><div class="line"></div><div class="line">Output: &quot;1(2()(4))(3)&quot;</div><div class="line"></div><div class="line">Explanation: Almost the same as the first example,</div><div class="line">except we can&apos;t omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">tree2str</span><span class="params">(TreeNode t)</span> </span>&#123;</div><div class="line"></div><div class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();        </div><div class="line">        helper(builder, t);</div><div class="line">        <span class="keyword">return</span> builder.toString();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(StringBuilder builder, TreeNode t)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</div><div class="line">            builder.append(Integer.toString(t.val));</div><div class="line">            <span class="keyword">if</span> (t.left != <span class="keyword">null</span> || t.right != <span class="keyword">null</span>) &#123;</div><div class="line">                builder.append(<span class="string">"("</span>);</div><div class="line">                helper(builder, t.left);</div><div class="line">                builder.append(<span class="string">")"</span>);</div><div class="line">                <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123;</div><div class="line">                    builder.append(<span class="string">"("</span>);</div><div class="line">                    helper(builder, t.right);</div><div class="line">                    builder.append(<span class="string">")"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[408. Valid Word Abbreviation]]></title>
      <url>/2017/07/02/2017-07-02-408-Valid-Word-Abbreviation/</url>
      <content type="html"><![CDATA[<p>Given a non-empty string s and an abbreviation abbr, return whether the string matches with the given abbreviation.</p>
<p>A string such as “word” contains only the following valid abbreviations:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[&quot;word&quot;, &quot;1ord&quot;, &quot;w1rd&quot;, &quot;wo1d&quot;, &quot;wor1&quot;, &quot;2rd&quot;, &quot;w2d&quot;, &quot;wo2&quot;, &quot;1o1d&quot;, &quot;1or1&quot;, &quot;w1r1&quot;, &quot;1o2&quot;, &quot;2r1&quot;, &quot;3d&quot;, &quot;w3&quot;, &quot;4&quot;]</div></pre></td></tr></table></figure></p>
<p>Notice that only the above abbreviations are valid abbreviations of the string “word”. Any other string is not a valid abbreviation of “word”.</p>
<p>Note:<br>Assume s contains only lowercase letters and abbr contains only lowercase letters and digits.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Given s = &quot;internationalization&quot;, abbr = &quot;i12iz4n&quot;:</div><div class="line"></div><div class="line">Return true.</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Given s = &quot;apple&quot;, abbr = &quot;a2e&quot;:</div><div class="line"></div><div class="line">Return false.</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>string类的题目似乎用指针可以规避掉一些cornercase的处理。这题用两个指针维护当前比较的起始位置。<br>先比较是否相等，如果相等则都往前进一步。<br>如果不相等，则考虑abbr是否为数字，把数字parse出来后i相应的比较位置就前进对应的数字个数。<br>这里要注意的是，数字的开端不能为０.<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validWordAbbreviation</span><span class="params">(String word, String abbr)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (word == <span class="keyword">null</span> &amp;&amp; abbr == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (word == <span class="keyword">null</span> || abbr == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (i &lt; word.length() &amp;&amp; j &lt; abbr.length()) &#123;</div><div class="line">            <span class="keyword">char</span> w = word.charAt(i);</div><div class="line">            <span class="keyword">char</span> a = abbr.charAt(j);</div><div class="line">            <span class="keyword">if</span> (w == a) &#123;</div><div class="line">                i++;</div><div class="line">                j++;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; <span class="string">'0'</span> &amp;&amp; a &lt;= <span class="string">'9'</span>) &#123;</div><div class="line">                <span class="keyword">int</span> start = j;</div><div class="line">                <span class="keyword">while</span> (j &lt; abbr.length() &amp;&amp; abbr.charAt(j) &gt;= <span class="string">'0'</span> &amp;&amp; abbr.charAt(j) &lt;= <span class="string">'9'</span>) &#123;</div><div class="line">                    j++;</div><div class="line">                &#125;</div><div class="line">                i += Integer.valueOf(abbr.substring(start, j));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> i == word.length() &amp;&amp; j == abbr.length();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[157. Read N Characters Given Read4]]></title>
      <url>/2017/07/02/2017-07-02-157-Read-N-Characters-Given-Read4/</url>
      <content type="html"><![CDATA[<p>The API: int read4(char[] buf) reads 4 characters at a time from a file.</p>
<p>The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.</p>
<p>By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.</p>
<p>Note:<br>The read function will only be called once for each test case.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* The read4 API is defined in the parent class Reader4.</span></div><div class="line"><span class="comment">      int read4(char[] buf); */</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">Reader4</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> buf Destination buffer</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> n   Maximum number of characters to read</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span>    The number of characters read</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] buf, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>];</div><div class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (pos &lt; n) &#123;</div><div class="line">            <span class="keyword">int</span> read = read4(buffer);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; read &amp;&amp; pos &lt; n; i++) &#123;</div><div class="line">                buf[pos++] = buffer[i];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (read == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> pos;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[28. Implement strSTr()]]></title>
      <url>/2017/07/02/2017-07-02-28-Implement-strSTr/</url>
      <content type="html"><![CDATA[<p>Implement strStr().</p>
<p>Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (needle == <span class="keyword">null</span> || haystack == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> n = haystack.length(), m = needle.length();</div><div class="line">        <span class="keyword">if</span> (m &gt; n) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - m; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (haystack.substring(i, i + m).equals(needle)) &#123;</div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[381. Insert Delete GetRandom O(1) - Duplicates allowed]]></title>
      <url>/2017/07/01/2017-07-01-381-Insert-Delete-GetRandom-O-1-Duplicates-allowed/</url>
      <content type="html"><![CDATA[<p>Design a data structure that supports all following operations in average O(1) time.<br>Note: Duplicate elements are allowed.</p>
<pre><code>insert(val): Inserts an item val to the collection.
remove(val): Removes an item val from the collection if present.
getRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains.
</code></pre><p>Example:</p>
<p>// Init an empty collection.<br>RandomizedCollection collection = new RandomizedCollection();</p>
<p>// Inserts 1 to the collection. Returns true as the collection did not contain 1.<br>collection.insert(1);</p>
<p>// Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1].<br>collection.insert(1);</p>
<p>// Inserts 2 to the collection, returns true. Collection now contains [1,1,2].<br>collection.insert(2);</p>
<p>// getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3.<br>collection.getRandom();</p>
<p>// Removes 1 from the collection, returns true. Collection now contains [1,2].<br>collection.remove(1);</p>
<p>// getRandom should return 1 and 2 both equally likely.<br>collection.getRandom();</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>自己写的怎么都没过OA,这个AC的答案是网上抄的[捂脸]。主要的思想和没有duplicates的版本很相似。区别就是这里对于每一个数字，要存储的是出现的index的list。删除操作的时候，把末尾的元素直接写到被删除的元素的位置。同时维护一下两个index的list.<br>对于需要删除的数字，去掉list中相应的位置<br>对于末尾的数字，在list中加入要删除的数字的位置<br>在队列中把要删除的元素的位置置换为末尾的元素<br>删除队列末尾的元素（因为已经放到了队列中间去了)<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomizedCollection</span> </span>&#123;</div><div class="line"></div><div class="line">    ArrayList&lt;Integer&gt; result;</div><div class="line">    HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; map;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedCollection</span><span class="params">()</span> </span>&#123;</div><div class="line">        result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        map = <span class="keyword">new</span> HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        <span class="comment">// Add item to map if it doesn't already exist.</span></div><div class="line">        <span class="keyword">boolean</span> alreadyExists = map.containsKey(val);</div><div class="line">        <span class="keyword">if</span>(!alreadyExists) &#123;</div><div class="line">            map.put(val, <span class="keyword">new</span> LinkedHashSet&lt;Integer&gt;());</div><div class="line">        &#125;</div><div class="line">        map.get(val).add(result.size());</div><div class="line">        result.add(val);</div><div class="line">        <span class="keyword">return</span> !alreadyExists;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Removes a value from the collection. Returns true if the collection contained the specified element. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!map.containsKey(val)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Get arbitary index of the ArrayList that contains val</span></div><div class="line">        LinkedHashSet&lt;Integer&gt; valSet = map.get(val);</div><div class="line">        <span class="keyword">int</span> indexToReplace = valSet.iterator().next();</div><div class="line"></div><div class="line">        <span class="comment">// Obtain the set of the number in the last place of the ArrayList</span></div><div class="line">        <span class="keyword">int</span> numAtLastPlace = result.get(result.size() - <span class="number">1</span>);</div><div class="line">        LinkedHashSet&lt;Integer&gt; replaceWith = map.get(numAtLastPlace);</div><div class="line"></div><div class="line">        <span class="comment">// Replace val at arbitary index with very last number</span></div><div class="line">        result.set(indexToReplace, numAtLastPlace);</div><div class="line"></div><div class="line">        <span class="comment">// Remove appropriate index</span></div><div class="line">        valSet.remove(indexToReplace);</div><div class="line"></div><div class="line">        <span class="comment">// Don't change set if we were replacing the removed item with the same number</span></div><div class="line">        <span class="keyword">if</span>(indexToReplace != result.size() - <span class="number">1</span>) &#123;</div><div class="line">            replaceWith.remove(result.size() - <span class="number">1</span>);</div><div class="line">            replaceWith.add(indexToReplace);</div><div class="line">        &#125;</div><div class="line">        result.remove(result.size() - <span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="comment">// Remove map entry if set is now empty, then return</span></div><div class="line">        <span class="keyword">if</span>(valSet.isEmpty()) &#123;</div><div class="line">            map.remove(val);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Get a random element from the collection. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// Get linearly random item</span></div><div class="line">        Random random = <span class="keyword">new</span> Random();</div><div class="line">        <span class="keyword">return</span> result.get(random.nextInt(result.size()));</div><div class="line">        <span class="comment">// return result.get((int)(Math.random() * result.size()));</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Your RandomizedCollection object will be instantiated and called as such:</span></div><div class="line"><span class="comment"> * RandomizedCollection obj = new RandomizedCollection();</span></div><div class="line"><span class="comment"> * boolean param_1 = obj.insert(val);</span></div><div class="line"><span class="comment"> * boolean param_2 = obj.remove(val);</span></div><div class="line"><span class="comment"> * int param_3 = obj.getRandom();</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[126. Word Ladder II]]></title>
      <url>/2017/07/01/2017-07-01-126-Word-Ladder-II/</url>
      <content type="html"><![CDATA[<p>Given two words (beginWord and endWord), and a dictionary’s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:</p>
<p>   Only one letter can be changed at a time<br>   Each transformed word must exist in the word list. Note that beginWord is not a transformed word.</p>
<p>For example,</p>
<p>Given:<br>beginWord = “hit”<br>endWord = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p>
<p>Return<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</div><div class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>   Return an empty list if there is no such transformation sequence.<br>   All words have the same length.<br>   All words contain only lowercase alphabetic characters.<br>   You may assume no duplicates in the word list.<br>   You may assume beginWord and endWord are non-empty and are not the same.</p>
<p>UPDATE (2017/1/20):<br>The wordList parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>这题挺繁琐的。思想不难，难的是优化。用到的几个知识点总结一下：<br>一个是建立邻接链表来给DFS使用，也就是说，先用一次bfs来遍历出字典中所有word的前驱word.　从start开始，第一步就找出所有能转换为start的word。以此类推。<br>同时，为了dfs中的优化，每一步时同时记录当前word能到达下一个word的最小步数。<br>这里用一个distance来记录。当开始跑dfs的时候，distance就可以用来判断下一个变化的word是不是最短路上的。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</div><div class="line"></div><div class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</div><div class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</div><div class="line">        Map&lt;String, Integer&gt; distance = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</div><div class="line"></div><div class="line">        Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line">        <span class="keyword">for</span> (String ss : wordList) &#123;</div><div class="line">            dict.add(ss);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!dict.contains(endWord)) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        dict.add(beginWord);</div><div class="line">        dict.add(endWord);</div><div class="line"></div><div class="line">        List&lt;String&gt; ladder = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        bfs(map, distance, beginWord, endWord, dict);</div><div class="line">        dfs(res, ladder, endWord, beginWord, map, distance);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Map&lt;String, List&lt;String&gt;&gt; map, Map&lt;String, Integer&gt; distance, String start, String end, Set&lt;String&gt; dict)</span> </span>&#123;</div><div class="line"></div><div class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;String&gt;();</div><div class="line">        q.offer(start);</div><div class="line">        distance.put(start, <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="comment">// Create an adjacent list</span></div><div class="line">        <span class="keyword">for</span> (String s : dict) &#123;</div><div class="line">            map.put(s, <span class="keyword">new</span> ArrayList&lt;String&gt;());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</div><div class="line">            String current = q.poll();</div><div class="line"></div><div class="line">            List&lt;String&gt; candidates = getCandidates(current, dict);</div><div class="line">            <span class="keyword">for</span> (String candidate : candidates) &#123;</div><div class="line">                map.get(candidate).add(current);    <span class="comment">// reverse put</span></div><div class="line">                <span class="comment">// record the minimum length to the start point</span></div><div class="line">                <span class="keyword">if</span> (!distance.containsKey(candidate)) &#123;</div><div class="line">                    distance.put(candidate, distance.get(current) + <span class="number">1</span>);</div><div class="line">                    q.offer(candidate);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; ladder, String current, String start, Map&lt;String, List&lt;String&gt;&gt; map,</span></span></div><div class="line"><span class="function"><span class="params">                    Map&lt;String, Integer&gt; distance)</span> </span>&#123;</div><div class="line"></div><div class="line">        ladder.add(current);</div><div class="line">        <span class="keyword">if</span> (current.equals(start)) &#123;</div><div class="line">            Collections.reverse(ladder);</div><div class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;String&gt;(ladder));</div><div class="line">            Collections.reverse(ladder);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span> (String next : map.get(current)) &#123;</div><div class="line">                <span class="keyword">if</span> (distance.containsKey(next) &amp;&amp; distance.get(next) == distance.get(current) - <span class="number">1</span>) &#123;</div><div class="line">                    dfs(res, ladder, next, start, map, distance);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ladder.remove(ladder.size() - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">getCandidates</span><span class="params">(String word, Set&lt;String&gt; wordList)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; candidates = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</div><div class="line">                <span class="keyword">if</span> (c != word.charAt(i)) &#123;</div><div class="line">                    String modified = word.substring(<span class="number">0</span>, i) + c + word.substring(i + <span class="number">1</span>);</div><div class="line">                    <span class="keyword">if</span> (wordList.contains(modified)) &#123;</div><div class="line">                        candidates.add(modified);</div><div class="line">                        &#125;                    </div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> candidates;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[154. Find Minimum in Rotated Sorted Array II]]></title>
      <url>/2017/07/01/2017-07-01-154-Find-Minimum-in-Rotated-Sorted-Array-II/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Follow up for &quot;Find Minimum in Rotated Sorted Array&quot;:</div><div class="line">What if duplicates are allowed?</div><div class="line"></div><div class="line">Would this affect the run-time complexity? How and why?</div></pre></td></tr></table></figure>
<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<p>Find the minimum element.</p>
<p>The array may contain duplicates.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>当有重复数字的时候，最差的情况会退化成O(N)的算法。在原来算法的基础上还要判断两个数字是否相等。如果相等的时候，只能排除掉一个数而不是一半的数字。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end) &#123;</div><div class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> (nums[start] == nums[end]) &#123;</div><div class="line">                start++;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[start] &gt; nums[end]) &#123;</div><div class="line">                <span class="keyword">if</span> (nums[mid] &lt; nums[end]) &#123;</div><div class="line">                    end = mid;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == nums[end]) &#123;</div><div class="line">                    end--;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    start = mid;</div><div class="line">                &#125;                </div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// nums[start] &lt; nums[end]</span></div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums[start] &lt;= nums[end]) &#123;</div><div class="line">            <span class="keyword">return</span> nums[start];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> nums[end];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[41. First Missing Positive]]></title>
      <url>/2017/06/29/2017-06-29-41-First-Missing-Positive/</url>
      <content type="html"><![CDATA[<p>Given an unsorted integer array, find the first missing positive integer.</p>
<p>For example,<br>Given [1,2,0] return 3,<br>and [3,4,-1,1] return 2.</p>
<p>Your algorithm should run in O(n) time and uses constant space.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>归位的思想。把每一个数字放到他该在的位置上。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">            <span class="keyword">while</span> (nums[i] &lt;= n &amp;&amp; nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>]) &#123;</div><div class="line">                <span class="keyword">int</span> temp = nums[nums[i] - <span class="number">1</span>];</div><div class="line">                nums[nums[i] - <span class="number">1</span>] = nums[i];</div><div class="line">                nums[i] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[128. Longest Consecutive Sequence]]></title>
      <url>/2017/06/29/2017-06-29-128-Longest-Consecutive-Sequence/</url>
      <content type="html"><![CDATA[<p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>For example,<br>Given [100, 4, 200, 1, 3, 2],<br>The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.</p>
<p>Your algorithm should run in O(n) complexity.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>复杂度要求比较高，算来算去能用的也只有HashMap了。这个解法不太常见，用一个map存储一个range。<br>对于任意一个数，low和high都是数字本身。然后在map之内寻找下限和上限。寻找到之后更新res。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</div><div class="line">            <span class="keyword">if</span> (map.containsKey(num)) <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">int</span> low = num;</div><div class="line">            <span class="keyword">int</span> high = num;</div><div class="line">            <span class="keyword">if</span> (map.containsKey(num - <span class="number">1</span>)) low = map.get(num - <span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span> (map.containsKey(num + <span class="number">1</span>)) high = map.get(num + <span class="number">1</span>);</div><div class="line">            res = Math.max(res, high - low + <span class="number">1</span>);</div><div class="line">            map.put(num, num);</div><div class="line">            map.put(low, high);</div><div class="line">            map.put(high, low);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法2："><a href="#解法2：" class="headerlink" title="解法2："></a>解法2：</h3><p>这个解法清楚多了，首先把所有数据加入一个hashset. 之后对于每一个数，往下以及往上找到所有在set中的数据。 然后更新一下range。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</div><div class="line">            set.add(num);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</div><div class="line">            <span class="keyword">int</span> down = num - <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (set.contains(down)) &#123;</div><div class="line">                set.remove(down);</div><div class="line">                down--;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> upper = num + <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (set.contains(upper)) &#123;</div><div class="line">                set.remove(upper);</div><div class="line">                upper++;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            res = Math.max(res, upper - down - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[85. Maximal Rectangle]]></title>
      <url>/2017/06/29/2017-06-29-85-Maximal-Rectangle/</url>
      <content type="html"><![CDATA[<p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p>
<p>For example, given the following matrix:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1 0 1 0 0</div><div class="line">1 0 1 1 1</div><div class="line">1 1 1 1 1</div><div class="line">1 0 0 1 0</div></pre></td></tr></table></figure></p>
<p>Return 6.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>这题是运用了Largest Rectangle Area那题的解法。因为这题可以看成是一行一行的数字叠加起来，组成了一个histogram，求最大的面积。<br>那么实际的算法就是对于每一层，计算一个当前累积的histogram，然后再求一个最大面积就可以了。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>] == <span class="keyword">null</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[] heights = <span class="keyword">new</span> <span class="keyword">int</span>[matrix[<span class="number">0</span>].length + <span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</div><div class="line">                heights[j] = matrix[i][j] - <span class="string">'0'</span> == <span class="number">0</span> ? <span class="number">0</span> : heights[j] + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// calculate the maximum rectangle in histogram</span></div><div class="line">            Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; heights.length; j++) &#123;</div><div class="line">                <span class="keyword">int</span> height = heights[j];</div><div class="line">                <span class="keyword">while</span> (!stack.empty() &amp;&amp; height &lt; heights[stack.peek()]) &#123;</div><div class="line">                    <span class="keyword">int</span> last = heights[stack.pop()];</div><div class="line">                    <span class="keyword">int</span> width = stack.empty() ? j : j - stack.peek() - <span class="number">1</span>;</div><div class="line">                    res = Math.max(res, last * width);</div><div class="line">                &#125;</div><div class="line">                stack.push(j);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[4. Median of Two Sorted Array]]></title>
      <url>/2017/06/27/2017-06-27-4-Median-of-Two-Sorted-Array/</url>
      <content type="html"><![CDATA[<p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">nums1 = [1, 3]</div><div class="line">nums2 = [2]</div><div class="line"></div><div class="line">The median is 2.0</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">nums1 = [1, 2]</div><div class="line">nums2 = [3, 4]</div><div class="line"></div><div class="line">The median is (2 + 3)/2 = 2.5</div></pre></td></tr></table></figure></p>
<h3 id="解法1：-Math"><a href="#解法1：-Math" class="headerlink" title="解法1： Math"></a>解法1： Math</h3><p>参考这篇<a href="https://discuss.leetcode.com/topic/4996/share-my-o-log-min-m-n-solution-with-explanation" target="_blank" rel="external">解释</a><br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> m = nums1.length;</div><div class="line">            <span class="keyword">int</span> n = nums2.length;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (m &gt; n) &#123;</div><div class="line">                <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> start = <span class="number">0</span>, end = m, half = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</div><div class="line">            <span class="comment">// Satisfy both condition, calculate the medium</span></div><div class="line">            <span class="keyword">int</span> max_of_left = <span class="number">0</span>, min_of_right = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span> (start &lt;= end) &#123;</div><div class="line">                i = (start + end) / <span class="number">2</span>;</div><div class="line">                j = half- i;</div><div class="line">                <span class="keyword">if</span> (i &lt; m &amp;&amp; j &gt; <span class="number">0</span> &amp;&amp; nums2[j - <span class="number">1</span>] &gt; nums1[i]) &#123;</div><div class="line">                    start = i + <span class="number">1</span>;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &lt; n &amp;&amp; nums1[i - <span class="number">1</span>] &gt; nums2[j]) &#123;</div><div class="line">                    end = i - <span class="number">1</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</div><div class="line">                        max_of_left = nums2[j - <span class="number">1</span>];</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</div><div class="line">                        max_of_left = nums1[i - <span class="number">1</span>];</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        max_of_left = Math.max(nums1[i - <span class="number">1</span>], nums2[j - <span class="number">1</span>]);</div><div class="line"></div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">           <span class="comment">// Check if the total number of elements is odd or even</span></div><div class="line">            <span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">1</span>) &#123;</div><div class="line">                <span class="keyword">return</span> max_of_left;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (i == m) &#123;</div><div class="line">                min_of_right = nums2[j];</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == n) &#123;</div><div class="line">                min_of_right = nums1[i];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                min_of_right = Math.min(nums1[i], nums2[j]);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> (max_of_left + min_of_right)/<span class="number">2.0</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法2：-Kth-Value"><a href="#解法2：-Kth-Value" class="headerlink" title="解法2： Kth Value"></a>解法2： Kth Value</h3><p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[57. Insert Interval]]></title>
      <url>/2017/06/27/2017-06-27-57-Insert-Interval/</url>
      <content type="html"><![CDATA[<p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).</p>
<p>You may assume that the intervals were initially sorted according to their start times.</p>
<p>Example 1:<br>Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].</p>
<p>Example 2:<br>Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].</p>
<p>This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>自己写的版本比较繁琐，先用binary search来查找插入的位置，然后把interval插入，然后再merge interval。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">insert</span><span class="params">(List&lt;Interval&gt; intervals, Interval newInterval)</span> </span>&#123;</div><div class="line"></div><div class="line">        List&lt;Interval&gt; res = <span class="keyword">new</span> ArrayList&lt;Interval&gt;();</div><div class="line">        <span class="keyword">if</span> (intervals.size() == <span class="number">0</span> &amp;&amp; newInterval == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (intervals.size() == <span class="number">0</span>) &#123;</div><div class="line">            res.add(newInterval);</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> position = binarySearch(intervals, newInterval);</div><div class="line"></div><div class="line">        <span class="comment">// Insert into the intervals;</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (position &lt; intervals.size()) &#123;</div><div class="line">          intervals.add(position, newInterval);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          intervals.add(newInterval);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Merge Intervals using intervals</span></div><div class="line"></div><div class="line">        Interval last = intervals.get(<span class="number">0</span>);</div><div class="line">        res.add(last);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</div><div class="line">          Interval current = intervals.get(i);</div><div class="line">          <span class="comment">// check if we need to merge</span></div><div class="line">          <span class="keyword">if</span> (current.start &lt;= last.end) &#123;</div><div class="line">            last.end = Math.max(last.end, current.end);</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">            res.add(current);</div><div class="line">            last = current;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;Interval&gt; intervals, Interval newInterval)</span> </span>&#123;</div><div class="line"></div><div class="line">      <span class="comment">// return the first interval that the start is larger than newInterval's start</span></div><div class="line">      <span class="keyword">int</span> start = <span class="number">0</span>, end = intervals.size() - <span class="number">1</span>;</div><div class="line">      <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end) &#123;</div><div class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</div><div class="line">        Interval temp = intervals.get(mid);</div><div class="line">        <span class="keyword">if</span> (temp.start &lt;= newInterval.start) &#123;</div><div class="line">          start = mid;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          end = mid;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (intervals.get(start).start &gt;= newInterval.start) &#123;</div><div class="line">        <span class="keyword">return</span> start;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (intervals.get(end).start &gt;= newInterval.start) &#123;</div><div class="line">        <span class="keyword">return</span> end;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> intervals.size();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法2："><a href="#解法2：" class="headerlink" title="解法2："></a>解法2：</h3><p>不需要用binary search来查找插入位置，而是在一边遍历的情况下用另一个指针pos来维护该插入的位置。这个思想在其他的题目中也见过。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">insert</span><span class="params">(List&lt;Interval&gt; intervals, Interval newInterval)</span> </span>&#123;</div><div class="line"></div><div class="line">        List&lt;Interval&gt; res = <span class="keyword">new</span> ArrayList&lt;Interval&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;    <span class="comment">// find an insert position for newInterval</span></div><div class="line">        <span class="keyword">for</span> (Interval it : intervals) &#123;</div><div class="line">            <span class="keyword">if</span> (it.end &lt; newInterval.start) &#123;</div><div class="line">                res.add(it);</div><div class="line">                pos++;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newInterval.end &lt; it.start) &#123;</div><div class="line">                res.add(it);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                newInterval.start = Math.min(it.start, newInterval.start);</div><div class="line">                newInterval.end = Math.max(it.end, newInterval.end);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        res.add(pos, newInterval);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[45. Jump Game II]]></title>
      <url>/2017/06/27/2017-06-27-45-Jump-Game-II/</url>
      <content type="html"><![CDATA[<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<p>For example:<br>Given array A = [2,3,1,1,4]</p>
<p>The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)</p>
<p>Note:<br>You can assume that you can always reach the last index.</p>
<h3 id="解法1：Greedy-O-N-Time-O-1-Space"><a href="#解法1：Greedy-O-N-Time-O-1-Space" class="headerlink" title="解法1：Greedy O(N) Time O(1) Space"></a>解法1：Greedy O(N) Time O(1) Space</h3><p>这题可以作为复习Greedy Algorithm的一个很好的范例。最核心的思想和Jump Game一样，用一个变量维护上一步可以走到的最远距离。如果当前的距离比他远，则说明需要额外的一步。同时维护一个下一步可以走到的最远距离，便是在当前的最远距离和i + nums[i]中取最大值即可。</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Greedy</span></div><div class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (i &gt; last) &#123;</div><div class="line">                last = cur;</div><div class="line">                step++;</div><div class="line">                <span class="keyword">if</span> (last &gt;= nums.length) &#123;</div><div class="line">                    <span class="keyword">return</span> step;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            cur = Math.max(cur, i + nums[i]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> step;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法2：Greedy-O-N-Time-O-N-Space-DP-thinking"><a href="#解法2：Greedy-O-N-Time-O-N-Space-DP-thinking" class="headerlink" title="解法2：Greedy O(N) Time O(N) Space, DP thinking"></a>解法2：Greedy O(N) Time O(N) Space, DP thinking</h3><p>用一个dp数组来存储每一个点所需要的最少步数。<br>然后从0开始扫描，找出当前点所能到的最远距离。然后从下一位置开始扫描，对于每一个可以到达的点都更新最少的步数，也就是dp[j] = dp[i] + 1。到此，j位置上的结果已经找出，不会再有比他步数更少的解了。<br>最后返回dp[n-1]即可。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line"></div><div class="line">        <span class="comment">// dp pointer</span></div><div class="line">        <span class="keyword">int</span> j=<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</div><div class="line">            <span class="keyword">int</span> loc= nums[i] + i;</div><div class="line">            <span class="keyword">while</span> (j&lt;=loc &amp;&amp; j&lt;nums.length) &#123;</div><div class="line">                dp[j] = dp[i] + <span class="number">1</span>;</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> dp[dp.length-<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[533. Lonely Pixel II]]></title>
      <url>/2017/06/26/2017-06-26-533-Lonely-Pixel-II/</url>
      <content type="html"><![CDATA[<p>Given a picture consisting of black and white pixels, and a positive integer N, find the number of black pixels located at some specific row R and column C that align with all the following rules:</p>
<pre><code>Row R and column C both contain exactly N black pixels.
For all rows that have a black pixel at column C, they should be exactly the same as row R
</code></pre><p>The picture is represented by a 2D char array consisting of ‘B’ and ‘W’, which means black and white pixels respectively.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Input:                                            </div><div class="line">[[&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;],    </div><div class="line"> [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;],    </div><div class="line"> [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;],    </div><div class="line"> [&apos;W&apos;, &apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;W&apos;]]</div><div class="line"></div><div class="line">N = 3</div><div class="line">Output: 6</div><div class="line">Explanation: All the bold &apos;B&apos; are the black pixels we need (all &apos;B&apos;s at column 1 and 3).</div><div class="line">        0    1    2    3    4    5         column index                                            </div><div class="line">0    [[&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;],    </div><div class="line">1     [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;],    </div><div class="line">2     [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;],    </div><div class="line">3     [&apos;W&apos;, &apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;W&apos;]]    </div><div class="line">row index</div><div class="line"></div><div class="line">Take &apos;B&apos; at row R = 0 and column C = 1 as an example:</div><div class="line">Rule 1, row R = 0 and column C = 1 both have exactly N = 3 black pixels.</div><div class="line">Rule 2, the rows have black pixel at column C = 1 are row 0, row 1 and row 2. They are exactly the same as row R = 0.</div></pre></td></tr></table></figure></p>
<p>Note:</p>
<pre><code>The range of width and height of the input 2D array is [1,200].
</code></pre><h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>很繁琐的一道题。。。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBlackPixel</span><span class="params">(<span class="keyword">char</span>[][] picture, <span class="keyword">int</span> N)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (picture == <span class="keyword">null</span> || picture.length == <span class="number">0</span> || picture[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> m = picture.length, n = picture[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[] cols = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// Use a hashMap to store the rows string that satisfy that row pixel count is N</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</div><div class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (picture[i][j] == <span class="string">'B'</span>) &#123;</div><div class="line">                    cols[j]++;</div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (count == N) &#123;</div><div class="line">                String curRow = <span class="keyword">new</span> String(picture[i]);</div><div class="line">                map.put(curRow, map.getOrDefault(curRow, <span class="number">0</span>) + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (String row : map.keySet()) &#123;</div><div class="line">            <span class="keyword">if</span> (map.get(row) != N) <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (row.charAt(i) == <span class="string">'B'</span> &amp;&amp; cols[i] == N) &#123;</div><div class="line">                    res += N;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[548. Split Array with Equal Sum]]></title>
      <url>/2017/06/26/2017-06-26-548-Split-Array-with-Equal-Sum/</url>
      <content type="html"><![CDATA[<p>Given an array with n integers, you need to find if there are triplets (i, j, k) which satisfies following conditions:</p>
<p>   0 &lt; i, i + 1 &lt; j, j + 1 &lt; k &lt; n - 1<br>   Sum of subarrays (0, i - 1), (i + 1, j - 1), (j + 1, k - 1) and (k + 1, n - 1) should be equal.</p>
<p>where we define that subarray (L, R) represents a slice of the original array starting from the element indexed L to the element indexed R.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Input: [1,2,1,2,1,2,1]</div><div class="line">Output: True</div><div class="line">Explanation:</div><div class="line">i = 1, j = 3, k = 5.</div><div class="line">sum(0, i - 1) = sum(0, 0) = 1</div><div class="line">sum(i + 1, j - 1) = sum(2, 2) = 1</div><div class="line">sum(j + 1, k - 1) = sum(4, 4) = 1</div><div class="line">sum(k + 1, n - 1) = sum(6, 6) = 1</div></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>   1 &lt;= n &lt;= 2000.<br>   Elements in the given array will be in range [-1,000,000, 1,000,000].</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>这题又是2sum的一个变种。把一个数组分成加和相等的4份。trick在于如果遍历中间的点，那么左右那边变成找出是否存在切割点使得切割之后的两份的加和相等。<br>那么这一部分就可以用hashset来解决。存储可以等分的sum，然后在右边的部分寻找等分的时候看是否在左面出现过。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">6</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">        sum[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            sum[i] = sum[i - <span class="number">1</span>] + nums[i];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span>; j &lt; nums.length - <span class="number">3</span>; j++) &#123;</div><div class="line">            HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; j - <span class="number">1</span>; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (sum[i - <span class="number">1</span>] == sum[j - <span class="number">1</span>] - sum[i]) &#123;</div><div class="line">                    set.add(sum[i - <span class="number">1</span>]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">2</span>; k &lt; nums.length - <span class="number">1</span>; k++) &#123;</div><div class="line">                <span class="keyword">if</span> (sum[k - <span class="number">1</span>] - sum[j] == sum[nums.length - <span class="number">1</span>] - sum[k] &amp;&amp; set.contains(sum[k - <span class="number">1</span>] - sum[j])) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[560. Subarray Sum Equals K]]></title>
      <url>/2017/06/26/2017-06-26-560-Subarray-Sum-Equals-K/</url>
      <content type="html"><![CDATA[<p>Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.</p>
<p>Example 1:</p>
<p>Input:nums = [1,1,1], k = 2<br>Output: 2</p>
<p>Note:</p>
<pre><code>The length of the array is in range [1, 20,000].
The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7].
</code></pre><h3 id="解法1：O-N-Time-O-N-Space"><a href="#解法1：O-N-Time-O-N-Space" class="headerlink" title="解法1：O(N) Time + O(N) Space"></a>解法1：O(N) Time + O(N) Space</h3><p>这题和2Sum的思路有点像。首先是一道continuous sum的题，可以考虑用prefix sum的办法。<br>每次计算一个累加和，假设为sum，sum-presum=k也就意味着，sum-k=presum,如果我们用一个hashtable存储每一个presum出现的次数，那就可以指导对于任意一个sum，其满足要求的presum是否出现过，并且出现过几次。这一点和2sum是一样的，只是一个用加法一个用减法。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line"></div><div class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            sum += nums[i];</div><div class="line">            <span class="keyword">if</span> (sum == k) &#123;</div><div class="line">                cnt++;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (map.containsKey(sum - k)) &#123;</div><div class="line">                cnt += map.get(sum - k);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (map.containsKey(sum)) &#123;</div><div class="line">                map.put(sum, map.get(sum) + <span class="number">1</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                map.put(sum, <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> cnt;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[682. Maximum Product of Three Numbers]]></title>
      <url>/2017/06/24/2017-06-24-682-Maximum-Product-of-Three-Numbers/</url>
      <content type="html"><![CDATA[<p>Given an integer array, find three numbers whose product is maximum and output the maximum product.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: [1,2,3]</div><div class="line">Output: 6</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: [1,2,3,4]</div><div class="line">Output: 24</div></pre></td></tr></table></figure></p>
<p>Note:</p>
<pre><code>The length of the given array will be in range [3,104] and all elements are in the range [-1000, 1000].
Multiplication of any three numbers in the input won&apos;t exceed the range of 32-bit signed integer.
</code></pre><h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>这题用3Sum smaller的思路，不过是简化了的版本。每对应一个数字，只需要考虑如果是负数时最小的乘积和如果是正数时最大的乘积。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span> ) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Arrays.sort(nums);  <span class="comment">// sort ascending</span></div><div class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span>) &#123;</div><div class="line">                res = Math.max(res, nums[i] * nums[i + <span class="number">1</span>] * nums[n - <span class="number">1</span>]);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</div><div class="line">                res = Math.max(res, nums[n - <span class="number">1</span>] * nums[n - <span class="number">2</span>] * nums[i]);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                res = Math.max(res, <span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[562. Longest Line of Consecutive One in Matrix]]></title>
      <url>/2017/06/24/2017-06-24-562-Longest-Line-of-Consecutive-One-in-Matrix/</url>
      <content type="html"><![CDATA[<p>Given a 01 matrix M, find the longest line of consecutive one in the matrix. The line could be horizontal, vertical, diagonal or anti-diagonal.</p>
<p>Example:</p>
<p>Input:<br>[[0,1,1,0],<br> [0,1,1,0],<br> [0,0,0,1]]<br>Output: 3</p>
<p>Hint: The number of elements in the given matrix will not exceed 10,000.</p>
<h3 id="解法1：DP-O-nm"><a href="#解法1：DP-O-nm" class="headerlink" title="解法1：DP, O(nm)"></a>解法1：DP, O(nm)</h3><p>用一个三维数组记录每一个格子上4个方向的最长的个数。同时更新一下最长的值即可。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestLine</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (M.length == <span class="number">0</span> || M[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[M.length][M[<span class="number">0</span>].length][<span class="number">4</span>];</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (M[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">                dp[<span class="number">0</span>][<span class="number">0</span>][i] = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M[<span class="number">0</span>].length; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (M[i][j] == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</div><div class="line">                    dp[i][j][k] = <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// vertical line</span></div><div class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</div><div class="line">                    dp[i][j][<span class="number">0</span>] = dp[i - <span class="number">1</span>][j][<span class="number">0</span>] + <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// horizontal line</span></div><div class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</div><div class="line">                    dp[i][j][<span class="number">1</span>] = dp[i][j - <span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// diagonal line</span></div><div class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &lt; M[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</div><div class="line">                    dp[i][j][<span class="number">3</span>] = dp[i - <span class="number">1</span>][j + <span class="number">1</span>][<span class="number">3</span>] + <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// anti diagonal line</span></div><div class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</div><div class="line">                    dp[i][j][<span class="number">2</span>] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">2</span>] + <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                res = Math.max(res, Math.max(dp[i][j][<span class="number">0</span>], dp[i][j][<span class="number">1</span>]));</div><div class="line">                res = Math.max(res, Math.max(dp[i][j][<span class="number">2</span>], dp[i][j][<span class="number">3</span>]));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[565. Array Nesting]]></title>
      <url>/2017/06/24/2017-06-24-565-Array-Nesting/</url>
      <content type="html"><![CDATA[<p>A zero-indexed array A consisting of N different integers is given. The array contains all integers in the range [0, N - 1].</p>
<p>Sets S[K] for 0 &lt;= K &lt; N are defined as follows:</p>
<p>S[K] = { A[K], A[A[K]], A[A[A[K]]], … }.</p>
<p>Sets S[K] are finite for each K and should NOT contain duplicates.</p>
<p>Write a function that given an array A consisting of N integers, return the size of the largest set S[K] for this array.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Input: A = [5,4,0,3,1,6,2]</div><div class="line">Output: 4</div><div class="line">Explanation:</div><div class="line">A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.</div><div class="line"></div><div class="line">One of the longest S[K]:</div><div class="line">S[0] = &#123;A[0], A[5], A[6], A[2]&#125; = &#123;5, 6, 2, 0&#125;</div></pre></td></tr></table></figure></p>
<p>Note:</p>
<pre><code>N is an integer within the range [1, 20,000].
The elements of A are all distinct.
Each element of array A is an integer within the range [0, N-1].
</code></pre><h3 id="解法1：-O-N-Time-O-N-Space"><a href="#解法1：-O-N-Time-O-N-Space" class="headerlink" title="解法1： O(N) Time + O(N) Space"></a>解法1： O(N) Time + O(N) Space</h3><p>用DFS的思想，同时记录所访问过的元素。对于每一个未被访问过的元素跑一遍DFS，直到碰到已经访问过的元素位置，同时更新一下最大的值。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayNesting</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="comment">// union find</span></div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</div><div class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line">            <span class="keyword">int</span> current = i;</div><div class="line">            <span class="keyword">while</span> (!visited[current]) &#123;</div><div class="line">                cnt++;</div><div class="line">                visited[current] = <span class="keyword">true</span>;</div><div class="line">                current = nums[current];</div><div class="line">            &#125;</div><div class="line">            res = Math.max(res, cnt);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[611. Valid Triangle Number]]></title>
      <url>/2017/06/24/2017-06-24-611-Valid-Triangle-Number/</url>
      <content type="html"><![CDATA[<p>Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Input: [2,2,3,4]</div><div class="line">Output: 3</div><div class="line">Explanation:</div><div class="line">Valid combinations are:</div><div class="line">2,3,4 (using the first 2)</div><div class="line">2,3,4 (using the second 2)</div><div class="line">2,2,3</div></pre></td></tr></table></figure></p>
<p>Note:</p>
<pre><code>The length of the given array won&apos;t exceed 1000.
The integers in the given array are in the range of [0, 1000].
</code></pre><h3 id="解法1：O-N-2"><a href="#解法1：O-N-2" class="headerlink" title="解法1：O(N^2)"></a>解法1：O(N^2)</h3><p>这题的思路和3SUM smaller很像，也可以用O(N^2)解决。<br>首先要确定，满足一个三角形的条件是任意两条边之和要大于第三条边。那么如果先对数组排序。<br>如果A<b<c, a+="" b="">C, 另外两个条件一定也满足。<br>用3sum smaller的算法是先固定一个点。这题里面我们固定住最大的边比较好想<br>从后往前扫描，用双指针指向最小的两条边。如果left + right &gt; 第三边,那么从left 到right的所有边都可以满足[right, last]这个组合。</b<c,></p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">triangleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Arrays.sort(nums);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">3</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">2</span>; i--) &#123;</div><div class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, right = i - <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</div><div class="line">                <span class="keyword">if</span> (nums[left] + nums[right] &gt; nums[i]) &#123;</div><div class="line">                    res += right - left;</div><div class="line">                    right--;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    left++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[621. Task Scheduler]]></title>
      <url>/2017/06/24/2017-06-24-621-Task-Scheduler/</url>
      <content type="html"><![CDATA[<p>Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks.Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle.</p>
<p>However, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle.</p>
<p>You need to return the least number of intervals the CPU will take to finish all the given tasks.</p>
<p>Example 1:</p>
<p>Input: tasks = [‘A’,’A’,’A’,’B’,’B’,’B’], n = 2<br>Output: 8<br>Explanation: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B.</p>
<p>Note:</p>
<pre><code>The number of tasks is in the range [1, 10000].
The integer n is in the range [0, 100].
</code></pre><h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>先找出出现频率最大的数字，假设频率为k。然后分开每一个数字使得两个数字之间间隔为n。<br>这样，会有k-1个间隔出现。所有频率小于k的数字都可以完全填充在这k-1个间隔里面。<br>那么，这个时候总长度就是：(k - 1) * (n + 1) + 频率为k的数字的个数。<br>（n+1)是因为每一个分段都是一个最高频的数字加上剩下的空， i.e. AXXXXXXXXX<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> task: tasks) &#123;</div><div class="line">            map[task - <span class="string">'A'</span>]++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Arrays.sort(map);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> maxFreq = map[<span class="number">25</span>];</div><div class="line"></div><div class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = map.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">if</span> (map[i] == maxFreq) &#123;</div><div class="line">                t++;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> Math.max(tasks.length, (maxFreq - <span class="number">1</span>) * (n + <span class="number">1</span>) + t);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[495. Teemo Attacking]]></title>
      <url>/2017/06/24/2017-06-24-495-Teemo-Attacking/</url>
      <content type="html"><![CDATA[<p>In LLP world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo’s attacking ascending time series towards Ashe and the poisoning time duration per Teemo’s attacking, you need to output the total time that Ashe is in poisoned condition.</p>
<p>You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Input: [1,4], 2</div><div class="line">Output: 4</div><div class="line">Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately.</div><div class="line">This poisoned status will last 2 seconds until the end of time point 2.</div><div class="line">And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds.</div><div class="line">So you finally need to output 4.</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Input: [1,2], 2</div><div class="line">Output: 3</div><div class="line">Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned.</div><div class="line">This poisoned status will last 2 seconds until the end of time point 2.</div><div class="line">However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status.</div><div class="line">Since the poisoned status won&apos;t add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3.</div><div class="line">So you finally need to output 3.</div></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>   You may assume the length of given time series array won’t exceed 10000.<br>   You may assume the numbers in the Teemo’s attacking time series and his poisoning time duration per attacking are non-negative integers, which won’t exceed 10,000,000.</p>
<h3 id="解法1：-Greedy"><a href="#解法1：-Greedy" class="headerlink" title="解法1： Greedy"></a>解法1： Greedy</h3><p>关键点在于： 两次攻击的间隔如果小于duration，那么上一次攻击的有效时间就是间隔时间。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPoisonedDuration</span><span class="params">(<span class="keyword">int</span>[] timeSeries, <span class="keyword">int</span> duration)</span> </span>&#123;</div><div class="line"></div><div class="line">       <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">       <span class="keyword">if</span> (timeSeries.length == <span class="number">0</span> || duration == <span class="number">0</span>) &#123;</div><div class="line">           <span class="keyword">return</span> res;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; timeSeries.length; i++) &#123;</div><div class="line">           <span class="keyword">int</span> diff = timeSeries[i] - timeSeries[i - <span class="number">1</span>];</div><div class="line">           <span class="keyword">if</span> (diff &lt; duration) &#123;</div><div class="line">               res += diff;</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               res += duration;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// Add the last piece</span></div><div class="line">       res += duration;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[370. Range Addition]]></title>
      <url>/2017/06/24/2017-06-24-370-Range-Addition/</url>
      <content type="html"><![CDATA[<p>Assume you have an array of length n initialized with all 0’s and are given k update operations.</p>
<p>Each operation is represented as a triplet: [startIndex, endIndex, inc] which increments each element of subarray A[startIndex … endIndex] (startIndex and endIndex inclusive) with inc.</p>
<p>Return the modified array after all k operations were executed.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Given:</div><div class="line"></div><div class="line">    length = 5,</div><div class="line">    updates = [</div><div class="line">        [1,  3,  2],</div><div class="line">        [2,  4,  3],</div><div class="line">        [0,  2, -2]</div><div class="line">    ]</div><div class="line"></div><div class="line">Output:</div><div class="line"></div><div class="line">    [-2, 0, 3, 5, 3]</div></pre></td></tr></table></figure></p>
<p>Explanation:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Initial state:</div><div class="line">[ 0, 0, 0, 0, 0 ]</div><div class="line"></div><div class="line">After applying operation [1, 3, 2]:</div><div class="line">[ 0, 2, 2, 2, 0 ]</div><div class="line"></div><div class="line">After applying operation [2, 4, 3]:</div><div class="line">[ 0, 2, 5, 5, 3 ]</div><div class="line"></div><div class="line">After applying operation [0, 2, -2]:</div><div class="line">[-2, 0, 3, 5, 3 ]</div></pre></td></tr></table></figure></p>
<h3 id="解法1：-O-n-O-k"><a href="#解法1：-O-n-O-k" class="headerlink" title="解法1： O(n) + O(k)"></a>解法1： O(n) + O(k)</h3><p>这题如果用一般的办法会TLE。关键的点在于不用更新start和end之间所有的数。那么我们只更新start的数，意思是从这往后所有的数都要加上start对应的数字。同时需要在end+1的地方减去increment，意思是从这里往后所有的数要减去start对应的数字，以此来抵消多加的那一份。<br>最后我们在遍历一遍数组，做一个累加就得到了结果。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getModifiedArray(<span class="keyword">int</span> length, <span class="keyword">int</span>[][] updates) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[length];</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; updates.length; i++) &#123;</div><div class="line">            res[updates[i][<span class="number">0</span>]] += updates[i][<span class="number">2</span>];</div><div class="line">            <span class="keyword">if</span> (updates[i][<span class="number">1</span>] &lt; res.length - <span class="number">1</span>) &#123;</div><div class="line">                res[updates[i][<span class="number">1</span>] + <span class="number">1</span>] -= updates[i][<span class="number">2</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; res.length; i++) &#123;</div><div class="line">            res[i] += res[i - <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[245. Shortest Word Distance III]]></title>
      <url>/2017/06/24/2017-06-24-245-Shortest-Word-Distance-III/</url>
      <content type="html"><![CDATA[<p>This is a follow up of Shortest Word Distance. The only difference is now word1 could be the same as word2.</p>
<p>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p>
<p>word1 and word2 may be the same and they represent two individual words in the list.</p>
<p>For example,<br>Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”].</p>
<p>Given word1 = “makes”, word2 = “coding”, return 1.<br>Given word1 = “makes”, word2 = “makes”, return 3.</p>
<p>Note:<br>You may assume word1 and word2 are both in the list.</p>
<h3 id="解法1：双指针"><a href="#解法1：双指针" class="headerlink" title="解法1：双指针"></a>解法1：双指针</h3><p>区别就是当word1和word2相同的时候，退化成只需要一个指针就可以了。在这种情况下，先判断之前是否出现过这个单词，如果出现过计算下当前的距离，然后更新上一次出现的位置。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestWordDistance</span><span class="params">(String[] words, String word1, String word2)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (words.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> left = -<span class="number">1</span>, right = -<span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (words[i].equals(word1) &amp;&amp; word1.equals(word2)) &#123;</div><div class="line">                <span class="keyword">if</span> (left != -<span class="number">1</span>) &#123;</div><div class="line">                    res = Math.min(res, i - left);    </div><div class="line">                &#125;</div><div class="line">                left = i;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (words[i].equals(word1)) &#123;</div><div class="line">                left = i;</div><div class="line">                <span class="keyword">if</span> (right != -<span class="number">1</span>) &#123;</div><div class="line">                    res = Math.min(res, left - right);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (words[i].equals(word2)) &#123;</div><div class="line">                right = i;</div><div class="line">                <span class="keyword">if</span> (left != -<span class="number">1</span>) &#123;</div><div class="line">                    res = Math.min(res, right - left);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[259. 3Sum Smaller]]></title>
      <url>/2017/06/23/2017-06-23-259-3Sum-Smaller/</url>
      <content type="html"><![CDATA[<p>Given an array of n integers nums and a target, find the number of index triplets i, j, k with 0 &lt;= i &lt; j &lt; k &lt; n that satisfy the condition nums[i] + nums[j] + nums[k] &lt; target.</p>
<p>For example, given nums = [-2, 0, 1, 3], and target = 2.</p>
<p>Return 2. Because there are two triplets which sums are less than 2:</p>
<p>[-2, 0, 1]<br>[-2, 0, 3]</p>
<p>Follow up:<br>Could you solve it in O(n2) runtime?</p>
<h3 id="解法1：-O-N-2"><a href="#解法1：-O-N-2" class="headerlink" title="解法1： O(N^2)"></a>解法1： O(N^2)</h3><p>O(N^2)的解法和3Sum或者3Sum closest类似，但比较tricky的地方是，在用双指针left和right找到一个<target的数的时候，其实right 和left之间所有的数都满足要求（排序之后）。所以这个时候我们把right-left加入到res中，然后更新left即可。="" c++="" <figure="" class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></target的数的时候，其实right></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumSmaller</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">3</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Arrays.sort(nums);</div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++) &#123;</div><div class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</div><div class="line">            <span class="keyword">int</span> right = n - <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</div><div class="line">                <span class="keyword">int</span> sum = nums[i] + nums[left] + nums[right];</div><div class="line">                <span class="keyword">if</span> (sum &lt; target) &#123;</div><div class="line">                    cnt += right - left;    <span class="comment">// trick is here</span></div><div class="line">                    left++;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    right--;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> cnt;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[163. Missing Ranges]]></title>
      <url>/2017/06/23/2017-06-23-163-Missing-Ranges/</url>
      <content type="html"><![CDATA[<p>Given a sorted integer array where the range of elements are in the inclusive range [lower, upper], return its missing ranges.</p>
<p>For example, given [0, 1, 3, 50, 75], lower = 0 and upper = 99, return [“2”, “4-&gt;49”, “51-&gt;74”, “76-&gt;99”].</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>挺无聊的一道题，主要是corner case比较多。<br>算法不难，就是遍历一遍数组。找出是否是连续的数，如果不是那么补上缺少的range。<br>corner case有：<br>缺少的是一个数，不是range<br>两个相同的数<br>数字已经是Integer.MAX_VALUE，会溢出。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findMissingRanges</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>&#123;</div><div class="line"></div><div class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (lower == upper) &#123;</div><div class="line">                res.add(Integer.toString(lower));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                res.add(Integer.toString(lower) + <span class="string">"-&gt;"</span> + Integer.toString(upper));</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; nums[i] &gt; lower) &#123;</div><div class="line">                <span class="keyword">if</span> (nums[i] == lower + <span class="number">1</span>) &#123;</div><div class="line">                    res.add(Integer.toString(lower));</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                     res.add(Integer.toString(lower) + <span class="string">"-&gt;"</span> + Integer.toString(nums[i] - <span class="number">1</span>));</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (nums[i] != nums[i - <span class="number">1</span>] &amp;&amp; nums[i] &gt; nums[i - <span class="number">1</span>] + <span class="number">1</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>] + <span class="number">2</span>) &#123;</div><div class="line">                        res.add(Integer.toString(nums[i - <span class="number">1</span>] + <span class="number">1</span>));</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        res.add(Integer.toString(nums[i - <span class="number">1</span>] + <span class="number">1</span>) + <span class="string">"-&gt;"</span> + Integer.toString(nums[i] - <span class="number">1</span>));</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (i == nums.length - <span class="number">1</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (upper &gt; nums[i]) &#123;</div><div class="line">                    <span class="keyword">if</span> (upper == nums[i] + <span class="number">1</span>) &#123;</div><div class="line">                        res.add(Integer.toString(upper));</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        res.add(Integer.toString(nums[i] + <span class="number">1</span>) + <span class="string">"-&gt;"</span> + Integer.toString(upper));</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[442. Find All Duplicates in an Array]]></title>
      <url>/2017/06/23/2017-06-23-442-Find-All-Duplicates-in-an-Array/</url>
      <content type="html"><![CDATA[<p>Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.</p>
<p>Find all the elements that appear twice in this array.</p>
<p>Could you do it without extra space and in O(n) runtime?</p>
<p>Example:</p>
<p>Input:<br>[4,3,2,7,8,2,3,1]</p>
<p>Output:<br>[2,3]</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>这题比较关键的是题目的条件，数字在1和n之间。那么用置换的办法可以达到复杂度的要求。对于每一个数字，如果没有重复，排序之后他应该在i+1上。<br>那么我们可以把每一个数字归位。要注意，如果i和j置换了，i不应该往前进而是应该停留原地（i–那行很重要）<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// Use the condition that num in nums are between 1 and n</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i] != nums[nums[i] - <span class="number">1</span>]) &#123;</div><div class="line">                <span class="keyword">int</span> temp = nums[i];</div><div class="line">                nums[i] = nums[temp -<span class="number">1</span>];</div><div class="line">                nums[temp - <span class="number">1</span>] = temp;</div><div class="line">                i--;        <span class="comment">// very important</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (i != nums[i] - <span class="number">1</span>) &#123;</div><div class="line">                res.add(nums[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[209. Minimum Size Subarray Sum]]></title>
      <url>/2017/06/23/2017-06-23-209-Minimum-Size-Subarray-Sum/</url>
      <content type="html"><![CDATA[<p>Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead.</p>
<p>For example, given the array [2,3,1,2,4,3] and s = 7,<br>the subarray [4,3] has the minimal length under the problem constraint.</p>
<p>More practice:</p>
<p>If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).</p>
<h3 id="解法1：dynamic-window-O-N"><a href="#解法1：dynamic-window-O-N" class="headerlink" title="解法1：dynamic window O(N)"></a>解法1：dynamic window O(N)</h3><p>动态窗口的一种应用。用左右两个指针维护一个窗口，先移动右指针直到加和&gt;=sum, 然后在开始移动左指针，每次移动判断加和是否还满足并且更新最小的差距。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, n = nums.length, sum = <span class="number">0</span>;</div><div class="line">        <span class="comment">// left, right is a dynamic window</span></div><div class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</div><div class="line">            <span class="keyword">while</span> (sum &lt; s &amp;&amp; right &lt; n) &#123;</div><div class="line">                sum += nums[right++];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">while</span> (sum &gt;= s) &#123;</div><div class="line">                res = Math.min(res, right - left);</div><div class="line">                sum -= nums[left++];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res == Integer.MAX_VALUE ? <span class="number">0</span> : res;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法2：-binary-search"><a href="#解法2：-binary-search" class="headerlink" title="解法2： binary search"></a>解法2： binary search</h3><p>用binary search的条件是数组一定是一定程度上有序的。这里把数组变成了一个累加的数组。然后对于每一个加和<br>sum， 寻找在之后的第一个数字k使得k&gt;=sum+s，找到之后更新坐标。<br>Java<br><figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int minSubArrayLen(int s, int[] nums) &#123;</div><div class="line"></div><div class="line">        if (nums.length == 0) &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Create a helper array</div><div class="line">        int n = nums.length;</div><div class="line">        int[] helper = new int[n + 1];</div><div class="line">        for (int i = 1; i &lt;= n; i++) &#123;</div><div class="line">            helper[i] = helper[i - 1] + nums[i - 1];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int res = Integer.MAX_VALUE;</div><div class="line"></div><div class="line">        for (int i =  0; i &lt; n; i++) &#123;</div><div class="line">            int temp = binarySearch(helper, i + 1, n, s + helper[i]);</div><div class="line">            if (temp != -1) &#123;</div><div class="line">                res = Math.min(res, temp - i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return res == Integer.MAX_VALUE ? 0 : res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private int binarySearch(int[] nums, int left, int right, int target) &#123;</div><div class="line">        // Find the first element in nums that is larger or equal to the target</div><div class="line">        while (left + 1 &lt; right) &#123;</div><div class="line">            int mid = left + (right - left) / 2;</div><div class="line">            if (nums[mid] &lt; target) &#123;</div><div class="line">                left = mid;</div><div class="line">            &#125; else if (nums[mid] &gt;= target) &#123;</div><div class="line">                right = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (nums[left] &gt;= target) &#123;</div><div class="line">            return left;</div><div class="line">        &#125; else if (nums[right] &gt;= target) &#123;</div><div class="line">            return right;</div><div class="line">        &#125; else &#123;</div><div class="line">            return -1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Dynamic Window </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[277. Find the Celebrity]]></title>
      <url>/2017/06/23/2017-06-23-277-Find-the-Celebrity/</url>
      <content type="html"><![CDATA[<p>Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.</p>
<p>Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: “Hi, A. Do you know B?” to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).</p>
<p>You are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n), your function should minimize the number of calls to knows.</p>
<p>Note: There will be exactly one celebrity if he/she is in the party. Return the celebrity’s label if there is a celebrity in the party. If there is no celebrity, return -1.</p>
<h3 id="解法1-Greedy"><a href="#解法1-Greedy" class="headerlink" title="解法1: Greedy"></a>解法1: Greedy</h3><p>这题用暴力法解的话是O(N^2)的复杂度，那么要降低复杂度只有O(N), O(logN), O(NlogN)几种。似乎binary search也不能很好解决。在这种情况下，有一类算法可能有奇效，就是greedy。<br>可以用greedy的题目有一类特征就是有的时候题目会告诉，如果有的话有且仅有一个解。<br>这里我们就先遍历一遍数组，找到一个可能为celebrity的数字。<br>然后再验证一遍该数字，是否满足条件，如果不满足条件，那么就说明没有celebrity。如果有，那么就是他。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">Relation</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> celebrity = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (knows(celebrity, i)) &#123;</div><div class="line">                celebrity = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (celebrity != i &amp;&amp; (knows(celebrity, i) || !knows(i, celebrity))) &#123;</div><div class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> celebrity;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[74. Search a 2D Matrix]]></title>
      <url>/2017/06/23/2017-06-23-74-Search-a-2D-Matrix/</url>
      <content type="html"><![CDATA[<p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<pre><code>Integers in each row are sorted from left to right.
The first integer of each row is greater than the last integer of the previous row.
</code></pre><p>For example,</p>
<p>Consider the following matrix:</p>
<p>[<br>  [1,   3,  5,  7],<br>  [10, 11, 16, 20],<br>  [23, 30, 34, 50]<br>]</p>
<p>Given target = 3, return true.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>这题有两种做法，都用到了binary search。一种只需要一次binary search，也就是下面的这种解法。但缺点是row×col可能会溢出，同时取余数的操作比较expensive。<br>还有一种是两次binary search。先用一次找出最后一行其中第一个数字小于target，然后再这行再用一次binary search。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> m = matrix.length;</div><div class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = m * n - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end) &#123;</div><div class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">int</span> row = mid / n;</div><div class="line">            <span class="keyword">int</span> col = mid % n;</div><div class="line">            <span class="keyword">if</span> (matrix[row][col] &lt; target) &#123;</div><div class="line">                start = mid;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &gt; target) &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (matrix[start / n][start % n] == target || matrix[end / n][end % n] == target) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[81. Search in Rotated Sorted Array II]]></title>
      <url>/2017/06/23/2017-06-23-81-Search-in-Rotated-Sorted-Array-II/</url>
      <content type="html"><![CDATA[<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<p>Write a function to determine if a given target is in the array.</p>
<p>The array may contain duplicates.</p>
<h3 id="解法1-O-logN-worst-case-O-n"><a href="#解法1-O-logN-worst-case-O-n" class="headerlink" title="解法1: O(logN), worst case O(n)"></a>解法1: O(logN), worst case O(n)</h3><p>当有重复值的时候，我们在判断丢弃left或者是right half的时候，如果碰到nums[mid] == nums[end]或者nums[mid] == nums[start]的时候，不能判断哪一个部分需要抛弃。这个时候只能让end–或者start–<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end) &#123;</div><div class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[end]) &#123;</div><div class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; nums[end] &gt;= target) &#123;</div><div class="line">                    start = mid;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    end = mid;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[end]) &#123;</div><div class="line">                <span class="keyword">if</span> (nums[start] &lt;= target &amp;&amp; nums[mid] &gt; target) &#123;</div><div class="line">                    end = mid;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    start = mid;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                end--;  <span class="comment">// can not remove a half</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums[end] == target || nums[start] == target) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[18. 4Sum]]></title>
      <url>/2017/06/23/2017-06-23-18-4Sum/</url>
      <content type="html"><![CDATA[<p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>
<p>Note: The solution set must not contain duplicate quadruplets.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.</div><div class="line"></div><div class="line">A solution set is:</div><div class="line">[</div><div class="line">  [-1,  0, 0, 1],</div><div class="line">  [-2, -1, 1, 2],</div><div class="line">  [-2,  0, 0, 2]</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h3 id="解法1：-O-N-3"><a href="#解法1：-O-N-3" class="headerlink" title="解法1： O(N^3)"></a>解法1： O(N^3)</h3><p>和3Sum一样的思路，最外层遍历第一个数，第二层遍历第二个数，之后用双指针像中间扫描。遇到加和为target的就推入list中。要注意的是需要去重。那么每一次去重的时候只需要跳过和前一个一样的数就可以了。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line"></div><div class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Arrays.sort(nums);      <span class="comment">// need to sort first</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">3</span>; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n - <span class="number">2</span>; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (j != i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">int</span> k = j + <span class="number">1</span>;</div><div class="line">                <span class="keyword">int</span> m = n - <span class="number">1</span>;</div><div class="line">                <span class="keyword">while</span> (k &lt; m) &#123;</div><div class="line">                    <span class="keyword">while</span> (k != j + <span class="number">1</span> &amp;&amp; k &lt; m &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) &#123;</div><div class="line">                        k++;    <span class="comment">// remove duplicates</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">while</span> (m != n - <span class="number">1</span> &amp;&amp; k &lt; m &amp;&amp; nums[m] == nums[m + <span class="number">1</span>]) &#123;</div><div class="line">                        m--;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (k &lt; m) &#123;</div><div class="line">                        <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[k] + nums[m];</div><div class="line">                        <span class="keyword">if</span> (sum == target) &#123;</div><div class="line">                            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">                            temp.add(nums[i]);</div><div class="line">                            temp.add(nums[j]);</div><div class="line">                            temp.add(nums[k]);</div><div class="line">                            temp.add(nums[m]);</div><div class="line">                            res.add(temp);</div><div class="line">                            k++;</div><div class="line">                            m--;</div><div class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</div><div class="line">                            k++;</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            m--;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[16.3Sum Closest]]></title>
      <url>/2017/06/23/2017-06-23-16-3Sum-Closest/</url>
      <content type="html"><![CDATA[<p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<pre><code>For example, given array S = {-1 2 1 -4}, and target = 1.

The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
</code></pre><h3 id="解法1：O-N-2"><a href="#解法1：O-N-2" class="headerlink" title="解法1：O(N^2)"></a>解法1：O(N^2)</h3><p>closest转化为程序的意思就是说，需要一个var来记录每一次的sum，然后把当前的diff和之前diff来比较。<br>循环的时候从头开始像后循环。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Arrays.sort(nums);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> closest = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span> &amp;&amp; i &lt; nums.length; i++) &#123;</div><div class="line">            closest += nums[i];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">3</span>) &#123;</div><div class="line">            <span class="keyword">return</span> closest;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</div><div class="line">            <span class="keyword">int</span> j =  i + <span class="number">1</span>;</div><div class="line">            <span class="keyword">int</span> k = nums.length - <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (j &lt; k) &#123;</div><div class="line">                <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[k];</div><div class="line">                <span class="keyword">if</span> (Math.abs(sum - target) &lt; Math.abs(closest - target)) &#123;</div><div class="line">                    closest = sum;</div><div class="line">                    <span class="keyword">if</span> (closest == target) <span class="keyword">return</span> closest;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (sum &lt; target) &#123;</div><div class="line">                    j++;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    k--;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> closest;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[575. Distribute Candies]]></title>
      <url>/2017/06/21/2017-06-21-575-Distribute-Candies/</url>
      <content type="html"><![CDATA[<p>Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Input: candies = [1,1,2,2,3,3]</div><div class="line">Output: 3</div><div class="line">Explanation:</div><div class="line">There are three different kinds of candies (1, 2 and 3), and two candies for each kind.</div><div class="line">Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too.</div><div class="line">The sister has three different kinds of candies.</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Input: candies = [1,1,2,3]</div><div class="line">Output: 2</div><div class="line">Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1].</div><div class="line">The sister has two different kinds of candies, the brother has only one kind of candies.</div></pre></td></tr></table></figure></p>
<p>Note:</p>
<pre><code>The length of the given array is in range [2, 10,000], and will be even.
The number in given array is in range [-100,000, 100,000].
</code></pre><h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>有一类问题的思路是这样的：如果求最大或者最小值，先考虑一下理论上可能可以取到的值。然后再以此为突破口看看是否有思路。<br>这题就是这样，先想到要取n/2个数，那么最大的种类也就是n/2，不可能再大了。那么如果数组里的类别比n/2小，那么最大的值就是数组里的数的种类数。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(<span class="keyword">int</span>[] candies)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (candies == <span class="keyword">null</span> || candies.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> candy: candies) &#123;</div><div class="line">            set.add(candy);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> Math.min(set.size(), candies.length / <span class="number">2</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[557. Reverse Words in a String III]]></title>
      <url>/2017/06/21/2017-06-21-557-Reverse-Words-in-a-String-III/</url>
      <content type="html"><![CDATA[<p>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p>
<p>Example 1:</p>
<p>Input: “Let’s take LeetCode contest”<br>Output: “s’teL ekat edoCteeL tsetnoc”</p>
<p>Note: In the string, each word is separated by single space and there will not be any extra space in the string.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>用两个指针指向需要reverse的部分，再分别reverse。把string转化成char array之后比较好操作。<br>char array到string可以用new string(a)来转化。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> s;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">char</span>[] ch = s.toCharArray();</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (end &lt; ch.length) &#123;</div><div class="line">            <span class="keyword">if</span> (ch[end] != <span class="string">' '</span>) &#123;</div><div class="line">                end++;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// reverse substring from start to end</span></div><div class="line">                reverse(ch, start, end - <span class="number">1</span>);</div><div class="line">                <span class="keyword">while</span> (end &lt; ch.length &amp;&amp; ch[end] == <span class="string">' '</span>) &#123;</div><div class="line">                    end++;</div><div class="line">                &#125;</div><div class="line">                start = end;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        reverse(ch, start, end - <span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(ch);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</div><div class="line">            <span class="keyword">char</span> temp = ch[start];</div><div class="line">            ch[start] = ch[end];</div><div class="line">            ch[end] = temp;</div><div class="line">            start++;</div><div class="line">            end--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[617. Merge Two Binary Trees]]></title>
      <url>/2017/06/21/2017-06-21-617-Merge-Two-Binary-Trees/</url>
      <content type="html"><![CDATA[<p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p>
<p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line"> Tree 1                     Tree 2                  </div><div class="line">         1                         2                             </div><div class="line">        / \                       / \                            </div><div class="line">       3   2                     1   3                        </div><div class="line">      /                           \   \                      </div><div class="line">     5                             4   7                  </div><div class="line">Output:</div><div class="line">Merged tree:</div><div class="line">      3</div><div class="line">     / \</div><div class="line">    4   5</div><div class="line">   / \   \</div><div class="line">  5   4   7</div></pre></td></tr></table></figure></p>
<p>Note: The merging process must start from the root nodes of both trees.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>Tree最常见的divide &amp; conquer思想，分成左右树。然后分别递归。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        TreeNode node = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (t2 == <span class="keyword">null</span>) &#123;</div><div class="line">            node = <span class="keyword">new</span> TreeNode(t1.val);</div><div class="line">            node.left = mergeTrees(t1.left, <span class="keyword">null</span>);</div><div class="line">            node.right = mergeTrees(t1.right, <span class="keyword">null</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t1 == <span class="keyword">null</span>) &#123;</div><div class="line">            node = <span class="keyword">new</span> TreeNode(t2.val);</div><div class="line">            node.left = mergeTrees(t2.left, <span class="keyword">null</span>);</div><div class="line">            node.right = mergeTrees(t2.right, <span class="keyword">null</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            node = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</div><div class="line">            node.left = mergeTrees(t1.left, t2.left);</div><div class="line">            node.right = mergeTrees(t1.right, t2.right);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> node;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[80. Remove Duplicates from Sorted Array II]]></title>
      <url>/2017/06/21/2017-06-21-80-Remove-Duplicates-from-Sorted-Array-II/</url>
      <content type="html"><![CDATA[<p>Follow up for <a href="http://bigteemo.github.io/2016/12/18/leetcode-solution-Remove-Duplicates-from-Sorted-Array-26/">“Remove Duplicates”</a>:<br>What if duplicates are allowed at most twice?</p>
<p>For example,<br>Given sorted array nums = [1,1,1,2,2,3],</p>
<p>Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn’t matter what you leave beyond the new length.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>还是双指针。用一个慢指针p来记录下一个需要插入的位置。一开始快慢指针都在一起。然后比较快指针p所对应的元素与p-2所对应的元素。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> nums.length;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> p = <span class="number">2</span>, i = <span class="number">2</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt; nums.length) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i] != nums[p - <span class="number">2</span>]) &#123;</div><div class="line">                nums[p++] = nums[i];</div><div class="line">            &#125;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> p;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[289. Game of Life]]></title>
      <url>/2017/06/20/2017-06-20-289-Game-of-Life/</url>
      <content type="html"><![CDATA[<p>According to the Wikipedia’s article: “The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.”</p>
<p>Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</p>
<p>   Any live cell with fewer than two live neighbors dies, as if caused by under-population.<br>   Any live cell with two or three live neighbors lives on to the next generation.<br>   Any live cell with more than three live neighbors dies, as if by over-population..<br>   Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.</p>
<p>Write a function to compute the next state (after one update) of the board given its current state.</p>
<p>Follow up:</p>
<p>   Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.<br>   In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>这题的关键点在于要想到用状态机来存储过去的历史。如果一位上仅用0,1表示的话，那么只能表示两个状态。如果我们用2 bits（也就是0,1,2,3）来表示的话可以表示4个状态。<br>这里我们有<br>0 -&gt; 0 : 0<br>1 -&gt; 1 : 1<br>1 -&gt; 0 : 2<br>0 -&gt; 1 : 3<br>然后逐个扫描，根据规则update每一个元素。要注意的是判断live cell的时候要check两个数值，一个是1，一个是2。这个地方很容易错。<br>最后我们对结果数组对2取对数就可以了。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public void gameOfLife(int[][] board) &#123;</div><div class="line"></div><div class="line">        if (board.length == 0 || board[0].length == 0) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int m = board.length, n = board[0].length;</div><div class="line"></div><div class="line">        // define directions</div><div class="line">        int[][] directions = new int[][]&#123;&#123;0,-1&#125;,&#123;-1,-1&#125;,&#123;-1,0&#125;,&#123;-1,1&#125;,&#123;0,1&#125;,&#123;1,1&#125;,&#123;1,0&#125;,&#123;1,-1&#125;&#125;;</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; m; i++) &#123;</div><div class="line">            for (int j = 0; j &lt; n; j++) &#123;</div><div class="line">                int cnt = 0;</div><div class="line">                for (int k = 0; k &lt; directions.length; k++) &#123;</div><div class="line">                    int row = i + directions[k][0];</div><div class="line">                    int col = j + directions[k][1];</div><div class="line">                    if (row &gt;= 0 &amp;&amp; row &lt; m &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; n &amp;&amp; (board[row][col] == 1 || board[row][col] == 2)) &#123;</div><div class="line">                        cnt++;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if (board[i][j] == 1 &amp;&amp; (cnt &lt; 2 || cnt &gt; 3)) &#123;</div><div class="line">                    board[i][j] = 2;</div><div class="line">                &#125; else if (board[i][j] == 0 &amp;&amp; cnt == 3) &#123;</div><div class="line">                    board[i][j] = 3;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; m; i++) &#123;</div><div class="line">            for (int j = 0; j &lt; n; j++) &#123;</div><div class="line">                board[i][j] %= 2;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> 状态机 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[229. Majority Element II]]></title>
      <url>/2017/06/20/2017-06-20-229-Majority-Element-II/</url>
      <content type="html"><![CDATA[<p>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>Moore Voting 算法的延伸。 和Majority Element I类似，这里用两个变量来维护当前出现次数较大的数字。<br>对于第二个元素n2初始化为0是没关系的，因为他的计数器初始化为0。如果有数字和他一样的话计数器再加1。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line"></div><div class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> n1 = nums[<span class="number">0</span>], n2 = <span class="number">0</span>, c1 = <span class="number">0</span>, c2 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</div><div class="line">            <span class="keyword">if</span> (num == n1) &#123;</div><div class="line">                c1++;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == n2) &#123;</div><div class="line">                c2++;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c1 == <span class="number">0</span>) &#123;</div><div class="line">                n1 = num;</div><div class="line">                c1 = <span class="number">1</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c2 == <span class="number">0</span>) &#123;</div><div class="line">                n2 = num;</div><div class="line">                c2 = <span class="number">1</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                c1--;</div><div class="line">                c2--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        c1 = <span class="number">0</span>;</div><div class="line">        c2 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</div><div class="line">            <span class="keyword">if</span> (num == n1) &#123;</div><div class="line">                c1++;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == n2) &#123;</div><div class="line">                c2++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (c1 &gt; nums.length / <span class="number">3</span>) &#123;</div><div class="line">            res.add(n1);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (c2 &gt; nums.length / <span class="number">3</span>) &#123;</div><div class="line">            res.add(n2);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[287. Find the Duplicate Number]]></title>
      <url>/2017/06/20/2017-06-20-287-Find-the-Duplicate-Number/</url>
      <content type="html"><![CDATA[<p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
<p>Note:</p>
<p>   You must not modify the array (assume the array is read only).<br>   You must use only constant, O(1) extra space.<br>   Your runtime complexity should be less than O(n2).<br>   There is only one duplicate number in the array, but it could be repeated more than once.</p>
<h3 id="解法1：O-NlogN"><a href="#解法1：O-NlogN" class="headerlink" title="解法1：O(NlogN)"></a>解法1：O(NlogN)</h3><p>这题是一个binary search的变形。题目给的条件显示能套用的常用算法应该只剩下binary search了。<br>难点是怎么舍弃一半的空间。这里巧妙的用了这个特性：1 - n的数字的mid是（1+n)/2, 那么如果比mid小的数较多，说明重复的数在小半区。这样我们可以缩小范围。<br>如果比mid小的数较少，那么重复的数就在大半区。<br>计算出一个mid之后统计和mid大小的时候要遍历。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = nums.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</div><div class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</div><div class="line">            <span class="comment">// loop through nums</span></div><div class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</div><div class="line">                <span class="keyword">if</span> (num &lt;= mid) &#123;</div><div class="line">                    cnt++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (cnt &gt; mid) &#123;</div><div class="line">                right = mid;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                left = mid + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> left;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法2：O-N"><a href="#解法2：O-N" class="headerlink" title="解法2：O(N)"></a>解法2：O(N)</h3><p>龟兔赛跑的算法，和找闭环的入口的思路一样。这里用的是一个扩展了的算法。<br>核心就是对于slow指针apply function一次，而对于fast指针apply function两次。<br>具体的解释可以参考<a href="http://bookshadow.com/weblog/2015/09/28/leetcode-find-duplicate-number/" target="_blank" rel="external">这个</a><br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            slow = nums[slow];</div><div class="line">            fast = nums[nums[fast]];</div><div class="line">            <span class="keyword">if</span> (slow == fast) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        fast = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            slow = nums[slow];</div><div class="line">            fast = nums[fast];</div><div class="line">            <span class="keyword">if</span> (slow == fast) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> slow;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Moore Voting </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[33. Search in Rotated Sorted Array]]></title>
      <url>/2017/06/20/2017-06-20-33-Search-in-Rotated-Sorted-Array/</url>
      <content type="html"><![CDATA[<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>Binary Search的经典题。主要是要考虑怎么扔掉一半。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end) &#123;</div><div class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> (nums[start] == nums[mid]) &#123;</div><div class="line">                <span class="keyword">return</span> mid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (nums[start] &lt; nums[mid]) &#123;</div><div class="line">                <span class="keyword">if</span> (target &lt; nums[mid] &amp;&amp; target &gt;= nums[start]) &#123;</div><div class="line">                    end = mid;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    start = mid;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end]) &#123;</div><div class="line">                    start = mid;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    end = mid;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums[end] == target) &#123;</div><div class="line">            <span class="keyword">return</span> end;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums[start] == target) &#123;</div><div class="line">            <span class="keyword">return</span> start;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[228. Summary Ranges]]></title>
      <url>/2017/06/20/2017-06-20-228-Summary-Ranges/</url>
      <content type="html"><![CDATA[<p>Given a sorted integer array without duplicates, return the summary of its ranges.</p>
<p>For example, given [0,1,2,4,5,7], return [“0-&gt;2”,”4-&gt;5”,”7”].</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>这题思路很简单，双指针。就是要写好写的没有bug不容易。<br>用一个j记录end的距离，然后在push到结果的时候检查j是否为1，以此来判断是否是单数。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">summaryRanges</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line"></div><div class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</div><div class="line">            <span class="keyword">int</span> j = <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (i + j &lt; n &amp;&amp; nums[i + j] - nums[i] == j) &#123;</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">            String range = j == <span class="number">1</span> ? Integer.toString(nums[i]) : Integer.toString(nums[i]) + <span class="string">"-&gt;"</span> + Integer.toString(nums[i + j - <span class="number">1</span>]);</div><div class="line">            res.add(range);</div><div class="line">            i += j;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[624. Maximum Distance in Arrays]]></title>
      <url>/2017/06/20/2017-06-20-624-Maximum-Distance-in-Arrays/</url>
      <content type="html"><![CDATA[<p>Given m arrays, and each array is sorted in ascending order. Now you can pick up two integers from two different arrays (each array picks one) and calculate the distance. We define the distance between two integers a and b to be their absolute difference |a-b|. Your task is to find the maximum distance.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">[[1,2,3],</div><div class="line">[4,5],</div><div class="line">[1,2,3]]</div><div class="line">Output: 4</div><div class="line">Explanation:</div><div class="line">One way to reach the maximum distance 4 is to pick 1 in the first or third array and pick 5 in the second array.</div></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>   Each given array will have at least 1 number. There will be at least two non-empty arrays.<br>   The total number of the integers in all the m arrays will be in the range of [2, 10000].<br>   The integers in the m arrays will be in the range of [-10000, 10000].</p>
<h3 id="解法1：-O-NM"><a href="#解法1：-O-NM" class="headerlink" title="解法1： O(NM)"></a>解法1： O(NM)</h3><p>Maintain global min and max calculated from previous arrays and compare current min, max wrt to the global ones.<br>Results should be in Max(res, abs(global_min - current_max)) and Max(res, abs(global_max - current_min))<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; arrays)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> amin = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">int</span> amax = Integer.MIN_VALUE;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrays.get(<span class="number">0</span>).size(); i++) &#123;</div><div class="line">            amin = Math.min(amin, arrays.get(<span class="number">0</span>).get(i));</div><div class="line">            amax = Math.max(amax, arrays.get(<span class="number">0</span>).get(i));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arrays.size(); i++) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// get min and max from each array</span></div><div class="line">            <span class="keyword">int</span> cmin = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">int</span> cmax = Integer.MIN_VALUE;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arrays.get(i).size(); j++) &#123;</div><div class="line">                cmin = Math.min(cmin, arrays.get(i).get(j));</div><div class="line">                cmax = Math.max(cmax, arrays.get(i).get(j));</div><div class="line">                res = Math.max(res, Math.abs(amin - cmax));</div><div class="line">                res = Math.max(res, Math.abs(amax - cmin));</div><div class="line">            &#125;</div><div class="line">            amin = Math.min(cmin, amin);</div><div class="line">            amax = Math.max(cmax, amax);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[219. Contains Duplicate II]]></title>
      <url>/2017/06/06/2017-06-06-219-Contains-Duplicate-II/</url>
      <content type="html"><![CDATA[<p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.</p>
<h3 id="解法1：O-N-Time-O-N-Space"><a href="#解法1：O-N-Time-O-N-Space" class="headerlink" title="解法1：O(N) Time + O(N) Space"></a>解法1：O(N) Time + O(N) Space</h3><p>用一个HashMap来存储每一个number出现的位置。然后对于所有出现过两次以上的数字计算是否有满足的答案。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, List&lt;Integer&gt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (map.containsKey(nums[i])) &#123;</div><div class="line">                map.get(nums[i]).add(i);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                map.put(nums[i], <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</div><div class="line">                map.get(nums[i]).add(i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// traverse the HashMap</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : map.keySet()) &#123;</div><div class="line">            <span class="keyword">if</span> (map.get(num).size() &gt;= <span class="number">2</span>) &#123;</div><div class="line">                List&lt;Integer&gt; indices = map.get(num);</div><div class="line">                <span class="comment">// traverse the list</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indices.size() - <span class="number">1</span>; ++i) &#123;</div><div class="line">                    <span class="keyword">if</span> (indices.get(i + <span class="number">1</span>) - indices.get(i) &lt;= k) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[566. Reshape the Matrix]]></title>
      <url>/2017/06/06/2017-06-06-566-Reshape-the-Matrix/</url>
      <content type="html"><![CDATA[<p>In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data.</p>
<p>You’re given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively.</p>
<p>The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.</p>
<p>If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Input: </div><div class="line">nums = </div><div class="line">[[1,2],</div><div class="line"> [3,4]]</div><div class="line">r = 1, c = 4</div><div class="line">Output: </div><div class="line">[[1,2,3,4]]</div><div class="line">Explanation:</div><div class="line">The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Input: </div><div class="line">nums = </div><div class="line">[[1,2],</div><div class="line"> [3,4]]</div><div class="line">r = 2, c = 4</div><div class="line">Output: </div><div class="line">[[1,2],</div><div class="line"> [3,4]]</div><div class="line">Explanation:</div><div class="line">There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.</div></pre></td></tr></table></figure></p>
<p>Note:<br>The height and width of the given matrix is in range [1, 100].<br>The given r and c are all positive.<br>Show Company Tags<br>Show Tags</p>
<h3 id="解法1：O-MN"><a href="#解法1：O-MN" class="headerlink" title="解法1：O(MN)"></a>解法1：O(MN)</h3><p>主要就是掌握一个二维数组的index对应的行列的求法。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] matrixReshape(<span class="keyword">int</span>[][] nums, <span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums[<span class="number">0</span>] == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> row = nums.length;</div><div class="line">        <span class="keyword">int</span> col = nums[<span class="number">0</span>].length;</div><div class="line">        </div><div class="line">        <span class="comment">// check for dimension match</span></div><div class="line">        <span class="keyword">if</span> (row * col != r * c) &#123;</div><div class="line">            <span class="keyword">return</span> nums;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[r][c];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; ++i) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; ++j) &#123;</div><div class="line">                <span class="comment">// calculate the original index</span></div><div class="line">                <span class="keyword">int</span> index = i * c + j;</div><div class="line">                res[i][j] = nums[index / col][index % col];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[581. Shortest Unsorted Continuous Subarray]]></title>
      <url>/2017/06/06/2017-06-06-581-Shortest-Unsorted-Continuous-Subarray/</url>
      <content type="html"><![CDATA[<p>Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.</p>
<p>You need to find the shortest such subarray and output its length.</p>
<p>Example 1:<br>Input: [2, 6, 4, 8, 10, 9, 15]<br>Output: 5<br>Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.<br>Note:<br>Then length of the input array is in range [1, 10,000].<br>The input array may contain duplicates, so ascending order here means &lt;=.</p>
<h3 id="解法1：O-NlogN"><a href="#解法1：O-NlogN" class="headerlink" title="解法1：O(NlogN)"></a>解法1：O(NlogN)</h3><p>这题的思路是从一个sorted过的array出发，然后再用两个指针从两端往里面找和sorted之后的结果不一样的位置。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span>[] sorted = nums.clone();</div><div class="line">        Arrays.sort(sorted);</div><div class="line">        </div><div class="line">        <span class="comment">// two pointers from left and from right</span></div><div class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i] == sorted[i]) &#123;</div><div class="line">                len++;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i] == sorted[i]) &#123;</div><div class="line">                len++;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> Math.max(<span class="number">0</span>, nums.length - len);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Array Partition I (561)]]></title>
      <url>/2017/06/06/2017-06-06-leetcode-solution-Array-Partition-I-561/</url>
      <content type="html"><![CDATA[<p>Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Input: [1,4,3,2]</div><div class="line"></div><div class="line">Output: 4</div><div class="line">Explanation: n is 2, and the maximum sum of pairs is 4.</div></pre></td></tr></table></figure></p>
<p>Note:<br>n is a positive integer, which is in the range of [1, 10000].<br>All the integers in the array will be in the range of [-10000, 10000].</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>这题其实是一个数学题，先排序之后每两个组成一组的话选出的最小值的和是最大的。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;nums.length; i = i + <span class="number">2</span>) &#123;</div><div class="line">            sum += nums[i];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Can Place Flowers (605)]]></title>
      <url>/2017/06/06/2017-06-06-leetcode-solutions-Can-Place-Flowers-605/</url>
      <content type="html"><![CDATA[<p>Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.</p>
<p>Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: flowerbed = [1,0,0,0,1], n = 1</div><div class="line">Output: True</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: flowerbed = [1,0,0,0,1], n = 2</div><div class="line">Output: False</div></pre></td></tr></table></figure></p>
<p>Note:<br>The input array won’t violate no-adjacent-flowers rule.<br>The input array size is in the range of [1, 20000].<br>n is a non-negative integer which won’t exceed the input array size.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="keyword">int</span>[] flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (flowerbed == <span class="keyword">null</span> || flowerbed.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;        </div><div class="line">        </div><div class="line">        <span class="comment">// traverse from left to right</span></div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> size = flowerbed.length;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (i &lt; size &amp;&amp; flowerbed[i] == <span class="number">1</span>) &#123;</div><div class="line">                i += <span class="number">2</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= size) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// check left &amp; right </span></div><div class="line">                <span class="keyword">if</span> ((i == <span class="number">0</span> || flowerbed[i - <span class="number">1</span>] == <span class="number">0</span>) &amp;&amp; (i == size - <span class="number">1</span> || flowerbed[i + <span class="number">1</span>] == <span class="number">0</span>)) &#123;</div><div class="line">                    flowerbed[i] = <span class="number">1</span>;</div><div class="line">                    n--;</div><div class="line">                    i += <span class="number">2</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    i += <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> n == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Spiral Matrix II (59)]]></title>
      <url>/2017/06/06/2017-06-06-leetcode-solution-Spiral-Matrix-II-59/</url>
      <content type="html"><![CDATA[<p>Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.</p>
<p>For example,<br>Given n = 3,</p>
<p>You should return the following matrix:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line"> [ 1, 2, 3 ],</div><div class="line"> [ 8, 9, 4 ],</div><div class="line"> [ 7, 6, 5 ]</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</div><div class="line">        <span class="keyword">int</span> level = (n + <span class="number">1</span>) / <span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</div><div class="line">        <span class="comment">// fill by level</span></div><div class="line">        </div><div class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level; ++i) &#123;</div><div class="line">            <span class="keyword">int</span> lastrow = n - i - <span class="number">1</span>;</div><div class="line">            <span class="keyword">int</span> lastcol = n - i - <span class="number">1</span>;</div><div class="line">            </div><div class="line">            <span class="comment">// move right</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= lastcol; ++j) &#123;</div><div class="line">                res[i][j] = num;</div><div class="line">                num++;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// move down</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= lastrow; ++j) &#123;</div><div class="line">                res[j][lastcol] = num;</div><div class="line">                num++;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// move left</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = lastcol - <span class="number">1</span>; j &gt;= i; --j) &#123;</div><div class="line">                res[lastrow][j] = num;</div><div class="line">                num++;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// move up</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = lastrow - <span class="number">1</span>; j &gt; i; --j) &#123;</div><div class="line">                res[j][i] = num;</div><div class="line">                num++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode solution: Sort Characters By Frequency (451)]]></title>
      <url>/2017/04/20/2017-04-20-leetcode-solution-Sort-Characters-By-Frequency-451/</url>
      <content type="html"><![CDATA[<p>Given a string, sort it in decreasing order based on the frequency of characters.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">&quot;tree&quot;</div><div class="line"></div><div class="line">Output:</div><div class="line">&quot;eert&quot;</div><div class="line"></div><div class="line">Explanation:</div><div class="line">&apos;e&apos; appears twice while &apos;r&apos; and &apos;t&apos; both appear once.</div><div class="line">So &apos;e&apos; must appear before both &apos;r&apos; and &apos;t&apos;. Therefore &quot;eetr&quot; is also a valid answer.</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">&quot;cccaaa&quot;</div><div class="line"></div><div class="line">Output:</div><div class="line">&quot;cccaaa&quot;</div><div class="line"></div><div class="line">Explanation:</div><div class="line">Both &apos;c&apos; and &apos;a&apos; appear three times, so &quot;aaaccc&quot; is also a valid answer.</div><div class="line">Note that &quot;cacaca&quot; is incorrect, as the same characters must be together.</div></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">&quot;Aabb&quot;</div><div class="line"></div><div class="line">Output:</div><div class="line">&quot;bbAa&quot;</div><div class="line"></div><div class="line">Explanation:</div><div class="line">&quot;bbaA&quot; is also a valid answer, but &quot;Aabb&quot; is incorrect.</div><div class="line">Note that &apos;A&apos; and &apos;a&apos; are treated as two different characters.</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character,Integer&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: s.toCharArray()) &#123;</div><div class="line">            map.put(c, map.getOrDefault(c,<span class="number">0</span>) + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        List&lt;Map.Entry&lt;Character, Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(map.entrySet());</div><div class="line">        Comparator&lt;Map.Entry&lt;Character,Integer&gt;&gt; comparator = <span class="keyword">new</span> Comparator&lt;Map.Entry&lt;Character, Integer&gt;&gt;() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry&lt;Character, Integer&gt; left, Map.Entry&lt;Character, Integer&gt; right)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> right.getValue().compareTo(left.getValue());</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        </div><div class="line">        list.sort(comparator);</div><div class="line">        </div><div class="line">        <span class="comment">// Create String</span></div><div class="line">        StringBuffer ss = <span class="keyword">new</span> StringBuffer();</div><div class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : list) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entry.getValue(); ++i) &#123;</div><div class="line">                ss.append(entry.getKey());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> ss.toString();</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Search a 2D Matrix (74)]]></title>
      <url>/2017/04/08/2017-04-08-leetcode-solution-Search-a-2D-Matrix-74/</url>
      <content type="html"><![CDATA[<p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<p>Integers in each row are sorted from left to right.<br>The first integer of each row is greater than the last integer of the previous row.<br>For example,</p>
<p>Consider the following matrix:</p>
<p>[<br>  [1,   3,  5,  7],<br>  [10, 11, 16, 20],<br>  [23, 30, 34, 50]<br>]<br>Given target = 3, return true.</p>
<h3 id="解法1：Binary-Search-O-logMN-MN-total-of-elements"><a href="#解法1：Binary-Search-O-logMN-MN-total-of-elements" class="headerlink" title="解法1：Binary Search O(logMN) MN = total # of elements"></a>解法1：Binary Search O(logMN) MN = total # of elements</h3><p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode解题: Merge Intervals (56)]]></title>
      <url>/2017/04/08/2017-04-08-Leetcode-solution-Merge-Intervals-56/</url>
      <content type="html"><![CDATA[<p>Given a collection of intervals, merge all overlapping intervals.</p>
<p>For example,<br>Given [1,3],[2,6],[8,10],[15,18],<br>return [1,6],[8,10],[15,18].</p>
<h3 id="解法1：O-NlogN-Time"><a href="#解法1：O-NlogN-Time" class="headerlink" title="解法1：O(NlogN) Time"></a>解法1：O(NlogN) Time</h3><p>先排序之后再合并比较简单。只要检查后面的start是否比前面的end小就可以了。</p>
<p>Java<br>主要是锻炼一下Java中用Collections.sort(list, comparator)的用法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for an interval.</span></div><div class="line"><span class="comment"> * public class Interval &#123;</span></div><div class="line"><span class="comment"> *     int start;</span></div><div class="line"><span class="comment"> *     int end;</span></div><div class="line"><span class="comment"> *     Interval() &#123; start = 0; end = 0; &#125;</span></div><div class="line"><span class="comment"> *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">merge</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.size() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> intervals;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        Comparator&lt;Interval&gt; comparator = <span class="keyword">new</span> Comparator&lt;Interval&gt;() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Interval left, Interval right)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> left.start - right.start;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">// Sort the interval based on the start </span></div><div class="line">        Collections.sort(intervals, comparator);</div><div class="line">        </div><div class="line">        List&lt;Interval&gt; res = <span class="keyword">new</span> ArrayList&lt;Interval&gt;();</div><div class="line">        res.add(intervals.get(<span class="number">0</span>));</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); ++i) &#123;</div><div class="line">            Interval current = intervals.get(i);</div><div class="line">            Interval previous = res.get(res.size() - <span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span> (current.start &lt;= previous.end) &#123;</div><div class="line">                previous.end = Math.max(current.end, previous.end);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                res.add(current);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Integer to Roman (12)]]></title>
      <url>/2017/04/08/2017-04-08-leetcode-solution-Integer-to-Roman-12/</url>
      <content type="html"><![CDATA[<p>Given an integer, convert it to a roman numeral.</p>
<p>Input is guaranteed to be within the range from 1 to 3999.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>主要的思路是要先构造出来罗马数字中的“根”数。也就是说，除了那么1,5,10,50,100,500,1000的数字，还有那些需要特殊处理的，比如40.<br>然后得算法就简单了，就遍历一遍dict， 每当找出来一个比当前base小的数就计算出需要重复几遍，比如III。<br>然后更新base数值。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="comment">// Write your code here</span></div><div class="line">        </div><div class="line">         </div><div class="line">        String dict[] = <span class="keyword">new</span> String[]&#123;<span class="string">"M"</span>, <span class="string">"CM"</span>, <span class="string">"D"</span>, <span class="string">"CD"</span>, <span class="string">"C"</span>, <span class="string">"XC"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>, <span class="string">"X"</span>, <span class="string">"IX"</span>, <span class="string">"V"</span>, <span class="string">"IV"</span>, <span class="string">"I"</span>&#125;;</div><div class="line">        <span class="keyword">int</span> base[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</div><div class="line">        </div><div class="line">        String res = <span class="string">""</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dict.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (n &gt;= base[i]) &#123;</div><div class="line">                </div><div class="line">                <span class="keyword">int</span> count = n / base[i];</div><div class="line">                n = n % base[i];</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++) &#123;</div><div class="line">                    res += dict[i];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: String to Integer (8)]]></title>
      <url>/2017/04/08/2017-04-08-leetcode-solution-String-to-Integer-8/</url>
      <content type="html"><![CDATA[<p>Implement atoi to convert a string to an integer.</p>
<p>Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.</p>
<p>Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>这题要考虑的corner case比较多，也是这题的难点。<br>corner case有：<br><em>empty string</em><br><em>string with space</em><br><em>string with positive or negative sign</em><br><em>string with non-digit numbers</em><br><em>overflow integer</em><br>对于overflow的处理有两种情况。一个是当前的total乘以10之后超过Integer.MAX_VALUE，由于不能直接比total * 10 &gt; Integer.MAX_VALUE, 我们可以换一种比法。<br>用Integer.MAX_VALUE / 10 &lt; total 表示判断标准。<br>但是这又有一种情况就是Integer.MAX_VALUE / 10 是整数除法，可能会有遗漏的情况是最后一位不同。<br>那么就需要排除Integer.MAX_VALUE / 10 == total &amp;&amp; Integer.MAX_VALUE % 10 &lt; digit 的情况。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.isEmpty() || str.trim().isEmpty()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        str = str.trim();</div><div class="line">        </div><div class="line">        <span class="keyword">boolean</span> isNegative = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span> (str.charAt(<span class="number">0</span>) == <span class="string">'-'</span>) &#123;</div><div class="line">            isNegative = <span class="keyword">true</span>;</div><div class="line">            str = str.substring(<span class="number">1</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.charAt(<span class="number">0</span>) == <span class="string">'+'</span>) &#123;</div><div class="line">            str = str.substring(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// check if all characters are digits</span></div><div class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); ++i) &#123;</div><div class="line">            <span class="keyword">char</span> ch = str.charAt(i);</div><div class="line">            <span class="keyword">if</span> (ch &lt; <span class="string">'0'</span> || ch &gt;<span class="string">'9'</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">int</span> digit = ch - <span class="string">'0'</span>;</div><div class="line">            <span class="keyword">if</span> (Integer.MAX_VALUE/<span class="number">10</span> &lt; total || (Integer.MAX_VALUE/<span class="number">10</span> == total &amp;&amp; Integer.MAX_VALUE % <span class="number">10</span> &lt; digit)) &#123;</div><div class="line">                <span class="keyword">return</span> isNegative ? Integer.MIN_VALUE : Integer.MAX_VALUE;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            total = total * <span class="number">10</span> + digit;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="keyword">return</span> isNegative ? (-<span class="number">1</span>) * total : total;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[random interviews: identify the heavy ball]]></title>
      <url>/2017/04/08/2017-04-08-random-interviews-identify-the-heavy-ball/</url>
      <content type="html"><![CDATA[<p>Given an array with 100 balls (each ball is to be imagined as an element in the array). 99 are of same weight only 1 is not. Identify the ball. </p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 面经题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Amazon </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[random interviews: shortest path in a matrix]]></title>
      <url>/2017/04/08/2017-04-08-random-interviews-shortest-path-in-a-matrix/</url>
      <content type="html"><![CDATA[<p>The task was to find the shortest path between x1,y1 and x2,y2 in a maze. You can move horizontally and vertically, where 1 is a wall and 0 is free space. output is k shortest steps to move from the start point to end point.</p>
<h3 id="解法1：BFS"><a href="#解法1：BFS" class="headerlink" title="解法1：BFS"></a>解法1：BFS</h3><p>典型的BFS题目，用一个queue来解决。同时标记每一个已经visit过的元素的parent<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">Java</div><div class="line">&#123;% codeblock lang:java %&#125;</div><div class="line">public List&lt;List&lt;Integer&gt;&gt; shortestPath(int[][] maze, int[] start, int[] end) &#123;</div><div class="line">	List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();</div><div class="line"></div><div class="line">	if (maze == null || maze.length == 0 || maze[0].length == 0) &#123;</div><div class="line">		return res;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if (start[0] == end[0] &amp;&amp; start[1] == end[1]) &#123;</div><div class="line">		List&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(Arrays.asList(start));</div><div class="line">		res.add(temp);</div><div class="line">		return res;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	int row = maze.length;</div><div class="line">	int col = maze[0].length;</div><div class="line">	// Use a map to store each point&apos;s shortest parent from the start point</div><div class="line">	Map&lt;List&lt;Integer&gt;, List&lt;Integer&gt;&gt; map = new HashMap&lt;List&lt;Integer&gt;, List&lt;Integer&gt;&gt;();</div><div class="line"></div><div class="line">	int[][] directions = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;</div><div class="line"></div><div class="line"></div><div class="line">	List&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(Arrays.asList(start));</div><div class="line">	map.put(temp, null);</div><div class="line">	Queue&lt;List&lt;Integer&gt;&gt; queue = new LinkedList&lt;List&lt;Integer&gt;&gt;();</div><div class="line">	queue.offer(temp);</div><div class="line">	maze[start[0]][start[1]] = -1;</div><div class="line">	while(!queue.isEmpty()) &#123;</div><div class="line">		int size = queue.size();</div><div class="line">		for (int i = 0; i &lt; size; ++i) &#123;</div><div class="line">			List&lt;Integer&gt; cur = queue.poll();</div><div class="line">			for (int j = 0; j &lt; directions.length; ++j) &#123;</div><div class="line">				int x = cur.get(0) + directions[j][0];</div><div class="line">				int y = cur.get(1) + directions[j][1];</div><div class="line">				if (x &gt;= 0 &amp;&amp; x &lt; row &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; col &amp;&amp; maze[x][j] != -1) &#123;</div><div class="line">					ArrayList&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(Arrays.asList(x,y));</div><div class="line">					if (x == end[0] &amp;&amp; y == end[1]) &#123;</div><div class="line">						// find the destination</div><div class="line">						res = getPath(map, temp);</div><div class="line">						return res;</div><div class="line">					&#125;</div><div class="line">					queue.offer(temp);</div><div class="line">					map.put(temp, cur);</div><div class="line">					maze[x][y] = -1; // mark as visited</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return res;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private List&lt;List&lt;Integer&gt;&gt; getPath(HashMap&lt;List&lt;Integer&gt;, List&lt;Integer&gt;&gt; map, List&lt;Integer&gt; end) &#123;</div><div class="line">	List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();</div><div class="line">	List&lt;Integer&gt; cur = end;</div><div class="line">	while(map.get(cur) != null) &#123;</div><div class="line">		res.add(cur);</div><div class="line">		cur = map.get(cur);</div><div class="line">	&#125;</div><div class="line">	return res;</div><div class="line">&#125;</div><div class="line">&#123;% endcodeblock %&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 面经题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> BFS </tag>
            
            <tag> Amazon </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[random interviews: create a file system]]></title>
      <url>/2017/04/08/2017-04-08-random-interviews-create-a-file-system/</url>
      <content type="html"><![CDATA[<p>Design a file system. Write code for file, directory and all necessary classes.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>这下面的解法来源于这个<a href="https://www.careercup.com/question?id=17722662" target="_blank" rel="external">career cup</a>上的回答<br>A file system can be represented with a Tree data structure. We can have one class called file (a directory is also a file). This class can track its current directory, its parent directory and files in this directory (in case this file is a special file called directory). Then we can create a class to manage file system which is manipulating the nodes of the tree. </p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> filesystem;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">file</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> String name;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">long</span> size;</div><div class="line">        <span class="keyword">private</span> Date timeStamp;</div><div class="line">        <span class="keyword">private</span> file currentDir;</div><div class="line">        <span class="keyword">private</span> file parentDir;</div><div class="line"></div><div class="line">        <span class="comment">// a directory is also a file containing reference to other files</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isDirectory;</div><div class="line">        <span class="keyword">public</span> ArrayList&lt;file&gt; subfiles;</div><div class="line"></div><div class="line">        <span class="comment">// Advanced class members if required</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span>[] permissions;</div><div class="line">        <span class="keyword">private</span> String owner;</div><div class="line">        <span class="keyword">private</span> String group;</div><div class="line">           </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">file</span><span class="params">(String name, file currentDir, <span class="keyword">boolean</span> isDir)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">            <span class="keyword">this</span>.currentDir = currentDir;</div><div class="line">            <span class="keyword">this</span>.timeStamp = <span class="keyword">new</span> Date();</div><div class="line">            <span class="keyword">this</span>.isDirectory = isDir;</div><div class="line">            <span class="keyword">this</span>.size = <span class="number">0</span>; <span class="comment">// initial size</span></div><div class="line">            <span class="keyword">this</span>.parentDir = currentDir.getParentDirectory();</div><div class="line">            <span class="keyword">if</span> (isDir == <span class="keyword">true</span>)</div><div class="line">                <span class="keyword">this</span>.subfiles = <span class="keyword">new</span> ArrayList&lt;file&gt;();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateTimeStamp</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.timeStamp = <span class="keyword">new</span> Date();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> file <span class="title">getParentDirectory</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.parentDir;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rename</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> file root; <span class="comment">// root folder</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystem</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// every file system should have a root folder</span></div><div class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> file(<span class="string">"root"</span>, <span class="keyword">null</span>, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createFile</span><span class="params">(String name, file curDir, <span class="keyword">boolean</span> isDir)</span> </span>&#123;</div><div class="line">        file f = <span class="keyword">new</span> file(name, curDir, isDir);</div><div class="line">        curDir.subfiles.add(f);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[random interviews: k closest neighbors]]></title>
      <url>/2017/04/08/2017-04-08-random-interviews-k-closest-neighbors/</url>
      <content type="html"><![CDATA[<p>Given a set of points in a cartesian plane, and a start point , find the k closest points to the starting point.</p>
<p>Points = [(1,2),(2,3),(4,6),(7,9)]<br>Start Point = (2,2)</p>
<p>Find 2 closest points to start point<br>这题要考虑的corner case比较多，也是这题的难点。<br>corner case有：<br><em>empty string</em><br><em>string with space</em><br><em>string with positive or negative sign</em><br><em>string with non-digit numbers</em><br><em>overflow integer</em><br>对于overflow的处理有两种情况。一个是当前的total乘以10之后超过Integer.MAX_VALUE，由于不能直接比total * 10 &gt; Integer.MAX_VALUE, 我们可以换一种比法。<br>用Integer.MAX_VALUE / 10 &lt; total 表示判断标准。<br>但是这又有一种情况就是Integer.MAX_VALUE / 10 是整数除法，可能会有遗漏的情况是最后一位不同。<br>那么就需要排除Integer.MAX_VALUE / 10 == total &amp;&amp; Integer.MAX_VALUE % 10 &lt; digit 的情况。</p>
<h3 id="解法1：Priority-Queue-O-NlogK"><a href="#解法1：Priority-Queue-O-NlogK" class="headerlink" title="解法1：Priority Queue, O(NlogK)"></a>解法1：Priority Queue, O(NlogK)</h3><p>最容易想的就是用一个size为k的heap来存储每一个点。如果还没存满k个就直接存入。<br>如果存满了每当下一个点到p的距离比top的小的时候在把top弹出。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Point&gt; <span class="title">closestNeighbors</span><span class="params">(Point[] points, Point center)</span> </span>&#123;</div><div class="line">	Comparator&lt;Point&gt; comparator = <span class="keyword">new</span> Comparator&lt;Point&gt;() &#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Point left, Point right)</span> </span>&#123;</div><div class="line">			<span class="keyword">return</span> distance(right, center) - distance(left, center);</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	PriorityQueue&lt;Point&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;Point&gt;(comparator);</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (Point p : points) &#123;</div><div class="line">		<span class="keyword">if</span> (queue.size() &lt; k) &#123;</div><div class="line">			queue.offer(p);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">if</span> (distance(p, center) &lt; queue.peek()) &#123;</div><div class="line">				queue.poll();</div><div class="line">				queue.offer(p);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	List&lt;Point&gt; res = <span class="keyword">new</span> ArrayList&lt;Point&gt;();</div><div class="line">	<span class="keyword">while</span> (!queue.isEmpty()) &#123;</div><div class="line">		res.offer(queue.poll());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">distance</span><span class="params">(Point a, Point b)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法2：-Quick-Select-O-N"><a href="#解法2：-Quick-Select-O-N" class="headerlink" title="解法2： Quick Select, O(N)"></a>解法2： Quick Select, O(N)</h3><p>一般面试给出上面的解法就可以了。如果面试官喜欢刁难的话可能是需要这个解法。<br>思路和find median有点类似，就是先用quick select找出到center距离为第k大的point.然后再扫描一遍数组得到所有小于那个距离的点即可。<br>code有空的时候再来补上吧。。<br>Java<br><figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 面经题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PriorityQueue </tag>
            
            <tag> Amazon </tag>
            
            <tag> Selection Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Largest Rectangle in Histogram (84)]]></title>
      <url>/2017/04/08/2017-04-08-leetcode-solution-Largest-Rectangle-in-Histogram-84/</url>
      <content type="html"><![CDATA[<p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.<br><img src="https://leetcode.com/static/images/problemset/histogram.png" alt="alt text" title="Logo Title Text 1"></p>
<p>Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].</p>
<p><img src="https://leetcode.com/static/images/problemset/histogram_area.png" alt="alt text" title="Pic 2"></p>
<p>The largest rectangle is shown in the shaded area, which has area = 10 unit.</p>
<p>For example,<br>Given heights = [2,1,5,6,2,3],<br>return 10.</p>
<h3 id="解法1：Stack-O-N"><a href="#解法1：Stack-O-N" class="headerlink" title="解法1：Stack O(N)"></a>解法1：Stack O(N)</h3><p>这题的思路比较巧妙。一般的思路计算面积，办法是先找出左右的边界，然后找出高度。那么这种算法的复杂度是O(N^3)的。<br>如果我们换一个思路，枚举高度而不是枚举边界。那么对于任意一个高度的bar，我们只需要找出来他左面第一个比它矮的和右边第一个比它矮的bar就能算出来对应的使用这个bar作为最高高度的面积了。<br>那么这里需要记录左面的已经遍历过的高度。如果说我们维护一个递增的stack，每一个栈顶元素他对应的左面的比他小的bar的位置就确定了。<br>如果碰到右面比他矮的bar，那么我们就可以计算出当前栈顶的bar对应的面积。<br><em>stack中存上index而不是高度方便计算面积</em><br><em>并且要注意计算到最后一个bar之后要清理stack中还存在的bar</em><br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (heights == <span class="keyword">null</span> || heights.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</div><div class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line"></div><div class="line">        stack.push(<span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; heights.length; ++i) &#123;</div><div class="line">            <span class="keyword">int</span> current = heights[i];</div><div class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; current &lt; heights[stack.peek()]) &#123;</div><div class="line">                <span class="keyword">int</span> bar = heights[stack.pop()];</div><div class="line">                <span class="keyword">int</span> left = stack.isEmpty()? -<span class="number">1</span> : stack.peek();</div><div class="line">                max = Math.max(bar * (i - left - <span class="number">1</span>), max);</div><div class="line">            &#125;</div><div class="line">            stack.push(i);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</div><div class="line">            <span class="keyword">int</span> bar = heights[stack.pop()];</div><div class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[stack.peek()] == bar) &#123;</div><div class="line">                stack.pop();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> left = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</div><div class="line">            max = Math.max(max, bar * (heights.length - left - <span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另一种写法较为简单。诀窍是在数组的最后放一个0，这样可以保证清空stack中的值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (heights == <span class="keyword">null</span> || heights.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] h = Arrays.copyOf(heights, heights.length + <span class="number">1</span>); <span class="comment">// padding zero at the end</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h.length; ++i) &#123;</div><div class="line">            <span class="keyword">int</span> bar = h[i];</div><div class="line">            <span class="keyword">while</span> (!stack.empty() &amp;&amp; bar &lt; h[stack.peek()]) &#123;</div><div class="line">                <span class="keyword">int</span> last = h[stack.pop()];</div><div class="line">                <span class="comment">// calculate the width</span></div><div class="line">                <span class="keyword">int</span> width = stack.empty() ? i : i - stack.peek() - <span class="number">1</span>;</div><div class="line">                res = Math.max(res, width * last);</div><div class="line">            &#125;</div><div class="line">            stack.push(i);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> Amazon </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[random interviews: check if a piece is valid in a go game]]></title>
      <url>/2017/04/07/2017-04-07-random-interviews-check-if-a-piece-is-valid-in-a-go-game/</url>
      <content type="html"><![CDATA[<p>Given a go board, check if a piece is alive or not.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">XXX</div><div class="line">X0X</div><div class="line">XXX</div></pre></td></tr></table></figure>
<p>is not alive</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">XXX</div><div class="line">X0 X</div><div class="line">XXXX</div></pre></td></tr></table></figure>
<p>is still alive</p>
<p>Assume your piece is marked as 1, enemy’s pieces are marked as -1. Empty space is marked as 0.</p>
<h3 id="解法1：DFS"><a href="#解法1：DFS" class="headerlink" title="解法1：DFS"></a>解法1：DFS</h3><p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> bool <span class="title">isAlive</span><span class="params">(<span class="keyword">int</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">	<span class="comment">// Mark visited nodes as Integer.MAX_VALUE;</span></div><div class="line">	<span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] == -<span class="number">1</span> || board[i][j] == Integer.MAX_VALUE) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;	</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (board[i][j] == <span class="number">0</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	board[i][j] = Integer.MAX_VALUE;</div><div class="line">	<span class="keyword">return</span> isAlive(board, i + <span class="number">1</span>, j) || isAlive(board, i - <span class="number">1</span>, j) || isAlive(board, i, j + <span class="number">1</span>) || isAlive(board, i, j - <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 面经题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Most Frequent Subtree Sum (508)]]></title>
      <url>/2017/04/07/2017-04-07-leetcode-solution-Most-Frequent-Subtree-Sum-508/</url>
      <content type="html"><![CDATA[<p>Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.</p>
<p>Examples 1<br>Input:</p>
<p>  5<br> /  \<br>2   -3<br>return [2, -3, 4], since all the values happen only once, return all of them in any order.<br>Examples 2<br>Input:</p>
<p>  5<br> /  \<br>2   -5<br>return [2], since 2 happens twice, however -5 only occur once.<br>Note: You may assume the sum of values in any subtree is in the range of 32-bit signed integer.</p>
<h3 id="解法1：Tree-traversal-HashMap-O-N"><a href="#解法1：Tree-traversal-HashMap-O-N" class="headerlink" title="解法1：Tree traversal + HashMap O(N)"></a>解法1：Tree traversal + HashMap O(N)</h3><p>计算每一个节点的sum很方便，就是leftsum + rightsum。然后用一个hashmap维护每一个sum的出现的频率。<br>最后统计最大频率的key。下面的解法我用了排序，实际上不需要排序。只需要遍历两遍，一遍找出最大频率，第二部就是找出所有频率为max的key就可以了。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findFrequentTreeSum(TreeNode root) &#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</div><div class="line">        helper(root, map);</div><div class="line">        </div><div class="line">        <span class="comment">// Sort map entry based on the frequency</span></div><div class="line">        Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; comparator = <span class="keyword">new</span> Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; left, Map.Entry&lt;Integer, Integer&gt; right)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> right.getValue().compareTo(left.getValue());</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;Map.Entry&lt;Integer, Integer&gt;&gt;();</div><div class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</div><div class="line">            res.add(entry);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        res.sort(comparator);   <span class="comment">// Sort by frequency in decreasing order</span></div><div class="line">        <span class="keyword">int</span> maxFreq = res.get(<span class="number">0</span>).getValue();</div><div class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); ++i) &#123;</div><div class="line">             <span class="keyword">if</span> (res.get(i).getValue() == maxFreq) &#123;</div><div class="line">                 temp.add(res.get(i).getKey());</div><div class="line">             &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span>[] resArray = <span class="keyword">new</span> <span class="keyword">int</span>[temp.size()];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.size(); ++i) &#123;</div><div class="line">            resArray[i] = temp.get(i);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> resArray;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root, Map&lt;Integer, Integer&gt; freqMap)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> left = helper(root.left, freqMap);</div><div class="line">        <span class="keyword">int</span> right = helper(root.right, freqMap);</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> sum = left + right + root.val;</div><div class="line">        freqMap.put(sum, freqMap.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> Amazon </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Sliding Window Maximum (239)]]></title>
      <url>/2017/04/07/2017-04-07-leetcode-solution-Sliding-Window-Maximum-239/</url>
      <content type="html"><![CDATA[<p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.</p>
<p>For example,<br>Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Window position                Max</div><div class="line">---------------               -----</div><div class="line">[1  3  -1] -3  5  3  6  7       3</div><div class="line"> 1 [3  -1  -3] 5  3  6  7       3</div><div class="line"> 1  3 [-1  -3  5] 3  6  7       5</div><div class="line"> 1  3  -1 [-3  5  3] 6  7       5</div><div class="line"> 1  3  -1  -3 [5  3  6] 7       6</div><div class="line"> 1  3  -1  -3  5 [3  6  7]      7</div></pre></td></tr></table></figure></p>
<p>Therefore, return the max sliding window as [3,3,5,5,6,7].</p>
<p>Note:<br>You may assume k is always valid, ie: 1 ≤ k ≤ input array’s size for non-empty array.</p>
<p>Follow up:<br>Could you solve it in linear time?</p>
<p>Hint:</p>
<p>How about using a data structure such as deque (double-ended queue)?<br>The queue size need not be the same as the window’s size.<br>Remove redundant elements and the queue should store only elements that need to be considered</p>
<h3 id="解法1：Heap"><a href="#解法1：Heap" class="headerlink" title="解法1：Heap"></a>解法1：Heap</h3><p>这题用Heap来解的话比较直观，维护一个k大小的priorityqueue。这里有一个用法是可以用Collections.reverseOrder()来生成一个comparator。<br>但是复杂度感觉不太清楚。remove的复杂度是O(k), insert的复杂度是O(logk),感觉整体的复杂度应该是O(NK)，而有些地方说是O(NlogK). 　<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(Collections.reverseOrder());</div><div class="line">        </div><div class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (queue.size() &gt;= k) &#123;</div><div class="line">                queue.remove(nums[i - k]);</div><div class="line">            &#125;</div><div class="line">            queue.offer(nums[i]);</div><div class="line">            <span class="keyword">if</span> (i  + <span class="number">1</span> &gt;= k) &#123;</div><div class="line">                res[i - k + <span class="number">1</span>] = queue.peek();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="解法2-double-linked-list-deque-O-N"><a href="#解法2-double-linked-list-deque-O-N" class="headerlink" title="解法2: double linked list (deque), O(N)"></a>解法2: double linked list (deque), O(N)</h1><p>基本思路是维护一个deque，这个deque的head就存着当前window中的最大值。<br>那么要维护这么一个数据结构，就要求我们在每一次insert的时候要把所有小于他的数都弹出去。<br>同时，要维护窗口，需要加入一个的同时也弹出最左边的元素。由于我们在insert的时候有可能已经把需要弹出的元素弹出了，那么就先用一个if语句来判断是否head是一个需要被弹出的元素。<br>复杂度的分析是基于，每一个元素只可能被弹出和访问一次。所以是O(N)<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</div><div class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];   </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        LinkedList&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();  </div><div class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (!deque.isEmpty() &amp;&amp; deque.peekFirst() == i - k) &#123;</div><div class="line">                deque.removeFirst();</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;</div><div class="line">                deque.removeLast();</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            deque.offer(i);</div><div class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= k) &#123;</div><div class="line">                res[i - k + <span class="number">1</span>] = nums[deque.peekFirst()];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> Amazon </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Serialize and Deserialize BST (449)]]></title>
      <url>/2017/03/30/2017-03-30-leetcode-solution-Serialize-and-Deserialize-BST-449/</url>
      <content type="html"><![CDATA[<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>
<p>Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<p>The encoded string should be as compact as possible.</p>
<p>Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Rotate Function (396)]]></title>
      <url>/2017/03/30/2017-03-30-leetcode-solution-Rotate-Function-396/</url>
      <content type="html"><![CDATA[<p>Given an array of integers A and let n to be its length.</p>
<p>Assume Bk to be an array obtained by rotating the array A k positions clock-wise, we define a “rotation function” F on A as follow:</p>
<p>F(k) = 0 <em> Bk[0] + 1 </em> Bk[1] + … + (n-1) * Bk[n-1].</p>
<p>Calculate the maximum value of F(0), F(1), …, F(n-1).</p>
<p>Note:<br>n is guaranteed to be less than 105.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">A = [4, 3, 2, 6]</div><div class="line"></div><div class="line">F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25</div><div class="line">F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16</div><div class="line">F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23</div><div class="line">F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26</div><div class="line"></div><div class="line">So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.</div></pre></td></tr></table></figure></p>
<h3 id="解法1：找规律-O-N-Time-O-1-Space"><a href="#解法1：找规律-O-N-Time-O-1-Space" class="headerlink" title="解法1：找规律 O(N) Time + O(1) Space"></a>解法1：找规律 O(N) Time + O(1) Space</h3><p>这题用找规律的办法，找规律的时候把数字简化成A,B,C,D.<br>f(0) = 0A + 1B + 2C + 3D<br>f(1) = 0D + 1A + 2B + 3C<br>f(2) = OC + 1D + 2A + 3B</p>
<p>在考虑一个sum = 1A + 1B + 1C + 1D<br>那么可以得到<br>f(1) = f(0) + sum - 4D<br>f(2) = f(1) + sum - 4C<br>…<br>于是一个O(N)的解法就出来了<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxRotateFunction</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> f = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; ++i) &#123;</div><div class="line">            f += i * A[i];</div><div class="line">            sum += A[i];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> res = f; <span class="comment">// f(0)</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; ++i) &#123;</div><div class="line">            f = f + sum - A.length * A[A.length - i];</div><div class="line">            res = Math.max(res, f);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> 找规律 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Boundary of Binary Tree (545)]]></title>
      <url>/2017/03/30/2017-03-30-leetcode-solution-Boundary-of-Binary-Tree-545/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, return the values of its boundary in anti-clockwise direction starting from root. Boundary includes left boundary, leaves, and right boundary in order without duplicate nodes.</p>
<p>Left boundary is defined as the path from root to the left-most node. Right boundary is defined as the path from root to the right-most node. If the root doesn’t have left subtree or right subtree, then the root itself is left boundary or right boundary. Note this definition only applies to the input binary tree, and not applies to any subtrees.</p>
<p>The left-most node is defined as a leaf node you could reach when you always firstly travel to the left subtree if exists. If not, travel to the right subtree. Repeat until you reach a leaf node.</p>
<p>The right-most node is also defined by the same way with left and right exchanged.</p>
<p>Example 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">  1</div><div class="line">   \</div><div class="line">    2</div><div class="line">   / \</div><div class="line">  3   4</div><div class="line"></div><div class="line">Ouput:</div><div class="line">[1, 3, 4, 2]</div><div class="line"></div><div class="line">Explanation:</div><div class="line">The root doesn&apos;t have left subtree, so the root itself is left boundary.</div><div class="line">The leaves are node 3 and 4.</div><div class="line">The right boundary are node 1,2,4. Note the anti-clockwise direction means you should output reversed right boundary.</div><div class="line">So order them in anti-clockwise without duplicates and we have [1,3,4,2].</div></pre></td></tr></table></figure></p>
<p>Example 2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">    ____1_____</div><div class="line">   /          \</div><div class="line">  2            3</div><div class="line"> / \          / </div><div class="line">4   5        6   </div><div class="line">   / \      / \</div><div class="line">  7   8    9  10  </div><div class="line">       </div><div class="line">Ouput:</div><div class="line">[1,2,4,7,8,9,10,6,3]</div><div class="line"></div><div class="line">Explanation:</div><div class="line">The left boundary are node 1,2,4. (4 is the left-most node according to definition)</div><div class="line">The leaves are node 4,7,8,9,10.</div><div class="line">The right boundary are node 1,3,6,10. (10 is the right-most node).</div><div class="line">So order them in anti-clockwise without duplicate nodes we have [1,2,4,7,8,9,10,6,3].</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>参考了<a href="http://www.cnblogs.com/dongling/p/6622312.html" target="_blank" rel="external">这篇</a>的解法。<br>对于leaf我们可以用dfs来解决。似乎还需要两个function分别来存储left path和right path。那么在找寻left path的过程中，我们一直向左，如果碰到左面的节点就属于left path，如果还有右节点那么就用dfs搜索leaf。<br>对于right path也是一个原理。<br>对于rightPath函数的写法，要注意对于每一个节点，要先得出leaf node，再得出right node。因为题目要求是逆时针<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">boundaryOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        res.add(root.val);</div><div class="line">        leftPath(root.left, res);</div><div class="line">        rightPath(root.right, res);</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftPath</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</div><div class="line">            res.add(root.val);</div><div class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</div><div class="line">                leftPath(root.left, res);</div><div class="line">                dfs(root.right,res);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                leftPath(root.right, res);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightPath</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</div><div class="line">                dfs(root.left, res);	<span class="comment">// 这里的顺序要注意</span></div><div class="line">                rightPath(root.right, res);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                rightPath(root.left, res);</div><div class="line">            &#125;</div><div class="line">            res.add(root.val);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</div><div class="line">            res.add(root.val);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        dfs(root.left, res);</div><div class="line">        dfs(root.right, res);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Trapping Rain Water (42)]]></title>
      <url>/2017/03/29/2017-03-29-leetcode-solution-Trapping-Rain-Water-42/</url>
      <content type="html"><![CDATA[<p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p>For example,<br>Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.</p>
<p><img src="https://leetcode.com/static/images/problemset/rainwatertrap.png" alt="alt text" title="Logo Title Text 1"><br>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p>
<h3 id="解法1-两遍扫描-O-N-Time-O-N-Space"><a href="#解法1-两遍扫描-O-N-Time-O-N-Space" class="headerlink" title="解法1: 两遍扫描 O(N) Time O(N) Space"></a>解法1: 两遍扫描 O(N) Time O(N) Space</h3><p>这题和<a href="http://bigteemo.github.io/2017/03/29/leetcode-solution-Product-of-Array-Except-Self-238/">Product of Array except itself</a>有点类似。对于每一个bar，顶端是否能储水取决于左面和右面是否有比它高的bar，假设有而且较低的bar的高度是h，那么对于现在这个bar能储水的量就是h-height。<br>由此我们可以得出一个思路：对于每一个bar，计算出左边和右边的最高的bar。<br>在计算右面的bar的时候，我们不必要维护一个新的数组，而是用一个变量就可以了。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> heights: an array of integers</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span>: a integer</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trapRainWater</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (heights == <span class="keyword">null</span> || heights.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> n = heights.length;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="keyword">int</span>[] leftHeight = <span class="keyword">new</span> <span class="keyword">int</span>[heights.length];</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; n; i++) &#123;</div><div class="line">            leftHeight[i] = Math.max(leftHeight[i - <span class="number">1</span>], heights[i - <span class="number">1</span>]);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> rightHeight = <span class="number">0</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            rightHeight = Math.max(rightHeight, heights[i + <span class="number">1</span>]);</div><div class="line">            sum += Math.max(<span class="number">0</span>, Math.min(leftHeight[i], rightHeight) - heights[i]);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法2：Stack-O-N-Time-O-N-Space"><a href="#解法2：Stack-O-N-Time-O-N-Space" class="headerlink" title="解法2：Stack, O(N) Time O(N) Space"></a>解法2：Stack, O(N) Time O(N) Space</h3><p>这题也可以用stack来做。但感觉stack比较容易错。<br>stack的思路是，要存水必须有一个凹槽。那么我们用stack维护一个递减的数列，遇到比现在的top的数更大的时候就知道有水可以存储了。<br>当前的top即是凹槽的底，弹出top之后如果还不是空，则继续比较top和当前的bar的高度，如果当前bar还高，那么存储的水就是top - bottom 乘上距离。<br>这里有一个地方容易错就是，如果当前的height不比top高，那么这个时候也要存储结果。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (height.length &lt; <span class="number">3</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// Stack stores the index of a element in the array</span></div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</div><div class="line">        </div><div class="line">        stack.push(<span class="number">0</span>);</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.length; ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (height[i] &gt; height[stack.peek()]) &#123;</div><div class="line">                <span class="keyword">int</span> bottom = height[stack.peek()];</div><div class="line">                stack.pop();</div><div class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &gt;= height[stack.peek()]) &#123;</div><div class="line">                    res += (height[stack.peek()] - bottom) * (i - stack.peek() - <span class="number">1</span>);</div><div class="line">                    bottom = height[stack.pop()];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (!stack.isEmpty()) &#123;</div><div class="line">                    res += (height[i] - bottom) * ( i - stack.peek() - <span class="number">1</span>);	<span class="comment">//这地方容易漏掉</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            stack.push(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Insert Delete GetRandom O(1) (380)]]></title>
      <url>/2017/03/29/2017-03-29-leetcode-solution-Insert-Delete-GetRandom-O-1-380/</url>
      <content type="html"><![CDATA[<p>Design a data structure that supports all following operations in average O(1) time.</p>
<p>insert(val): Inserts an item val to the set if not already present.<br>remove(val): Removes an item val from the set if present.<br>getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.<br>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// Init an empty set.</div><div class="line">RandomizedSet randomSet = new RandomizedSet();</div><div class="line"></div><div class="line">// Inserts 1 to the set. Returns true as 1 was inserted successfully.</div><div class="line">randomSet.insert(1);</div><div class="line"></div><div class="line">// Returns false as 2 does not exist in the set.</div><div class="line">randomSet.remove(2);</div><div class="line"></div><div class="line">// Inserts 2 to the set, returns true. Set now contains [1,2].</div><div class="line">randomSet.insert(2);</div><div class="line"></div><div class="line">// getRandom should return either 1 or 2 randomly.</div><div class="line">randomSet.getRandom();</div><div class="line"></div><div class="line">// Removes 1 from the set, returns true. Set now contains [2].</div><div class="line">randomSet.remove(1);</div><div class="line"></div><div class="line">// 2 was already in the set, so return false.</div><div class="line">randomSet.insert(2);</div><div class="line"></div><div class="line">// Since 2 is the only number in the set, getRandom always return 2.</div><div class="line">randomSet.getRandom();</div></pre></td></tr></table></figure></p>
<h3 id="解法1：Two-HashMaps"><a href="#解法1：Two-HashMaps" class="headerlink" title="解法1：Two HashMaps"></a>解法1：Two HashMaps</h3><p>这题如果没有getRandom的话用一个set就可以解决了。因为加上了getRandom，那么需要用一些方法来存储每一个数字对应的index。由此就想到用两个hashmap来存储数字和他位置的对应关系。insert比较好解决，就是把对应关系加入两个map中。remove稍微复杂一点，首先将对应的数字pair从两个map中移除。<br>如果说移除的是最后一个元素或者是唯一一个元素，移除之后不需要对map额外处理。如果是移除的当中的某个元素。那么移除之后他们的index就不是连续的了。这个时候就要额外的来处理一下。因为要把最后一位的元素对应的位置-1， 那么我们可以把最后一位元素对应的位置放到刚才删除的元素的位置上。然后更新存储位置的hashmap就可以了。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; valueIndex;</div><div class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; indexValue;</div><div class="line">    <span class="keyword">private</span> Random rand;</div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</div><div class="line">        valueIndex = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</div><div class="line">        indexValue = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</div><div class="line">        rand = <span class="keyword">new</span> Random(System.currentTimeMillis());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (valueIndex.containsKey(val)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span> index = valueIndex.size();</div><div class="line">            valueIndex.put(val, index);</div><div class="line">            indexValue.put(index, val);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (valueIndex.containsKey(val)) &#123;</div><div class="line">            <span class="keyword">int</span> index = valueIndex.get(val);</div><div class="line">            valueIndex.remove(val);</div><div class="line">            indexValue.remove(index);</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (valueIndex.isEmpty() || index == valueIndex.size()) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// if delete from the middle,</span></div><div class="line">            <span class="comment">// put the last element into the middle</span></div><div class="line">            <span class="keyword">int</span> last = indexValue.get(indexValue.size());</div><div class="line">            valueIndex.put(last, index);</div><div class="line">            indexValue.remove(indexValue.size());</div><div class="line">            indexValue.put(index, last);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/** Get a random element from the set. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (valueIndex.isEmpty()) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valueIndex.size() == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> indexValue.get(<span class="number">0</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span> index = rand.nextInt(valueIndex.size());</div><div class="line">            <span class="keyword">return</span> indexValue.get(index);    </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></div><div class="line"><span class="comment"> * RandomizedSet obj = new RandomizedSet();</span></div><div class="line"><span class="comment"> * boolean param_1 = obj.insert(val);</span></div><div class="line"><span class="comment"> * boolean param_2 = obj.remove(val);</span></div><div class="line"><span class="comment"> * int param_3 = obj.getRandom();</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Product of Array Except Self (238)]]></title>
      <url>/2017/03/29/2017-03-29-leetcode-solution-Product-of-Array-Except-Self-238/</url>
      <content type="html"><![CDATA[<p>Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p>
<p>Solve it without division and in O(n).</p>
<p>For example, given [1,2,3,4], return [24,12,8,6].</p>
<p>Follow up:<br>Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)</p>
<h3 id="解法1：O-N-Time-O-1-Space"><a href="#解法1：O-N-Time-O-1-Space" class="headerlink" title="解法1：O(N) Time + O(1) Space"></a>解法1：O(N) Time + O(1) Space</h3><p>把题目分成两个小问题来解决。except self换句话说就是左面的和右面的乘积。<br>那么从左面扫一遍得到一组数，从右面扫一遍得到一组数。然后把左右两组数相乘便是答案。<br>一个小要求是需要O(1)的space。在从右面扫描的时候我们不用维护一个数组，而是用一个变量product来记录现在的乘积。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> nums;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">        <span class="comment">// from left to right</span></div><div class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i) &#123;</div><div class="line">            res[i] = res[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> product = <span class="number">1</span>;</div><div class="line">        </div><div class="line">        <span class="comment">// from right to left</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</div><div class="line">            res[i] = res[i] * product;</div><div class="line">            product = product * nums[i];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Longest Palindromic Substring (5)]]></title>
      <url>/2017/03/28/2017-03-28-leetcode-solution-Longest-Palindromic-Substring-5/</url>
      <content type="html"><![CDATA[<p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Input: &quot;babad&quot;</div><div class="line"></div><div class="line">Output: &quot;bab&quot;</div><div class="line"></div><div class="line">Note: &quot;aba&quot; is also a valid answer.</div></pre></td></tr></table></figure></p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input: &quot;cbbd&quot;</div><div class="line"></div><div class="line">Output: &quot;bb&quot;</div></pre></td></tr></table></figure></p>
<h3 id="解法1：DP-O-N-2"><a href="#解法1：DP-O-N-2" class="headerlink" title="解法1：DP: O(N^2)"></a>解法1：DP: O(N^2)</h3><p>字符串的问题，如果牵涉到substring(i,j)的，要是往dp方向上考虑就需要用二维的。这题也不例外。<br>dp[i][j]表示的是，(i,j)这个字符串是否是palindrome。<br>有三种情况可以考虑，一个是i == j, 一个是相邻，还有一个是距离大于2。<br>每次找到一个palindrome的时候都更新下max，同时也更新一下res的string。<br>要注意的是我们要求矩阵从下往上搜索，并且j &gt;= i, 所以我们只搜索了上半部的矩阵。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = s.length();</div><div class="line">        </div><div class="line">        <span class="keyword">boolean</span>[][] state = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> maxlen = Integer.MIN_VALUE;</div><div class="line">        String res = <span class="string">""</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (i == j) &#123;</div><div class="line">                    state[i][j] = <span class="keyword">true</span>;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == i + <span class="number">1</span>) &#123;</div><div class="line">                    state[i][j] = s.charAt(i) == s.charAt(j);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    state[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; state[i + <span class="number">1</span>][j - <span class="number">1</span>];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (state[i][j]) &#123;</div><div class="line">                    <span class="keyword">int</span> len = j - i + <span class="number">1</span>;</div><div class="line">                    <span class="keyword">if</span> (len &gt; maxlen) &#123;</div><div class="line">                        maxlen = len;</div><div class="line">                        res = s.substring(i, j + <span class="number">1</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Longest Substring Without Repeating Characters (3)]]></title>
      <url>/2017/03/28/2017-03-28-leetcode-solution-Longest-Substring-Without-Repeating-Characters-3/</url>
      <content type="html"><![CDATA[<p>Given a string, find the length of the longest substring without repeating characters.</p>
<p>Examples:</p>
<p>Given “abcabcbb”, the answer is “abc”, which the length is 3.</p>
<p>Given “bbbbb”, the answer is “b”, with the length of 1.</p>
<p>Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p><a href="http://www.cnblogs.com/springfor/p/3872327.html" target="_blank" rel="external">这个答案</a>对我的启发比较大，主要可以用于一类题目。<br>思路是用一个hashtable维护出现过的字母的位置，只存储上一次出现过的位置。<br>那么如果遇到还未出现过的字符则直接向前进，如果遇到出现过的字符那么需要比较当前的substring的长度和max。<br>同时，需要移动left指针，因为从left开始到right部分已经不符合要求了。left需要移动到上一次出现的位置+1.<br>注意这里有个坑：因为可能出现上一次的位置比现在left的位置还好往后，要保证left只进不退，只能用left = Math.max(left, last_pos)来保证。<br><em>还有一个坑，就是在最后一步还需要判断max和当前right - left的大小的比较。</em><br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span>[] table = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</div><div class="line">        Arrays.fill(table, -<span class="number">1</span>);</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</div><div class="line">            <span class="keyword">int</span> current_char = (<span class="keyword">int</span>)s.charAt(right);</div><div class="line">            <span class="keyword">int</span> last_pos = table[current_char];</div><div class="line">            <span class="keyword">if</span> (last_pos != -<span class="number">1</span>) &#123;</div><div class="line">                max = Math.max(right - left, max);</div><div class="line">                <span class="comment">// move left pointer</span></div><div class="line">                left = Math.max(left, table[current_char] + <span class="number">1</span>);</div><div class="line">                table[current_char] = right;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                table[current_char] = right;</div><div class="line">            &#125;</div><div class="line">            ++right;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> Math.max(max, right - left);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Rotate Image (48)]]></title>
      <url>/2017/03/28/2017-03-28-leetcode-solution-Rotate-Image-48/</url>
      <content type="html"><![CDATA[<p>You are given an n x n 2D matrix representing an image.</p>
<p>Rotate the image by 90 degrees (clockwise).</p>
<p>Follow up:<br>Could you do this in-place?</p>
<p>Show Company Tags<br>Show Tags</p>
<h3 id="解法1：特殊解法"><a href="#解法1：特殊解法" class="headerlink" title="解法1：特殊解法　"></a>解法1：特殊解法　</h3><p>如果是out-of-place的解法，就用<br><code>temp[j][n - 1 - j] = matrix[i][j]</code></p>
<p>如果要inplace的解法：可以有这么几种：</p>
<ul>
<li>先按逆对角线翻转一次，然后按ｘ轴中线翻转一次。</li>
<li>或者呢也可以先transpose，然后把每一行翻转。<br>个人感觉第二种解法比较好记也比较好写。不容易出错</li>
</ul>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> n = matrix.length;</div><div class="line">        <span class="comment">// flip along /</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; ++j) &#123;</div><div class="line">               swap(matrix, i, j, n - <span class="number">1</span> - j, n - <span class="number">1</span> - i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// flip between </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</div><div class="line">                swap(matrix, i, j, n - <span class="number">1</span> - i, j);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> ix, <span class="keyword">int</span> iy, <span class="keyword">int</span> jx, <span class="keyword">int</span> jy)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = matrix[ix][iy];</div><div class="line">        matrix[ix][iy] = matrix[jx][jy];</div><div class="line">        matrix[jx][jy] = temp;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Word Break (139)]]></title>
      <url>/2017/03/28/2017-03-28-leetcode-solution-Word-Break-139/</url>
      <content type="html"><![CDATA[<p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.</p>
<p>For example, given<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s = &quot;leetcode&quot;,</div><div class="line">dict = [&quot;leet&quot;, &quot;code&quot;].</div></pre></td></tr></table></figure></p>
<p>Return true because “leetcode” can be segmented as “leet code”.</p>
<h3 id="解法1：DP-O-N-2"><a href="#解法1：DP-O-N-2" class="headerlink" title="解法1：DP O(N^2)"></a>解法1：DP O(N^2)</h3><p>经典的用DP的问题，用一个dp数组来记录。dp[i]表示前i个字符是否可能分词。<br>所以对于每一个dp[i], dp[i] = true if word(0,i) in dict, or dp[k] = true &amp;&amp; word(k, i) in dict<br>这题的坑在于java的substring比较坑，string.substring(j,k)表示从第j个字符到第k-1个字符所组成的substring。<br>我们这里需要用word(k,i)表示的是第k+1个字符到第i-1个字符。这里容易出错需要注意一下。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isEmpty() || wordDict == <span class="keyword">null</span> || wordDict.size() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// convert to set</span></div><div class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line">        <span class="keyword">for</span> (String word: wordDict) &#123;</div><div class="line">            set.add(word);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</div><div class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (set.contains(s.substring(<span class="number">0</span>,i))) &#123;</div><div class="line">                dp[i] = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</div><div class="line">                    <span class="keyword">if</span> (dp[j] &amp;&amp; set.contains(s.substring(j, i))) &#123;</div><div class="line">                        dp[i] = <span class="keyword">true</span>;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> dp[s.length()];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Kth Largest Element in an Array (215)]]></title>
      <url>/2017/03/27/2017-03-27-leetcode-solution-Kth-Largest-Element-in-an-Array-215/</url>
      <content type="html"><![CDATA[<p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p>For example,<br>Given [3,2,1,5,6,4] and k = 2, return 5.</p>
<p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p>
<h3 id="解法1：PriorityQueue-O-NlogK-Space-O-K"><a href="#解法1：PriorityQueue-O-NlogK-Space-O-K" class="headerlink" title="解法1：PriorityQueue, O(NlogK), Space O(K)"></a>解法1：PriorityQueue, O(NlogK), Space O(K)</h3><p>一种解法是很直观的用heap来解决，维护一个大小为k的堆。因为每次insert的操作的时间复杂度是O(logK), 一共要遍历N个元素。<br>最后取出顶元素即可。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(k);</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</div><div class="line">            queue.offer(num);</div><div class="line">            <span class="keyword">if</span> (queue.size() &gt; k) &#123;</div><div class="line">                queue.poll();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> queue.poll();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法2：比较优解-Quick-Select-Average-O-N-worst-O-N-2-Space-O-1"><a href="#解法2：比较优解-Quick-Select-Average-O-N-worst-O-N-2-Space-O-1" class="headerlink" title="解法2：比较优解 Quick Select, Average O(N), worst O(N^2), Space O(1)"></a>解法2：比较优解 Quick Select, Average O(N), worst O(N^2), Space O(1)</h3><p>主要是用到了Quick Select中一次partition就可以知道pivot在array中的具体位置，假设是X。<br>那么如果X == k, 我们要求的就求道了。假设是X &lt; k, 那么我们只需要在右半边找，反之就在左半边找。<br>要掌握partition函数的写法。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> helper(nums, nums.length - k + <span class="number">1</span>, <span class="number">0</span>, nums.length - <span class="number">1</span>);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (start == end) &#123;</div><div class="line">            <span class="keyword">return</span> nums[start];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> p = partition(nums, start, end);</div><div class="line">        <span class="keyword">if</span> (p + <span class="number">1</span> == k) &#123;</div><div class="line">            <span class="keyword">return</span> nums[p];</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p + <span class="number">1</span> &lt; k) &#123;</div><div class="line">            <span class="keyword">return</span> helper(nums, k, p + <span class="number">1</span>, end);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> helper(nums, k, start, p - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> pivot = nums[end];</div><div class="line">        <span class="keyword">int</span> index = start;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</div><div class="line">                swap(nums, index, i);</div><div class="line">                ++index;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        swap(nums, end, index);</div><div class="line">        <span class="keyword">return</span> index;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = nums[i];</div><div class="line">        nums[i] = nums[j];</div><div class="line">        nums[j] = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> PriorityQueue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Add Two Numbers (2)]]></title>
      <url>/2017/03/27/2017-03-27-leetcode-solution-Add-Two-Numbers-2/</url>
      <content type="html"><![CDATA[<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8</p>
<h3 id="解法1：O-N-M-Time-O-1-Space"><a href="#解法1：O-N-M-Time-O-1-Space" class="headerlink" title="解法1：O(N + M) Time + O(1) Space"></a>解法1：O(N + M) Time + O(1) Space</h3><p>这题的坑是leetocde的OJ可能会TLE，要用tail.next = new ListNode(temp)就可以过了。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * public class ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</div><div class="line">        </div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode tail = dummy;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">int</span> val = l1.val + l2.val + carry;</div><div class="line">            <span class="keyword">int</span> digit = val % <span class="number">10</span>;</div><div class="line">            carry = val / <span class="number">10</span>;</div><div class="line">            ListNode temp = <span class="keyword">new</span> ListNode(digit);</div><div class="line">            tail.next = temp;</div><div class="line">            tail = tail.next;</div><div class="line">            l1 = l1.next;</div><div class="line">            l2 = l2.next;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">int</span> val = l1.val + carry;</div><div class="line">            <span class="keyword">int</span> digit = val  % <span class="number">10</span>;</div><div class="line">            carry = val / <span class="number">10</span>;</div><div class="line">            tail.next = <span class="keyword">new</span> ListNode(digit);</div><div class="line">            tail = tail.next;</div><div class="line">            l1 = l1.next;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (l2 != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">int</span> val = l2.val + carry;</div><div class="line">            <span class="keyword">int</span> digit = val % <span class="number">10</span>;</div><div class="line">            carry = val / <span class="number">10</span>;</div><div class="line">            tail.next = <span class="keyword">new</span> ListNode(digit);</div><div class="line">            tail = tail.next;</div><div class="line">            l2 = l2.next;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</div><div class="line">            tail.next = <span class="keyword">new</span> ListNode(carry);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Group Anagrams (49)]]></title>
      <url>/2017/03/27/2017-03-27-leetcode-solution-Group-Anagrams-49/</url>
      <content type="html"><![CDATA[<p>Given an array of strings, group anagrams together.</p>
<p>For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>Return:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;],</div><div class="line">  [&quot;nat&quot;,&quot;tan&quot;],</div><div class="line">  [&quot;bat&quot;]</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>Note: All inputs will be in lower-case.</p>
<h3 id="解法1：HashMap-O-N-Time-O-N-Space"><a href="#解法1：HashMap-O-N-Time-O-N-Space" class="headerlink" title="解法1：HashMap, O(N) Time + O(N) Space"></a>解法1：HashMap, O(N) Time + O(N) Space</h3><p>因为anagram是表示排序后A,B的字母一样，那么就可以用一个hashmap存储每一个group， group的key就是排序后的string。<br>string排序在java中并没有自带的函数，可以先转换成chararray，然后用Arrays.sort来排序。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</div><div class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</div><div class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        HashMap&lt;String, ArrayList&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String, ArrayList&lt;String&gt;&gt;();</div><div class="line">        <span class="keyword">for</span> (String str: strs) &#123;</div><div class="line">            String temp = sorted(str);</div><div class="line">            <span class="keyword">if</span> (!map.containsKey(temp)) &#123;</div><div class="line">                ArrayList&lt;String&gt; collection = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">                collection.add(str);</div><div class="line">                map.put(temp, collection);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                map.get(temp).add(str);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</div><div class="line">            res.add(map.get(key));</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sorted</span><span class="params">(String x)</span> </span>&#123;</div><div class="line">        <span class="keyword">char</span>[] temp = x.toCharArray();</div><div class="line">        Arrays.sort(temp);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(temp);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode解题: Word Ladder (127)]]></title>
      <url>/2017/03/27/2017-03-27-leetcode-solution-Word-Ladder-127/</url>
      <content type="html"><![CDATA[<p>Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:</p>
<p>Only one letter can be changed at a time.<br>Each transformed word must exist in the word list. Note that beginWord is not a transformed word.<br>For example,</p>
<p>Given:<br>beginWord = “hit”<br>endWord = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br>As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>return its length 5.</p>
<p>Note:<br>Return 0 if there is no such transformation sequence.<br>All words have the same length.<br>All words contain only lowercase alphabetic characters.<br>You may assume no duplicates in the word list.<br>You may assume beginWord and endWord are non-empty and are not the same.</p>
<h3 id="解法1：BFS-Time-O-26LN"><a href="#解法1：BFS-Time-O-26LN" class="headerlink" title="解法1：BFS, Time O(26LN)"></a>解法1：BFS, Time O(26<em>L</em>N)</h3><p>求最小路径，用BFS比较自然可以想到。关键是怎么构建一个图. 我们把每一个word改变一个字母，检查是否在已知的dict中。由于查询用hashtable是最快的，这里需要考虑用一个hashset来存放dict。<br>然后用一个BFS遍历就可以了。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (wordList == <span class="keyword">null</span> || wordList.size() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (beginWord.equals(endWord)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// To boost lookup</span></div><div class="line">        Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line">        <span class="keyword">for</span> (String word: wordList) &#123;</div><div class="line">            dict.add(word);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</div><div class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line">        </div><div class="line">        queue.offer(beginWord);</div><div class="line">        visited.add(beginWord);</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</div><div class="line">            ++res;</div><div class="line">            <span class="keyword">int</span> size = queue.size();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</div><div class="line">                String current = queue.poll();</div><div class="line">                List&lt;String&gt; next = getNextWords(current, dict);</div><div class="line">                <span class="keyword">for</span> (String candidate: next) &#123;</div><div class="line">                    <span class="keyword">if</span> (candidate.equals(endWord)) &#123;</div><div class="line">                        <span class="keyword">return</span> res;</div><div class="line">                    &#125;              </div><div class="line">                    <span class="keyword">if</span> (!visited.contains(candidate)) &#123;</div><div class="line">                        queue.offer(candidate);</div><div class="line">                        visited.add(candidate);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">replace</span><span class="params">(String origin, <span class="keyword">int</span> index, <span class="keyword">char</span> c)</span> </span>&#123;</div><div class="line">        <span class="keyword">char</span>[] temp = origin.toCharArray();</div><div class="line">        temp[index] = c;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(temp);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getNextWords</span><span class="params">(String origin, Set&lt;String&gt; dict)</span> </span>&#123;</div><div class="line">        </div><div class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> i = <span class="string">'a'</span>; i &lt;= <span class="string">'z'</span>; ++i) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; origin.length(); ++j) &#123;</div><div class="line">                <span class="keyword">if</span> (origin.charAt(j) == i) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                String temp = replace(origin, j, i);</div><div class="line">                <span class="keyword">if</span> (dict.contains(temp)) &#123;</div><div class="line">                    res.add(temp);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Search a 2D Matrix II (240)]]></title>
      <url>/2017/03/26/2017-03-26-leetcode-solution-Search-a-2D-Matrix-II-240/</url>
      <content type="html"><![CDATA[<p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<p>Integers in each row are sorted in ascending from left to right.<br>Integers in each column are sorted in ascending from top to bottom.<br>For example,</p>
<p>Consider the following matrix:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [1,   4,  7, 11, 15],</div><div class="line">  [2,   5,  8, 12, 19],</div><div class="line">  [3,   6,  9, 16, 22],</div><div class="line">  [10, 13, 14, 17, 24],</div><div class="line">  [18, 21, 23, 26, 30]</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>Given target = 5, return true.</p>
<p>Given target = 20, return false.</p>
<h3 id="解法1：O-N-M"><a href="#解法1：O-N-M" class="headerlink" title="解法1：O(N + M)"></a>解法1：O(N + M)</h3><p>这题和Matrix I的区别是上一行和下一行不是递增的，也就是说不能串起来当成一个sorted array来处理。<br>这题要变换下思路，考虑右上角和左下角两个点。比如左下角，比数字大就往上，比它数字小就往右。直到找到所要求的答案。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span> x = m - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (matrix[x][y] &lt; target) &#123;</div><div class="line">                ++y;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[x][y] &gt; target) &#123;</div><div class="line">                --x;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &gt;= n) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Count Primes (204)]]></title>
      <url>/2017/03/26/2017-03-26-leetcode-solution-Count-Primes-204/</url>
      <content type="html"><![CDATA[<p>Description:</p>
<p>Count the number of prime numbers less than a non-negative number, n.</p>
<p>Hint:</p>
<p>Let’s start with a isPrime function. To determine if a number is prime, we need to check if it is not divisible by any number less than n. The runtime complexity of isPrime function would be O(n) and hence counting the total prime numbers up to n would be O(n2). Could we do better?</p>
<p>As we know the number must not be divisible by any number &gt; n / 2, we can immediately cut the total iterations half by dividing only up to n / 2. Could we still do better?</p>
<p>Let’s write down all of 12’s factors:</p>
<p>2 × 6 = 12<br>3 × 4 = 12<br>4 × 3 = 12<br>6 × 2 = 12<br>As you can see, calculations of 4 × 3 and 6 × 2 are not necessary. Therefore, we only need to consider factors up to √n because, if n is divisible by some number p, then n = p × q and since p ≤ q, we could derive that p ≤ √n.</p>
<p>Our total runtime has now improved to O(n1.5), which is slightly better. Is there a faster approach?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public int countPrimes(int n) &#123;</div><div class="line">   int count = 0;</div><div class="line">   for (int i = 1; i &lt; n; i++) &#123;</div><div class="line">      if (isPrime(i)) count++;</div><div class="line">   &#125;</div><div class="line">   return count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private boolean isPrime(int num) &#123;</div><div class="line">   if (num &lt;= 1) return false;</div><div class="line">   // Loop&apos;s ending condition is i * i &lt;= num instead of i &lt;= sqrt(num)</div><div class="line">   // to avoid repeatedly calling an expensive function sqrt().</div><div class="line">   for (int i = 2; i * i &lt;= num; i++) &#123;</div><div class="line">      if (num % i == 0) return false;</div><div class="line">   &#125;</div><div class="line">   return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>The Sieve of Eratosthenes is one of the most efficient ways to find all prime numbers up to n. But don’t let that name scare you, I promise that the concept is surprisingly simple.</p>
<p>Sieve of Eratosthenes: algorithm steps for primes below 121. “Sieve of Eratosthenes Animation” by SKopp is licensed under CC BY 2.0.</p>
<p>We start off with a table of n numbers. Let’s look at the first number, 2. We know all multiples of 2 must not be primes, so we mark them off as non-primes. Then we look at the next number, 3. Similarly, all multiples of 3 such as 3 × 2 = 6, 3 × 3 = 9, … must not be primes, so we mark them off as well. Now we look at the next number, 4, which was already marked off. What does this tell you? Should you mark off all multiples of 4 as well?</p>
<p>4 is not a prime because it is divisible by 2, which means all multiples of 4 must also be divisible by 2 and were already marked off. So we can skip 4 immediately and go to the next number, 5. Now, all multiples of 5 such as 5 × 2 = 10, 5 × 3 = 15, 5 × 4 = 20, 5 × 5 = 25, … can be marked off. There is a slight optimization here, we do not need to start from 5 × 2 = 10. Where should we start marking off?</p>
<p>In fact, we can mark off multiples of 5 starting at 5 × 5 = 25, because 5 × 2 = 10 was already marked off by multiple of 2, similarly 5 × 3 = 15 was already marked off by multiple of 3. Therefore, if the current number is p, we can always mark off multiples of p starting at p2, then in increments of p: p2 + p, p2 + 2p, … Now what should be the terminating loop condition?</p>
<p>It is easy to say that the terminating loop condition is p &lt; n, which is certainly correct but not efficient. Do you still remember Hint #3?</p>
<p>Yes, the terminating loop condition can be p &lt; √n, as all non-primes ≥ √n must have already been marked off. When the loop terminates, all the numbers in the table that are non-marked are prime.</p>
<p>The Sieve of Eratosthenes uses an extra O(n) memory and its runtime complexity is O(n log log n). For the more mathematically inclined readers, you can read more about its algorithm complexity on Wikipedia.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">boolean</span>[] isPrime = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</div><div class="line">        Arrays.fill(isPrime, <span class="keyword">true</span>);</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt; n; ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (!isPrime[i]) <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; n; j += i) &#123;</div><div class="line">                isPrime[j] = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (isPrime[i]) &#123;</div><div class="line">                ++count;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: K-diff Pairs in an Array (532)]]></title>
      <url>/2017/03/26/2017-03-26-leetcode-solution-K-diff-Pairs-in-an-Array-532/</url>
      <content type="html"><![CDATA[<p>Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Input: [3, 1, 4, 1, 5], k = 2</div><div class="line">Output: 2</div><div class="line">Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).</div><div class="line">Although we have two 1s in the input, we should only return the number of unique pairs.</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input:[1, 2, 3, 4, 5], k = 1</div><div class="line">Output: 4</div><div class="line">Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).</div></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input: [1, 3, 1, 5, 4], k = 0</div><div class="line">Output: 1</div><div class="line">Explanation: There is one 0-diff pair in the array, (1, 1).</div></pre></td></tr></table></figure></p>
<p>Note:<br>The pairs (i, j) and (j, i) count as the same pair.<br>The length of the array won’t exceed 10,000.<br>All the integers in the given input belong to the range: [-1e7, 1e7].</p>
<h3 id="解法1：Two-pointers-O-NlogN-Time-O-1-Space"><a href="#解法1：Two-pointers-O-NlogN-Time-O-1-Space" class="headerlink" title="解法1：Two pointers, O(NlogN) Time + O(1) Space"></a>解法1：Two pointers, O(NlogN) Time + O(1) Space</h3><p>可以先排序，这样找距离为k的数就好找了。用Two pointers的方法来解，left负责从左到右遍历，right负责找对应于left的距离为k的数。<br>这题的坑点在于有重复的值，所以left需要去重，也就是下面程序的i， 那么如果说i在循环内因为重复的问题已经向前进了，那么right进行到下一次循环的时候需要至少从i+1开始，也就是<br>我们的那句j = Math.max(i + 1, j)的意义。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPairs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        Arrays.sort(nums); <span class="comment">// first sort the input</span></div><div class="line">        </div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, j = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</div><div class="line">            j = Math.max(i + <span class="number">1</span>, j);</div><div class="line">            <span class="keyword">while</span> ( j &lt; n &amp;&amp; (<span class="keyword">long</span>)nums[j] - nums[i] &lt; k) &#123;</div><div class="line">                ++j;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (j &lt; n &amp;&amp; (<span class="keyword">long</span>)nums[j] - nums[i] == k) &#123;</div><div class="line">                ++res;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span> (i &lt; n - <span class="number">1</span> &amp;&amp; nums[i + <span class="number">1</span>] == nums[i]) &#123;</div><div class="line">                ++i;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法2：HashMap-O-N-Time-O-N-Space"><a href="#解法2：HashMap-O-N-Time-O-N-Space" class="headerlink" title="解法2：HashMap, O(N) Time + O(N) Space"></a>解法2：HashMap, O(N) Time + O(N) Space</h3><p>这个解法借用了Two sum的思路，在two sum里，我们用一个hashmap来判断对应的两个数的和是否为target。这里也一样。如果要找寻是否有两个数的差是否为k， 那么我们也可以把他们都放到map中。<br>所不同的地方就是这里是统计个数。那么如果k是一个正数，我们只需要判断对应的另外一个数是否在map中。如果k为0， 那么要判断现在这个数出现的次数是否大于1.<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPairs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</div><div class="line">            <span class="keyword">if</span> (map.containsKey(num)) &#123;</div><div class="line">                map.put(num, map.get(num) + <span class="number">1</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                map.put(num, <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</div><div class="line">            <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; map.get(key) &gt; <span class="number">1</span>) &#123;</div><div class="line">                ++res;</div><div class="line">            &#125; </div><div class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; map.containsKey(key + k)) &#123;</div><div class="line">                ++res;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Two Sum II - Input array is sorted (167)]]></title>
      <url>/2017/03/26/2017-03-26-leetcode-solution-Two-Sum-II-Input-array-is-sorted-167/</url>
      <content type="html"><![CDATA[<p>Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>
<p>You may assume that each input would have exactly one solution and you may not use the same element twice.</p>
<p>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p>
<h3 id="解法1：O-N-Time-O-1-Complexity"><a href="#解法1：O-N-Time-O-1-Complexity" class="headerlink" title="解法1：O(N) Time + O(1) Complexity"></a>解法1：O(N) Time + O(1) Complexity</h3><p>如果是已经sorted的话这题就很简单了，比较容易的能想到可以用two pointers， left和right按照加和的大小不停的移动。</p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = numbers.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</div><div class="line">            <span class="keyword">int</span> sum = numbers[left] + numbers[right];</div><div class="line">            <span class="keyword">if</span> (sum &lt; target) &#123;</div><div class="line">                ++left;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</div><div class="line">                --right;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                res[<span class="number">0</span>] = left + <span class="number">1</span>;</div><div class="line">                res[<span class="number">1</span>] = right + <span class="number">1</span>;</div><div class="line">                <span class="keyword">return</span> res;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> Two pointers </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode解题: Min stack (155)]]></title>
      <url>/2017/03/23/2017-03-23-leetcode-solution-Min-stack-155/</url>
      <content type="html"><![CDATA[<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">push(x) -- Push element x onto stack.</div><div class="line">pop() -- Removes the element on top of the stack.</div><div class="line">top() -- Get the top element.</div><div class="line">getMin() -- Retrieve the minimum element in the stack.</div><div class="line">Example:</div><div class="line">MinStack minStack = new MinStack();</div><div class="line">minStack.push(-2);</div><div class="line">minStack.push(0);</div><div class="line">minStack.push(-3);</div><div class="line">minStack.getMin();   --&gt; Returns -3.</div><div class="line">minStack.pop();</div><div class="line">minStack.top();      --&gt; Returns 0.</div><div class="line">minStack.getMin();   --&gt; Returns -2.</div></pre></td></tr></table></figure>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>这题可以作为让你写一个Stack的class的follow up问题。<br>Implenment stack的时候可以用arraylist而不是用array, 这样就不用自己写一个resize function来维护底层数据的存放。<br>维护一个min, 可以有两个方法。一个是维护另一个arraylist， 保存对应每一个数据当前的最小值。<br>另一个方法是class MinStack extends Iterable<integer>, 然后需要有一个iterator(), 来返回一个Iterator<integer>的classmyiteraor，<br>这个myiterator implements Iterator<integer> 需要两个函数，hasNext()和next()</integer></integer></integer></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/** initialize your data structure here. */</span></div><div class="line">    List&lt;Integer&gt; data;</div><div class="line">    List&lt;Integer&gt; mins;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</div><div class="line">        data = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        mins = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        data.add(x);</div><div class="line">        <span class="keyword">if</span> (mins.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">            mins.add(mins.get(mins.size() - <span class="number">1</span>) &lt; x ? mins.get(mins.size() - <span class="number">1</span>) : x);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            mins.add(x);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (data.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">            data.remove(data.size() - <span class="number">1</span>);</div><div class="line">            mins.remove(mins.size() - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> data.get(data.size() - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mins.get(mins.size() - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></div><div class="line"><span class="comment"> * MinStack obj = new MinStack();</span></div><div class="line"><span class="comment"> * obj.push(x);</span></div><div class="line"><span class="comment"> * obj.pop();</span></div><div class="line"><span class="comment"> * int param_3 = obj.top();</span></div><div class="line"><span class="comment"> * int param_4 = obj.getMin();</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Spiral Matrix (54)]]></title>
      <url>/2017/03/23/2017-03-23-leetcode-solution-Spiral-Matrix-54/</url>
      <content type="html"><![CDATA[<p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p>
<p>For example,<br>Given the following matrix:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line"> [ 1, 2, 3 ],</div><div class="line"> [ 4, 5, 6 ],</div><div class="line"> [ 7, 8, 9 ]</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>You should return [1,2,3,6,9,8,7,4,5].</p>
<h3 id="解法1：O-M-N-Time-O-1-Space"><a href="#解法1：O-M-N-Time-O-1-Space" class="headerlink" title="解法1：O(M*N) Time, O(1) Space"></a>解法1：O(M*N) Time, O(1) Space</h3><p>运用分层处理的思想。一般情况，每一层有4条边组成，顺序是按照right, down, left, up。而且每一层的最后一行和第一行， 最后一列和第一列是对应关系。意思是说如果我们从第i行开始，那么与之对应的最后一行便是m - 1 - i, 列野同理。<br>那么层数有多少呢？这是又行数和列数决定的. level = (min(row, col) + 1) / 2<br>还有一个坑是对于单行或者单列的处理需要单独计算。</p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span> level = (Math.min(m, n) + <span class="number">1</span>) / <span class="number">2</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level; ++i) &#123;</div><div class="line">            <span class="keyword">int</span> lastrow = m - i - <span class="number">1</span>;</div><div class="line">            <span class="keyword">int</span> lastcol = n - i - <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (i == lastrow) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= lastcol; ++j) &#123;</div><div class="line">                    res.add(matrix[i][j]);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == lastcol) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= lastrow; ++j) &#123;</div><div class="line">                    res.add(matrix[j][i]);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// To right</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; lastcol; ++j) &#123;</div><div class="line">                    res.add(matrix[i][j]);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// down</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; lastrow; ++j) &#123;</div><div class="line">                    res.add(matrix[j][lastcol]);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// left</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = lastcol; j &gt; i; --j) &#123;</div><div class="line">                    res.add(matrix[lastrow][j]);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// up</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = lastrow; j &gt; i; --j) &#123;</div><div class="line">                    res.add(matrix[j][i]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Divide two Integers (29)]]></title>
      <url>/2017/03/23/2017-03-23-leetcode-solution-Divide-two-Integers-29/</url>
      <content type="html"><![CDATA[<p>Divide two integers without using multiplication, division and mod operator.</p>
<p>If it is overflow, return MAX_INT.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>这题有几个坑：一个是分母有可能是0， 这种情况要判断dividend的正负而返回。一个是INT_MIN/(-1) &gt; INT_MAX, 所以这种条件下会overflow。还有一个是分子分母有可能符号不同。<br>除法的基本算法是把被除数A分拆成A = B*(2^n1 + 2^n2 + ….), 每一次找出比A小的最大的B的2的倍数，也就是求出Ni。这里每一次B乘以2的操作可以用左位移表示。<br>这里引出了另外一个坑，就是往左移的时候可能会溢出，所以一开始要把他们转化为long型再操作。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (divisor == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> dividend &gt;= <span class="number">0</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">return</span> Integer.MAX_VALUE;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">boolean</span> neg = <span class="keyword">false</span>;</div><div class="line">	    <span class="keyword">if</span> ((dividend &gt; <span class="number">0</span> &amp;&amp; divisor &lt; <span class="number">0</span>) || (dividend &lt; <span class="number">0</span> &amp;&amp; divisor &gt; <span class="number">0</span>)) &#123;</div><div class="line">	        neg = <span class="keyword">true</span>;</div><div class="line">	    &#125;</div><div class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">		<span class="keyword">long</span> x = Math.abs((<span class="keyword">long</span>)dividend);</div><div class="line">		<span class="keyword">long</span> y = Math.abs((<span class="keyword">long</span>)divisor);</div><div class="line">		<span class="keyword">while</span> ( x &gt;= y) &#123;</div><div class="line">			<span class="keyword">int</span> shift = <span class="number">1</span>;</div><div class="line">			<span class="keyword">while</span> (x &gt;= (y&lt;&lt;shift)) &#123;</div><div class="line">				++shift;</div><div class="line">			&#125;</div><div class="line">			x -= y &lt;&lt; (shift - <span class="number">1</span>);</div><div class="line">			res += <span class="number">1</span> &lt;&lt; (shift - <span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> neg ? <span class="number">0</span> - res : res;         </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> Amazon </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Relative Ranks (506)]]></title>
      <url>/2017/03/12/2017-03-12-leetcode-solution-Relative-Ranks-506/</url>
      <content type="html"><![CDATA[<p>Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: “Gold Medal”, “Silver Medal” and “Bronze Medal”.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Input: [5, 4, 3, 2, 1]</div><div class="line">Output: [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;, &quot;4&quot;, &quot;5&quot;]</div><div class="line">Explanation: The first three athletes got the top three highest scores, so they got &quot;Gold Medal&quot;, &quot;Silver Medal&quot; and &quot;Bronze Medal&quot;. </div><div class="line">For the left two athletes, you just need to output their relative ranks according to their scores.</div></pre></td></tr></table></figure></p>
<p>Note:<br>N is a positive integer and won’t exceed 10,000.<br>All the scores of athletes are guaranteed to be unique.</p>
<h3 id="解法1：Priority-Queue"><a href="#解法1：Priority-Queue" class="headerlink" title="解法1：Priority Queue"></a>解法1：Priority Queue</h3><p>这里感觉是要用一个带下标的排序，那么我们可以自己实现一个带下标的排序，或者可以使用已有的可排序的数据结构。对于可排序的比较熟悉的就是PriorityQueue了。<br>每一个放入的元素都会自动排序，那么我们只需要全部放入然后一个个读出同时判断是第几个元素就可以解决medal的归属问题。<br>用一个辅助class记录data和index，同时实现一个comparator，来比较这两个pair。</p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">pair</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> data;</div><div class="line">    <span class="keyword">int</span> index;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">pair</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.data = d;</div><div class="line">        <span class="keyword">this</span>.index = i;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> String[] findRelativeRanks(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">        Comparator&lt;pair&gt; comparator = <span class="keyword">new</span> Comparator&lt;pair&gt;() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(pair a, pair b)</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span> (a.data &lt; b.data) &#123;</div><div class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.data == b.data) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        PriorityQueue&lt;pair&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;pair&gt;(nums.length, comparator);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</div><div class="line">            queue.offer(<span class="keyword">new</span> pair(nums[i], i));</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        String[] res = <span class="keyword">new</span> String[nums.length];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</div><div class="line">            pair temp = queue.peek();</div><div class="line">            <span class="keyword">if</span> (queue.size() &gt; <span class="number">3</span>) &#123;</div><div class="line">                res[temp.index] = Integer.toString(queue.size());</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (queue.size() == <span class="number">3</span>) &#123;</div><div class="line">                res[temp.index] = <span class="string">"Bronze Medal"</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (queue.size() == <span class="number">2</span>) &#123;</div><div class="line">                res[temp.index] = <span class="string">"Silver Medal"</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                res[temp.index] = <span class="string">"Gold Medal"</span>;</div><div class="line">            &#125;</div><div class="line">            queue.poll();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> PriorityQueue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Minesweeper (529)]]></title>
      <url>/2017/03/12/2017-03-12-leetcode-solution-Minesweeper-529/</url>
      <content type="html"><![CDATA[<p>Let’s play the minesweeper game (Wikipedia, online game)!</p>
<p>You are given a 2D char matrix representing the game board. ‘M’ represents an unrevealed mine, ‘E’ represents an unrevealed empty square, ‘B’ represents a revealed blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit (‘1’ to ‘8’) represents how many mines are adjacent to this revealed square, and finally ‘X’ represents a revealed mine.</p>
<p>Now given the next click position (row and column indices) among all the unrevealed squares (‘M’ or ‘E’), return the board after revealing this position according to the following rules:</p>
<p>If a mine (‘M’) is revealed, then the game is over - change it to ‘X’.<br>If an empty square (‘E’) with no adjacent mines is revealed, then change it to revealed blank (‘B’) and all of its adjacent unrevealed squares should be revealed recursively.<br>If an empty square (‘E’) with at least one adjacent mine is revealed, then change it to a digit (‘1’ to ‘8’) representing the number of adjacent mines.<br>Return the board when no more squares will be revealed.<br>Example 1:<br>Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[&apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;],</div><div class="line"> [&apos;E&apos;, &apos;E&apos;, &apos;M&apos;, &apos;E&apos;, &apos;E&apos;],</div><div class="line"> [&apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;],</div><div class="line"> [&apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;]]</div></pre></td></tr></table></figure></p>
<p>Click : [3,0]</p>
<p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[&apos;B&apos;, &apos;1&apos;, &apos;E&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class="line"> [&apos;B&apos;, &apos;1&apos;, &apos;M&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class="line"> [&apos;B&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class="line"> [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;]]</div></pre></td></tr></table></figure></p>
<p>Explanation:<br><img src="https://leetcode.com/static/images/problemset/minesweeper_example_1.png" alt="alt text" title="explanation"><br>Example 2:<br>Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[&apos;B&apos;, &apos;1&apos;, &apos;E&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class="line"> [&apos;B&apos;, &apos;1&apos;, &apos;M&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class="line"> [&apos;B&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class="line"> [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;]]</div></pre></td></tr></table></figure></p>
<p>Click : [1,2]</p>
<p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[&apos;B&apos;, &apos;1&apos;, &apos;E&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class="line"> [&apos;B&apos;, &apos;1&apos;, &apos;X&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class="line"> [&apos;B&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class="line"> [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;]]</div></pre></td></tr></table></figure></p>
<p>Explanation:<br><img src="https://leetcode.com/static/images/problemset/minesweeper_example_2.png" alt="alt text" title="explanation"></p>
<p>Note:<br>The range of the input matrix’s height and width is [1,50].<br>The click position will only be an unrevealed square (‘M’ or ‘E’), which also means the input board contains at least one clickable square.<br>The input board won’t be a stage when game is over (some mines have been revealed).<br>For simplicity, not mentioned rules should be ignored in this problem. For example, you don’t need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>题目看起来很复杂，其实实现起来比较简单。就一步步按照他的规则来就可以。主要是考察了DFS或者是BFS的应用。这里我用了DFS的解法，对于每一个click的方块。如果是地雷，那么直接return了。<br>如果不是地雷，那么统计一下周围地雷的个数。如果是空的，那么就对所有相邻的都做一遍DFS，如果是有地雷则直接范围地雷的个数。</p>
<p>Java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    // defines the 8 directions it can point to</div><div class="line">    private int[][] directions = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;-1,1&#125;,&#123;1,1&#125;,&#123;1,-1&#125;,&#123;-1,-1&#125;&#125;;</div><div class="line">    public char[][] updateBoard(char[][] board, int[] click) &#123;</div><div class="line">        </div><div class="line">        if (board.length == 0 || board[0].length == 0) &#123;</div><div class="line">            return board;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        dfs(board, click[0], click[1]);</div><div class="line">        </div><div class="line">        return board;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private void dfs(char[][] board, int i, int j) &#123;</div><div class="line">        if (board[i][j] == &apos;M&apos;) &#123;</div><div class="line">            board[i][j] = &apos;X&apos;;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (board[i][j] == &apos;E&apos;) &#123;</div><div class="line">            int n = getNumberOfMines(board, i, j);</div><div class="line">            if (n == 0) &#123;</div><div class="line">                board[i][j] = &apos;B&apos;;</div><div class="line">                // doing dfs for each direction</div><div class="line">                for (int[] direction: directions) &#123;</div><div class="line">                    int x = i + direction[0];</div><div class="line">                    int y = j + direction[1];</div><div class="line">                    if (x &lt; 0 || x &gt;= board.length || y &lt; 0 || y &gt;= board[0].length || board[x][y] == &apos;M&apos;) &#123;</div><div class="line">                        continue;</div><div class="line">                    &#125;</div><div class="line">                    dfs(board, x, y);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                board[i][j] = (char)(n + &apos;0&apos;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private int getNumberOfMines(char[][] board, int i, int j) &#123;</div><div class="line">        int n = board.length;</div><div class="line">        int m = board[0].length;</div><div class="line">        int count = 0;</div><div class="line">        for (int[] direction: directions) &#123;</div><div class="line">            int x = i + direction[0];</div><div class="line">            int y = j + direction[1];</div><div class="line">            if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m) &#123;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            if (board[x][y] == &apos;M&apos;) &#123;</div><div class="line">                ++count;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode解题: Lonely Pixel (531)]]></title>
      <url>/2017/03/12/2017-03-12-leetcode-solution-Lonely-Pixel-531/</url>
      <content type="html"><![CDATA[<p>Given a picture consisting of black and white pixels, find the number of black lonely pixels.</p>
<p>The picture is represented by a 2D char array consisting of ‘B’ and ‘W’, which means black and white pixels respectively.</p>
<p>A black lonely pixel is character ‘B’ that located at a specific position where the same row and same column don’t have any other black pixels.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Input: </div><div class="line">[[&apos;W&apos;, &apos;W&apos;, &apos;B&apos;],</div><div class="line"> [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;],</div><div class="line"> [&apos;B&apos;, &apos;W&apos;, &apos;W&apos;]]</div><div class="line"></div><div class="line">Output: 3</div><div class="line">Explanation: All the three &apos;B&apos;s are black lonely pixels.</div></pre></td></tr></table></figure></p>
<p>Note:<br>The range of width and height of the input 2D array is [1,500].</p>
<h3 id="解法1：O-MN-Time-O-M-N-Space"><a href="#解法1：O-MN-Time-O-M-N-Space" class="headerlink" title="解法1：O(MN) Time + O(M + N) Space"></a>解法1：O(MN) Time + O(M + N) Space</h3><p>用两个数组分别记录每一行， 每一列的pixel的个数，然后遍历一遍矩阵，对于每一个B的位置查看当前行列的B的个数。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLonelyPixel</span><span class="params">(<span class="keyword">char</span>[][] picture)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (picture.length == <span class="number">0</span> || picture[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> n = picture.length;</div><div class="line">        <span class="keyword">int</span> m = picture[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[] row = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        <span class="keyword">int</span>[] col = <span class="keyword">new</span> <span class="keyword">int</span>[m];</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</div><div class="line">                <span class="keyword">if</span> (picture[i][j] == <span class="string">'B'</span>) &#123;</div><div class="line">                    row[i]++;</div><div class="line">                    col[j]++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;++i) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</div><div class="line">                <span class="keyword">if</span> (picture[i][j] == <span class="string">'B'</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (row[i] == <span class="number">1</span> &amp;&amp; col[j] == <span class="number">1</span>) &#123;</div><div class="line">                        ++count;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Find Largest Value in Each Tree Row (515)]]></title>
      <url>/2017/03/12/2017-03-12-leetcode-solution-Find-Largest-Value-in-Each-Tree-Row-515/</url>
      <content type="html"><![CDATA[<p>You need to find the largest value in each row of a binary tree.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Input: </div><div class="line"></div><div class="line">          1</div><div class="line">         / \</div><div class="line">        3   2</div><div class="line">       / \   \  </div><div class="line">      5   3   9 </div><div class="line"></div><div class="line">Output: [1, 3, 9]</div></pre></td></tr></table></figure></p>
<h3 id="解法1：BFS"><a href="#解法1：BFS" class="headerlink" title="解法1：BFS"></a>解法1：BFS</h3><p>因为是按行来选择最大值，自然想到用BFS遍历每一行，然后存储下每一行的最大值。主要考察了BFS的写法。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestValues</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">		<span class="comment">// bfs</span></div><div class="line">		List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> result;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</div><div class="line">		queue.offer(root);</div><div class="line">		<span class="keyword">while</span> (!queue.isEmpty()) &#123;</div><div class="line">			<span class="keyword">int</span> size = queue.size();</div><div class="line">			<span class="keyword">int</span> levelmax = Integer.MIN_VALUE;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</div><div class="line">				TreeNode cur = queue.poll();</div><div class="line">				levelmax = Math.max(levelmax, cur.val);</div><div class="line">				<span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</div><div class="line">					queue.offer(cur.left);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</div><div class="line">					queue.offer(cur.right);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			result.add(levelmax);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Number of Islands II (305)]]></title>
      <url>/2017/03/12/2017-03-12-leetcode-solution-Number-of-Islands-II-305/</url>
      <content type="html"><![CDATA[<p>A 2d grid map of m rows and n columns is initially filled with water. We may perform an addLand operation which turns the water at position (row, col) into a land. Given a list of positions to operate, count the number of islands after each addLand operation. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p>Example:</p>
<p>Given m = 3, n = 3, positions = [[0,0], [0,1], [1,2], [2,1]].<br>Initially, the 2d grid grid is filled with water. (Assume 0 represents water and 1 represents land).</p>
<p>0 0 0<br>0 0 0<br>0 0 0<br>Operation #1: addLand(0, 0) turns the water at grid[0][0] into a land.</p>
<p>1 0 0<br>0 0 0   Number of islands = 1<br>0 0 0<br>Operation #2: addLand(0, 1) turns the water at grid<a href="https://discuss.leetcode.com/topic/29613/easiest-java-solution-with-explanations/4" target="_blank" rel="external">0</a> into a land.</p>
<p>1 1 0<br>0 0 0   Number of islands = 1<br>0 0 0<br>Operation #3: addLand(1, 2) turns the water at grid[1][2] into a land.</p>
<p>1 1 0<br>0 0 1   Number of islands = 2<br>0 0 0<br>Operation #4: addLand(2, 1) turns the water at grid<a href="https://discuss.leetcode.com/topic/29613/easiest-java-solution-with-explanations/4" target="_blank" rel="external">2</a> into a land.</p>
<p>1 1 0<br>0 0 1   Number of islands = 3<br>0 1 0<br>We return the result as an array: [1, 1, 2, 3]</p>
<p>Challenge:</p>
<p>Can you do it in time complexity O(k log mn), where k is the length of the positions?</p>
<h3 id="解法1：Union-Find-O-k-logmn"><a href="#解法1：Union-Find-O-k-logmn" class="headerlink" title="解法1：Union Find O(k logmn)"></a>解法1：Union Find O(k logmn)</h3><p>这是一题难题了，为了熟悉Union Find的算法也做（抄）一下吧。主要是参考了<a href="https://discuss.leetcode.com/topic/29613/easiest-java-solution-with-explanations/4" target="_blank" rel="external">这篇</a>.<br>Union Find很适合用来解决两点是否想通的问题。用一个roots来记录每一个点的group id也就是下面code中的parent。<br>然后对于每一个插入的点，首先把自己的点的group id设为自己，然后搜索周围相邻的点，如果相邻的点是陆地并且相邻的点的group id和自己不同的时候，则说明需要进行Union操作。<br>这个时候对于当前岛屿的数量需要-1，因为合并了一个。<br>Java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    </div><div class="line">	private int[][] directions = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;;</div><div class="line"></div><div class="line">	public List&lt;Integer&gt; numIslands2(int m, int n, int[][] positions) &#123;</div><div class="line">		// Union Find</div><div class="line">		List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();</div><div class="line">		if (m &lt;= 0 || n &lt;= 0 || positions.length == 0 || positions[0].length == 0) &#123;</div><div class="line">			return result;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		int count = 0;</div><div class="line">		int[] roots = new int[m * n];</div><div class="line">		Arrays.fill(roots, -1);</div><div class="line"></div><div class="line">		for (int[] position: positions) &#123;</div><div class="line">			// positions</div><div class="line">			count++;</div><div class="line">			int index = n * position[0] + position[1];</div><div class="line">			roots[index] = index;</div><div class="line">			// perform union operations</div><div class="line">			for (int[] direction: directions) &#123;</div><div class="line">				int x = position[0] + direction[0];</div><div class="line">				int y = position[1] + direction[1];</div><div class="line">				int neighbor = x * n + y;</div><div class="line">				if ( x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || roots[neighbor] == -1) &#123;</div><div class="line">					continue;</div><div class="line">				&#125;</div><div class="line">				int parent = find(roots, neighbor);</div><div class="line">				if (parent != index) &#123;</div><div class="line">					roots[index] = parent;</div><div class="line">					count--;</div><div class="line">					index = parent;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			result.add(count);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	private int find(int[] roots, int index) &#123;</div><div class="line">		while (roots[index] != index) &#123;</div><div class="line">			index = roots[index];</div><div class="line">		&#125;</div><div class="line">		return index;</div><div class="line">	&#125;		</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Keyboard Row (500)]]></title>
      <url>/2017/03/12/2017-03-12-leetcode-solution-Keyboard-Row-500/</url>
      <content type="html"><![CDATA[<p>Given a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below.<br><img src="https://leetcode.com/static/images/problemset/keyboard.png" alt="alt text" title="American Keyboard"></p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]</div><div class="line">Output: [&quot;Alaska&quot;, &quot;Dad&quot;]</div></pre></td></tr></table></figure></p>
<p>Note:<br>You may use one character in the keyboard more than once.<br>You may assume the input string will only contain letters of alphabet.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>这题就是掌握一下语言中对于string查找相关的操作。<br>Java<br>Java中的string.toCharArray()，还有查找一个char是否在string里的操作string.indexOf(s) == -1<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    String[] keyboards = &#123;<span class="string">"qwertyuiop"</span>,<span class="string">"asdfghjkl"</span>,<span class="string">"zxcvbnm"</span>&#125;;</div><div class="line">    <span class="keyword">public</span> String[] findWords(String[] words) &#123;</div><div class="line">        </div><div class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        <span class="keyword">for</span> (String word: words) &#123;</div><div class="line">            <span class="keyword">for</span> (String row: keyboards) &#123;</div><div class="line">                <span class="keyword">boolean</span> temp = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> s: word.toLowerCase().toCharArray()) &#123;</div><div class="line">                    <span class="keyword">if</span> (row.indexOf(s) == -<span class="number">1</span>) &#123;</div><div class="line">                        temp = <span class="keyword">false</span>;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (temp) &#123;</div><div class="line">                    res.add(word);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String[] r = <span class="keyword">new</span> String[res.size()];</div><div class="line">        res.toArray(r);</div><div class="line">        <span class="keyword">return</span> r;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Construct the rectangle (492)]]></title>
      <url>/2017/03/12/2017-03-12-leetcode-solution-Construct-the-rectangle-492/</url>
      <content type="html"><![CDATA[<p>For a web developer, it is very important to know how to design a web page’s size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1. The area of the rectangular web page you designed must equal to the given target area.</div><div class="line"></div><div class="line">2. The width W should not be larger than the length L, which means L &gt;= W.</div><div class="line"></div><div class="line">3. The difference between length L and width W should be as small as possible.</div></pre></td></tr></table></figure></p>
<p>You need to output the length L and the width W of the web page you designed in sequence.<br>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Input: 4</div><div class="line">Output: [2, 2]</div><div class="line">Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. </div><div class="line">But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.</div></pre></td></tr></table></figure></p>
<p>Note:<br>The given area won’t exceed 10,000,000 and is a positive integer<br>The web page’s width and length you designed must be positive integers.</p>
<h3 id="解法1：O-Sqrt-area"><a href="#解法1：O-Sqrt-area" class="headerlink" title="解法1：O(Sqrt(area))"></a>解法1：O(Sqrt(area))</h3><p>按照提议，如果area是一个完全平方数的话正方形的边长就是最佳答案。那么可以从平方根出发，找出 1 &lt;= x &lt;= sqrt(area)当中最大的能被area整除的数就是所要求的。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructRectangle(<span class="keyword">int</span> area) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> temp = (<span class="keyword">int</span>) Math.sqrt(area);</div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (area % temp != <span class="number">0</span> ) &#123;</div><div class="line">            --temp;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span>[] res = &#123;area / temp, temp &#125;;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Detect Capital (520)]]></title>
      <url>/2017/03/12/2017-03-12-leetcode-solution-Detect-Capital-520/</url>
      <content type="html"><![CDATA[<p>Given a word, you need to judge whether the usage of capitals in it is right or not.</p>
<p>We define the usage of capitals in a word to be right when one of the following cases holds:</p>
<p>All letters in this word are capitals, like “USA”.<br>All letters in this word are not capitals, like “leetcode”.<br>Only the first letter in this word is capital if it has more than one letter, like “Google”.<br>Otherwise, we define that this word doesn’t use capitals in a right way.<br>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: &quot;USA&quot;</div><div class="line">Output: True</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: &quot;FlaG&quot;</div><div class="line">Output: False</div></pre></td></tr></table></figure></p>
<p>Note: The input will be a non-empty word consisting of uppercase and lowercase latin letters.</p>
<h3 id="解法1：Regex-表达式"><a href="#解法1：Regex-表达式" class="headerlink" title="解法1：Regex 表达式"></a>解法1：Regex 表达式</h3><p>感觉这个做法比较像作弊。。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">detectCapitalUse</span><span class="params">(String word)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> word.matches(<span class="string">"[A-Z]+|[a-z]+|[A-Z][a-z]+"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法2-常规解法"><a href="#解法2-常规解法" class="headerlink" title="解法2: 常规解法"></a>解法2: 常规解法</h3><p>常规的想法，可以判断是否都是大写或者都是小写，或者第2个字母开始是否都是小写。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">detectCapitalUse</span><span class="params">(String word)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (word.equals(word.toUpperCase())) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (word.equals(word.toLowerCase())) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (word.substring(<span class="number">1</span>).equals(word.substring(<span class="number">1</span>).toLowerCase())) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Max Consecutive Ones (485)]]></title>
      <url>/2017/03/12/2017-03-12-leetcode-solution-Max-Consecutive-Ones-485/</url>
      <content type="html"><![CDATA[<p>Given a binary array, find the maximum number of consecutive 1s in this array.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Input: [1,1,0,1,1,1]</div><div class="line">Output: 3</div><div class="line">Explanation: The first two digits or the last three digits are consecutive 1s.</div><div class="line">    The maximum number of consecutive 1s is 3.</div></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>The input array will only contain 0 and 1.<br>The length of input array is a positive integer and will not exceed 10,000</p>
<h3 id="解法1：O-N-一次遍历"><a href="#解法1：O-N-一次遍历" class="headerlink" title="解法1：O(N),一次遍历"></a>解法1：O(N),一次遍历</h3><p>dp的思想，dp[i] = dp[i - 1] + 1 if dp[i] == 1 else dp[i] = 0, 然后用一个res来记录当前遇到的最大值即可。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</div><div class="line">            <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</div><div class="line">                ++count;</div><div class="line">                res = Math.max(res, count);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                count = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Next Greater Element I (496)]]></title>
      <url>/2017/03/12/2017-03-12-leetcode-solution-Next-Greater-Element-I-496/</url>
      <content type="html"><![CDATA[<p>You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1’s elements in the corresponding places of nums2.</p>
<p>The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Input: nums1 = [4,1,2], nums2 = [1,3,4,2].</div><div class="line">Output: [-1,3,-1]</div><div class="line">Explanation:</div><div class="line">    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.</div><div class="line">    For number 1 in the first array, the next greater number for it in the second array is 3.</div><div class="line">    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Input: nums1 = [2,4], nums2 = [1,2,3,4].</div><div class="line">Output: [3,-1]</div><div class="line">Explanation:</div><div class="line">    For number 2 in the first array, the next greater number for it in the second array is 3.</div><div class="line">    For number 4 in the first array, there is no next greater number for it in the second array, so output -1.</div></pre></td></tr></table></figure></p>
<p>Note:<br>All elements in nums1 and nums2 are unique.<br>The length of both nums1 and nums2 would not exceed 1000.</p>
<h3 id="解法1：Stack-HashMap-O-N-Time-O-N-Space"><a href="#解法1：Stack-HashMap-O-N-Time-O-N-Space" class="headerlink" title="解法1：Stack + HashMap: O(N) Time + O(N) Space"></a>解法1：Stack + HashMap: O(N) Time + O(N) Space</h3><p>很好的一道题，主要的思路是在扫描的过程中得出每一个element对应的next greater element。 然后在hashmap中查找所需要的结果。<br>一次遍历找出next greater element的思路是[A,B] 如果B比A大那么B就是A对应的结果。如果B比A小的话要找出第一个比B大的数才是B的结果，而A要等到比A自己大的才可以。<br>那么试想，如果碰到一个递减数列[5,4,3,2,1]如果出现一个6，比前面所有的数都大，这个时候这个6就是所有数的NGE。所以有此我们可以用一个stack来维护递减的数列，只要下一个数比stack的top大，那么top值得NGE就是当前的值。<br>不停的弹出stack的值直到top的值比当前的值大为止。</p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] findNums, <span class="keyword">int</span>[] nums) &#123;</div><div class="line">        </div><div class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</div><div class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; num &gt; stack.peek()) &#123;</div><div class="line">                map.put(stack.pop(), num);</div><div class="line">            &#125;</div><div class="line">            stack.push(num);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// scan through findNums</span></div><div class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[findNums.length];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; ++i) &#123;</div><div class="line">            res[i] = map.getOrDefault(findNums[i], -<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode解题: Number of Islands (200)]]></title>
      <url>/2017/03/08/2017-03-08-leetcode-solution-Number-of-Islands-200/</url>
      <content type="html"><![CDATA[<p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p>Example 1:</p>
<p>11110<br>11010<br>11000<br>00000<br>Answer: 1</p>
<p>Example 2:</p>
<p>11000<br>11000<br>00100<br>00011<br>Answer: 3</p>
<h3 id="解法1：DFS"><a href="#解法1：DFS" class="headerlink" title="解法1：DFS"></a>解法1：DFS</h3><p>用DFS遍历每一个元素，如果是1就表示有一个岛屿，并且用DFS遍历所有与之相连的节点。并且把他们标注为非岛屿。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</div><div class="line">   		    <span class="keyword">if</span> (grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; ++i) &#123;</div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; ++j) &#123;</div><div class="line">					<span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</div><div class="line">						++res;</div><div class="line">						dfs(grid, i, j);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.length || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].length) &#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</div><div class="line">			grid[i][j] = <span class="string">'0'</span>;</div><div class="line">			dfs(grid, i + <span class="number">1</span>, j);</div><div class="line">			dfs(grid, i - <span class="number">1</span>, j);</div><div class="line">			dfs(grid, i, j + <span class="number">1</span>);</div><div class="line">			dfs(grid, i, j - <span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;		</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法2：BFS"><a href="#解法2：BFS" class="headerlink" title="解法2：BFS"></a>解法2：BFS</h3><p>Java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">class pair &#123;</div><div class="line">	int x, y;</div><div class="line">	public pair(int row, int col) &#123;</div><div class="line">		this.x = row;</div><div class="line">		this.y = col;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">public class Solution &#123;</div><div class="line">    public int numIslands(char[][] grid) &#123;</div><div class="line">		if (grid.length == 0 || grid[0].length == 0) &#123;</div><div class="line">			return 0;</div><div class="line">		&#125;</div><div class="line">		int res = 0;</div><div class="line">		for (int i = 0; i &lt; grid.length; ++i) &#123;</div><div class="line">			for (int j = 0; j &lt; grid[0].length; ++j) &#123;</div><div class="line">				if (grid[i][j] == &apos;1&apos;) &#123;</div><div class="line">					++res;</div><div class="line">					bfs(grid, i, j);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;    </div><div class="line">		return res;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private int[][] directions = new int[][] &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;;</div><div class="line"></div><div class="line">	private void bfs(char[][] grid, int i, int j) &#123;</div><div class="line">	    int row = grid.length;</div><div class="line">	    int col = grid[0].length;</div><div class="line">		Queue&lt;pair&gt; queue = new LinkedList&lt;pair&gt;();</div><div class="line">		if (grid[i][j] == &apos;1&apos;) &#123;</div><div class="line">			queue.offer(new pair(i, j));</div><div class="line">			grid[i][j] = &apos;0&apos;;</div><div class="line">		&#125;</div><div class="line">		while (!queue.isEmpty()) &#123;</div><div class="line">			pair cur = queue.poll();</div><div class="line">			for (int d = 0; d &lt; directions.length; ++d) &#123;</div><div class="line">			    int x = cur.x + directions[d][0];</div><div class="line">			    int y = cur.y + directions[d][1];</div><div class="line">			    if (!isInbound(row, col, x, y)) &#123;</div><div class="line">			       continue;</div><div class="line">			    &#125;</div><div class="line">			    if (grid[x][y] == &apos;1&apos;) &#123;</div><div class="line">			        queue.offer(new pair(x,y));</div><div class="line">			        grid[x][y] = &apos;0&apos;;</div><div class="line">			    &#125;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125;		</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	private boolean isInbound(int row, int col, int i, int j) &#123;</div><div class="line">	   return i &gt;= 0 &amp;&amp; i &lt; row &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; col;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Graph Valid Tree (261)]]></title>
      <url>/2017/03/08/2017-03-08-leetcode-solution-Graph-Valid-Tree-261/</url>
      <content type="html"><![CDATA[<p>Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.</p>
<p>For example:</p>
<p>Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true.</p>
<p>Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.</p>
<p>Hint:</p>
<p>Given n = 5 and edges = [[0, 1], [1, 2], [3, 4]], what should your return? Is this case a valid tree?<br>According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.”<br>Note: you can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>此题用Union Find最简便，DFS 和 BFS 都可以。</p>
<h3 id="解法1：-DFS"><a href="#解法1：-DFS" class="headerlink" title="解法1： DFS"></a>解法1： DFS</h3><p>按照题目意思，这是一个undirectedgraph判定是否是tree的问题，那么一个无向图要满足两个条件。一个是要全连通，另一个是要没有环。<br>基本思想是用DFS遍历，如果遍历到之前遇过的节点说明有环。遍历之后如果还有没有遍历过的节点那么就不是全通图。</p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validTree</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</div><div class="line">		<span class="comment">// Construct the graph using hashmap</span></div><div class="line">		<span class="comment">// Empty Tree</span></div><div class="line">		<span class="comment">// Need to satisfy two conditions, 1) all nodes are linked 2) no cycle in the list</span></div><div class="line">		<span class="keyword">if</span> ((edges.length == <span class="number">0</span> || edges[<span class="number">0</span>].length == <span class="number">0</span>)) &#123;</div><div class="line">		    <span class="keyword">return</span> n == <span class="number">1</span> || n == <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">		HashMap&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, List&lt;Integer&gt;&gt;();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span>[] edge: edges) &#123;</div><div class="line">			<span class="keyword">if</span> (!map.containsKey(edge[<span class="number">0</span>])) &#123;</div><div class="line">				map.put(edge[<span class="number">0</span>], <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (!map.containsKey(edge[<span class="number">1</span>])) &#123;</div><div class="line">				map.put(edge[<span class="number">1</span>], <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</div><div class="line">			&#125;</div><div class="line">			map.get(edge[<span class="number">0</span>]).add(edge[<span class="number">1</span>]);</div><div class="line">			map.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">		List&lt;Boolean&gt; visited = <span class="keyword">new</span> ArrayList&lt;Boolean&gt;(n);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</div><div class="line">		    visited.add(<span class="keyword">false</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">boolean</span> res = dfs(map, visited, <span class="number">0</span>, -<span class="number">1</span>);</div><div class="line">		<span class="keyword">if</span> (!res) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">boolean</span> node: visited) &#123;</div><div class="line">			<span class="keyword">if</span> (!node) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(HashMap&lt;Integer, List&lt;Integer&gt;&gt; map, List&lt;Boolean&gt; visited, <span class="keyword">int</span> cur, <span class="keyword">int</span> prev)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (visited.get(cur)) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// prev records the node that link to the current dfs function call</span></div><div class="line">		visited.set(cur, <span class="keyword">true</span>);</div><div class="line">		List&lt;Integer&gt; connected = map.get(cur);</div><div class="line">		<span class="keyword">if</span> (connected == <span class="keyword">null</span>) &#123;</div><div class="line">		    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> node: connected) &#123;</div><div class="line">		    <span class="keyword">if</span> (node != prev) &#123;</div><div class="line">    			<span class="keyword">boolean</span> res = dfs(map, visited, node, cur);</div><div class="line">    			<span class="keyword">if</span> (!res) &#123;</div><div class="line">    				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    			&#125;</div><div class="line">		    &#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">			</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法2：-BFS"><a href="#解法2：-BFS" class="headerlink" title="解法2： BFS"></a>解法2： BFS</h3><p>BFS 的思想和DFS的基本一致。要注意的是，在存储图的信息的时候，用一个Set比较方便。因为之后当我们在扫描一个节点连接的节点时，要删除对应节点中的edge（就是a连向b，那么b的相连node中一定有a，为了避免出现再遇到a，需要把对应的a从b相连的节点的list中删除，用set比较方便的解决此问题）<br>同时用一个set来维护已经访问过的节点。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validTree</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (edges.length == <span class="number">0</span> || edges[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> n == <span class="number">1</span> || n == <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		HashMap&lt;Integer, Set&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Set&lt;Integer&gt;&gt;();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span>[] edge: edges) &#123;</div><div class="line">			<span class="keyword">if</span> (!map.containsKey(edge[<span class="number">0</span>])) &#123;</div><div class="line">				map.put(edge[<span class="number">0</span>], <span class="keyword">new</span> HashSet&lt;Integer&gt;());</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (!map.containsKey(edge[<span class="number">1</span>])) &#123;</div><div class="line">				map.put(edge[<span class="number">1</span>], <span class="keyword">new</span> HashSet&lt;Integer&gt;());</div><div class="line">			&#125;</div><div class="line">			map.get(edge[<span class="number">0</span>]).add(edge[<span class="number">1</span>]);</div><div class="line">			map.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="comment">// Start BFS</span></div><div class="line">		Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();   </div><div class="line">		Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</div><div class="line">		queue.offer(<span class="number">0</span>);</div><div class="line">		set.add(<span class="number">0</span>);</div><div class="line">		<span class="keyword">while</span> (!queue.isEmpty()) &#123;</div><div class="line">		    <span class="keyword">int</span> node = queue.poll();</div><div class="line">		    Set&lt;Integer&gt; elements = map.get(node);</div><div class="line">		    <span class="keyword">if</span> (elements != <span class="keyword">null</span>) &#123;</div><div class="line">		        <span class="keyword">for</span> (<span class="keyword">int</span> element: elements) &#123;</div><div class="line">		            <span class="keyword">if</span> (set.contains(element)) &#123;</div><div class="line">		                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		            &#125;</div><div class="line">		            queue.offer(element);</div><div class="line">		            set.add(element);</div><div class="line">		            map.get(element).remove(node);</div><div class="line">		        &#125;</div><div class="line">		    &#125;</div><div class="line">		    </div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="comment">// Check the length of Set</span></div><div class="line">		<span class="keyword">return</span> set.size() == n;</div><div class="line"></div><div class="line">	</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法3：-Union-Find"><a href="#解法3：-Union-Find" class="headerlink" title="解法3： Union Find"></a>解法3： Union Find</h3><p>Union Find的算法就不详述了。Union Find很适合来解决Graph找circle的问题。 这里的思路是如果两个node同属于一个parent那么就有circle存在。<br>如果不属于同一个parent，那么就把他们union起来成为一个group.<br>要注意的是最后如果没有出现circle，要比较一下是否每一个node都连接起来了，用edges.length == n - 1就可以判断<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validTree</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="keyword">int</span>[] parents = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        Arrays.fill(parents, -<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge: edges) &#123;</div><div class="line">            <span class="keyword">int</span> x = find(parents, edge[<span class="number">0</span>]);</div><div class="line">            <span class="keyword">int</span> y = find(parents, edge[<span class="number">1</span>]);</div><div class="line">            <span class="keyword">if</span> (x == y) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            parents[x] = y;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> edges.length == n - <span class="number">1</span>;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] parents, <span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (parents[x] != -<span class="number">1</span>) x = parents[x];</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode solution: Reconstruct Itinerary (332)]]></title>
      <url>/2017/03/05/2017-03-05-leetcode-solution-Reconstruct-Itinerary-332/</url>
      <content type="html"><![CDATA[<p>Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.</p>
<p>Note:<br>If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [“JFK”, “LGA”] has a smaller lexical order than [“JFK”, “LGB”].<br>All airports are represented by three capital letters (IATA code).<br>You may assume all tickets form at least one valid itinerary.<br>Example 1:<br>tickets = [[“MUC”, “LHR”], [“JFK”, “MUC”], [“SFO”, “SJC”], [“LHR”, “SFO”]]<br>Return [“JFK”, “MUC”, “LHR”, “SFO”, “SJC”].<br>Example 2:<br>tickets = [[“JFK”,”SFO”],[“JFK”,”ATL”],[“SFO”,”ATL”],[“ATL”,”JFK”],[“ATL”,”SFO”]]<br>Return [“JFK”,”ATL”,”JFK”,”SFO”,”ATL”,”SFO”].<br>Another possible reconstruction is [“JFK”,”SFO”,”ATL”,”JFK”,”ATL”,”SFO”]. But it is larger in lexical order.</p>
<h3 id="解法1：建图-DFS"><a href="#解法1：建图-DFS" class="headerlink" title="解法1：建图 + DFS"></a>解法1：建图 + DFS</h3><p>首先是建图的思想，这题看起来就要用DFS，可是没有图可以操作，对于这类的问题要想到用一个Hashmap来构造图的边的关系。<br>这里有一个小的trick是用到了PriorityQueue， 因为最后的结果是要排序后较小的，那么我们构建hashmap的时候就要把每一个start对应的destination排好序，我们就可以用PQ来存储。<br>而题目有一个隐含的条件就是一定有解，那么如果我们在搜索碰到一个没有对应destination的城市的时候，他一定是要求的最后一个string。<br>所以我们在写DFS的时候，要把res.add(cur)放在while语句之后。</p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(String[][] tickets)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="comment">// Construct the graph, using HashMap</span></div><div class="line">        HashMap&lt;String, PriorityQueue&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String, PriorityQueue&lt;String&gt;&gt;();</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (String[] pair: tickets) &#123;</div><div class="line">            <span class="keyword">if</span> (map.containsKey(pair[<span class="number">0</span>])) &#123;</div><div class="line">                map.get(pair[<span class="number">0</span>]).add(pair[<span class="number">1</span>]);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                map.put(pair[<span class="number">0</span>], <span class="keyword">new</span> PriorityQueue&lt;String&gt;());</div><div class="line">                map.get(pair[<span class="number">0</span>]).add(pair[<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// DFS the map and construct the itinerary</span></div><div class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        dfs(map, <span class="string">"JFK"</span>, res);</div><div class="line">        Collections.reverse(res);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(HashMap&lt;String, PriorityQueue&lt;String&gt;&gt; map, String cur, List&lt;String&gt; res)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (map.containsKey(cur) &amp;&amp; !map.get(cur).isEmpty()) &#123;</div><div class="line">            dfs(map, map.get(cur).poll(), res);</div><div class="line">        &#125;</div><div class="line">        res.add(cur);</div><div class="line"></div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> PriorityQueue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Find Bottom Left Tree Value (513)]]></title>
      <url>/2017/03/05/2017-03-05-leetcode-solution-Find-Bottom-Left-Tree-Value-513/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, find the leftmost value in the last row of the tree.</p>
<p>Example 1:<br>Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  2</div><div class="line"> / \</div><div class="line">1   3</div></pre></td></tr></table></figure></p>
<p>Output:<br>1<br>Example 2:<br>Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    1</div><div class="line">   / \</div><div class="line">  2   3</div><div class="line"> /   / \</div><div class="line">4   5   6</div><div class="line">   /</div><div class="line">  7</div></pre></td></tr></table></figure></p>
<p>Output:<br>7<br>Note: You may assume the tree (i.e., the given root node) is not NULL.</p>
<h3 id="解法1：DFS-O-N"><a href="#解法1：DFS-O-N" class="headerlink" title="解法1：DFS, O(N)"></a>解法1：DFS, O(N)</h3><p>这题code写起来很简单，思路是这样的：每到一层第一个扫描到的可能就是我们要找的node。那么不断的更新这个node的值最后当遍历完这个树之后就可以得到答案了。<br>DFS遍历的时候维护一个全局变量maxdepth， 然后每下一层就更新一下当前的depth，如果depth比maxdepth大，说明当前到达的是一个新层，而且访问的一定是这一层的最左的元素。<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> maxDepth = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        </div><div class="line">        dfs(root, <span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> val;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (depth &gt; maxDepth) &#123;</div><div class="line">            maxDepth = depth;</div><div class="line">            val = root.val;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</div><div class="line">            dfs(root.left, depth + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</div><div class="line">            dfs(root.right, depth + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode solution: The Maze (490)]]></title>
      <url>/2017/03/05/2017-03-05-leetcode-solution-The-Maze-490/</url>
      <content type="html"><![CDATA[<p>There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won’t stop rolling until hitting a wall. When the ball stops, it could choose the next direction.</p>
<p>Given the ball’s start position, the destination and the maze, determine whether the ball could stop at the destination.</p>
<p>The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.</p>
<p>Example 1</p>
<p>Input 1: a maze represented by a 2D array<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0 0 1 0 0</div><div class="line">0 0 0 0 0</div><div class="line">0 0 0 1 0</div><div class="line">1 1 0 1 1</div><div class="line">0 0 0 0 0</div></pre></td></tr></table></figure></p>
<p>Input 2: start coordinate (rowStart, colStart) = (0, 4)<br>Input 3: destination coordinate (rowDest, colDest) = (4, 4)<br><img src="https://leetcode.com/static/images/problemset/maze_1_example_1.png" alt="alt text"><br>Output: true<br>Explanation: One possible way is : left -&gt; down -&gt; left -&gt; down -&gt; right -&gt; down -&gt; right.</p>
<p>Example 2</p>
<p>Input 1: a maze represented by a 2D array<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0 0 1 0 0</div><div class="line">0 0 0 0 0</div><div class="line">0 0 0 1 0</div><div class="line">1 1 0 1 1</div><div class="line">0 0 0 0 0</div></pre></td></tr></table></figure></p>
<p>Input 2: start coordinate (rowStart, colStart) = (0, 4)<br>Input 3: destination coordinate (rowDest, colDest) = (3, 2)<br><img src="https://leetcode.com/static/images/problemset/maze_1_example_2.png" alt="alt text"><br>Output: false<br>Explanation: There is no way for the ball to stop at the destination.</p>
<p>Note:<br>There is only one ball and one destination in the maze.<br>Both the ball and the destination exist on an empty space, and they will not be at the same position initially.<br>The given maze does not contain border (like the red rectangle in the example pictures), but you could assume the border of the maze are all walls.<br>The maze contains at least 2 empty spaces, and both the width and height of the maze won’t exceed 100.</p>
<h3 id="解法1：DFS-Memorization"><a href="#解法1：DFS-Memorization" class="headerlink" title="解法1：DFS + Memorization"></a>解法1：DFS + Memorization</h3><p>这题和一般的地图题或者是有一题岛屿的题目类似，都可以用DFS来解决。这里的难点或者是区别在，球会一直往一个方向滚直到撞到了墙。所以在设计dfs程序的时候要考虑这个问题，可以用一个while循环解决。另外，对于已经访问过的点，不需要额外的申请一个空间来存储，只需要把已经访问过的node对应的maze的值设为-1就可。<br>对于dfs的优化呢，可以用一个dp矩阵来记录每一个扫描过的初始节点是否有解来剪掉一些枝</p>
<p>Java<br>
public class Solution {
    public boolean hasPath(int[][] maze, int[] start, int[] destination) {
        
        if (maze.length == 0 || maze[0].length == 0) {
            return true;
        }
        
        int[][] dp = new int[maze.length][maze[0].length];
        for (int[] row: dp) {
            Arrays.fill(row, -1);
        }
        return dfs(maze, start[0], start[1], destination, dp);
        
    }
    
    private boolean dfs(int[][] maze, int i, int j, int[] destination, int[][] dp) {
        if (i == destination[0] && j == destination[1]) {
            return true;
        }
        
        if (dp[i][j]!= -1) {
            return dp[i][j] == 1 ? true: false;
        }
        boolean res = false;
        int[][] directions = {{0,-1},{-1,0},{0,1},{1,0}};
        maze[i][j] = -1;  
        for (int[] dir: directions) {
            int x = i, y = j;
            int xinc = dir[0];
            int yinc = dir[1];
            while (x >= 0 && x < maze.length && y >= 0 && y < maze[0].length && maze[x][y] != 1) {
                x += xinc;
                y += yinc;
            }
            x -= xinc;
            y -= yinc;
            if (maze[x][y] != -1) {
                res = res || dfs(maze, x,y, destination, dp);
            }
        }
        
        dp[i][j] = res? 1: 0;
        maze[i][j] = 0;
        return res;
    }

}
</p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Clone Graph (133)]]></title>
      <url>/2017/03/05/2017-03-05-leetcode-solution-Clone-Graph-133/</url>
      <content type="html"><![CDATA[<p>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.</p>
<p>OJ’s undirected graph serialization:<br>Nodes are labeled uniquely.</p>
<p>We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.<br>As an example, consider the serialized graph {0,1,2#1,2#2,2}.</p>
<p>The graph has a total of three nodes, and therefore contains three parts as separated by #.</p>
<p>First node is labeled as 0. Connect node 0 to both nodes 1 and 2.<br>Second node is labeled as 1. Connect node 1 to node 2.<br>Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.<br>Visually, the graph looks like the following:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">   1</div><div class="line">  / \</div><div class="line"> /   \</div><div class="line">0 --- 2</div><div class="line">     / \</div><div class="line">     \_/</div></pre></td></tr></table></figure></p>
<h3 id="解法1：HashMap-DFS-O-N-Time-O-N-Space"><a href="#解法1：HashMap-DFS-O-N-Time-O-N-Space" class="headerlink" title="解法1：HashMap + DFS, O(N) Time + O(N) Space"></a>解法1：HashMap + DFS, O(N) Time + O(N) Space</h3><p>思路和有一题linkedlist有random pointer的一样，要分两步进行，一个是要遍历整个图（可选dfs或者bfs），另外要用一个hashmap来记录node和node之间的对应关系。</p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for undirected graph.</span></div><div class="line"><span class="comment"> * class UndirectedGraphNode &#123;</span></div><div class="line"><span class="comment"> *     int label;</span></div><div class="line"><span class="comment"> *     List&lt;UndirectedGraphNode&gt; neighbors;</span></div><div class="line"><span class="comment"> *     UndirectedGraphNode(int x) &#123; label = x; neighbors = new ArrayList&lt;UndirectedGraphNode&gt;(); &#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map = <span class="keyword">new</span> HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt;();</div><div class="line">        dfs(node, map);</div><div class="line">        <span class="keyword">for</span> (UndirectedGraphNode old: map.keySet()) &#123;</div><div class="line">            <span class="keyword">if</span> (node.neighbors != <span class="keyword">null</span>) &#123;</div><div class="line">                List&lt;UndirectedGraphNode&gt; ns = <span class="keyword">new</span> ArrayList&lt;UndirectedGraphNode&gt;();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; old.neighbors.size(); ++i) &#123;</div><div class="line">                    ns.add(map.get(old.neighbors.get(i)));</div><div class="line">                &#125;</div><div class="line">                map.get(old).neighbors = ns;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> map.get(node);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(UndirectedGraphNode node, HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!map.containsKey(node)) &#123;</div><div class="line">            <span class="comment">// Delay the assignment of neighbors</span></div><div class="line">            UndirectedGraphNode cloned = <span class="keyword">new</span> UndirectedGraphNode(node.label);</div><div class="line">            map.put(node, cloned);</div><div class="line">            <span class="keyword">if</span> (node.neighbors!= <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node.neighbors.size(); ++i) &#123;</div><div class="line">                    dfs(node.neighbors.get(i), map);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Partition Equal Subset Sum (416)]]></title>
      <url>/2017/02/20/2017-02-20-leetcode-solution-Partition-Equal-Subset-Sum-416/</url>
      <content type="html"><![CDATA[<p>Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>
<p>Note:<br>Each of the array element will not exceed 100.<br>The array size will not exceed 200.<br>Example 1:</p>
<p>Input: [1, 5, 11, 5]</p>
<p>Output: true</p>
<p>Explanation: The array can be partitioned as [1, 5, 5] and [11].<br>Example 2:</p>
<p>Input: [1, 2, 3, 5]</p>
<p>Output: false</p>
<p>Explanation: The array cannot be partitioned into equal sum subsets.</p>
<h3 id="解法1：DP-O-N-M-M是要找的子数组的和的大小。"><a href="#解法1：DP-O-N-M-M是要找的子数组的和的大小。" class="headerlink" title="解法1：DP: O(N*M), M是要找的子数组的和的大小。"></a>解法1：DP: O(N*M), M是要找的子数组的和的大小。</h3><p>这题参考了<a href="http://www.cnblogs.com/grandyang/p/5951422.html" target="_blank" rel="external">这个</a>的解法， 这一类的dp的题目里，dp[i]的数组的下标往往表示的是能取得值。<br>这里呢，首先想到要能分成两个同等大小的数组，原数组的和一定必须是偶数，而且这样的话每一个子数组的和是sum/2<br>有了这个之后，dp[i]的定义就变成了原数组是否有一个子数组他的和是i。<br>进一步，我们可以遍历整个数组，对于每一个数x，我们从target开始往下update， dp[x] = dp[x] || dp[target - x]<br>就是说，如果dp[x]要存在的话，dp[target - x]一定也存在。</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums.size() &lt;= <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>); </div><div class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(target + <span class="number">1</span>, <span class="literal">false</span>);</div><div class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= nums[i]; --j) &#123;</div><div class="line">                dp[j] = dp[j] || dp[j - nums[i]];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[target];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode解题: Range Sum Query 2D - Immutable]]></title>
      <url>/2017/02/20/2017-02-20-Leetcode-solution-Range-Sum-Query-2D-Immutable/</url>
      <content type="html"><![CDATA[<p>Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).</p>
<p><img src="https://leetcode.com/static/images/courses/range_sum_query_2d.png" alt="alt text" title="Logo Title Text 1"><br>The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.</p>
<p>Example:<br>Given matrix = [<br>  [3, 0, 1, 4, 2],<br>  [5, 6, 3, 2, 1],<br>  [1, 2, 0, 1, 5],<br>  [4, 1, 0, 1, 7],<br>  [1, 0, 3, 0, 5]<br>]</p>
<p>sumRegion(2, 1, 4, 3) -&gt; 8<br>sumRegion(1, 1, 2, 2) -&gt; 11<br>sumRegion(1, 2, 2, 4) -&gt; 12<br>Note:<br>You may assume that the matrix does not change.<br>There are many calls to sumRegion function.<br>You may assume that row1 ≤ row2 and col1 ≤ col2.</p>
<h3 id="解法1：DP-O-N-2-Initialization-O-1-Function-Call"><a href="#解法1：DP-O-N-2-Initialization-O-1-Function-Call" class="headerlink" title="解法1：DP: O(N^2) Initialization, O(1) Function Call"></a>解法1：DP: O(N^2) Initialization, O(1) Function Call</h3><p>这题不难，题目意思是里面的程序会要call很多次。如果不做优化的话每次的成本都是O(N^2).<br>如果我们先预处理一下，把每一个点的累计和存储一下，就是说dp[i][j]是从[0][0]到[i][j]的和。<br>那么当要计算子矩阵的和的时候，我们可以得到如下的关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sum[i][j] = dp[i][j] - dp[i][j-1] - dp[i-1][j] + dp[i-1][j-1]</div></pre></td></tr></table></figure></p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    NumMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix) &#123;</div><div class="line">        <span class="comment">// initialize dp</span></div><div class="line">        dp = matrix;    <span class="comment">// copy assignment operator</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); ++i) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].size(); ++j) &#123;</div><div class="line">                dp[i][j] = (i == <span class="number">0</span>?<span class="number">0</span>: dp[i - <span class="number">1</span>][j]) + (j == <span class="number">0</span>?<span class="number">0</span>:dp[i][j - <span class="number">1</span>]) </div><div class="line">                - (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>?dp[i <span class="number">-1</span>][j - <span class="number">1</span>]: <span class="number">0</span>) + matrix[i][j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> dp[row2][col2] - (row1 &gt; <span class="number">0</span>? dp[row1 - <span class="number">1</span>][col2]: <span class="number">0</span>) - (col1 &gt; <span class="number">0</span> ? dp[row2][col1 - <span class="number">1</span>]: <span class="number">0</span>) + (row1 &gt; <span class="number">0</span> &amp;&amp; col1 &gt;<span class="number">0</span> ? dp[row1 - <span class="number">1</span>][col1 - <span class="number">1</span>]: <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Your NumMatrix object will be instantiated and called as such:</span></div><div class="line"><span class="comment"> * NumMatrix obj = new NumMatrix(matrix);</span></div><div class="line"><span class="comment"> * int param_1 = obj.sumRegion(row1,col1,row2,col2);</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode解题: Best time to buy and sell stock with cooldown (309)]]></title>
      <url>/2017/02/19/2017-02-19-Leetcode-solution-Best-time-to-buy-and-sell-stock-with-cooldown-309/</url>
      <content type="html"><![CDATA[<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p>
<p>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).<br>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)<br>Example:</p>
<p>prices = [1, 2, 3, 0, 2]<br>maxProfit = 3<br>transactions = [buy, sell, cooldown, buy, sell]</p>
<h3 id="解法1：DP-O-N-Time-O-N-Space"><a href="#解法1：DP-O-N-Time-O-N-Space" class="headerlink" title="解法1：DP O(N) Time + O(N) Space"></a>解法1：DP O(N) Time + O(N) Space</h3><p>这题主要要想到用两个数组来记录每一天的两种状态。一个是第i天持有股票，一个是第i天未持有股票。<br>用sell和buy代表两个数组。buy就是第i天持有股票的投资组合的最大市值。sell就是第i天未持有股票时的投资组合的最大市值。<br>那么初始状态sell[0] = 0, buy[0] = -prices[0]这是表示如果第一天持有股票的话一定是买入操作，那么需要花去prices[0]的钱。<br>那么每一天投资组合的演化可以得出下面的关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">第i天未持股的最大市值要么是上一天1）持股2）未持股。</div><div class="line">如果未持股则市值不变，如果持股那么因为第i天一定要卖掉，</div><div class="line">所以如果上一天持股的话则今天的最大市值只能是buy[i-1]+Prices[i]</div><div class="line">sell[i] = max(sell[i - 1], buy[i - 1] + prices[i])</div><div class="line">同理，</div><div class="line">buy[i] = max(buy[i - 1], sell[i - 2] - prices[i])</div></pre></td></tr></table></figure></p>
<p>依此写出如下程序，如果要求的话可以对空间进一步优化成O(1)<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (prices.size() &lt;= <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> n = prices.size();</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sell(n, <span class="number">0</span>);</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; buy(n, <span class="number">0</span>);</div><div class="line">        </div><div class="line">        buy[<span class="number">0</span>] = -prices[<span class="number">0</span>];</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</div><div class="line">            sell[i] = max(sell[i - <span class="number">1</span>], buy[i - <span class="number">1</span>] + prices[i]);</div><div class="line">            buy[i] = max(buy[i - <span class="number">1</span>], (i &gt; <span class="number">1</span>? sell[i - <span class="number">2</span>]:<span class="number">0</span>) - prices[i]);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> sell[n - <span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Longest Palindromic Subsequence (516)]]></title>
      <url>/2017/02/16/2017-02-16-leetcode-solution-Longest-Palindromic-Subsequence-516/</url>
      <content type="html"><![CDATA[<p>Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000.</p>
<p>Example 1:<br>Input:</p>
<p><code>&quot;bbbab&quot;
Output:</code>4<br>One possible longest palindromic subsequence is “bbbb”.<br>Example 2:<br>Input:</p>
<p><code>&quot;cbbd&quot;
Output:</code>2<br>One possible longest palindromic subsequence is “bb”</p>
<h3 id="解法1：DP-O-N-2"><a href="#解法1：DP-O-N-2" class="headerlink" title="解法1：DP: O(N^2)"></a>解法1：DP: O(N^2)</h3><p>字符串的问题的DP有的时候需要考虑2D的DP解法。这题就是一个列子。<br>假设dp[i][j]是指(i,j)的子字符串的LPS, 那么如果首尾字符相同的话<br>dp[i][j] = dp[i + 1][j - 1] + 2<br>如果不相同的话，可以是错位match，也就是说要么用上尾字符，要么用上头字符。<br>dp[i][j] = max(dp[i+1][j], dp[i][j-1])</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (s.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> n = s.size() - <span class="number">1</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> dp[n + <span class="number">1</span>][n + <span class="number">1</span>] &#123;<span class="number">0</span>&#125;;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</div><div class="line">            dp[i][i] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</div><div class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</div><div class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    dp[i][j] = max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Coin Change (322)]]></title>
      <url>/2017/02/16/2017-02-16-leetcode-solution-Coin-Change-322/</url>
      <content type="html"><![CDATA[<p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p>
<p>Example 1:<br>coins = [1, 2, 5], amount = 11<br>return 3 (11 = 5 + 5 + 1)</p>
<p>Example 2:<br>coins = [2], amount = 3<br>return -1.</p>
<p>Note:<br>You may assume that you have an infinite number of each kind of coin.</p>
<h3 id="解法1：DP-O-N-M-N-是coin的个数，M是amount的数字"><a href="#解法1：DP-O-N-M-N-是coin的个数，M是amount的数字" class="headerlink" title="解法1：DP, O(N*M), N 是coin的个数，M是amount的数字"></a>解法1：DP, O(N*M), N 是coin的个数，M是amount的数字</h3><p>用DP来解，因为涉及到了“检验某一种步骤是否可行”。基本思路是假设dp[i]代表的是$i所需要的最少的coins的数目。<br>因为我们的coins的面额是已知的。那么对每一个coins的面额j<br>我们可以有如下的关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dp[i + coins[j]] = min(dp[i] + 1, dp[i + coins[j]])</div></pre></td></tr></table></figure></p>
<p>因为dp[i]已知，那么最多的coins就能确定是dp[i] + 1, 直接用下一个可用的coin即可。<br>然后对于coins的array和从1到i循环，不停的更新dp[i], dp[amount]就是我们要求的数值。<br>要注意的是，在更新一个dp[i‘]的时候， 要保证dp[i]已知（！=INT_MAX)而且下标不要超界，还有coins[j]也不要超过INT_MAX (不会overflow)<br>可以用coins[j] &lt;= INT_MAX - i<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(amount + <span class="number">1</span>, INT_MAX);</div><div class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// initialize the first data point</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= amount; ++i) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.size(); ++j) &#123;</div><div class="line">                <span class="keyword">if</span> (coins[j] != INT_MAX &amp;&amp; i + coins[j] &lt;= amount &amp;&amp; dp[i] != INT_MAX) &#123;</div><div class="line">                    dp[i + coins[j]] = min(dp[i] + <span class="number">1</span>, dp[i + coins[j]]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[amount] == INT_MAX ? <span class="number">-1</span>: dp[amount];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Counting Bits (338)]]></title>
      <url>/2017/02/16/2017-02-16-leetcode-solution-Counting-Bits-338/</url>
      <content type="html"><![CDATA[<p>Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.</p>
<p>Example:<br>For num = 5 you should return [0,1,1,2,1,2].</p>
<p>Follow up:</p>
<p>It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?<br>Space complexity should be O(n).<br>Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.<br>Hint:</p>
<p>You should make use of what you have produced already.<br>Divide the numbers in ranges like [2-3], [4-7], [8-15] and so on. And try to generate new range from previous.<br>Or does the odd/even status of the number help you in calculating the number of 1s?</p>
<h3 id="解法1：找规律，-O（N）"><a href="#解法1：找规律，-O（N）" class="headerlink" title="解法1：找规律， O（N）"></a>解法1：找规律， O（N）</h3><p>本题比较简单的解法也是从找规律而来<br>0 -&gt; 0<br>1 -&gt; 1<br>2 -&gt; 10 -&gt; 1<br>3 -&gt; 11 -&gt; 2<br>4 -&gt; 100 -&gt; 1<br>5 -&gt; 101 -&gt; 2<br>对于偶数i，他的1的个数是i/2的1的个数<br>杜宇奇数i，他的1的个数是i/的1的个数+1</p>
<p>因为对于一个数除以2的操作就是一个右移操作，而偶数的最低位为0，奇数的最低位为1， 那么右移的时候偶数的1的个数不会变，奇数的1的个数会减少1. 由此写出程序。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> num) &#123;</div><div class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>&#125;;</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= num; ++i) &#123;</div><div class="line">			<span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">				res.push_back(res[i/<span class="number">2</span>]);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				res.push_back(res[i/<span class="number">2</span>] + <span class="number">1</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Integer Break (343)]]></title>
      <url>/2017/02/16/2017-02-16-leetcode-solution-Integer-Break-343/</url>
      <content type="html"><![CDATA[<p>Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.</p>
<p>For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).</p>
<p>Note: You may assume that n is not less than 2 and not larger than 58.</p>
<p>Hint:</p>
<p>There is a simple O(n) solution to this problem.<br>You may check the breaking results of n ranging from 7 to 10 to discover the regularities.</p>
<h3 id="解法1：找规律，-O-N"><a href="#解法1：找规律，-O-N" class="headerlink" title="解法1：找规律， O(N)"></a>解法1：找规律， O(N)</h3><p>如果把从2到10的结果写出来可以发现，最大的结果是每一个数先分解成3的和，然后和剩下的数的乘积最大。本题还有DP的解法，之后补上</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">2</span> || n == <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (n &gt; <span class="number">4</span>) &#123;</div><div class="line">            res *= <span class="number">3</span>;</div><div class="line">            n -= <span class="number">3</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res * n;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Search Insert Position (35)]]></title>
      <url>/2017/02/16/2017-02-16-leetcode-solution-Search-Insert-Position-35/</url>
      <content type="html"><![CDATA[<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<p>Here are few examples.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[1,3,5,6], 5 → 2</div><div class="line">[1,3,5,6], 2 → 1</div><div class="line">[1,3,5,6], 7 → 4</div><div class="line">[1,3,5,6], 0 → 0</div></pre></td></tr></table></figure></p>
<h3 id="解法1：Binary-Search-O-NLogn"><a href="#解法1：Binary-Search-O-NLogn" class="headerlink" title="解法1：Binary Search O(NLogn)"></a>解法1：Binary Search O(NLogn)</h3><p>因为是sorted， 用binary search很容易解决。要注意的是最后判断nums[start], nums[end]的时候如果都没有符合的，那么说明要插入的位置是array的尾巴，要返回的结果是end+1， 比如<br><code>searchInsert([0],1)</code>这样的情况。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> start = <span class="number">0</span>, end = nums.size() <span class="number">-1</span>;</div><div class="line">		<span class="keyword">while</span> (start + <span class="number">1</span> &lt; end) &#123;</div><div class="line">			<span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</div><div class="line">			<span class="keyword">if</span> (nums[mid] &gt; target) &#123;</div><div class="line">				end = mid;</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				start = mid;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (nums[start] &gt;= target) &#123;</div><div class="line">			<span class="keyword">return</span> start;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (nums[end] &gt;= target) &#123;</div><div class="line">			<span class="keyword">return</span> end;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> end + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Find Minimum in Rotated Sorted Array (153)]]></title>
      <url>/2017/02/16/2017-02-16-leetcode-solution-Find-Minimum-in-Rotated-Sorted-Array-153/</url>
      <content type="html"><![CDATA[<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
<h3 id="解法1：Binary-Search"><a href="#解法1：Binary-Search" class="headerlink" title="解法1：Binary Search"></a>解法1：Binary Search</h3><p>这也是一题经典的binary search的题目。 难点在于怎么判断最小值是在mid的左面还是右面，以此来缩小范围。<br>当搜索的范围[start, end]确定了之后，mid的取值可以有几种情况</p>
<ul>
<li>start &lt; end, 那么最小值在start和mid之间</li>
<li>start &gt; end, 那么最小值的位置取决于mid和start，end的关系<ul>
<li>如果mid &lt; end, 那么最小值一定在start和mid之间</li>
<li>如果mid &gt; end, 那么pivot点一定在mid和end之间。<br>按照这个思路写程序就很简单了。<br>C++<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> start = <span class="number">0</span>, end = nums.size() - <span class="number">1</span>;</div><div class="line">		<span class="keyword">while</span> (start + <span class="number">1</span> &lt; end) &#123;</div><div class="line">			<span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</div><div class="line">			<span class="keyword">if</span> (nums[start] &lt; nums[end]) &#123;</div><div class="line">				end = mid;</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">if</span> (nums[mid] &lt; nums[end]) &#123;</div><div class="line">					end = mid;</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					start = mid;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (nums[start] &lt; nums[end]) &#123;</div><div class="line">			<span class="keyword">return</span> nums[start];</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> nums[end];</div><div class="line">		&#125; </div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解法: Search for a Range (34)]]></title>
      <url>/2017/02/16/2017-02-16-leetcode-solution-Search-for-a-Range-34/</url>
      <content type="html"><![CDATA[<p>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.</p>
<p>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
<p>If the target is not found in the array, return [-1, -1].</p>
<p>For example,<br>Given [5, 7, 7, 8, 8, 10] and target value 8,<br>return [3, 4].</p>
<h3 id="解法1：Binary-Search-O-logN"><a href="#解法1：Binary-Search-O-logN" class="headerlink" title="解法1：Binary Search, O(logN)"></a>解法1：Binary Search, O(logN)</h3><p>看到在sorted array里找元素的问题，首先想到可以用binary search。 这里用两次binarysearch， 一次找到range的起始点，一次找到最后一个点。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</div><div class="line">		<span class="keyword">int</span> start = searchFirst(nums, target);</div><div class="line">		<span class="keyword">int</span> end = searchLast(nums, target);</div><div class="line">		<span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;start, end&#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">searchFirst</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> start = <span class="number">0</span>, end = nums.size() - <span class="number">1</span>;</div><div class="line">		<span class="keyword">while</span> (start + <span class="number">1</span> &lt; end) &#123;</div><div class="line">			<span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</div><div class="line">			<span class="keyword">if</span> (nums[mid] &lt; target) &#123;</div><div class="line">				start = mid;</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				end = mid;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (nums[start] == target) &#123;</div><div class="line">			<span class="keyword">return</span> start;</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[end] == target) &#123;</div><div class="line">			<span class="keyword">return</span> end;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">searchLast</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.size() - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end) &#123;</div><div class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</div><div class="line">                start = mid;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (nums[end] == target) &#123;</div><div class="line">            <span class="keyword">return</span> end;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[start] == target) &#123;</div><div class="line">            <span class="keyword">return</span> start;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Sort Colors (75)]]></title>
      <url>/2017/02/09/2017-02-09-leetcode-solution-Sort-Colors-75/</url>
      <content type="html"><![CDATA[<p>Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>
<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<p>Note:<br>You are not suppose to use the library’s sort function for this problem.</p>
<p>Follow up:<br>A rather straight forward solution is a two-pass algorithm using counting sort.<br>First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.</p>
<p>Could you come up with an one-pass algorithm using only constant space?</p>
<h3 id="解法1：-Bucket-sort-counting-sort-O-N-Time-with-two-passes"><a href="#解法1：-Bucket-sort-counting-sort-O-N-Time-with-two-passes" class="headerlink" title="解法1： Bucket sort/counting sort, O(N) Time with two passes"></a>解法1： Bucket sort/counting sort, O(N) Time with two passes</h3><p>Bucket sort, 统计0,1,2的个数然后再逐个写入<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="comment">// bucket sort</span></div><div class="line">        <span class="keyword">int</span> red = <span class="number">0</span>, white = <span class="number">0</span>, blue = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</div><div class="line">                red++;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</div><div class="line">                white++;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                blue++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= red; j++) &#123;</div><div class="line">            nums[i++] = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= white; j++) &#123;</div><div class="line">            nums[i++] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= blue; j++) &#123;</div><div class="line">            nums[i++] = <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法2：-One-pass-O-N"><a href="#解法2：-One-pass-O-N" class="headerlink" title="解法2： One pass O(N)"></a>解法2： One pass O(N)</h3><p>类似于双指针的思路,这里用了一个low记录0的位置,用了一个high记录2的位置,然后从左往右扫描. 如果是0或者2就知道该插入在什么地方,如果是1那么就往前移动.<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums.size() &lt;= <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size() <span class="number">-1</span>;</div><div class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (mid &lt; nums.size() &amp;&amp; mid &lt;= high) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[mid] == <span class="number">0</span>) &#123;</div><div class="line">                swap(nums, low, mid);</div><div class="line">                ++low;</div><div class="line">                ++mid;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == <span class="number">2</span>) &#123;</div><div class="line">                swap(nums, high, mid);</div><div class="line">                --high;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ++mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = nums[i];</div><div class="line">        nums[i] = nums[j];</div><div class="line">        nums[j] =temp;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>###解法3: One pass O(N) ###<br>用两个指针记录zero和one插入的位置。<br>对于每一个新数字，先插入最大的数字。因为如果是其他数字的话在之后的操作中会被覆盖。<br>然后从大到小的判断当前数字为哪一个。如果是1那么只移动one的位置并插入。<br>如果是zero，那么需要先移动one并且赋值，然后移动zero再赋值。如果zero插入的位置原本是一个1，那么被覆盖的1就被one的指针找回了。<br>Java<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> zero = <span class="number">-1</span>;</div><div class="line">        <span class="keyword">int</span> one = <span class="number">-1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; nums.length; ++k) &#123;</div><div class="line">            <span class="keyword">int</span> v = nums[k];</div><div class="line">            nums[k] = <span class="number">2</span>;    <span class="comment">// no matter what, set this to 2</span></div><div class="line">            <span class="keyword">if</span> (v == <span class="number">0</span>) &#123;</div><div class="line">                nums[++one] = <span class="number">1</span>;</div><div class="line">                nums[++zero] = <span class="number">0</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v == <span class="number">1</span>) &#123;</div><div class="line">                nums[++one] = <span class="number">1</span>;    <span class="comment">// advance one</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Jump Game (55)]]></title>
      <url>/2017/02/09/2017-02-09-leetcode-solution-Jump-Game-55/</url>
      <content type="html"><![CDATA[<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<p>For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A = [2,3,1,1,4], return true.</div><div class="line"></div><div class="line">A = [3,2,1,0,4], return false.</div></pre></td></tr></table></figure></p>
<h3 id="解法1：-Greedy-O-N-Time"><a href="#解法1：-Greedy-O-N-Time" class="headerlink" title="解法1： Greedy, O(N) Time"></a>解法1： Greedy, O(N) Time</h3><p>一个贪心的解法, 主要是维护一个variable叫reach, 他记录目前为止能达到的最远的距离. 然后扫描vector,如果当前的位置是不能达到的,则返回false.<br>否则更新reach的值,进入下一个元素.<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> reach = <span class="number">0</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (; i &lt; nums.size() &amp;&amp; reach &gt;= i; ++i) &#123;</div><div class="line">            reach = max(reach, i + nums[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> i == nums.size();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解法: Next Permutation (31)]]></title>
      <url>/2017/02/09/2017-02-09-leetcode-solution-Next-Permutation-31/</url>
      <content type="html"><![CDATA[<p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place, do not allocate extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1,2,3 → 1,3,2</div><div class="line">3,2,1 → 1,2,3</div><div class="line">1,1,5 → 1,5,1</div></pre></td></tr></table></figure></p>
<h3 id="解法1：-O-N-Time"><a href="#解法1：-O-N-Time" class="headerlink" title="解法1： O(N) Time"></a>解法1： O(N) Time</h3><p>一个固定的解法,可以写出来几个答案然后从当中找结论.<br>解法是:<br>从右往左找到第一个数字使得num[i] &lt; num[i + 1], 设i为pivot<br>从右往左找到第一个数字使得num[j] &gt; num[pivot], 记录j<br>将pivot和j指向的item互换<br>将pivot右边的数组reverse</p>
<p>要注意的是,在第二步中由于pviot右面的数组一定是sorted(从大到小), 所以我们在寻找第一个比pivot数字大的时候可以采用binary search来提供一些小的optimization.</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (nums.size() &lt;= <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> pivot = <span class="number">-1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &lt; nums[i]) &#123;</div><div class="line">                pivot = i - <span class="number">1</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (pivot == <span class="number">-1</span>) &#123;</div><div class="line">            <span class="built_in">std</span>::reverse(nums.begin(), nums.end());</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// find the first element that is larger than nums[pivot]</span></div><div class="line">        <span class="keyword">int</span> ex = bsearch(nums, pivot + <span class="number">1</span>, nums.size() - <span class="number">1</span>, nums[pivot]);</div><div class="line">        <span class="keyword">int</span> temp = nums[pivot];</div><div class="line">        nums[pivot] = nums[ex];</div><div class="line">        nums[ex] = temp;</div><div class="line">        </div><div class="line">        <span class="comment">// reverse ex + 1 ~ end</span></div><div class="line">        <span class="built_in">std</span>::reverse(nums.begin() + pivot + <span class="number">1</span>, nums.end());</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> ref)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end) &#123;</div><div class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> (nums[mid] &gt; ref) &#123;</div><div class="line">                start = mid;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (nums[end] &gt; ref) &#123;</div><div class="line">            <span class="keyword">return</span> end;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> start;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解法: Container With Most Water (11)]]></title>
      <url>/2017/02/09/2017-02-09-leetcode-solution-Container-With-Most-Water-11/</url>
      <content type="html"><![CDATA[<p>Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p>Note: You may not slant the container and n is at least 2.</p>
<h3 id="解法1：-Two-pointers-O-N-Time-One-pass"><a href="#解法1：-Two-pointers-O-N-Time-One-pass" class="headerlink" title="解法1： Two pointers, O(N) Time, One pass"></a>解法1： Two pointers, O(N) Time, One pass</h3><p>比较典型的two pointers的题目. 主要思路是, 一个container的面积是(right- left) * (左右两块挡板较短的那一块的长度)<br>那么要maximize一个面积,可以做的是增长距离,或者是增长板的长度.<br>设两个指针,从左右边界开始,这个时候,我们的长度是最长的.计算一下当前的面积<br>如果要提高这个面积, 因为只能缩小长度,则我们必须要提高短板的长度.<br>那么不停的移动左右指针(哪一根指针指向的板较短就移哪一根)<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> area = INT_MIN;</div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.size() - <span class="number">1</span>; </div><div class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</div><div class="line">            area = max(area, (right - left) * (min(height[left], height[right])));</div><div class="line">            <span class="keyword">if</span> (height[left] &lt;= height[right]) &#123;</div><div class="line">                ++left;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                --right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> area;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Verify Preorder Serialization of a Binary Tree (331)]]></title>
      <url>/2017/02/09/2017-02-09-leetcode-solution-Verify-Preorder-Serialization-of-a-Binary-Tree-331/</url>
      <content type="html"><![CDATA[<p>One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as #.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">     _9_</div><div class="line">    /   \</div><div class="line">   3     2</div><div class="line">  / \   / \</div><div class="line"> 4   1  #  6</div><div class="line">/ \ / \   / \</div><div class="line"># # # #   # #</div></pre></td></tr></table></figure></p>
<p>For example, the above binary tree can be serialized to the string “9,3,4,#,#,1,#,#,2,#,6,#,#”, where # represents a null node.</p>
<p>Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.</p>
<p>Each comma separated value in the string must be either an integer or a character ‘#’ representing null pointer.</p>
<p>You may assume that the input format is always valid, for example it could never contain two consecutive commas such as “1,,3”.</p>
<p>Example 1:<br><code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code><br>Return <code>true</code></p>
<p>Example 2:<br><code>&quot;1,#&quot;</code><br>Return <code>false</code></p>
<p>Example 3:<br><code>&quot;9,#,#,1&quot;</code><br>Return <code>false</code></p>
<h3 id="解法1：-剪叶子的思路"><a href="#解法1：-剪叶子的思路" class="headerlink" title="解法1： 剪叶子的思路"></a>解法1： 剪叶子的思路</h3><p>每当遇到两个连续的”#”的时候,并且前一个字符不是”#”的时候,可以判断这是一个叶子.如果我们把每一个叶子剪掉并且替换成”#”的话,我们实际上在不停的从下往上的砍叶子直到砍完为止.<br>这样的思路对于binary tree在其他题目中似乎也见过.那么对于一个valid的binary tree,最后一定是能砍光的. 以此可以得出如下的算法.<br><code>C++</code><br>注意的是这里用vector当成一个stack用,因为我们需要access前面的2个元素,用vector效率较高.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSerialization</span><span class="params">(<span class="built_in">string</span> preorder)</span> </span>&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="function"><span class="built_in">istringstream</span> <span class="title">ss</span><span class="params">(preorder)</span></span>;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; s;</div><div class="line">        <span class="built_in">string</span> item;</div><div class="line">        <span class="keyword">while</span> (getline(ss, item, <span class="string">','</span>)) &#123;</div><div class="line">            s.push_back(item);</div><div class="line">            <span class="keyword">while</span> (s.size() &gt;= <span class="number">3</span> &amp;&amp; item == <span class="string">"#"</span> &amp;&amp; s[s.size() - <span class="number">2</span>] == <span class="string">"#"</span> &amp;&amp; s[s.size() <span class="number">-3</span>] != <span class="string">"#"</span>) &#123;</div><div class="line">                s.pop_back();</div><div class="line">                s.pop_back();</div><div class="line">                s.pop_back();</div><div class="line">                s.push_back(item);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> s.size() == <span class="number">1</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">"#"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法2-outbound-inbound"><a href="#解法2-outbound-inbound" class="headerlink" title="解法2: outbound - inbound"></a>解法2: outbound - inbound</h3><p>这个解法的核心是. 首先把所有的NULL NODE看成是valid node. 每一个node的inbound/outbound的connection可以统计如下:</p>
<ol>
<li>每一个非NULL节点都有两个outbound和一个inbound (除了root)</li>
<li>每一个NULL节点都有一个inbound和0个outbound</li>
<li>一个valid的树如果计算所有的outbound和inbound的差,一定是等于0的,并且从root到任意一节点, outbound - inbound都一定不是负数.<br>有了这个结论之后, code写起来很直白.<br><code>C++</code><figure class="highlight plain"><figcaption><span>lang: cpp</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool isValidSerialization(string preorder) &#123;</div><div class="line">        std::istringstream ss(preorder);</div><div class="line">        string item;</div><div class="line">        int diff = 1;</div><div class="line">        while (getline(ss, item, &apos;,&apos;)) &#123;</div><div class="line">            if (--diff &lt; 0) return false;</div><div class="line">            if (item != &quot;#&quot;) diff += 2;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        return diff == 0;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: 132 Pattern (456)]]></title>
      <url>/2017/02/04/2017-02-04-leetcode-Solution-132-Pattern-456/</url>
      <content type="html"><![CDATA[<p>Given a sequence of n integers a1, a2, …, an, a 132 pattern is a subsequence ai, aj, ak such that i &lt; j &lt; k and ai &lt; ak &lt; aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.</p>
<p>Note: n will be less than 15,000.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Input: [1, 2, 3, 4]</div><div class="line"></div><div class="line">Output: False</div><div class="line"></div><div class="line">Explanation: There is no 132 pattern in the sequence.</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Input: [3, 1, 4, 2]</div><div class="line"></div><div class="line">Output: True</div><div class="line"></div><div class="line">Explanation: There is a 132 pattern in the sequence: [1, 4, 2].</div></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Input: [-1, 3, 2, 0]</div><div class="line"></div><div class="line">Output: True</div><div class="line"></div><div class="line">Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].</div></pre></td></tr></table></figure></p>
<h3 id="解法1：-O-N-Time"><a href="#解法1：-O-N-Time" class="headerlink" title="解法1： O(N) Time"></a>解法1： O(N) Time</h3><p>参考了<a href="https://discuss.leetcode.com/topic/67881/single-pass-c-o-n-space-and-time-solution-8-lines-with-detailed-explanation/2" target="_blank" rel="external">discussion</a>的解答, 基本思想是我们从后往前扫描. 用一个stack维护一个递增的序列, stack中的值则是s2的备选. 每当扫描一个新数时,先比较是否比s3小,如果比s3小则说明已找到答案.如果比s3大则更新s3和s2的值.<br>更新的时候: 把stack中所有比当前值小的数弹出, 每一个弹出的数都是s3的备选.<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> s3 = INT_MIN;</div><div class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s2;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i] &lt; s3) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;   </div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">while</span> (!s2.empty() &amp;&amp; s2.top() &lt; nums[i]) &#123;</div><div class="line">                s3 = s2.top(); s2.pop();</div><div class="line">            &#125;</div><div class="line">            s2.push(nums[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Remove K Digits (402)]]></title>
      <url>/2017/02/04/2017-02-04-leetcode-solution-Remove-K-Digits-402/</url>
      <content type="html"><![CDATA[<p>Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.</p>
<p>Note:<br>The length of num is less than 10002 and will be ≥ k.<br>The given num does not contain any leading zero.<br>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input: num = &quot;1432219&quot;, k = 3</div><div class="line">Output: &quot;1219&quot;</div><div class="line">Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input: num = &quot;10200&quot;, k = 1</div><div class="line">Output: &quot;200&quot;</div><div class="line">Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.</div></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input: num = &quot;10&quot;, k = 2</div><div class="line">Output: &quot;0&quot;</div><div class="line">Explanation: Remove all the digits from the number and it is left with nothing which is 0.</div></pre></td></tr></table></figure></p>
<h3 id="解法1：-贪心算法"><a href="#解法1：-贪心算法" class="headerlink" title="解法1： 贪心算法"></a>解法1： 贪心算法</h3><p>这题用贪心的算法, 观察可以发现如果每次remove的时候满足<code>if (num[i] &gt; num[i + 1])</code>, 那么得到的数一定是最小的.<br>这里可以用一个string来存储当前扫描的结果,如果发现现在的字符比string的最后一个字符小,那么就把string的最后一个字符去掉. (目的是维护一个递增的数列)<br>最后呢,我们只需要去前<code>num.size() - k</code>个数即可.要注意的是因为每次去除数字的时候k数会变,所以一开始需要用一个变量存储初值.<br>最后返回的时候要去掉leading zero.<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (k &gt;= num.size()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</div><div class="line">        <span class="keyword">int</span> n = k;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : num) &#123;</div><div class="line">            <span class="keyword">while</span> (!res.empty() &amp;&amp; res.back() &gt; ch &amp;&amp; k &gt; <span class="number">0</span>) &#123;</div><div class="line">                k--;</div><div class="line">                res.pop_back();</div><div class="line">            &#125;</div><div class="line">            res.push_back(ch);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (res[start] == <span class="string">'0'</span>) &#123;start++;&#125;</div><div class="line">        </div><div class="line">        <span class="comment">// Take first num.size() - k elements</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (start &gt;= res.size()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> res.substr(start, min(start + num.size() - n, res.size()));</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Stack </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Simplify Path (71)]]></title>
      <url>/2017/02/04/2017-02-04-leetcode-solution-Simplify-Path-71/</url>
      <content type="html"><![CDATA[<p>Total Accepted: 74685<br>Total Submissions: 309287<br>Difficulty: Medium<br>Contributors: Admin<br>Given an absolute path for a file (Unix-style), simplify it.</p>
<p>For example,<br>path = <code>&quot;/home/&quot;</code>, =&gt; <code>&quot;/home&quot;</code><br>path = <code>&quot;/a/./b/../../c/&quot;</code>, =&gt; <code>&quot;/c&quot;</code></p>
<p>Corner Cases:<br>Did you consider the case where path = <code>&quot;/../&quot;</code>?<br>In this case, you should return <code>&quot;/&quot;</code>.<br>Another corner case is the path might contain multiple slashes ‘/‘ together, such as <code>&quot;/home//foo/&quot;</code>.<br>In this case, you should ignore redundant slashes and return <code>&quot;/home/foo&quot;</code>.</p>
<h3 id="解法1：-Stack"><a href="#解法1：-Stack" class="headerlink" title="解法1： Stack"></a>解法1： Stack</h3><p>比较清楚的思路是, 用一个stack来存储每一级的path, 如果遇到”.”则跳过,如果遇到”..”表明要前进一级, 那就把当前的栈顶的path弹出<br>最后栈就是存放的reverse过的path,一个个把他们串起来就可以了.<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="built_in">string</span> <span class="title">simplifyPath</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; items;</div><div class="line">		<span class="built_in">string</span> item = <span class="string">""</span>;</div><div class="line">		<span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(path)</span></span>;</div><div class="line"></div><div class="line">		<span class="keyword">while</span>(getline(ss, item, <span class="string">'/'</span>)) &#123;</div><div class="line">			<span class="keyword">if</span> (item.size() == <span class="number">0</span> || item == <span class="string">"."</span>) &#123;</div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item == <span class="string">".."</span>) &#123;</div><div class="line">				<span class="keyword">if</span> (!items.empty()) &#123;</div><div class="line">					items.pop();</div><div class="line">				&#125;</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				items.push(item);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="built_in">string</span> res = <span class="string">""</span>;</div><div class="line">		<span class="keyword">while</span> (!items.empty()) &#123;</div><div class="line">			res += <span class="string">"/"</span> + items.top() + res;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> res.empty() ? <span class="string">"/"</span> : res;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Stack </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Decode String (394)]]></title>
      <url>/2017/02/04/2017-01-26-leetcode-solution-Decode-String-394/</url>
      <content type="html"><![CDATA[<p>Given an encoded string, return it’s decoded string.</p>
<p>The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.</p>
<p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p>
<p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like 3a or 2[4].</p>
<p>Examples:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s = &quot;3[a]2[bc]&quot;, return &quot;aaabcbc&quot;.</div><div class="line">s = &quot;3[a2[c]]&quot;, return &quot;accaccacc&quot;.</div><div class="line">s = &quot;2[abc]3[cd]ef&quot;, return &quot;abcabccdcdcdef&quot;.</div></pre></td></tr></table></figure></p>
<h3 id="解法1：-递归"><a href="#解法1：-递归" class="headerlink" title="解法1： 递归"></a>解法1： 递归</h3><p>主要的想法就是， 每一个数字后面一定跟着一个左括号。 而左括号里面的东西是另外一个decode的过程，一个decode结束的标志是要么string结束了，或者是遇到了右括号（[),<br>要注意的是,为了要不停的往前扫描,我们在递归函数返回的时候需要记录当前扫描到的位置. 可以用辅助class解决,在c++里也可以用引用解决这个问题.<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line">		<span class="built_in">string</span> res = decode(s, pos);</div><div class="line">		<span class="keyword">return</span> res;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="built_in">string</span> <span class="title">decode</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span>&amp; pos)</span> </span>&#123;</div><div class="line">		<span class="built_in">string</span> res = <span class="string">""</span>;</div><div class="line"></div><div class="line">		<span class="keyword">while</span> (pos &lt; s.size() &amp;&amp; s[pos] != <span class="string">']'</span>) &#123;</div><div class="line">			<span class="keyword">if</span> (!<span class="built_in">isdigit</span>(s[pos])) &#123;</div><div class="line">				res += s[pos];</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">int</span> start = pos;</div><div class="line">				<span class="keyword">while</span> (pos &lt; s.size() &amp;&amp; <span class="built_in">isdigit</span>(s[pos])) &#123;</div><div class="line">					pos++;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">int</span> number = stoi(s.substr(start, pos));</div><div class="line">				pos++;	<span class="comment">// skip the [</span></div><div class="line">				<span class="built_in">string</span> next = decode(s, pos);</div><div class="line">				pos++;	<span class="comment">// since decode stops at ] or at the end of string, we need to skip ]</span></div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; ++i) &#123;</div><div class="line">					res += next;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> res;</div><div class="line">	&#125;	 </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法2-Stack"><a href="#解法2-Stack" class="headerlink" title="解法2: Stack"></a>解法2: Stack</h3><p>用递归的算法如果要用iteration的办法解决一般会用到Stack. 基本的思路是用两个stack分别记录数字和字符, 当遇到”]”时使用当前栈顶的字母和数字来进行decode, 然后decode的结果要存入字母的栈顶.<br>最后的结果要么是当前的字符串, 要么是栈顶的字符串.<br>C++<br><figure class="highlight plain"><figcaption><span>lang: cpp</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">	string decodeString(string s) &#123;</div><div class="line"></div><div class="line">		stack&lt;int&gt; numbers;</div><div class="line">		stack&lt;string&gt; decoded;</div><div class="line"></div><div class="line">		string t;	// 记录在遇到&quot;[&quot;之前的string</div><div class="line">		int number = 0;	</div><div class="line"></div><div class="line">		for (int i = 0; i &lt; s.size(); ++i) &#123;</div><div class="line">			if (isdigit(s[i])) &#123;</div><div class="line">				number = number * 10 + s[i] - &apos;0&apos;;</div><div class="line">			&#125; else if (s[i] == &apos;[&apos;) &#123;</div><div class="line">				numbers.push(number);</div><div class="line">				number = 0;</div><div class="line">				decoded.push(t);	// 把当前所记录到的string存入栈中</div><div class="line">				t = &quot;&quot;;</div><div class="line">			&#125; else if (s[i] == &apos;]&apos;) &#123;</div><div class="line">				int rep = numbers.top();</div><div class="line">				numbers.pop();</div><div class="line">				for (int j = 0; j &lt; rep; ++j) &#123;</div><div class="line">					decoded.top() += t;	// t记录了当前扫描到还没有decode的string</div><div class="line">				&#125;</div><div class="line">				t = decoded.top();	</div><div class="line">				decoded.pop();	</div><div class="line">			&#125; else &#123;</div><div class="line">				t += s[i];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		return decoded.empty()? t : decoded.top();</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Stack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Mini Parser (385)]]></title>
      <url>/2017/01/26/2017-01-26-leetcode-solution-Mini-Parser-385/</url>
      <content type="html"><![CDATA[<p>Given a nested list of integers represented as a string, implement a parser to deserialize it.</p>
<p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p>
<p>Note: You may assume that the string is well-formed:</p>
<p>String is non-empty.<br>String does not contain white spaces.<br>String contains only digits 0-9, [, - ,, ].<br>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Given s = &quot;324&quot;,</div><div class="line"></div><div class="line">You should return a NestedInteger object which contains a single integer 324.</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Given s = &quot;[123,[456,[789]]]&quot;,</div><div class="line"></div><div class="line">Return a NestedInteger object containing a nested list with 2 elements:</div><div class="line"></div><div class="line">1. An integer containing value 123.</div><div class="line">2. A nested list containing two elements:</div><div class="line">    i.  An integer containing value 456.</div><div class="line">    ii. A nested list with one element:</div><div class="line">         a. An integer containing value 789.</div></pre></td></tr></table></figure></p>
<h3 id="解法1：-Iterative"><a href="#解法1：-Iterative" class="headerlink" title="解法1： Iterative"></a>解法1： Iterative</h3><p>这题自己写的stack版本怎么也过不了OJ， 参考了这篇<a href="http://www.cnblogs.com/grandyang/p/5771434.html" target="_blank" rel="external">帖子</a>的解法<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">NestedInteger <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> NestedInteger();</div><div class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] != <span class="string">'['</span>) <span class="keyword">return</span> NestedInteger(stoi(s));</div><div class="line">        <span class="built_in">stack</span>&lt;NestedInteger&gt; st;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'['</span>) &#123;</div><div class="line">                st.push(NestedInteger());</div><div class="line">                start = i + <span class="number">1</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">','</span> || s[i] == <span class="string">']'</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (i &gt; start) &#123;</div><div class="line">                    st.top().add(NestedInteger(stoi(s.substr(start, i - start))));</div><div class="line">                &#125;</div><div class="line">                start = i + <span class="number">1</span>;</div><div class="line">                <span class="keyword">if</span> (s[i] == <span class="string">']'</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (st.size() &gt; <span class="number">1</span>) &#123;</div><div class="line">                        NestedInteger t = st.top(); st.pop();</div><div class="line">                        st.top().add(t);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> st.top();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Stack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Flatten Nested List Iterator (341)]]></title>
      <url>/2017/01/23/2017-01-23-leetcode-solution-Flatten-Nested-List-Iterator-341/</url>
      <content type="html"><![CDATA[<p>Given a nested list of integers, implement an iterator to flatten it.</p>
<p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p>
<p>Example 1:<br>Given the list [[1,1],2,[1,1]],</p>
<p>By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].</p>
<p>Example 2:<br>Given the list [1,[4,[6]]],</p>
<p>By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].</p>
<h3 id="解法1：-Stack，-O-N-Time-O-N-Space-N-is-the-number-of-total-items"><a href="#解法1：-Stack，-O-N-Time-O-N-Space-N-is-the-number-of-total-items" class="headerlink" title="解法1： Stack， O(N) Time, O(N) Space, N is the number of total items"></a>解法1： Stack， O(N) Time, O(N) Space, N is the number of total items</h3><p>这题是用iteration的办法解决递归的问题，一般此类问题容易想到用stack解决。这题哪里可以用stack呢？每一个nestedInteger都可能是一个list of nestedInteger， 那么我们对于每一个元素，如果是单数，则任务完成，如果是一个list， 那么我们把所有的元素都推入栈中，直到第一个元素是单数或者到遍历结束为止。 由于栈是FILO, 所以每次推入的时候需要从后往前推。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></div><div class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></div><div class="line"><span class="comment"> * class NestedInteger &#123;</span></div><div class="line"><span class="comment"> *   public:</span></div><div class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></div><div class="line"><span class="comment"> *     bool isInteger() const;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></div><div class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></div><div class="line"><span class="comment"> *     int getInteger() const;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></div><div class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></div><div class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    NestedIterator(<span class="built_in">vector</span>&lt;NestedInteger&gt; &amp;nestedList) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nestedList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</div><div class="line">            s.push(nestedList[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> res = s.top().getInteger();</div><div class="line">        s.pop();</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</div><div class="line">            <span class="keyword">if</span> (s.top().isInteger()) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">vector</span>&lt;NestedInteger&gt; cur = s.top().getList();</div><div class="line">            s.pop();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = cur.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</div><div class="line">                s.push(cur[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">stack</span>&lt;NestedInteger&gt; s;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Your NestedIterator object will be instantiated and called as such:</span></div><div class="line"><span class="comment"> * NestedIterator i(nestedList);</span></div><div class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Stack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Letter Combinations of a Phone Number (17)]]></title>
      <url>/2017/01/23/2017-01-23-leetcode-solution-Letter-Combinations-of-a-Phone-Number-17/</url>
      <content type="html"><![CDATA[<p>Given a digit string, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt="alt text"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input:Digit string &quot;23&quot;</div><div class="line">Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</div></pre></td></tr></table></figure></p>
<p>Note:<br>Although the above answer is in lexicographical order, your answer could be in any order you want.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>先建一个map来存储每一个字母可以映射的字母，然后就是常规的backtracking的解法。没有特殊的地方。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; <span class="built_in">map</span>;</div><div class="line">        <span class="built_in">map</span>[<span class="string">'2'</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;</div><div class="line">        <span class="built_in">map</span>[<span class="string">'3'</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &#123;<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>&#125;;</div><div class="line">        <span class="built_in">map</span>[<span class="string">'4'</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &#123;<span class="string">'g'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>&#125;;</div><div class="line">        <span class="built_in">map</span>[<span class="string">'5'</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &#123;<span class="string">'j'</span>,<span class="string">'k'</span>,<span class="string">'l'</span>&#125;;</div><div class="line">        <span class="built_in">map</span>[<span class="string">'6'</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &#123;<span class="string">'m'</span>,<span class="string">'n'</span>,<span class="string">'o'</span>&#125;;</div><div class="line">        <span class="built_in">map</span>[<span class="string">'7'</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &#123;<span class="string">'p'</span>,<span class="string">'q'</span>,<span class="string">'r'</span>,<span class="string">'s'</span>&#125;;</div><div class="line">        <span class="built_in">map</span>[<span class="string">'8'</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &#123;<span class="string">'t'</span>,<span class="string">'u'</span>,<span class="string">'v'</span>&#125;;</div><div class="line">        <span class="built_in">map</span>[<span class="string">'9'</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &#123;<span class="string">'w'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>&#125;;</div><div class="line">        </div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</div><div class="line">        <span class="built_in">string</span> cur = <span class="string">""</span>;</div><div class="line">        <span class="keyword">if</span> (digits.size() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        helper(digits, <span class="number">0</span>, cur, res, <span class="built_in">map</span>);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">        </div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> digits, <span class="keyword">int</span> pos, <span class="built_in">string</span> cur, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; <span class="built_in">map</span>)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (cur.size() == digits.size()) &#123;</div><div class="line">            res.push_back(cur);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; digits.size(); ++i) &#123;</div><div class="line">            <span class="keyword">char</span> digit = digits[i];</div><div class="line">            <span class="keyword">if</span> (!<span class="built_in">map</span>.count(digit)) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; dict = <span class="built_in">map</span>[digit];</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dict.size(); ++j) &#123;</div><div class="line">                    <span class="built_in">string</span> temp = cur + dict[j];</div><div class="line">                    helper(digits, i + <span class="number">1</span>, temp, res, <span class="built_in">map</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Backtracking </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Permutation II (47)]]></title>
      <url>/2017/01/21/2017-01-21-leetcode-solution-Permutation-II-47/</url>
      <content type="html"><![CDATA[<p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p>For example,<br>[1,1,2] have the following unique permutations:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [1,1,2],</div><div class="line">  [1,2,1],</div><div class="line">  [2,1,1]</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h3 id="解法1：-O-n"><a href="#解法1：-O-n" class="headerlink" title="解法1： O(n!)"></a>解法1： O(n!)</h3><p>主要是理解在递归的过程中，怎么算一个重复的数字。这里重复是指如果当前数和前一个数相同（排序后）， 并且前面一个数还没有被使用过的情况下，那么这个数算重复了（因为可能的答案已经被从前一个数字出发的递归中概括了）。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</div><div class="line">        <span class="keyword">if</span> (nums.empty()) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited (nums.size(), <span class="literal">false</span>);</div><div class="line">        <span class="built_in">std</span>::sort(nums.begin(), nums.end());</div><div class="line">        helper(nums, visited, cur, res);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cur, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (cur.size() == nums.size()) &#123;</div><div class="line">            res.push_back(cur);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !visited[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</div><div class="line">            cur.push_back(nums[i]);</div><div class="line">            visited[i] = <span class="literal">true</span>;</div><div class="line">            helper(nums, visited, cur, res);</div><div class="line">            cur.pop_back();</div><div class="line">            visited[i] = <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> backtracking </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Permutations (46)]]></title>
      <url>/2017/01/21/2017-01-21-leetcode-solution-Permutations-46/</url>
      <content type="html"><![CDATA[<p>Given a collection of distinct numbers, return all possible permutations.</p>
<p>For example,<br>[1,2,3] have the following permutations:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [1,2,3],</div><div class="line">  [1,3,2],</div><div class="line">  [2,1,3],</div><div class="line">  [2,3,1],</div><div class="line">  [3,1,2],</div><div class="line">  [3,2,1]</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h3 id="解法1：-O-n"><a href="#解法1：-O-n" class="headerlink" title="解法1： O(n!)"></a>解法1： O(n!)</h3><p>也是经典的backtracking的问题，对于这种permutation的问题， 要维护一个visited数组来记录每一个元素是否被选取了，因为这里每次都是从头开始扫描。 递归终止的条件是当选取的答案的长度和原数组的长度一致的时候就说明一个permutation已经完成。<br>因为有n!个组合，每一个组合访问一次，总的复杂度是O（n!).<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</div><div class="line">        <span class="keyword">if</span> (nums.empty()) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited (nums.size(), <span class="literal">false</span>);</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur;</div><div class="line">        helper(nums, visited, cur, res);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cur, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (cur.size() == nums.size()) &#123;</div><div class="line">            res.push_back(cur);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</div><div class="line">                cur.push_back(nums[i]);</div><div class="line">                visited[i] = <span class="literal">true</span>;</div><div class="line">                helper(nums, visited, cur, res);</div><div class="line">                cur.pop_back();</div><div class="line">                visited[i] = <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> backtracking </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Combination Sum II (40)]]></title>
      <url>/2017/01/21/2017-01-21-leetcode-solution-Combination-Sum-II-40/</url>
      <content type="html"><![CDATA[<p>Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p>
<p>Each number in C may only be used once in the combination.</p>
<p>Note:<br>All numbers (including target) will be positive integers.<br>The solution set must not contain duplicate combinations.<br>For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,<br>A solution set is:<br>[<br>  [1, 7],<br>  [1, 2, 5],<br>  [2, 6],<br>  [1, 1, 6]<br>]</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>这题和<a href="http://bigteemo.github.io/2017/01/21/leetcode-solution-Combination-Sum-39/">Combination Sum</a>的唯一区别是每一个数字只能使用一次，那么每一次挑选的时候无论是否有解都往前进一格就可以了。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; current;</div><div class="line">    sort(candidates.begin(),candidates.end());</div><div class="line">    backTracking(candidates.begin(),current,res,candidates,target);</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; current,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!target) res.push_back(current);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">for</span>(;n!=candidates.end()&amp;&amp;*n&lt;=target;++n)&#123;</div><div class="line">            current.push_back(*n);</div><div class="line">            backTracking(n+<span class="number">1</span>,current,res,candidates,target-*n);</div><div class="line">            current.pop_back();</div><div class="line">            <span class="keyword">while</span>(n+<span class="number">1</span>!=candidates.end()&amp;&amp;*(n+<span class="number">1</span>)==*n) ++n;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> backtracking </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Combination Sum (39)]]></title>
      <url>/2017/01/21/2017-01-21-leetcode-solution-Combination-Sum-39/</url>
      <content type="html"><![CDATA[<p>Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p>
<p>The same repeated number may be chosen from C unlimited number of times.</p>
<p>Note:<br>All numbers (including target) will be positive integers.<br>The solution set must not contain duplicate combinations.<br>For example, given candidate set [2, 3, 6, 7] and target 7,<br>A solution set is:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [7],</div><div class="line">  [2, 2, 3]</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>经典的backtracking的做法。 一个可能的小改进是可以先对原数组进行排序，然后再判断target是否还大于当前可选的节点，这样可以提高一点效率。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</div><div class="line"></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</div><div class="line">        <span class="keyword">if</span> (candidates.size() == <span class="number">0</span> || target &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur;</div><div class="line">        </div><div class="line">        helper(candidates, target, <span class="number">0</span>, cur, res);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> pos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cur, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</div><div class="line">            res.push_back(cur);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; candidates.size(); ++i) &#123;</div><div class="line">            cur.push_back(candidates[i]);</div><div class="line">            helper(candidates, target - candidates[i], i,cur, res);</div><div class="line">            cur.pop_back();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> backtracking </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Combinations (77)]]></title>
      <url>/2017/01/17/2017-01-17-leetcode-solution-Combinations-77/</url>
      <content type="html"><![CDATA[<p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p>
<p>For example,<br>If n = 4 and k = 2, a solution is:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [2,4],</div><div class="line">  [3,4],</div><div class="line">  [2,3],</div><div class="line">  [1,2],</div><div class="line">  [1,3],</div><div class="line">  [1,4],</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h3 id="解法1：-Backtracking"><a href="#解法1：-Backtracking" class="headerlink" title="解法1： Backtracking"></a>解法1： Backtracking</h3><p>常规的backtracking的题目，这里的特殊点是每一次要更新还剩下需要挑选的数字的个数。 然后用另外一个变量pos记录当前已经探索到的数字的位置。</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</div><div class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || n == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur;</div><div class="line">        </div><div class="line">        helper(n, k, <span class="number">1</span>, cur, res);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> pos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cur, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</div><div class="line">            res.push_back(cur);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;    </div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt;= n; ++i) &#123;</div><div class="line">            cur.push_back(i);</div><div class="line">            helper(n, k - <span class="number">1</span>, i + <span class="number">1</span>, cur, res);</div><div class="line">            cur.pop_back();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span>;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> backtracking </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Subsets II (90)]]></title>
      <url>/2017/01/17/2017-01-17-leetcode-solution-Subsets-II-90/</url>
      <content type="html"><![CDATA[<p>Given a collection of integers that might contain duplicates, nums, return all possible subsets.</p>
<p>Note: The solution set must not contain duplicate subsets.</p>
<p>For example,<br>If nums = [1,2,2], a solution is:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [2],</div><div class="line">  [1],</div><div class="line">  [1,2,2],</div><div class="line">  [2,2],</div><div class="line">  [1,2],</div><div class="line">  []</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>还是用通用的backtracking的模板，这里考察的是一个去重的feature。 对于题目意思中需要排除掉重复情况的时候， 我们首先要记得要把原数组进行排序。<br>然后去重时对于每一个选取的元素，考虑是否和之前的一致（或者是这次循环中第一个选取的值）<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</div><div class="line">        </div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</div><div class="line">        </div><div class="line">        <span class="comment">// sort the nums</span></div><div class="line">        <span class="built_in">std</span>::sort(nums.begin(), nums.end());</div><div class="line">        helper(nums, <span class="number">0</span>, temp, res);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> pos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cur, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</div><div class="line">        </div><div class="line">        res.push_back(cur);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (pos == nums.size()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; nums.size(); ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (i == pos || nums[i] != nums[i - <span class="number">1</span>]) &#123;</div><div class="line">                cur.push_back(nums[i]);</div><div class="line">                helper(nums, i + <span class="number">1</span>, cur, res);</div><div class="line">                cur.pop_back();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> backtracking </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Subsets (78)]]></title>
      <url>/2017/01/14/2017-01-14-leetcode-solution-Subsets-78/</url>
      <content type="html"><![CDATA[<p>Given a set of distinct integers, nums, return all possible subsets.</p>
<p>Note: The solution set must not contain duplicate subsets.</p>
<p>For example,<br>If nums = [1,2,3], a solution is:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [3],</div><div class="line">  [1],</div><div class="line">  [2],</div><div class="line">  [1,2,3],</div><div class="line">  [1,3],</div><div class="line">  [2,3],</div><div class="line">  [1,2],</div><div class="line">  []</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h3 id="解法1：-Backtracking-O-2-N"><a href="#解法1：-Backtracking-O-2-N" class="headerlink" title="解法1： Backtracking O(2^N)"></a>解法1： Backtracking O(2^N)</h3><p>Backtracking的模板解法。 用一个pos记录当前扫描到的位置。对于每一种情况，都是一个subset，所以递归的时候一开始就要把当前的结果给保存到结果集中。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</div><div class="line">        <span class="keyword">if</span> (nums.empty()) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur;</div><div class="line">        helper(nums, <span class="number">0</span>, cur, res);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> pos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cur, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</div><div class="line">        </div><div class="line">        res.push_back(cur);</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; nums.size(); ++i) &#123;</div><div class="line">            cur.push_back(nums[i]);</div><div class="line">            helper(nums, i + <span class="number">1</span>, cur, res);</div><div class="line">            cur.pop_back();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> backtracking </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Word Search (79)]]></title>
      <url>/2017/01/14/2017-01-14-leetcode-solution-Word-Search-79/</url>
      <content type="html"><![CDATA[<p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p>For example,<br>Given board =<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],</div><div class="line">  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],</div><div class="line">  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>word = “ABCCED”, -&gt; returns true,<br>word = “SEE”, -&gt; returns true,<br>word = “ABCB”, -&gt; returns false.</p>
<h3 id="解法1：-DFS-O-N-2-N是元素的个数"><a href="#解法1：-DFS-O-N-2-N是元素的个数" class="headerlink" title="解法1： DFS O(N^2) N是元素的个数"></a>解法1： DFS O(N^2) N是元素的个数</h3><p>这题的思路是，对于一个给定的string， 他的起点可以在图中的任意位置，那么我们就必须要对每一个起点进行遍历。 对于任意一个遍历， 需要维护一个visited图，来记录已经访问过的节点。<br>对于每一个节点，有4个方向可以选择，对每一个方向进行探索，只要其中有一个方向能找到string， 那么就算找到了。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (word.empty()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (board.empty() || board[<span class="number">0</span>].empty()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(board.size(), <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(board[<span class="number">0</span>].size(), <span class="literal">false</span>));</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); ++i) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].size(); ++j) &#123;</div><div class="line">                <span class="keyword">bool</span> temp = helper(word, board, visited, i, j);</div><div class="line">                <span class="keyword">if</span> (temp) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> word, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (word.empty()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (board[row][col] != word[<span class="number">0</span>]) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (word.size() == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        visited[row][col] = <span class="literal">true</span>;</div><div class="line">        </div><div class="line">        <span class="built_in">string</span> next = word.substr(<span class="number">1</span>, word.size() - <span class="number">1</span>);</div><div class="line">        </div><div class="line">        <span class="comment">// check up</span></div><div class="line">        <span class="comment">// bool up = false, right = false, bot = false, left = false;</span></div><div class="line">        <span class="keyword">if</span> (row &gt; <span class="number">0</span> &amp;&amp; !visited[row - <span class="number">1</span>][col] ) &#123;</div><div class="line">            <span class="keyword">bool</span> up = helper(next, board, visited, row - <span class="number">1</span>, col);</div><div class="line">            <span class="keyword">if</span> (up) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// right</span></div><div class="line">        <span class="keyword">if</span> (col &lt; board[<span class="number">0</span>].size() - <span class="number">1</span> &amp;&amp; !visited[row][col + <span class="number">1</span>]) &#123;</div><div class="line">            <span class="keyword">bool</span> right = helper(next, board, visited, row, col + <span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span> (right) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// down</span></div><div class="line">        <span class="keyword">if</span> (row &lt; board.size() - <span class="number">1</span> &amp;&amp; !visited[row + <span class="number">1</span>][col]) &#123;</div><div class="line">            <span class="keyword">bool</span> bot = helper(next, board, visited, row + <span class="number">1</span>, col);</div><div class="line">            <span class="keyword">if</span> (bot) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// left</span></div><div class="line">        <span class="keyword">if</span> (col &gt; <span class="number">0</span> &amp;&amp; !visited[row][col - <span class="number">1</span>]) &#123;</div><div class="line">            <span class="keyword">bool</span> left = helper(next, board, visited, row, col - <span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span> (left) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        visited[row][col] = <span class="literal">false</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> backtracking </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode解题: Gray Code (89)]]></title>
      <url>/2017/01/14/2017-01-14-leetcode-solution-Gray-Code-89/</url>
      <content type="html"><![CDATA[<p>The gray code is a binary numeral system where two successive values differ in only one bit.</p>
<p>Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p>
<p>For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">00 - 0</div><div class="line">01 - 1</div><div class="line">11 - 3</div><div class="line">10 - 2</div></pre></td></tr></table></figure></p>
<p>Note:<br>For a given n, a gray code sequence is not uniquely defined.</p>
<p>For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.</p>
<p>For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.</p>
<h3 id="解法1：-Recursive-O-2-N"><a href="#解法1：-Recursive-O-2-N" class="headerlink" title="解法1： Recursive O(2^N)"></a>解法1： Recursive O(2^N)</h3><p>这题一开始没有思路， 对于没思路的可以考虑多写几个最简单的情况的结果来找规律。本题就是一个列子。如果我们把n = 1， n = 2, n = 3的结果写出来就一目了然了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">n = 1</div><div class="line">0</div><div class="line">1</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">n = 2</div><div class="line">00</div><div class="line">01</div><div class="line">11</div><div class="line">10</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">n = 3</div><div class="line">000</div><div class="line">001</div><div class="line">011</div><div class="line">010</div><div class="line">110</div><div class="line">111</div><div class="line">101</div><div class="line">100</div></pre></td></tr></table></figure>
<p>可以发现，对于n的结果，有2^n个数，前2^n-1个数来自于n-1的结果，后一半的数是把n-1的结果倒序后最高位（n)位上加1即可。<br>有了这个结论，写程序就比较简单了。复杂度应该是O（2^N)</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; grayCode(<span class="keyword">int</span> n) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;<span class="number">0</span>&#125;;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; previous = grayCode(n - <span class="number">1</span>);</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">        </div><div class="line">        <span class="comment">// add previous level</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; previous.size(); ++i) &#123;</div><div class="line">            res.push_back(previous[i]);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = previous.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</div><div class="line">            <span class="comment">// add one to the high bits</span></div><div class="line">            <span class="keyword">int</span> temp =  previous[i] | (<span class="number">1</span> &lt;&lt; n - <span class="number">1</span>);</div><div class="line">            res.push_back(temp);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> 找规律 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Restore IP Address (93)]]></title>
      <url>/2017/01/13/2017-01-13-leetcode-solution-Restore-IP-Address-93/</url>
      <content type="html"><![CDATA[<p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p>
<p>For example:<br>Given “25525511135”,</p>
<p>return [“255.255.11.135”, “255.255.111.35”]. (Order does not matter)</p>
<h3 id="解法1：-Backtracking-Time-O-2-N-Space-O-2-N"><a href="#解法1：-Backtracking-Time-O-2-N-Space-O-2-N" class="headerlink" title="解法1： Backtracking, Time O(2^N), Space O(2^N)"></a>解法1： Backtracking, Time O(2^N), Space O(2^N)</h3><p>也是比较经典的backtracking的题目，也是不停的去取一部分string，要判断不用继续搜索的条件有这些：</p>
<ol>
<li>每个字串是否符合ip的条件，一定要是0到255， 并且开头的不能是0， 除了0本身。</li>
<li>字串的长度不能超过3</li>
<li>ip一共有4部分组成，所以也要判断是否超i过了这个条件。</li>
</ol>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; restoreIpAddresses(<span class="built_in">string</span> s) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</div><div class="line">        <span class="keyword">if</span> (s.empty()) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cur;</div><div class="line">        helper(s, <span class="number">0</span>, cur, res);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'0'</span> &amp;&amp; s.size() &gt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> temp = stoll(s);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (temp &gt;= <span class="number">0</span> &amp;&amp; temp &lt;= <span class="number">255</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">createIP</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; cur)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur.size() - <span class="number">1</span>; ++i) &#123;</div><div class="line">            res += cur[i] + <span class="string">"."</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        res += cur[cur.size() - <span class="number">1</span>];</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> pos, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; cur, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (pos == s.size()) &#123;</div><div class="line">            <span class="keyword">if</span> (cur.size() == <span class="number">4</span>) &#123;</div><div class="line">                res.push_back(createIP(cur));</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (cur.size() &gt; <span class="number">4</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; s.size(); ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (cur.size() &lt; <span class="number">4</span> &amp;&amp; i - pos &lt; <span class="number">3</span>) &#123;</div><div class="line">                <span class="built_in">string</span> item = s.substr(pos, i - pos + <span class="number">1</span>);</div><div class="line">                <span class="comment">// check if the item is between 0 and 255</span></div><div class="line">                <span class="keyword">if</span> (!isValid(item)) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                cur.push_back(item);</div><div class="line">                helper(s, i + <span class="number">1</span>, cur, res);</div><div class="line">                cur.pop_back();</div><div class="line">                    </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        </div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> backtracking </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Palindrome Partitioning (131)]]></title>
      <url>/2017/01/12/2017-01-12-leetcode-solution-Palindrome-Partitioning-131/</url>
      <content type="html"><![CDATA[<p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return all possible palindrome partitioning of s.</p>
<p>For example, given s = “aab”,<br>Return<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [&quot;aa&quot;,&quot;b&quot;],</div><div class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>常规的backtracking解法，这里我们用一个变量cut来记录当前cut的位置， 然后从cut + 1 开始一个一个个试是否是palindrome。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = s.size() - <span class="number">1</span>; i &lt; j; ++i, --j) &#123;</div><div class="line">            <span class="keyword">if</span> (s[i] != s[j]) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</div><div class="line">        <span class="keyword">if</span> (s.empty()) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cur;</div><div class="line">        </div><div class="line">        helper(s, <span class="number">0</span>, cur, res);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> cut, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; cur, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; res)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (cut == s.size()) &#123;</div><div class="line">            res.push_back(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(cur));</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cut + <span class="number">1</span>; i &lt;= s.size(); ++i) &#123;</div><div class="line">            <span class="built_in">string</span> prefix = s.substr(cut, i - cut);</div><div class="line">            <span class="keyword">if</span> (!isPalindrome(prefix)) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125; </div><div class="line">            </div><div class="line">            cur.push_back(prefix);</div><div class="line">            helper(s, i, cur, res);</div><div class="line">            cur.pop_back();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;;</div><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> backtracking </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Reverse Bits (190)]]></title>
      <url>/2017/01/10/2017-01-10-leetcode-solution-Reverse-Bits-190/</url>
      <content type="html"><![CDATA[<p>Reverse bits of a given 32 bits unsigned integer.</p>
<p>For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).</p>
<p>Follow up:<br>If this function is called many times, how would you optimize it?</p>
<p>Related problem: Reverse Integer</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</div><div class="line">            res &lt;&lt;= <span class="number">1</span>;</div><div class="line">            <span class="keyword">int</span> bit = n &amp; <span class="number">1</span>;</div><div class="line">            res = res | bit;</div><div class="line">            n &gt;&gt;= <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow up"></a>Follow up</h3><p>本题的follow up的解法参考<a href="https://discuss.leetcode.com/topic/9764/java-solution-and-optimization/2" target="_blank" rel="external">这个</a>帖<br>子</p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Number Complement (476)]]></title>
      <url>/2017/01/10/2017-01-10-leetcode-solution-Number-Complement-476/</url>
      <content type="html"><![CDATA[<p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.</p>
<p>Note:<br>The given integer is guaranteed to fit within the range of a 32-bit signed integer.<br>You could assume no leading zero bit in the integer’s binary representation.<br>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input: 5</div><div class="line">Output: 2</div><div class="line">Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.</div></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: 1</div><div class="line">Output: 0</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>观察可以发现，可以用XOR来flip每一位的bit， 而mark数是从第一个set bit开始所有位都为1的数字。<br>怎么判断最高的set bit是哪一个呢？可以用log2函数，最高位的1的位置一定是log2(num), 那么为了得到所有都是1的一个数，可以先左移log2(num) + 1， 然后把所得的数字-1即可。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> mask = (<span class="number">1</span> &lt;&lt; <span class="number">1</span> + <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(log2(num))) - <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> mask ^ num;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> mask = (<span class="number">1</span> &lt;&lt; ((<span class="keyword">int</span>)(Math.log10(num) / Math.log10(<span class="number">2</span>)) + <span class="number">1</span>)) - <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> num ^ mask;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法2：一位一位的转换"><a href="#解法2：一位一位的转换" class="headerlink" title="解法2：一位一位的转换"></a>解法2：一位一位的转换</h3><p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// last digit is set bit</span></div><div class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span> &amp;&amp; num != <span class="number">0</span>; i++) &#123;</div><div class="line">        <span class="keyword">int</span> digit = num &amp; <span class="number">1</span>;</div><div class="line">        num &gt;&gt;= <span class="number">1</span>;</div><div class="line">        pos++;</div><div class="line">        <span class="keyword">int</span> setBit = <span class="number">1</span> - digit;</div><div class="line">        setBit &lt;&lt;= i;</div><div class="line">        res |= setBit;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> res;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Combination Sum III (216)]]></title>
      <url>/2017/01/10/2017-01-10-leetcode-solution-Combination-Sum-III-216/</url>
      <content type="html"><![CDATA[<p>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>
<p>Example 1:</p>
<p>Input: k = 3, n = 7</p>
<p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[1,2,4]]</div></pre></td></tr></table></figure></p>
<p>Example 2:</p>
<p>Input: k = 3, n = 9</p>
<p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[1,2,6], [1,3,5], [2,3,4]]</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>典型的backtracking的题目，用一般的模板就能解决。用一个helper函数，用一个数保存当前试的数的起始位置， 用一个vector存储当前选出的答案。<br>要注意的是退出条件。 同时注意到由于存在可能计算重复的数据，所以memorization可以帮助efficiency，不过下面的答案没有用。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</div><div class="line">        <span class="keyword">int</span> num = <span class="number">1</span>; </div><div class="line">        <span class="keyword">int</span> max = <span class="number">9</span>;</div><div class="line">        helper(temp, res, k, n, num, max);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cur, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> num, <span class="keyword">int</span> max)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span> || (k == <span class="number">0</span> &amp;&amp; n &gt; <span class="number">0</span>) || (n == <span class="number">0</span> &amp;&amp; k != <span class="number">0</span>)) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; k == <span class="number">0</span>) &#123;</div><div class="line">            res.push_back(cur);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num; i &lt;= max; ++i) &#123;</div><div class="line">            cur.push_back(i);</div><div class="line">            helper(cur, res, k - <span class="number">1</span>,n - i, i + <span class="number">1</span>, max);</div><div class="line">            cur.pop_back();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> backtracking </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Permutation Sequence (60)]]></title>
      <url>/2017/01/09/2017-01-09-leetcode-solution-Permutation-Sequence-60/</url>
      <content type="html"><![CDATA[<p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p>
<p>By listing and labeling all of the permutations in order,<br>We get the following sequence (ie, for n = 3):</p>
<p>“123”<br>“132”<br>“213”<br>“231”<br>“312”<br>“321”<br>Given n and k, return the kth permutation sequence.</p>
<p>Note: Given n will be between 1 and 9 inclusive.</p>
<h3 id="解法1：-Math"><a href="#解法1：-Math" class="headerlink" title="解法1： Math"></a>解法1： Math</h3><p>数学题，解法就不重复了，第一位取值每(n - 1)!变化一位，第二位取值每（n - 2)% 变化一位。 通过k / (n - i)! 算出来的是index， 这就意味着每次取完一个数以后要把那个数删除。</p>
<p>C++<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c++ 里面vector的初始化如果用vector&lt;int&gt; (n, initial_value)的形式要注意是“（”， 不是“&#123;“， 花括号是给了一组初始的array</div></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; number ;</div><div class="line">        <span class="keyword">int</span> perm = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</div><div class="line">            number.push_back(i);</div><div class="line">            perm *= i;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        k--;</div><div class="line">        <span class="built_in">string</span> res;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</div><div class="line">            perm /= (n - i);</div><div class="line">            <span class="keyword">int</span> choosed = k / perm;</div><div class="line">            k %= perm;</div><div class="line">            res += to_string(number[choosed]);</div><div class="line">            number.erase(number.begin() + choosed);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Binary Tree Upside Down (156)]]></title>
      <url>/2017/01/09/2017-01-09-leetcode-solution-Binary-Tree-Upside-Down-156/</url>
      <content type="html"><![CDATA[<p>Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root.</p>
<p>For example:<br>Given a binary tree {1,2,3,4,5},<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    1</div><div class="line">   / \</div><div class="line">  2   3</div><div class="line"> / \</div><div class="line">4   5</div></pre></td></tr></table></figure></p>
<p>return the root of the binary tree [4,5,2,#,#,3,1].<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  4</div><div class="line"> / \</div><div class="line">5   2</div><div class="line">   / \</div><div class="line">  3   1</div></pre></td></tr></table></figure></p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>用分治的方法思考比较容易， 题目的意思是只有两种情况，一种是没有右子树，但可能有左子树，一种是有右子树但一定也有左子树。<br>变换之后，right tree变成left， root变成left， 而原来的left也需要进行upside down的变化。最后他的root是最终的root， 而他的最右子树变成了现在root和right的parent<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">res</span> &#123;</span></div><div class="line">    TreeNode* root;</div><div class="line">    TreeNode* tail;</div><div class="line">    res(TreeNode* r, TreeNode* t):root(r),tail(t) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">TreeNode* <span class="title">upsideDownBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        res result = helper(root);</div><div class="line">        <span class="keyword">return</span> result.root;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function">res <span class="title">helper</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!root) &#123;</div><div class="line">            <span class="keyword">return</span> res(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</div><div class="line">            <span class="keyword">return</span> res(root, root);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        res left = helper(root-&gt;left);</div><div class="line">        left.tail-&gt;left = root-&gt;right;</div><div class="line">        left.tail-&gt;right = root;</div><div class="line">        root-&gt;left = <span class="literal">NULL</span>;</div><div class="line">        root-&gt;right = <span class="literal">NULL</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> res(left.root, root);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Divide &amp; Conquer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Contains Duplicate II (219)]]></title>
      <url>/2017/01/07/2017-01-07-leetcode-solution-Contains-Duplicate-II-219/</url>
      <content type="html"><![CDATA[<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Length of Last Word (58)]]></title>
      <url>/2017/01/07/2017-01-07-leetcode-solution-Length-of-Last-Word-58/</url>
      <content type="html"><![CDATA[<p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.</p>
<p>If the last word does not exist, return 0.</p>
<p>Note: A word is defined as a character sequence consists of non-space characters only.</p>
<p>For example,<br>Given s = “Hello World”,<br>return 5.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>首<a href="http://bigteemo.github.io/2017/01/07/leetcode-solution-Word-Pattern-290/">这题</a>的启发，也用istringstream来读取一个个的word，直到最后一个string。<br>C++<br>```<br>这里要注意的是， getline会读取word直到下一个delimiter的出现，那么如果有两个连续的space，第二个space之前会读出一个“”， 也就是空字符串。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">ss</span><span class="params">(s)</span></span>;</div><div class="line">        <span class="built_in">string</span> word;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (getline(ss, word, <span class="string">' '</span>)) &#123;</div><div class="line">                <span class="keyword">if</span> (!word.empty()) &#123;</div><div class="line">                    res = word.size();    </div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法2："><a href="#解法2：" class="headerlink" title="解法2："></a>解法2：</h3><p>不用istringstream的操作， 一位位的读。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (s[i] == <span class="string">' '</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</div><div class="line">                    res = count;</div><div class="line">                &#125; </div><div class="line">                count = <span class="number">0</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ++count;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (count) res = count;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Word Pattern (290)]]></title>
      <url>/2017/01/07/2017-01-07-leetcode-solution-Word-Pattern-290/</url>
      <content type="html"><![CDATA[<p>Given a pattern and a string str, find if str follows the same pattern.</p>
<p>Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.</p>
<p>Examples:<br>pattern = “abba”, str = “dog cat cat dog” should return true.<br>pattern = “abba”, str = “dog cat cat fish” should return false.<br>pattern = “aaaa”, str = “dog cat cat dog” should return false.<br>pattern = “abba”, str = “dog dog dog dog” should return false.<br>Notes:<br>You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.</p>
<h3 id="解法1：-HashMap-O-N-M"><a href="#解法1：-HashMap-O-N-M" class="headerlink" title="解法1： HashMap, O(N + M)"></a>解法1： HashMap, O(N + M)</h3><p>这题对于我主要是学习C++的各种知识。。。 主要的思路是用两个map存储p到s的映射，也存储s到p的映射。<br>C++<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">读取一个string可以用到istringstream, 用法是istringstream ss(str);</div><div class="line">然后读取ss中的string可以用getline(const istringstream&amp;, const string&amp; word, char delimiter)</div><div class="line">getline如果返回为空则证明stream已经结束。</div><div class="line">最后要判断getline是否为空是因为有可能str比pattern长。</div></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordPattern</span><span class="params">(<span class="built_in">string</span> pattern, <span class="built_in">string</span> str)</span> </span>&#123;</div><div class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">ss</span><span class="params">(str)</span></span>;</div><div class="line">        <span class="built_in">string</span> word;    <span class="comment">// store the word from str</span></div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; p2s;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">char</span>&gt; s2p;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : pattern) &#123;</div><div class="line">            <span class="keyword">if</span> (!getline(ss, word, <span class="string">' '</span>)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (p2s.count(c) &amp;&amp; p2s[c] != word) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;   </div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (s2p.count(word) &amp;&amp; s2p[word] != c) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">            p2s[c] = word;</div><div class="line">            s2p[word] = c;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> !getline(ss, word, <span class="string">' '</span>);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Find Leaves of Binary Tree (366)]]></title>
      <url>/2017/01/07/2017-01-07-leetcode-solution-Find-Leaves-of-Binary-Tree-366/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, collect a tree’s nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty.</p>
<p>Example:<br>Given binary tree<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">          1</div><div class="line">         / \</div><div class="line">        2   3</div><div class="line">       / \     </div><div class="line">      4   5</div><div class="line">```  </div><div class="line">Returns [4, 5, 3], [2], [1].</div><div class="line"></div><div class="line">Explanation:</div><div class="line">1. Removing the leaves [4, 5, 3] would result in this tree:</div></pre></td></tr></table></figure></p>
<pre><code>  1
 / 
2          
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2. Now removing the leaf [2] would result in this tree:</div></pre></td></tr></table></figure>
<pre><code>1          
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3. Now removing the leaf [1] would result in the empty tree:</div></pre></td></tr></table></figure>
<pre><code>[]         
</code></pre><p>```<br>Returns [4, 5, 3], [2], [1].</p>
<h3 id="解法1：-DFS"><a href="#解法1：-DFS" class="headerlink" title="解法1： DFS"></a>解法1： DFS</h3><p>这题一开始想用Hashtable把tree转化成一个图然后不停的拨洋葱，后来参考了别人的做法发现不需要这样。 每一个点属于第几层的leave是由他的高度决定的。 那么我们只要遍历一次，算出每一个node的高度，如果高度为0， 那么就是leaf， 放在结果的第一个vector中，如果高度为1，那么放在第二个vector中以此类推。</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findLeaves(TreeNode* root) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</div><div class="line">        helper(root, res);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!root) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> height = max(helper(root-&gt;left, res), helper(root-&gt;right, res)) + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (height &gt;= res.size()) res.resize(height + <span class="number">1</span>);</div><div class="line">        res[height].push_back(root-&gt;val);</div><div class="line">        <span class="keyword">return</span> height;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法2：-剥洋葱"><a href="#解法2：-剥洋葱" class="headerlink" title="解法2： 剥洋葱"></a>解法2： 剥洋葱</h3><p>这种解法是用递归的方式不停的remove tree node。 用递归的方式的时候，如果要删掉一个leaf，办法是如果是leaf，则返回null， 而每一次递归的时候root-&gt;left = remove(left);<br>这样返回的NULL就会被赋值给root的left tree，所以就删掉了那个node。<br>每一次遍历的时候，都返回更新过的root， 直到root被删成空为止。<br>C++<br><figure class="highlight plain"><figcaption><span>lang: cpp</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;vector&lt;int&gt;&gt; findLeaves(TreeNode* root) &#123;</div><div class="line">        vector&lt;vector&lt;int&gt;&gt; res;</div><div class="line">        while (root) &#123;</div><div class="line">            vector&lt;int&gt; leaves;</div><div class="line">            root = removeLeaves(root, leaves);</div><div class="line">            res.push_back(leaves);</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    TreeNode* removeLeaves(TreeNode* root, vector&lt;int&gt;&amp; leaves) &#123;</div><div class="line">        if (!root) &#123;</div><div class="line">            return NULL;</div><div class="line">        &#125;</div><div class="line">        if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</div><div class="line">            leaves.push_back(root-&gt;val);</div><div class="line">            return NULL;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        root-&gt;left = removeLeaves(root-&gt;left, leaves);</div><div class="line">        root-&gt;right = removeLeaves(root-&gt;right, leaves);</div><div class="line">        return root;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode 解题: Construct Binary Tree from Preorder and Inorder Traversal (105)]]></title>
      <url>/2017/01/07/2017-01-07-leetcode-solution-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-105/</url>
      <content type="html"><![CDATA[<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<h3 id="解法1：-Recursive"><a href="#解法1：-Recursive" class="headerlink" title="解法1： Recursive"></a>解法1： Recursive</h3><p>Preorder的顺序是root，left，right<br>inorder的顺序是left，root，right<br>可见preorder的第一个一定是root，这样有了root的数值，我们就可以在inorder中找到root的位置，左边都是left，右边都是right<br>对左右子树同时进行tree construction。要注意的是下标容易出错， 要注意。</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (preorder.size() != inorder.size()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> helper(preorder, <span class="number">0</span>, preorder.size() - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.size() - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> pstart, <span class="keyword">int</span> pend, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> istart, <span class="keyword">int</span> iend)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (pstart &gt; pend || istart &gt; iend) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (pstart == pend) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(preorder[pstart]);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> rootval = preorder[pstart];</div><div class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(rootval);</div><div class="line">        </div><div class="line">        <span class="keyword">auto</span> iter = find(inorder.begin() + istart, inorder.begin() + iend + <span class="number">1</span>, rootval);</div><div class="line">        <span class="keyword">int</span> leftNum = iter - (inorder.begin() + istart);</div><div class="line">        </div><div class="line">        TreeNode* left = helper(preorder, pstart + <span class="number">1</span>, pstart + leftNum, inorder, istart, istart + leftNum - <span class="number">1</span>);</div><div class="line">        TreeNode* right = helper(preorder, pstart + leftNum + <span class="number">1</span>, pend, inorder, istart + leftNum + <span class="number">1</span>, iend);</div><div class="line">        </div><div class="line">        root-&gt;left = left;</div><div class="line">        root-&gt;right = right;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> In-order-traversal </tag>
            
            <tag> Pre-order-traversal </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Unique Binary Search Trees II (95)]]></title>
      <url>/2017/01/05/2017-01-05-leetcode-solution-Unique-Binary-Search-Trees-II-95/</url>
      <content type="html"><![CDATA[<p>Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1…n.</p>
<p>For example,<br>Given n = 3, your program should return all 5 unique BST’s shown below.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1         3     3      2      1</div><div class="line"> \       /     /      / \      \</div><div class="line">  3     2     1      1   3      2</div><div class="line"> /     /       \                 \</div><div class="line">2     1         2                 3</div></pre></td></tr></table></figure></p>
<h3 id="解法1：-Recursive-Divide-amp-Conquer"><a href="#解法1：-Recursive-Divide-amp-Conquer" class="headerlink" title="解法1： Recursive, Divide &amp; Conquer"></a>解法1： Recursive, Divide &amp; Conquer</h3><p>用分治的思想考虑会比较容易，从1到n，如果选择了i，那么1到i-1所能组成的tree都是i的左子树，i+1到n都为右子树。对于每一颗左子树和右子树的组合，我们都能构建一个新的树。<br>用递归的方式很容易解决。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; generateTrees(<span class="keyword">int</span> n) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> generate(<span class="number">1</span>, n);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; generate(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</div><div class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</div><div class="line">            res.push_back(<span class="literal">NULL</span>);</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i&lt;= end; ++i) &#123;</div><div class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; left = generate(start, i <span class="number">-1</span>);</div><div class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; right = generate(i + <span class="number">1</span>, end);</div><div class="line">            <span class="keyword">for</span> (TreeNode* l: left) &#123;</div><div class="line">                <span class="keyword">for</span> (TreeNode* r: right) &#123;</div><div class="line">                    TreeNode* root = <span class="keyword">new</span> TreeNode(i);</div><div class="line">                    root-&gt;left = l;</div><div class="line">                    root-&gt;right = r;</div><div class="line">                    res.push_back(root);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Minimum Height Trees (310)]]></title>
      <url>/2017/01/04/2017-01-04-leetcode-solution-Minimum-Height-Trees-310/</url>
      <content type="html"><![CDATA[<p>For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.</p>
<p>Format<br>The graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels).</p>
<p>You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.</p>
<p>Example 1:</p>
<p>Given n = 4, edges = [[1, 0], [1, 2], [1, 3]]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  0</div><div class="line">  |</div><div class="line">  1</div><div class="line"> / \</div><div class="line">2   3</div></pre></td></tr></table></figure></p>
<p>return <a href="https://discuss.leetcode.com/topic/30535/c-solution-o-n-time-o-n-space" target="_blank" rel="external">1</a></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Given n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</div><div class="line"></div><div class="line">     0  1  2</div><div class="line">      \ | /</div><div class="line">        3</div><div class="line">        |</div><div class="line">        4</div><div class="line">        |</div><div class="line">        5</div></pre></td></tr></table></figure></p>
<p>return [3, 4]</p>
<h3 id="解法1：-O-N-Time-O-N-Space"><a href="#解法1：-O-N-Time-O-N-Space" class="headerlink" title="解法1： O(N) Time + O(N) Space"></a>解法1： O(N) Time + O(N) Space</h3><p>这题有些难度。。一开始自己想了O(N*N)的算法，果断TLE了。 这里的解法是参考了<a href="https://discuss.leetcode.com/topic/30535/c-solution-o-n-time-o-n-space" target="_blank" rel="external">Discussion</a>里的一个解法。<br>首先要观察， 看对于一个图最多有几个可能的MHT， 答案是最多有两个。 为什么呢？假设有1个，那么就是自己。<br>假设有两个节点，则无论他们是否连接， 其中任何一个作为节点高度都是一样的。<br>如果只有三个节点， 那么如果有两个线连着，那么有两个叶子和一个中间点，那个中间点就是MHT。<br>有了这个思路， 我们可以从leaf出发，不停的向图中间靠拢，直到没有leaf为止（leaf定义为有且仅有一条边界）/</p>
<p>C++<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">可以用unordered_set&lt;int&gt;来表示children， 对应的操作有erase（）， insert（）</div><div class="line">C++中有std::swap可以用来交换两个container中的数据。</div><div class="line">vector可以用vector.clear()来清除里面的数据。</div></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findMinHeightTrees(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</div><div class="line">            res.push_back(<span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</div><div class="line">            res.push_back(<span class="number">0</span>);</div><div class="line">            res.push_back(<span class="number">1</span>);</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// Construct the tree</span></div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : edges) &#123;</div><div class="line">            <span class="keyword">if</span> (!<span class="built_in">map</span>.count(p.first)) &#123;</div><div class="line">                <span class="built_in">map</span>[p.first] = <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (!<span class="built_in">map</span>.count(p.second)) &#123;</div><div class="line">                <span class="built_in">map</span>[p.second] = <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;();</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">map</span>[p.first].insert(p.second);</div><div class="line">            <span class="built_in">map</span>[p.second].insert(p.first);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// Remove leaves until we have only 1 or 2 nodes</span></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; leaves;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[i].size() == <span class="number">1</span>) &#123;</div><div class="line">                leaves.push_back(i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; newLeaves;</div><div class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> leaf : leaves) &#123;</div><div class="line">                <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; innerLayer = <span class="built_in">map</span>[leaf];</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> node : innerLayer) &#123;</div><div class="line">                    <span class="built_in">map</span>[node].erase(leaf);</div><div class="line">                    <span class="keyword">if</span> (<span class="built_in">map</span>[node].size() == <span class="number">1</span>) &#123;</div><div class="line">                        newLeaves.push_back(node);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (newLeaves.empty()) &#123;</div><div class="line">                <span class="keyword">return</span> leaves;</div><div class="line">            &#125;</div><div class="line">            leaves.clear();</div><div class="line">            swap(leaves, newLeaves);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Count and Say (38)]]></title>
      <url>/2017/01/03/2017-01-03-leetcode-solution-Count-and-Say-38/</url>
      <content type="html"><![CDATA[<p>The count-and-say sequence is the sequence of integers beginning as follows:<br>1, 11, 21, 1211, 111221, …</p>
<p>1 is read off as “one 1” or 11.<br>11 is read off as “two 1s” or 21.<br>21 is read off as “one 2, then one 1” or 1211.<br>Given an integer n, generate the nth sequence.</p>
<p>Note: The sequence of integers will be represented as a string.</p>
<h3 id="解法1：-Recursive"><a href="#解法1：-Recursive" class="headerlink" title="解法1： Recursive"></a>解法1： Recursive</h3><p>用递归求得n-1的字符串，然后一位位遍历，每当得到和前一位不一样的字符时，保存前一位的字符的计数和字符。要注意的是最后一位的结果要在扫描结束后保存。<br>C++<br><code>C++ 里 从1个char转换到string可以用string(1, character)</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"1"</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">string</span> prev = countAndSay(n - <span class="number">1</span>);</div><div class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line">        <span class="keyword">char</span> cur = prev[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prev.size(); ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (prev[i] == prev[i - <span class="number">1</span>]) &#123;</div><div class="line">                count++;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                res += to_string(count) + <span class="built_in">string</span>(<span class="number">1</span>, cur);</div><div class="line">                cur = prev[i];</div><div class="line">                count = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        res += to_string(count) + <span class="built_in">string</span>(<span class="number">1</span>, prev[prev.size() - <span class="number">1</span>]);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Bulls and Cows (299)]]></title>
      <url>/2017/01/03/2017-01-03-leetcode-solution-Bulls-and-Cows-299/</url>
      <content type="html"><![CDATA[<p>You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number.</p>
<p>For example:</p>
<p>Secret number:  “1807”<br>Friend’s guess: “7810”<br>Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.)<br>Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return “1A3B”.</p>
<p>Please note that both secret number and friend’s guess may contain duplicate digits, for example:</p>
<p>Secret number:  “1123”<br>Friend’s guess: “0111”<br>In this case, the 1st 1 in friend’s guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return “1A1B”.<br>You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal.</p>
<h3 id="解法1：-O（N-Time-一次遍历"><a href="#解法1：-O（N-Time-一次遍历" class="headerlink" title="解法1： O（N) Time , 一次遍历"></a>解法1： O（N) Time , 一次遍历</h3><p>参考了[这个][1]的解法， 只需要一次遍历即可。思路是按位一个个遍历，如果碰到一样的字符则bull加1。 如果碰到不一样的字符，secret的字符对应的+1， guess对应的减1。这样就同时保存了secret和guess出现的字符的情况。 如果后续碰到如果secret字符对应的次数为负，则证明在guess中出现过； 如果guess字符对应的次数为正，则说明在secret中出现过。 这样的话就能记录一次cow。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getHint</span><span class="params">(<span class="built_in">string</span> secret, <span class="built_in">string</span> guess)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">map</span>(<span class="number">10</span>, <span class="number">0</span>);</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> bulls, cows;</div><div class="line">        </div><div class="line">        bulls = cows = <span class="number">0</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; secret.size(); ++i) &#123;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (secret[i] == guess[i]) &#123;</div><div class="line">                ++bulls;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="built_in">map</span>[secret[i] - <span class="string">'0'</span>] &lt; <span class="number">0</span>) &#123;</div><div class="line">                    ++cows;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (<span class="built_in">map</span>[guess[i] - <span class="string">'0'</span>] &gt; <span class="number">0</span>) &#123;</div><div class="line">                    ++cows;</div><div class="line">                &#125;</div><div class="line">                <span class="built_in">map</span>[secret[i] -<span class="string">'0'</span>]++;</div><div class="line">                <span class="built_in">map</span>[guess[i] - <span class="string">'0'</span>]--;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> to_string(bulls) + <span class="string">"A"</span> + to_string(cows) + <span class="string">"B"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Implement Trie (Prefix Tree) (208)]]></title>
      <url>/2017/01/03/2017-01-03-leetcode-solution-Implement-Trie-Prefix-Tree-208/</url>
      <content type="html"><![CDATA[<p>Implement a trie with insert, search, and startsWith methods.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>本题主要是考察Trie树的基本概念，可以参考<a href="https://en.wikipedia.org/wiki/Trie" target="_blank" rel="external">Wiki</a>的解释。 实现的时候，每一个node的children可以用一个map来实现，做insert或者是search的时候可以用一个current的指针从root开始不停的往下搜索。<br>比较直观，并没有难度。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Initialize your data structure here.</span></div><div class="line">    TrieNode() &#123;</div><div class="line">        isWord = <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt; children;</div><div class="line">    <span class="keyword">bool</span> isWord;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Trie() &#123;</div><div class="line">        root = <span class="keyword">new</span> TrieNode();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Inserts a word into the trie.</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</div><div class="line">        TrieNode* cur = root;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: word) &#123;</div><div class="line">            <span class="keyword">if</span> (!cur-&gt;children.count(c)) &#123;</div><div class="line">                cur-&gt;children[c] = <span class="keyword">new</span> TrieNode();</div><div class="line">            &#125;</div><div class="line">            cur = cur-&gt;children[c];</div><div class="line">        &#125;</div><div class="line">        cur-&gt;isWord = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Returns if the word is in the trie.</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</div><div class="line">        TrieNode* cur = root;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: word) &#123;</div><div class="line">            <span class="keyword">if</span> (!cur-&gt;children.count(c)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">            cur = cur-&gt;children[c];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> cur-&gt;isWord;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Returns if there is any word in the trie</span></div><div class="line">    <span class="comment">// that starts with the given prefix.</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</div><div class="line">        TrieNode* cur = root;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: prefix) &#123;</div><div class="line">            <span class="keyword">if</span> (!cur-&gt;children.count(c)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">            cur = cur-&gt;children[c];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    TrieNode* root;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// Your Trie object will be instantiated and called as such:</span></div><div class="line"><span class="comment">// Trie trie;</span></div><div class="line"><span class="comment">// trie.insert("somestring");</span></div><div class="line"><span class="comment">// trie.search("key");</span></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</div><div class="line">    Map&lt;Character, TrieNode&gt; map;</div><div class="line">    <span class="keyword">boolean</span> isWord;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> HashMap&lt;Character, TrieNode&gt;();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> TrieNode root;</div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/** Inserts a word into the trie. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</div><div class="line">        TrieNode current = root;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</div><div class="line">            <span class="keyword">if</span> (!current.map.containsKey(c)) &#123;</div><div class="line">                current.map.put(c, <span class="keyword">new</span> TrieNode());</div><div class="line">            &#125;</div><div class="line">            current = current.map.get(c);</div><div class="line">        &#125;</div><div class="line">        current.isWord = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</div><div class="line">        TrieNode current = root;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</div><div class="line">            <span class="keyword">if</span> (!current.map.containsKey(c)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            current = current.map.get(c);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> current.isWord;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</div><div class="line">        TrieNode current = root;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: prefix.toCharArray()) &#123;</div><div class="line">            <span class="keyword">if</span> (!current.map.containsKey(c)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            current = current.map.get(c);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></div><div class="line"><span class="comment"> * Trie obj = new Trie();</span></div><div class="line"><span class="comment"> * obj.insert(word);</span></div><div class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></div><div class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Trie </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: House Robber III (337)]]></title>
      <url>/2017/01/01/2017-01-01-leetcode-solution-House-Robber-III-337/</url>
      <content type="html"><![CDATA[<p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night.</p>
<p>Determine the maximum amount of money the thief can rob tonight without alerting the police.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  3</div><div class="line"> / \</div><div class="line">2   3</div><div class="line"> \   \ </div><div class="line">  3   1</div></pre></td></tr></table></figure></p>
<p>Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.<br>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    3</div><div class="line">   / \</div><div class="line">  4   5</div><div class="line"> / \   \ </div><div class="line">1   3   1</div></pre></td></tr></table></figure></p>
<p>Maximum amount of money the thief can rob = 4 + 5 = 9.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>参考了<a href="http://www.cnblogs.com/grandyang/p/5275096.html" target="_blank" rel="external">这个</a>帖子的解法3。 对于每一个节点，存在两种可能， 取或者不取。 那么可以用一个帮助函数，每一次计算的时候保存这两种情况的值。<br>用一个vector保存，v[0]表示从这个点出发，不包含这个点最大的可取值， v<a href="http://www.cnblogs.com/grandyang/p/5275096.html" target="_blank" rel="external">1</a>表示从这个点出发并且包含这个点可取的最大值。<br>那么对于一个root， 分别计算left和right的vector，再按取或者不取的情况计算出root的vector。<br>如果取root的值，那一定不能取left和right的值， 所以最大取值是left<a href="http://www.cnblogs.com/grandyang/p/5275096.html" target="_blank" rel="external">1</a> + right<a href="http://www.cnblogs.com/grandyang/p/5275096.html" target="_blank" rel="external">1</a> + val<br>如果不取root的值，那可以取left和right的值， 这也等价于两颗树，对这两颗树取这个问题的最大值，就是left两种情况的最大值+right两种情况的最大值。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp = helper(root);</div><div class="line">        <span class="keyword">return</span> max(temp[<span class="number">0</span>], temp[<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; helper(TreeNode* root) &#123;</div><div class="line">        <span class="keyword">if</span> (!root) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left = helper(root-&gt;left);</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right = helper(root-&gt;right);</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(<span class="number">2</span>,<span class="number">0</span>);</div><div class="line">        res[<span class="number">0</span>] = max(left[<span class="number">0</span>], left[<span class="number">1</span>]) + max(right[<span class="number">0</span>], right[<span class="number">1</span>]);</div><div class="line">        res[<span class="number">1</span>] = left[<span class="number">0</span>] + right[<span class="number">0</span>] + root-&gt;val;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> DFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Implement Stack using Queues (225)]]></title>
      <url>/2016/12/31/2016-12-31-leetcode-solution-Implement-Stack-using-Queues-225/</url>
      <content type="html"><![CDATA[<p>Implement the following operations of a stack using queues.</p>
<p>push(x) – Push element x onto stack.<br>pop() – Removes the element on top of the stack.<br>top() – Get the top element.<br>empty() – Return whether the stack is empty.<br>Notes:<br>You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty operations are valid.<br>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.<br>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>基本思路是当执行top或者是pop的时候，我们需要取出最后一个元素。那么前面的元素放哪里？ 可以直接push回当前的queue。 这样，当除最后一个元素被重新push后，第一个就是我们要求的元素。<br>要注意的是，top是不改变数据的，所以执行完top之前，要把第一个元素push回queue<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Push element x onto stack.</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        q.push(x);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Removes the element on top of the stack.</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> s = q.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s - <span class="number">1</span>; ++i) &#123;</div><div class="line">            q.push(q.front());</div><div class="line">            q.pop();</div><div class="line">        &#125;</div><div class="line">        q.pop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Get the top element.</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> s = q.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s - <span class="number">1</span>; ++i) &#123;</div><div class="line">            q.push(q.front());</div><div class="line">            q.pop();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> res = q.front();</div><div class="line">        q.push(res);</div><div class="line">        q.pop();</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Return whether the stack is empty.</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> q.empty();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Intersection of Two Linked Lists (160)]]></title>
      <url>/2016/12/31/2016-12-31-leetcode-solution-Intersection-of-Two-Linked-Lists-160/</url>
      <content type="html"><![CDATA[<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p>For example, the following two linked lists:</p>
<p>A:          a1 → a2<br>                   ↘<br>                     c1 → c2 → c3<br>                   ↗<br>B:     b1 → b2 → b3<br>begin to intersect at node c1.</p>
<p>Notes:</p>
<p>If the two linked lists have no intersection at all, return null.<br>The linked lists must retain their original structure after the function returns.<br>You may assume there are no cycles anywhere in the entire linked structure.<br>Your code should preferably run in O(n) time and use only O(1) memory.</p>
<h3 id="解法1：-O（M-N）-Time-O（1）-Space"><a href="#解法1：-O（M-N）-Time-O（1）-Space" class="headerlink" title="解法1： O（M + N） Time + O（1） Space"></a>解法1： O（M + N） Time + O（1） Space</h3><p>很巧妙的一个方法是如果我们将其中一个list的尾巴和另一个list的头部连接，那么就变成了求这个长list中是否有circle，如果有那么他们的交点是什么的题目。<br>要注意求交点的算法是：</p>
<ol>
<li>slow，fast pointer</li>
<li>slow = head， fast = head.next</li>
<li>找到slow和fast相等的点</li>
<li>把slow挪到head， fast往下移一格</li>
<li>一步一步走直到slow和fast相等<br>C++<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * struct ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode *next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!headA || !headB) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        ListNode *a = headA;</div><div class="line">        <span class="keyword">while</span> (a -&gt;next) &#123;</div><div class="line">            a = a-&gt;next;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        a-&gt;next =headB;</div><div class="line">        ListNode* temp = circle(headA);</div><div class="line">        a-&gt;next = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">return</span> temp;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function">ListNode* <span class="title">circle</span><span class="params">(ListNode* head)</span> </span>&#123;</div><div class="line">        </div><div class="line">        ListNode* slow = head;</div><div class="line">        ListNode* fast = head-&gt;next;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (slow != fast) &#123;</div><div class="line">            <span class="keyword">if</span> (!fast || !fast-&gt;next) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">            &#125;</div><div class="line">            slow = slow-&gt;next;</div><div class="line">            fast = fast-&gt;next-&gt;next;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        slow = head;</div><div class="line">        fast = fast-&gt;next;</div><div class="line">        <span class="keyword">while</span> (slow != fast) &#123;</div><div class="line">            slow =slow-&gt;next;</div><div class="line">            fast =fast-&gt;next;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> slow;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Construct Binary Tree from Inorder and Postorder Traversal (106)]]></title>
      <url>/2016/12/31/2016-12-31-leetcode-solution-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-106/</url>
      <content type="html"><![CDATA[<p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>You may assume that duplicates do not exist in the tree.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>首先回想一下inorder和postorder的遍历顺序是什么样的。 inorder是left，root，right。 postorder是left，right，root。 那么发现postorder对应的最后一个数就是tree的root， 当我们找到乐root之后就可以在inorder里面找到root的位置，假设为i。<br>按照inorder的顺序，在i左面的都是root的左节点，而在i右面的都是root的右节点。<br>对于左右子树，我们只要在运行一次同样的算法，只是更新一下取值的范围（左右边界）就可以了。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (inorder.empty()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> helper(inorder, <span class="number">0</span>, inorder.size() - <span class="number">1</span>, postorder, <span class="number">0</span>, postorder.size() - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> istart, <span class="keyword">int</span> iend, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span> pstart, <span class="keyword">int</span> pend)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (istart &gt; iend) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (istart == iend) &#123;</div><div class="line">            TreeNode* node = <span class="keyword">new</span> TreeNode(inorder[istart]);</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> val = postorder[pend];</div><div class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(val);</div><div class="line">        <span class="keyword">auto</span> iter = find(inorder.begin(), inorder.end(), val);</div><div class="line">        <span class="keyword">int</span> index = iter - inorder.begin();</div><div class="line">        <span class="keyword">int</span> leftNum = index - istart;</div><div class="line">        <span class="keyword">int</span> rightNum = iend - index;</div><div class="line">        </div><div class="line">        <span class="comment">// Find left tree</span></div><div class="line">        TreeNode* left = helper(inorder, istart, index - <span class="number">1</span>, postorder, pstart, pstart + leftNum - <span class="number">1</span>);</div><div class="line">        <span class="comment">// Find right tree</span></div><div class="line">        TreeNode* right = helper(inorder, index + <span class="number">1</span>, iend, postorder, pstart + leftNum, pstart + leftNum + rightNum - <span class="number">1</span>);</div><div class="line">        root-&gt;left = left;</div><div class="line">        root-&gt;right = right;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Remove Linked List Elements (203)]]></title>
      <url>/2016/12/30/2016-12-30-leetcode-solution-Remove-Linked-List-Elements-203/</url>
      <content type="html"><![CDATA[<p>Remove all elements from a linked list of integers that have value val.</p>
<p>Example<br>Given: 1 –&gt; 2 –&gt; 6 –&gt; 3 –&gt; 4 –&gt; 5 –&gt; 6, val = 6<br>Return: 1 –&gt; 2 –&gt; 3 –&gt; 4 –&gt; 5</p>
<h3 id="解法1：-O-N-One-Pass"><a href="#解法1：-O-N-One-Pass" class="headerlink" title="解法1： O(N) One Pass"></a>解法1： O(N) One Pass</h3><p>要注意的是因为可能头指针会被删除或者整条list会被删，要用dummy node。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * struct ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode *next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        dummy-&gt;next = head;</div><div class="line">        head = dummy;</div><div class="line">        <span class="keyword">while</span> (head-&gt;next) &#123;</div><div class="line">            <span class="keyword">if</span> (head-&gt;next-&gt;val == val) &#123;</div><div class="line">                ListNode* temp = head-&gt;next;</div><div class="line">                head-&gt;next = head-&gt;next-&gt;next;</div><div class="line">                <span class="keyword">delete</span> temp;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                head = head-&gt;next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ListNode* res = dummy-&gt;next;</div><div class="line">        <span class="keyword">delete</span> dummy;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode solution: Remove Nth Node From End of List (19)]]></title>
      <url>/2016/12/30/2016-12-30-leetcode-solution-Remove-Nth-Node-From-End-of-List-19/</url>
      <content type="html"><![CDATA[<p>Given a linked list, remove the nth node from the end of list and return its head.</p>
<p>For example,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</div><div class="line"></div><div class="line">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</div></pre></td></tr></table></figure></p>
<p>Note:<br>Given n will always be valid.<br>Try to do this in one pass.</p>
<h3 id="解法1：-Two-pointers-One-Pass-O-N-Time"><a href="#解法1：-Two-pointers-One-Pass-O-N-Time" class="headerlink" title="解法1： Two pointers, One Pass, O(N) Time"></a>解法1： Two pointers, One Pass, O(N) Time</h3><p>头node不确定，上dummy node大法。然后用双指针向前移动，找到Nth node的前一个node，删除后返回dummy-&gt;next<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * struct ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode *next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        dummy-&gt;next = head;</div><div class="line">        ListNode* left = dummy;</div><div class="line">        head = dummy;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</div><div class="line">            head = head-&gt;next;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (head-&gt;next) &#123;</div><div class="line">            left = left-&gt;next;</div><div class="line">            head = head-&gt;next;</div><div class="line">        &#125;</div><div class="line">        ListNode* temp = left-&gt;next;</div><div class="line">        left-&gt;next = left-&gt;next-&gt;next;</div><div class="line">        ListNode* res = dummy-&gt;next;</div><div class="line">        <span class="keyword">delete</span> temp;</div><div class="line">        <span class="keyword">delete</span> dummy;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Two pointers </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode解题: Path Sum II (113)]]></title>
      <url>/2016/12/30/2016-12-30-leetcode-solution-Path-Sum-II-113/</url>
      <content type="html"><![CDATA[<p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p>
<p>For example:<br>Given the below binary tree and sum = 22,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">      5</div><div class="line">     / \</div><div class="line">    4   8</div><div class="line">   /   / \</div><div class="line">  11  13  4</div><div class="line"> /  \    / \</div><div class="line">7    2  5   1</div></pre></td></tr></table></figure></p>
<p>return<br>[<br>   [5,4,11,2],<br>   [5,8,4,5]<br>]</p>
<h3 id="解法1：-DFS"><a href="#解法1：-DFS" class="headerlink" title="解法1： DFS"></a>解法1： DFS</h3><p>关于求所有的路径之类的题目，首先想到的都是DFS。 这道题也不例外。 用DFS遍历tree， 每一次往下一个node， 就把当前的sum减去node的val， 如果碰到叶子并且叶子的val和所剩的val相等，则加入paths中。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; paths;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</div><div class="line">        helper(root, sum, path, paths);</div><div class="line">        <span class="keyword">return</span> paths;  </div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* node, <span class="keyword">int</span> sum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; paths)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!node) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        path.push_back(node-&gt;val);</div><div class="line">        <span class="keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; sum == node-&gt;val) &#123;</div><div class="line">            paths.push_back(path);</div><div class="line">        &#125;</div><div class="line">        helper(node-&gt;left, sum - node-&gt;val, path, paths);</div><div class="line">        helper(node-&gt;right, sum - node-&gt;val, path, paths);</div><div class="line">        </div><div class="line">        path.pop_back();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> DFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Find All Anagrams in a String (438)]]></title>
      <url>/2016/12/29/2016-12-29-leetcode-solution-Find-All-Anagrams-in-a-String-438/</url>
      <content type="html"><![CDATA[<p>Given a string s and a non-empty string p, find all the start indices of p’s anagrams in s.</p>
<p>Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.</p>
<p>The order of output does not matter.</p>
<p>Example 1:</p>
<p>Input:<br>s: “cbaebabacd” p: “abc”</p>
<p>Output:<br>[0, 6]</p>
<p>Explanation:<br>The substring with start index = 0 is “cba”, which is an anagram of “abc”.<br>The substring with start index = 6 is “bac”, which is an anagram of “abc”.<br>Example 2:</p>
<p>Input:<br>s: “abab” p: “ab”</p>
<p>Output:<br>[0, 1, 2]</p>
<p>Explanation:<br>The substring with start index = 0 is “ab”, which is an anagram of “ab”.<br>The substring with start index = 1 is “ba”, which is an anagram of “ab”.<br>The substring with start index = 2 is “ab”, which is an anagram of “ab”.</p>
<h3 id="解法1：-滑动窗口，-O（N-Time"><a href="#解法1：-滑动窗口，-O（N-Time" class="headerlink" title="解法1： 滑动窗口， O（N) Time"></a>解法1： 滑动窗口， O（N) Time</h3><p>比较自然想到的是用一个hash来记录p中出现的字符个数，然后对于每一个字串去比较是否是一个p的anagram。但如果一个一个的字串比较的话，复杂度很高。<br>仔细想一想，每次向前挪一位的时候，我们只是更新了一个字符的信息，所以说一部分在hashtable中的信息还是可以用的。<br>那么我们可以运用滑动窗口的算法来保留已经得到的信息，每移动一格就更新一下hashtable中的信息。<br>具体的算法是这样的：<br>先遍历一遍p，记录每一个字符出现的次数并记录在hashtable中。<br>这里用的是滑动窗口的算法。用两个指针记录当前窗口的大小，</p>
<ol>
<li>right指针不停的向右侧移动。如果right指向的字符出现次数&gt;=1， 则表示找到一个对应的字符，所剩下的字符-1。</li>
<li>right字符在hashtable中出现的次数-1（无论是否出现过， 如果没有出现过，则数值为负值，便于区分是否是p中的字符）</li>
<li>right向右移动</li>
<li>判断count是否为0， 如果是表明所有的字符都出现过，则left指向的起始点就是一个有效的起始点。</li>
<li>如果窗口大小已经大于p的大小，那么就需要移动左指针。 首先看left指向的是否出现在p中（一定是》0的），如果是则count++</li>
<li>无论是否出现过，hash的值+1， 表明这个值已经退回。</li>
</ol>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findAnagrams(<span class="built_in">string</span> s, <span class="built_in">string</span> p) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">        <span class="keyword">if</span> (s.empty() || p.empty() ) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hash(<span class="number">26</span>, <span class="number">0</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : p) &#123;</div><div class="line">            hash[c - <span class="string">'a'</span>]+=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; <span class="keyword">int</span> count = p.size();</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (right &lt; s.size()) &#123;</div><div class="line">            <span class="keyword">if</span> (hash[s[right] - <span class="string">'a'</span>] &gt;= <span class="number">1</span>) &#123;</div><div class="line">                --count;</div><div class="line">            &#125;</div><div class="line">            hash[s[right] - <span class="string">'a'</span>]-=<span class="number">1</span>;</div><div class="line">            ++right;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">                res.push_back(left);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (right - left == p.size()) &#123;</div><div class="line">                <span class="keyword">if</span> (hash[s[left] - <span class="string">'a'</span>] &gt;= <span class="number">0</span>) &#123;</div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">                hash[s[left] - <span class="string">'a'</span>]+=<span class="number">1</span>;</div><div class="line">                left++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</div><div class="line"></div><div class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || s == <span class="keyword">null</span> || p.length() == <span class="number">0</span> || s.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] hash = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ss: p.toCharArray()) &#123;</div><div class="line">            hash[ss - <span class="string">'a'</span>]++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, count = p.length();</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</div><div class="line">            <span class="keyword">char</span> cur = s.charAt(right);</div><div class="line">            <span class="keyword">if</span> (hash[cur - <span class="string">'a'</span>] &gt; <span class="number">0</span>) &#123;</div><div class="line">                count--;</div><div class="line">            &#125;</div><div class="line">            ++right;</div><div class="line">            hash[cur - <span class="string">'a'</span>]--;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">                res.add(left);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (right - left == p.length()) &#123;</div><div class="line">                <span class="keyword">if</span> (hash[s.charAt(left) - <span class="string">'a'</span>] &gt;= <span class="number">0</span>) &#123;</div><div class="line">                    ++count;</div><div class="line">                &#125;</div><div class="line">                hash[s.charAt(left) - <span class="string">'a'</span>]++;</div><div class="line">                ++left;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运用滑动窗口的模板写一下<br>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line"></div><div class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : p.toCharArray()) &#123;</div><div class="line">            map.put(c, map.getOrDefault(c,<span class="number">0</span>) + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> count = map.size();</div><div class="line">        <span class="keyword">while</span> (end &lt; s.length()) &#123;</div><div class="line">            <span class="keyword">char</span> current = s.charAt(end);</div><div class="line">            <span class="keyword">if</span> (map.containsKey(current)) &#123;</div><div class="line">                map.put(current, map.get(current) - <span class="number">1</span>);</div><div class="line">                <span class="keyword">if</span> (map.get(current) == <span class="number">0</span>) &#123;</div><div class="line">                    count--;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            end++;</div><div class="line"></div><div class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// check if the current substring (start, end) qualify for a anagram</span></div><div class="line">                <span class="keyword">if</span> (end - start == p.length()) &#123;</div><div class="line">                    res.add(start);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">char</span> temp = s.charAt(start);</div><div class="line">                <span class="keyword">if</span> (map.containsKey(temp)) &#123;</div><div class="line">                    map.put(temp, map.get(temp) + <span class="number">1</span>);</div><div class="line">                    <span class="keyword">if</span> (map.get(temp) &gt; <span class="number">0</span>) &#123;</div><div class="line">                        count++;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                start++;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Isomorphic Strings (205)]]></title>
      <url>/2016/12/29/2016-12-29-leetcode-solution-Isomorphic-Strings-205/</url>
      <content type="html"><![CDATA[<p>Given two strings s and t, determine if they are isomorphic.</p>
<p>Two strings are isomorphic if the characters in s can be replaced to get t.</p>
<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.</p>
<p>For example,<br>Given “egg”, “add”, return true.</p>
<p>Given “foo”, “bar”, return false.</p>
<p>Given “paper”, “title”, return true.</p>
<p>Note:<br>You may assume both s and t have the same length.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>用hashmap， 要注意的是，除了有aa-&gt;ab情况要排除，还有ab-&gt;aa的情况也要排除，所以这里用到了两个hashmap。<br>C++<br>C++里hashmap查看是否有key也可以用map.count(key)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (s.size() != t.size()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (s.empty()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; mapLeft;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; mapRight;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</div><div class="line">            <span class="keyword">auto</span> left2Right = mapLeft.find(s[i]);</div><div class="line">            <span class="keyword">auto</span> right2Left = mapRight.find(t[i]);</div><div class="line">            <span class="keyword">if</span> (left2Right == mapLeft.end() &amp;&amp; right2Left == mapRight.end()) &#123;</div><div class="line">                mapLeft[s[i]] = t[i];</div><div class="line">                mapRight[t[i]] = s[i];</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left2Right != mapLeft.end()) &#123;</div><div class="line">                <span class="keyword">if</span> (mapLeft[s[i]] != t[i]) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                &#125;</div><div class="line">                mapRight[t[i]] = s[i];</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right2Left != mapRight.end()) &#123;</div><div class="line">                <span class="keyword">if</span> (mapRight[t[i]] != s[i]) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                &#125;</div><div class="line">                mapLeft[s[i]] = t[i];</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mapLeft[s[i]] != t[i] || mapRight[t[i]] != s[i]) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Flatten Binary Tree to Linked List (114)]]></title>
      <url>/2016/12/29/2016-12-29-leetcode-solution-Flatten-Binary-Tree-to-Linked-List-114/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<pre><code>    1
   / \
  2   5
 / \   \
3   4   6
</code></pre><p>The flattened tree should look like:<br>   1<br>    \<br>     2<br>      \<br>       3<br>        \<br>         4<br>          \<br>           5<br>            \<br>             6</p>
<h3 id="解法1：-Divide-amp-Conquer"><a href="#解法1：-Divide-amp-Conquer" class="headerlink" title="解法1： Divide &amp; Conquer"></a>解法1： Divide &amp; Conquer</h3><p>思路是对于每一个节点，如果有left和right两个child, 对left和right分别做flatten的话，只需要把left的child和right的root相连，同时把left的root设为NULL. 然后把root和left的root相连就得到了flatten的list。<br>具体实现起来的时候，可以建立一个辅助的struct来存储每一个节点对应的flatten之后的root和child。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NodePair</span> &#123;</span></div><div class="line">  TreeNode* root;</div><div class="line">  TreeNode* child;</div><div class="line">  NodePair(TreeNode* r, TreeNode* c):root(r),child(c) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!root) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        NodePair res = helper(root);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">        <span class="function">NodePair <span class="title">helper</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!root) &#123;</div><div class="line">            <span class="keyword">return</span> NodePair(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</div><div class="line">            <span class="keyword">return</span> NodePair(root, root);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        NodePair left = helper(root-&gt;left);</div><div class="line">        NodePair right = helper(root-&gt;right);</div><div class="line">        </div><div class="line">        <span class="comment">// Combine </span></div><div class="line">        root-&gt;left = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">if</span> (!left.root) &#123;</div><div class="line">            root-&gt;right = right.root;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            root-&gt;right = left.root;</div><div class="line">            left.child-&gt;left = <span class="literal">NULL</span>;</div><div class="line">            left.child-&gt;right = right.root;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> NodePair(root, right.child?right.child:left.child);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法2：-Preorder-traversal"><a href="#解法2：-Preorder-traversal" class="headerlink" title="解法2： Preorder traversal"></a>解法2： Preorder traversal</h3><p>从给的例子可以看到，最后的顺序是一个preorder traversal。 那么我们可以先进行preorder， 然后把vector中的node都连接起来。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!root) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; nodes;</div><div class="line">        preorder(nodes, root);</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.size() - <span class="number">1</span>; ++i) &#123;</div><div class="line">            nodes[i]-&gt;left = <span class="literal">NULL</span>;</div><div class="line">            nodes[i]-&gt;right = nodes[i + <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        nodes[nodes.size() - <span class="number">1</span>]-&gt;left = nodes[nodes.size() - <span class="number">1</span>]-&gt;right = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(<span class="built_in">vector</span>&lt;TreeNode*&gt;&amp; nodes, TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!root) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        nodes.push_back(root);</div><div class="line">        preorder(nodes, root-&gt;left);</div><div class="line">        preorder(nodes, root-&gt;right);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Divide &amp; Conquer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Merge Sorted Array (88)]]></title>
      <url>/2016/12/28/2016-12-28-leetcode-solution-Merge-Sorted-Array-88/</url>
      <content type="html"><![CDATA[<p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p>
<p>Note:<br>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.</p>
<h3 id="解法1：-O（M-N），-O（1）-Space"><a href="#解法1：-O（M-N），-O（1）-Space" class="headerlink" title="解法1： O（M + N）， O（1） Space"></a>解法1： O（M + N）， O（1） Space</h3><p>本题的function的return是void，看来必须是inplace的。 由于两个array都是sorted， 我们可以从大到小的merge，这样我们可以把merge过的数值插入到第一个array的尾部。<br>用一个指针维护插入的位置，另两个指针从大到小遍历两个array。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> mp = m - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> np = n - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> i = nums1.size() - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (mp &gt;= <span class="number">0</span> &amp;&amp; np &gt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (nums1[mp] &gt;= nums2[np]) &#123;</div><div class="line">                nums1[i--] = nums1[mp--];</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                nums1[i--] = nums2[np--];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (mp &gt;= <span class="number">0</span>) &#123;</div><div class="line">            nums1[i--] = nums1[mp--];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (np &gt;= <span class="number">0</span>) &#123;</div><div class="line">            nums1[i--] = nums2[np--];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Two pointers </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Path Sum (112)]]></title>
      <url>/2016/12/28/2016-12-28-leetcode-solution-Path-Sum-112/</url>
      <content type="html"><![CDATA[<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p>For example:<br>Given the below binary tree and sum = 22,<br>              5<br>             / \<br>            4   8<br>           /   / \<br>          11  13  4<br>         /  \      \<br>        7    2      1<br>return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</p>
<h3 id="解法1：-DFS"><a href="#解法1：-DFS" class="headerlink" title="解法1： DFS"></a>解法1： DFS</h3><p>很直白的一个DFS的题目，用递归的方式很简洁的完成。基本思路是对每一个子节点，都可以看成是一个新的问题，只是问题变成了要求的sum是sum-root-&gt;val。<br>直到leaf的时候判断当前要求的sum和自己是否一致（或者是更新了的sum是否为0）<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!root) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> cur = sum - root-&gt;val;</div><div class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</div><div class="line">            <span class="keyword">return</span> cur == <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left, cur) || hasPathSum(root-&gt;right, cur);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> DFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Sum Root to Leaf Numbers (129)]]></title>
      <url>/2016/12/28/2016-12-28-leetcode-solution-Sum-Root-to-Leaf-Numbers-129/</url>
      <content type="html"><![CDATA[<p>Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.</p>
<p>An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123.</p>
<p>Find the total sum of all root-to-leaf numbers.</p>
<p>For example,</p>
<pre><code>1
</code></pre><p>   / \<br>  2   3<br>The root-to-leaf path 1-&gt;2 represents the number 12.<br>The root-to-leaf path 1-&gt;3 represents the number 13.</p>
<p>Return the sum = 12 + 13 = 25.</p>
<p>Hide Tags Tree Depth-first Search<br>Show Similar Problems</p>
<h3 id="解法1：-DFS-，-O-N-Space-O（N）-Time"><a href="#解法1：-DFS-，-O-N-Space-O（N）-Time" class="headerlink" title="解法1： DFS ， O(N) Space + O（N） Time"></a>解法1： DFS ， O(N) Space + O（N） Time</h3><p>题意是对每一个path做一个操作（记录成一个数字），容易想到用DFS来遍历整棵数。<br>遍历的时候用一个vector存储每一个数字，最后对vector求一下和。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!root) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</div><div class="line">        helper(root, temp, <span class="number">0</span>);</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.size(); ++i) &#123;</div><div class="line">            sum += temp[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; buf, <span class="keyword">int</span> cur)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!root) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        cur = cur * <span class="number">10</span> + root-&gt;val;</div><div class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</div><div class="line">            buf.push_back(cur);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        helper(root-&gt;left, buf, cur);</div><div class="line">        helper(root-&gt;right, buf, cur);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法2：-DFS-，-O-1-Space-O（N）-Time"><a href="#解法2：-DFS-，-O-1-Space-O（N）-Time" class="headerlink" title="解法2： DFS ， O(1) Space + O（N） Time"></a>解法2： DFS ， O(1) Space + O（N） Time</h3><p>实际上不需要用一个vector来存储见到的数字。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!root) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> helper(root, <span class="number">0</span>);</div><div class="line">       </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">int</span> cur)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!root) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        cur = cur * <span class="number">10</span> + root-&gt;val;</div><div class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</div><div class="line">            <span class="keyword">return</span> cur;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> sum = helper(root-&gt;left, cur) + helper(root-&gt;right, cur);</div><div class="line">        <span class="keyword">return</span> sum; </div><div class="line">    &#125;</div><div class="line">    </div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> DFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Guess Number Higher or Lower (374)]]></title>
      <url>/2016/12/27/2016-12-27-leetcode-solution-Guess-Number-Higher-or-Lower-374/</url>
      <content type="html"><![CDATA[<p>We are playing the Guess Game. The game is as follows:</p>
<p>I pick a number from 1 to n. You have to guess which number I picked.</p>
<p>Every time you guess wrong, I’ll tell you whether the number is higher or lower.</p>
<p>You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0):</p>
<p>-1 : My number is lower<br> 1 : My number is higher<br> 0 : Congrats! You got it!<br>Example:<br>n = 10, I pick 6.</p>
<p>Return 6.</p>
<h3 id="解法1：-Binary-Search-O（logn"><a href="#解法1：-Binary-Search-O（logn" class="headerlink" title="解法1： Binary Search O（logn)"></a>解法1： Binary Search O（logn)</h3><p>很典型的二分法的题目。 没有难点。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Forward declaration of guess API.</span></div><div class="line"><span class="comment">// @param num, your guess</span></div><div class="line"><span class="comment">// @return -1 if my number is lower, 1 if my number is higher, otherwise return 0</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">guess</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> start = <span class="number">1</span>, end = n;</div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end) &#123;</div><div class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> (guess(mid) &lt;<span class="number">0</span> ) &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (guess(end) == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> end;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> start;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Valid Sudoku (36)]]></title>
      <url>/2016/12/27/2016-12-27-leetcode-solution-Valid-Sudoku-36/</url>
      <content type="html"><![CDATA[<p>Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.</p>
<p>The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.</p>
<p>A partially filled sudoku which is valid.</p>
<p>Note:<br>A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.</p>
<h3 id="解法1：-O（N-N）-Time-O-NN-Space-一次遍历"><a href="#解法1：-O（N-N）-Time-O-NN-Space-一次遍历" class="headerlink" title="解法1： O（N  N） Time + O(NN) Space, 一次遍历"></a>解法1： O（N <em> N） Time + O(N</em>N) Space, 一次遍历</h3><p>本题要满足三个条件，行，列以及小方块都不能包含重复的数字。<br>可以用三个数组记录每一个条件是否满足，因为每个条件有9行，9列或者9个小方块。 每一个条件能出现的数字只有1到9。<br>那么每次扫描一个数字时，判断三个条件是否出现过一样的数字，如果有则返回false。<br>这样的做法好处是只需要遍历一次，代码很整洁。<br>要注意的是在计算小方块的index的时候， 用了k = i / 3 <em> 3 + j / 3, 注意这里因为i是int，所以不能把/3</em>3抵消掉。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</div><div class="line">       </div><div class="line">       <span class="keyword">bool</span> rule1[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="literal">false</span>&#125;, rule2[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="literal">false</span>&#125;, rule3[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="literal">false</span>&#125;;</div><div class="line">       </div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); ++i) &#123;</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].size(); ++j) &#123;</div><div class="line">               <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) &#123;</div><div class="line">                   <span class="keyword">int</span> digit = board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>;</div><div class="line">                   <span class="keyword">int</span> smallMatrixIndex = i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>;</div><div class="line">                   <span class="keyword">if</span> (rule1[i][digit] || rule2[j][digit] || rule3[smallMatrixIndex][digit]) &#123;</div><div class="line">                       <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                   &#125;</div><div class="line">                   rule1[i][digit] = rule2[j][digit] = rule3[smallMatrixIndex][digit] = <span class="literal">true</span>;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解1法2：-O（N-N）-Time-O-1-Space，-三次遍历"><a href="#解1法2：-O（N-N）-Time-O-1-Space，-三次遍历" class="headerlink" title="解1法2： O（N * N） Time + O(1) Space， 三次遍历"></a>解1法2： O（N * N） Time + O(1) Space， 三次遍历</h3><p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</div><div class="line">        <span class="comment">// check row</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); ++i) &#123;</div><div class="line">            <span class="built_in">map</span>.clear();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].size(); ++j) &#123;</div><div class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (<span class="built_in">map</span>[board[i][j]] != <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="built_in">map</span>[board[i][j]] = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// check col</span></div><div class="line">        <span class="keyword">int</span> row = board.size();</div><div class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; ++i) &#123;</div><div class="line">            <span class="built_in">map</span>.clear();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row; ++j) &#123;</div><div class="line">                <span class="keyword">if</span> (board[j][i] == <span class="string">'.'</span>) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (<span class="built_in">map</span>[board[j][i]] != <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="built_in">map</span>[board[j][i]] = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// check small matrix</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row / <span class="number">3</span>; ++i) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col / <span class="number">3</span>; ++j) &#123;</div><div class="line">                <span class="built_in">map</span>.clear();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i * <span class="number">3</span>; k &lt; i * <span class="number">3</span> + <span class="number">3</span>; ++k) &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> m = j * <span class="number">3</span>; m &lt; j * <span class="number">3</span> + <span class="number">3</span>; ++m) &#123;</div><div class="line">                        <span class="keyword">if</span> (board[k][m] == <span class="string">'.'</span>) &#123;</div><div class="line">                            <span class="keyword">continue</span>;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">if</span> (<span class="built_in">map</span>[board[k][m]] != <span class="number">0</span>) &#123;</div><div class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                        &#125;</div><div class="line">                        <span class="built_in">map</span>[board[k][m]] = <span class="number">1</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Binary Tree Inorder Traversal]]></title>
      <url>/2016/12/27/2016-12-27-leetcode-solution-Binary-Tree-Inorder-Traversal/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree [1,null,2,3],<br>   1<br>    \<br>     2<br>    /<br>   3<br>return [1,3,2].</p>
<p>Note: Recursive solution is trivial, could you do it iteratively?</p>
<p>Show Company Tags<br>Show Tags<br>Show Similar Problems</p>
<h3 id="解法1：-Recursion"><a href="#解法1：-Recursion" class="headerlink" title="解法1： Recursion"></a>解法1： Recursion</h3><p>用递归的in-order很简单，按字面理解就是先左再自己再右。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">        helper(root, res);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!root) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        helper(root-&gt;left, res);</div><div class="line">        res.push_back(root-&gt;val);</div><div class="line">        helper(root-&gt;right, res);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法2：-Iterative"><a href="#解法2：-Iterative" class="headerlink" title="解法2： Iterative"></a>解法2： Iterative</h3><p>主要考虑的就是用一个stack来存储还没有访问的节点， 难点在于确定什么时候push和pop。<br>那么在寻找最小值的时候，一路上碰到的所有node都push<br>如果碰到了空节点，则证明现在的这条路已经到底了，需要往回寻找，这个时候就可以pop了，记录节点的数值。并且把将要探寻的指针放到right上继续。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">        <span class="keyword">if</span> (!root) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; store;</div><div class="line">        TreeNode* cur = root;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (cur || !store.empty()) &#123;</div><div class="line">            <span class="keyword">if</span> (cur) &#123;</div><div class="line">                store.push(cur);</div><div class="line">                cur = cur-&gt;left;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                TreeNode* temp = store.top();</div><div class="line">                res.push_back(temp-&gt;val);</div><div class="line">                store.pop();</div><div class="line">                cur = temp-&gt;right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> In-order-traversal </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Kth Smallest Element in a BST (230)]]></title>
      <url>/2016/12/27/2016-12-27-leetcode-solution-Kth-Smallest-Element-in-a-BST-230/</url>
      <content type="html"><![CDATA[<p>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.</p>
<p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p>
<p>Follow up:<br>What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p>
<p>Hint:</p>
<p>Try to utilize the property of a BST.<br>What if you could modify the BST node’s structure?<br>The optimal runtime complexity is O(height of BST).</p>
<h3 id="解法1：-In-order-traversal-O（N），-N-is-number-of-elements"><a href="#解法1：-In-order-traversal-O（N），-N-is-number-of-elements" class="headerlink" title="解法1： In-order traversal O（N）， N is number of elements"></a>解法1： In-order traversal O（N）， N is number of elements</h3><p>这题可以看成是一个in-order traversal的直接应用，因为BST的in-order traversal是一个有序数组，那么我们就可以根据这个性质，对数进行遍历直到找到第k个node。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="comment">// implement a in-order-traversal</span></div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> res;</div><div class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</div><div class="line">        TreeNode* cur = root;</div><div class="line">        <span class="keyword">while</span> (cur || !s.empty()) &#123;</div><div class="line">            <span class="keyword">if</span> (cur) &#123;</div><div class="line">                s.push(cur);</div><div class="line">                cur = cur-&gt;left;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ++count;</div><div class="line">                TreeNode* temp = s.top();</div><div class="line">                s.pop();</div><div class="line">                <span class="keyword">if</span> (count == k) &#123;</div><div class="line">                    res = temp-&gt;val;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                cur = temp-&gt;right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow up"></a>Follow up</h3><p>参考<a href="http://bookshadow.com/weblog/2015/07/02/leetcode-kth-smallest-element-bst/" target="_blank" rel="external">这篇</a>文章的思路</p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> In-order-traversal </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Arranging Coins (441)]]></title>
      <url>/2016/12/26/2016-12-26-leetcode-solution-Arranging-Coins-441/</url>
      <content type="html"><![CDATA[<p>You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins.</p>
<p>Given n, find the total number of full staircase rows that can be formed.</p>
<p>n is a non-negative integer and fits within the range of a 32-bit signed integer.</p>
<p>Example 1:</p>
<p>n = 5</p>
<p>The coins can form the following rows:<br>¤<br>¤ ¤<br>¤ ¤</p>
<p>Because the 3rd row is incomplete, we return 2.<br>Example 2:</p>
<p>n = 8</p>
<p>The coins can form the following rows:<br>¤<br>¤ ¤<br>¤ ¤ ¤<br>¤ ¤</p>
<p>Because the 4th row is incomplete, we return 3.</p>
<h3 id="解法1：-O-logN"><a href="#解法1：-O-logN" class="headerlink" title="解法1： O(logN)"></a>解法1： O(logN)</h3><p>一道很典型的binary search的题目，实际上这题是求最大的K， 满足1+2+… + k &lt;= n.<br>记录1+2+…+k = k*(k+1)/2<br>那么我们就可以用二分法来求出最大的k。<br>要注意的是当计算乘积的时候可能会溢出，所以需要用long来存放start和end。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> start = <span class="number">1</span>, end = n;</div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end) &#123;</div><div class="line">            <span class="keyword">long</span> mid = start + (end - start) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> (mid * (mid + <span class="number">1</span>) / <span class="number">2</span> &lt; n) &#123;</div><div class="line">                start = mid;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (end * (end + <span class="number">1</span>) / <span class="number">2</span> &lt;= n) &#123;</div><div class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)end;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)start;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> start = <span class="number">1</span>, end = n;</div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end) &#123;</div><div class="line">            <span class="keyword">long</span> mid = start + (end - start) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> ( mid * (mid + <span class="number">1</span>) / <span class="number">2</span> &lt; n) &#123;</div><div class="line">                start = mid;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (end * (end + <span class="number">1</span>) / <span class="number">2</span> &lt;= n) &#123;</div><div class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)end;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)start;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Valid Word Square (422)]]></title>
      <url>/2016/12/26/2016-12-26-leetcode-solution-Valid-Word-Square-422/</url>
      <content type="html"><![CDATA[<p>Given a sequence of words, check whether it forms a valid word square.</p>
<p>A sequence of words forms a valid word square if the kth row and column read the exact same string, where 0 ≤ k &lt; max(numRows, numColumns).</p>
<p>Note:<br>The number of words given is at least 1 and does not exceed 500.<br>Word length will be at least 1 and does not exceed 500.<br>Each word contains only lowercase English alphabet a-z.<br>Example 1:</p>
<p>Input:<br>[<br>  “abcd”,<br>  “bnrt”,<br>  “crmy”,<br>  “dtye”<br>]</p>
<p>Output:<br>true</p>
<p>Explanation:<br>The first row and first column both read “abcd”.<br>The second row and second column both read “bnrt”.<br>The third row and third column both read “crmy”.<br>The fourth row and fourth column both read “dtye”.</p>
<p>Therefore, it is a valid word square.<br>Example 2:</p>
<p>Input:<br>[<br>  “abcd”,<br>  “bnrt”,<br>  “crm”,<br>  “dt”<br>]</p>
<p>Output:<br>true</p>
<p>Explanation:<br>The first row and first column both read “abcd”.<br>The second row and second column both read “bnrt”.<br>The third row and third column both read “crm”.<br>The fourth row and fourth column both read “dt”.</p>
<p>Therefore, it is a valid word square.<br>Example 3:</p>
<p>Input:<br>[<br>  “ball”,<br>  “area”,<br>  “read”,<br>  “lady”<br>]</p>
<p>Output:<br>false</p>
<p>Explanation:<br>The third row reads “read” while the third column reads “lead”.</p>
<p>Therefore, it is NOT a valid word square.</p>
<h3 id="解法1：-O-M-N"><a href="#解法1：-O-M-N" class="headerlink" title="解法1： O(M * N)"></a>解法1： O(M * N)</h3><p>就是遍历一遍每个字母，对每个字母判断是否有对应的字母。如果没有，则为false<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validWordSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> m = words.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; words[i].size(); ++j) &#123;</div><div class="line">                <span class="keyword">char</span> cur = words[i][j];</div><div class="line">                <span class="keyword">if</span> (j &gt;= m) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (words[j].size() &lt;= i) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (words[j][i] != words[i][j]) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validWordSquare</span><span class="params">(List&lt;String&gt; words)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (words == <span class="keyword">null</span> || words.size() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Only need to search for the top diagonal</span></div><div class="line">        <span class="keyword">int</span> n = words.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; words.get(i).length(); j++) &#123;</div><div class="line">                <span class="keyword">if</span> (j &gt;= n) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (words.get(j).length() &lt;= i || words.get(j).charAt(i) != words.get(i).charAt(j)) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Delete Node in a BST (450)]]></title>
      <url>/2016/12/26/2016-12-26-leetcode-solution-Delete-Node-in-a-BST-450/</url>
      <content type="html"><![CDATA[<p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.</p>
<p>Basically, the deletion can be divided into two stages:</p>
<p>Search for a node to remove.<br>If the node is found, delete the node.<br>Note: Time complexity should be O(height of tree).</p>
<p>Example:</p>
<p>root = [5,3,6,2,4,null,7]<br>key = 3</p>
<pre><code>5
</code></pre><p>   / \<br>  3   6<br> / \   \<br>2   4   7</p>
<p>Given key to delete is 3. So we find the node with value 3 and delete it.</p>
<p>One valid answer is [5,4,6,2,null,null,7], shown in the following BST.</p>
<pre><code>5
</code></pre><p>   / \<br>  4   6<br> /     \<br>2       7</p>
<p>Another valid answer is [5,2,6,null,4,null,7].</p>
<pre><code>5
</code></pre><p>   / \<br>  2   6<br>   \   \<br>    4   7</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>此题比较复杂，参考了<a href="http://www.algolist.net/Data_structures/Binary_search_tree/Removal" target="_blank" rel="external">这篇</a>的解法。主要的思路是把要删除的节点分情况讨论。<br>基本的思路是： 对于一个要删除的节点，找出大于他的最小的node作为新的子root，或者是选出小于他的最大的node作为新的root。<br>解决此题的步骤如下：</p>
<ol>
<li>找出要删除的节点的父节点。</li>
<li>如果删除节点是leaf， 那么直接把父节点相应的连接设为null</li>
<li>如果删除节点只有一个子树， 那么把父节点指向唯一的那个子树</li>
<li>如果删除节点有两个子树， 那么找出大于删除节点的最小节点（设为x), 然后把删除节点的数值设为x的值，然后重新运行一遍删除操作。</li>
<li>上一步中，程序一定会终止因为最左节点一定是只有小于等于1个子节点。<br>等找出最小的大于他的node的时候（也就是右子树的最左节点）， 要分<br>C++<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">        TreeNode* dummy = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</div><div class="line">        dummy-&gt;left = root;</div><div class="line">        </div><div class="line">        TreeNode* parent = findNode(dummy, root, key);</div><div class="line">        TreeNode* node;</div><div class="line">        <span class="keyword">if</span> (parent-&gt;left &amp;&amp; parent-&gt;left-&gt;val == key) &#123;</div><div class="line">            node = parent-&gt;left;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;right &amp;&amp; parent-&gt;right-&gt;val == key) &#123;</div><div class="line">            node = parent-&gt;right;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// can't find the node</span></div><div class="line">            <span class="keyword">return</span> dummy-&gt;left;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        deleteNode(parent, node);</div><div class="line">        </div><div class="line">        TreeNode* res = dummy-&gt;left;</div><div class="line">        <span class="keyword">delete</span> dummy;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function">TreeNode* <span class="title">findNode</span><span class="params">(TreeNode* parent, TreeNode* cur,<span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!cur || cur-&gt;val == key) &#123;</div><div class="line">            <span class="keyword">return</span> parent;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (cur-&gt;val &lt; key) &#123;</div><div class="line">            <span class="keyword">return</span> findNode(cur, cur-&gt;right, key);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> findNode(cur, cur-&gt;left, key);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(TreeNode* parent, TreeNode* node)</span> </span>&#123;</div><div class="line">        <span class="comment">// delete the node, giving the parent</span></div><div class="line">         <span class="keyword">if</span> (!node-&gt;right) &#123;</div><div class="line">            <span class="keyword">if</span> (parent-&gt;left == node) &#123;</div><div class="line">                parent-&gt;left = node-&gt;left;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                parent-&gt;right = node-&gt;left;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!node-&gt;left) &#123;</div><div class="line">            <span class="keyword">if</span> (parent-&gt;left == node) &#123;</div><div class="line">                parent-&gt;left = node-&gt;right;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                parent-&gt;right = node-&gt;right;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            TreeNode* father = node;</div><div class="line">            TreeNode* child = node-&gt;right;</div><div class="line">            <span class="keyword">while</span> (child-&gt;left) &#123;</div><div class="line">                father = child;</div><div class="line">                child = child-&gt;left;</div><div class="line">            &#125;</div><div class="line">            node-&gt;val = child-&gt;val;</div><div class="line">            deleteNode(father, child);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Palindrome Number (9)]]></title>
      <url>/2016/12/25/2016-12-25-leetcode-solution-Palindrome-Number-9/</url>
      <content type="html"><![CDATA[<p>Determine whether an integer is a palindrome. Do this without extra space.</p>
<p>click to show spoilers.</p>
<p>Some hints:<br>Could negative integers be palindromes? (ie, -1)</p>
<p>If you are thinking of converting the integer to string, note the restriction of using extra space.</p>
<p>You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case?</p>
<p>There is a more generic way of solving this problem.</p>
<h3 id="解法1：-Reverse-integer-O（N），-N-is-the-number-of-digits"><a href="#解法1：-Reverse-integer-O（N），-N-is-the-number-of-digits" class="headerlink" title="解法1： Reverse integer O（N）， N is the number of digits"></a>解法1： Reverse integer O（N）， N is the number of digits</h3><p>用一个循环来反转数字，最后比较数字和反转的是否相等即可。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> copy = x;</div><div class="line">        <span class="keyword">int</span> re = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</div><div class="line">            re = re*<span class="number">10</span> + x % <span class="number">10</span>;</div><div class="line">            x /= <span class="number">10</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (copy == re) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法2：-Without-overflow"><a href="#解法2：-Without-overflow" class="headerlink" title="解法2： Without overflow"></a>解法2： Without overflow</h3><p>比较最左边和最右边的两个数，这样就不会有overflow的问题了。 取得左边的数的时候我们需要的是一个除数，这个可以先用O(N)的时间求出。<br>然后每次求出最右位和最左位。然后每次消掉两位数，相应的div也要缩小100<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> div = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> ( x / div &gt;= <span class="number">10</span>) &#123;</div><div class="line">            div *= <span class="number">10</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">int</span> left = x / div;</div><div class="line">            <span class="keyword">int</span> right = x % <span class="number">10</span>;</div><div class="line">            <span class="keyword">if</span> (left != right) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">            x = (x % div) / <span class="number">10</span>; <span class="comment">// 消掉两位</span></div><div class="line">            div /= <span class="number">100</span>;	<span class="comment">// 除数缩小100</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Closest Binary Search Tree Value (270)]]></title>
      <url>/2016/12/25/2016-12-25-leetcode-solution-Closest-Binary-Search-Tree-Value-270/</url>
      <content type="html"><![CDATA[<p>Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.</p>
<p>Note:<br>Given target value is a floating point.<br>You are guaranteed to have only one unique value in the BST that is closest to the target.</p>
<h3 id="解法1：-Divide-amp-Conquer"><a href="#解法1：-Divide-amp-Conquer" class="headerlink" title="解法1： Divide &amp; Conquer"></a>解法1： Divide &amp; Conquer</h3><p>关于树的题目，先考虑试试分治的思想，对于一个root，要找出最接近他的数值，可能比他小也可能比他大。所以如果他本身不等于target的话需要比较left 和right。似乎分治行得通。<br>由于题目给出guarantee有一个解，则不需要考虑空树的情况。 那么只要分三种情况考虑：</p>
<ol>
<li>左右子树都有， 那么比较左右子树的closestvalue和自身哪一个更close</li>
<li>左子树</li>
<li>右子树<br>其中2，3 只要比较root和其中一个子树算出来的结果就可以了。</li>
</ol>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode* root, <span class="keyword">double</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</div><div class="line">            <span class="keyword">return</span> root-&gt;val;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (root-&gt;val == target) &#123;</div><div class="line">            <span class="keyword">return</span> target;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> child;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;right) &#123;</div><div class="line">            <span class="keyword">int</span> left = closestValue(root-&gt;left, target);</div><div class="line">            <span class="keyword">int</span> right = closestValue(root-&gt;right, target);</div><div class="line">            child = <span class="built_in">abs</span>(left - target) &lt;= <span class="built_in">abs</span>(right - target)? left : right;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left) &#123;</div><div class="line">            child = closestValue(root-&gt;left, target);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right) &#123;</div><div class="line">            child = closestValue(root-&gt;right, target);   </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(child - target) &lt;= <span class="built_in">abs</span>(root-&gt;val - target) ? child: root-&gt;val;              </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Divide &amp; Conquer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode解题: Binary Tree Right Side View (199)]]></title>
      <url>/2016/12/25/2016-12-25-leetcode-solution-Binary-Tree-Right-Side-View-199/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<p>For example:<br>Given the following binary tree,<br>   1            &lt;—<br> /   \<br>2     3         &lt;—<br> \     \<br>  5     4       &lt;—<br>You should return [1, 3, 4].</p>
<h3 id="解法1：-BFS-O（N）"><a href="#解法1：-BFS-O（N）" class="headerlink" title="解法1： BFS, O（N）"></a>解法1： BFS, O（N）</h3><p>这题也是考察BFS算法的一个变形，题意是要求每一层最右边的node。那么我们按层遍历，对于每一层只取第一个（最右边）的node的数值就可以了。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rightSideView(TreeNode* root) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">        <span class="keyword">if</span> (!root) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</div><div class="line">        q.push(root);</div><div class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</div><div class="line">            <span class="keyword">int</span> k = q.size();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</div><div class="line">                TreeNode* cur = q.front();</div><div class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</div><div class="line">                    res.push_back(cur-&gt;val);    </div><div class="line">                &#125;</div><div class="line">                q.pop();</div><div class="line">                <span class="keyword">if</span> (cur-&gt;right) &#123;</div><div class="line">                    q.push(cur-&gt;right);</div><div class="line">                &#125; </div><div class="line">                <span class="keyword">if</span> (cur-&gt;left) &#123;</div><div class="line">                    q.push(cur-&gt;left);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> BFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Populating next right pointers in each node II (117)]]></title>
      <url>/2016/12/24/2016-12-24-leetcode-solution-Populkating-next-right-pointers-in-each-node-II-117/</url>
      <content type="html"><![CDATA[<p>Follow up for problem “Populating Next Right Pointers in Each Node”.</p>
<p>What if the given tree could be any binary tree? Would your previous solution still work?</p>
<p>Note:</p>
<p>You may only use constant extra space.<br>For example,<br>Given the following binary tree,<br>         1<br>       /  \<br>      2    3<br>     / \    \<br>    4   5    7<br>After calling your function, the tree should look like:<br>         1 -&gt; NULL<br>       /  \<br>      2 -&gt; 3 -&gt; NULL<br>     / \    \<br>    4-&gt; 5 -&gt; 7 -&gt; NULL</p>
<h3 id="解法1：-BFS，-O（N）-Time-O（1）-Space"><a href="#解法1：-BFS，-O（N）-Time-O（1）-Space" class="headerlink" title="解法1： BFS， O（N） Time + O（1） Space"></a>解法1： BFS， O（N） Time + O（1） Space</h3><p>运用此前<a href="http://bigteemo.github.io/2016/12/24/leetcode-solution-Populating-Next-right-pointers-in-each-node-116/">perfect tree</a>的解法，此题任然有效。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!root) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">queue</span>&lt;TreeLinkNode*&gt; q;</div><div class="line">    q.push(root);</div><div class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</div><div class="line">        <span class="keyword">int</span> number = q.size();</div><div class="line">        TreeLinkNode* prev = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; ++i) &#123;</div><div class="line">            TreeLinkNode* cur = q.front();</div><div class="line">            q.pop();</div><div class="line">            cur-&gt;next = prev;</div><div class="line">            prev = cur;</div><div class="line">            <span class="keyword">if</span> (cur-&gt;right) &#123;</div><div class="line">                q.push(cur-&gt;right);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (cur-&gt;left) &#123;</div><div class="line">                q.push(cur-&gt;left);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> BFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Populating Next right pointers in each node (116)]]></title>
      <url>/2016/12/24/2016-12-24-leetcode-solution-Populating-Next-right-pointers-in-each-node-116/</url>
      <content type="html"><![CDATA[<p>Given a binary tree</p>
<pre><code>struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
</code></pre><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<p>Note:</p>
<p>You may only use constant extra space.<br>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).<br>For example,<br>Given the following perfect binary tree,<br>         1<br>       /  \<br>      2    3<br>     / \  / \<br>    4  5  6  7<br>After calling your function, the tree should look like:<br>         1 -&gt; NULL<br>       /  \<br>      2 -&gt; 3 -&gt; NULL<br>     / \  / \<br>    4-&gt;5-&gt;6-&gt;7 -&gt; NULL<br>Show Company Tags<br>Show Tags<br>Show Similar Problems</p>
<h3 id="解法1：-BFS-O-N-Time-O（1）-Space"><a href="#解法1：-BFS-O-N-Time-O（1）-Space" class="headerlink" title="解法1： BFS, O(N) Time + O（1） Space"></a>解法1： BFS, O(N) Time + O（1） Space</h3><p>按照题目意思，似乎是一层一层的要连起来，第一个反应就是用BFS， 按层遍历。遍历的时候最好是从右往左，这样头node可以指向prev，之后不停的更新prev。实现起来没有难度。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for binary tree with next pointer.</span></div><div class="line"><span class="comment"> * struct TreeLinkNode &#123;</span></div><div class="line"><span class="comment"> *  int val;</span></div><div class="line"><span class="comment"> *  TreeLinkNode *left, *right, *next;</span></div><div class="line"><span class="comment"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!root) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">queue</span>&lt;TreeLinkNode*&gt; q;</div><div class="line">        q.push(root);</div><div class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</div><div class="line">            <span class="keyword">int</span> number = q.size();</div><div class="line">            TreeLinkNode* prev = <span class="literal">NULL</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; ++i) &#123;</div><div class="line">                TreeLinkNode* cur = q.front();</div><div class="line">                q.pop();</div><div class="line">                cur-&gt;next = prev;</div><div class="line">                prev = cur;</div><div class="line">                <span class="keyword">if</span> (cur-&gt;right) &#123;</div><div class="line">                    q.push(cur-&gt;right);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (cur-&gt;left) &#123;</div><div class="line">                    q.push(cur-&gt;left);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> BFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Minimum Depth of Binary Tree (111)]]></title>
      <url>/2016/12/24/2016-12-24-leetcode-solution-Minimum-Depth-of-Binary-Tree-111/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<h3 id="解法1：-BFS，-O（N"><a href="#解法1：-BFS，-O（N" class="headerlink" title="解法1： BFS， O（N),"></a>解法1： BFS， O（N),</h3><p>典型的用BFS的题，按层遍历，只要找到一个为叶子的节点，则当前记录的层数一定是最小层。 用一个queue来完成BFS。<br>C++<br>用到了queue<type> 的push(), front() 和pop()<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (!root) &#123;</div><div class="line">            <span class="keyword">return</span> count;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</div><div class="line">        q.push(root);</div><div class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</div><div class="line">            ++count;</div><div class="line">            <span class="keyword">int</span> k = q.size();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</div><div class="line">                TreeNode* temp = q.front();</div><div class="line">                q.pop();</div><div class="line">                <span class="keyword">if</span> (!temp-&gt;left &amp;&amp; !temp-&gt;right) &#123;</div><div class="line">                    <span class="keyword">return</span> count;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (temp-&gt;left) &#123;</div><div class="line">                    q.push(temp-&gt;left);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (temp-&gt;right) &#123;</div><div class="line">                    q.push(temp-&gt;right);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></type></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法2：-Recursive-Divide-and-Conquer-O-N"><a href="#解法2：-Recursive-Divide-and-Conquer-O-N" class="headerlink" title="解法2： Recursive, Divide and Conquer, O(N)"></a>解法2： Recursive, Divide and Conquer, O(N)</h3><p>一个数的最小层数是min（leftMin， rightMin） + 1, 用分治法和递归解决， code可以做到很简洁。<br>关于BFS和分治两者的复杂度分析，应该是一样的，参考<a href="http://www.jiuzhang.com/qa/332/" target="_blank" rel="external">九章</a>的一个解答<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (!root) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> helper(root);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!root) &#123;</div><div class="line">            <span class="keyword">return</span> INT_MAX;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> min(helper(root-&gt;left), helper(root-&gt;right)) + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> BFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Pascal's Triangle II (119)]]></title>
      <url>/2016/12/24/2016-12-24-leetcode-solution-Pascal-s-Triangle-II-119/</url>
      <content type="html"><![CDATA[<p>Given an index k, return the kth row of the Pascal’s triangle.</p>
<p>For example, given k = 3,<br>Return [1,3,3,1].</p>
<p>Note:<br>Could you optimize your algorithm to use only O(k) extra space?</p>
<h3 id="解法1：-重复利用Array-O-k-2-Time-O（K）-Space"><a href="#解法1：-重复利用Array-O-k-2-Time-O（K）-Space" class="headerlink" title="解法1： 重复利用Array, O(k^2) Time + O（K） Space"></a>解法1： 重复利用Array, O(k^2) Time + O（K） Space</h3><p>题目要求节省空间，想到的办法就是不停的修改当前的array。这里要注意的是：</p>
<ol>
<li>修改array的时候要从后往前修改，这样在计算前面的数值的时候不会受到已经修改过的数值的影响。</li>
<li>在修改array的时候是从1到当前的最后一个。因为当修改完毕之后array的大小才会增加。如果不注意这一点会出现[1,1,1]这样的结果。<br>C++<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getRow(<span class="keyword">int</span> rowIndex) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">        res.push_back(<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowIndex; ++i) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = res.size(); j &gt;= <span class="number">1</span>; --j) &#123;</div><div class="line">                res[j] += res[j - <span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">            res.push_back(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Pascal's Triangle (118)]]></title>
      <url>/2016/12/24/2016-12-24-leetcode-solution-Pascal-s-Triangle-118/</url>
      <content type="html"><![CDATA[<p>Given numRows, generate the first numRows of Pascal’s triangle.</p>
<p>For example, given numRows = 5,<br>Return</p>
<p>[<br>     [1],<br>    [1,1],<br>   [1,2,1],<br>  [1,3,3,1],<br> [1,4,6,4,1]<br>]</p>
<h3 id="解法1：-O（N-2-N-是numRows"><a href="#解法1：-O（N-2-N-是numRows" class="headerlink" title="解法1： O（N^2) N 是numRows"></a>解法1： O（N^2) N 是numRows</h3><p>很基础的题，注意第i层的第j个字符是第i-1层的第j个数和第j-1个数之和就可以了。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</div><div class="line">        <span class="keyword">if</span> (numRows == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x&#123;<span class="number">1</span>&#125;;</div><div class="line">        res.push_back(x);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numRows; ++i) &#123;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp&#123;<span class="number">1</span>&#125;;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</div><div class="line">                temp.push_back(res[i - <span class="number">1</span>][j - <span class="number">1</span>] + res[i - <span class="number">1</span>][j]);</div><div class="line">            &#125;</div><div class="line">            temp.push_back(<span class="number">1</span>);</div><div class="line">            res.push_back(temp);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Convert a Number to Hexadecimal (405)]]></title>
      <url>/2016/12/24/2016-12-24-leetcode-solution-Convert-a-Number-to-Hexadecimal-405/</url>
      <content type="html"><![CDATA[<p>iven an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used.</p>
<p>Note:</p>
<p>All letters in hexadecimal (a-f) must be in lowercase.<br>The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character ‘0’; otherwise, the first character in the hexadecimal string will not be the zero character.<br>The given number is guaranteed to fit within the range of a 32-bit signed integer.<br>You must not use any method provided by the library which converts/formats the number to hex directly.<br>Example 1:</p>
<p>Input:<br>26</p>
<p>Output:<br>“1a”<br>Example 2:</p>
<p>Input:<br>-1</p>
<p>Output:<br>“ffffffff”</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>16进制每一位表示4个bit的信息，4个bit可以表示0到15的数字，0~9用阿拉伯数字，10~15分别用a ~ f 表示。 那么基本思路就是每一次获取最右边的4位数，然后转化为16进制的数字。然后右移直到数字变为0。<br>C++<br>要注意的是C++ 中如果用+ 操作在string 和 string上，只能char或者string，所以如果是int则要转化为char再进行操作。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (num != <span class="number">0</span> &amp;&amp; count &lt; <span class="number">8</span>) &#123;</div><div class="line">            <span class="keyword">int</span> temp = num &amp; <span class="number">0xf</span>;</div><div class="line">            <span class="keyword">if</span> (temp &lt; <span class="number">10</span>) &#123;</div><div class="line">                res = to_string(temp) + res;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                res = <span class="keyword">char</span>(<span class="string">'a'</span> + temp - <span class="number">10</span>) + res;</div><div class="line">            &#125;</div><div class="line">            num = num &gt;&gt; <span class="number">4</span>;</div><div class="line">            ++count;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Math </tag>
            
            <tag> bit operator </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Binary Search Tree Iterator (173)]]></title>
      <url>/2016/12/23/2016-12-23-leetcode-solution-Binary-Search-Tree-Iterator-173/</url>
      <content type="html"><![CDATA[<p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p>
<p>Calling next() will return the next smallest number in the BST.</p>
<p>Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.</p>
<h3 id="解法1：-Stack"><a href="#解法1：-Stack" class="headerlink" title="解法1： Stack"></a>解法1： Stack</h3><p>用一个stack先预存排序了的treenode， 每次要调用next（）和hasNext（）的时候，只需要对stack操作即可。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for binary tree</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; data;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    BSTIterator(TreeNode *root) &#123;</div><div class="line">        traverse(root);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!root) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (!root-&gt;right &amp;&amp; !root-&gt;left) &#123;</div><div class="line">            data.push(root);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        traverse(root-&gt;right);</div><div class="line">        data.push(root);</div><div class="line">        traverse(root-&gt;left);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> !data.empty();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** @return the next smallest number */</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        TreeNode* temp = data.top();</div><div class="line">        <span class="keyword">int</span> res = temp-&gt;val;</div><div class="line">        data.pop();</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Your BSTIterator will be called like this:</span></div><div class="line"><span class="comment"> * BSTIterator i = BSTIterator(root);</span></div><div class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法2：-Stack，-非递归的in-order-traversal"><a href="#解法2：-Stack，-非递归的in-order-traversal" class="headerlink" title="解法2： Stack， 非递归的in order traversal"></a>解法2： Stack， 非递归的in order traversal</h3><p>实际上不需要预先存储排了序的treenode，而是在寻找最小的值的时候把经过的node用stack存起来。<br>这里实际上考的是iterative的in order traversal</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for binary tree</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; data;</div><div class="line">    TreeNode* cur;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    BSTIterator(TreeNode *root) &#123;</div><div class="line">        cur = root;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> cur || !data.empty();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** @return the next smallest number */</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (cur) &#123;</div><div class="line">            data.push(cur);</div><div class="line">            cur = cur-&gt;left;</div><div class="line">        &#125;</div><div class="line">        TreeNode* temp = data.top();</div><div class="line">        <span class="keyword">int</span> res = temp-&gt;val;</div><div class="line">        data.pop();</div><div class="line">        cur = temp-&gt;right;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Your BSTIterator will be called like this:</span></div><div class="line"><span class="comment"> * BSTIterator i = BSTIterator(root);</span></div><div class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></div><div class="line"><span class="comment"> */</span></div><div class="line"> </div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Find All Numbers Disappeared in an Array (448)]]></title>
      <url>/2016/12/22/2016-12-22-leetcode-solution-Find-All-Numbers-Disappeared-in-an-Array-448/</url>
      <content type="html"><![CDATA[<p>Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.</p>
<p>Find all the elements of [1, n] inclusive that do not appear in this array.</p>
<p>Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.</p>
<p>Example:</p>
<p>Input:<br>[4,3,2,7,8,2,3,1]</p>
<p>Output:<br>[5,6]</p>
<h3 id="解法1：-O（N-Time-O-1-Space"><a href="#解法1：-O（N-Time-O-1-Space" class="headerlink" title="解法1： O（N) Time + O(1) Space"></a>解法1： O（N) Time + O(1) Space</h3><p>本题是用了替换的办法。由于提前知道数的范围是从1 ~ n， 那么我们可以试着把每一个数放到该存在的位置，也就是nums[i] = i + 1。 不停的调整每一个位置上的数，直到满足这个条件或者是和要调整的位置上的数相等。<br>由于每一个数只visit一次，所以complexity是O（N）。<br>比较tricky的是，在置换两个数的时候要特别小心，我一开始写了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int ex = nums[i];</div><div class="line">nums[i] = nums[nums[i] - 1];</div><div class="line">nums[nums[i] - 1] = nums[i];</div></pre></td></tr></table></figure><br>这是不对的，因为在第二步nums[i]的值已经换过了。<br>等扫描结束一遍之后，再扫描一遍vector找出位置上的数和位置不同的数。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findDisappearedNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt; nums.size()) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i] - <span class="number">1</span> != i) &#123;</div><div class="line">                <span class="keyword">int</span> temp = nums[nums[i] - <span class="number">1</span>];</div><div class="line">                <span class="keyword">if</span> (temp == nums[i]) &#123;</div><div class="line">                    ++i;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    nums[nums[i] - <span class="number">1</span>] = nums[i];</div><div class="line">                    nums[i] = temp;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ++i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.size(); ++j) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[j] - <span class="number">1</span> != j) &#123;</div><div class="line">                res.push_back(j + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Binary Tree Paths (257)]]></title>
      <url>/2016/12/22/2016-12-22-leetcode-solution-Binary-Tree-Paths-257/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, return all root-to-leaf paths.</p>
<p>For example, given the following binary tree:</p>
<p>   1<br> /   \<br>2     3<br> \<br>  5<br>All root-to-leaf paths are:</p>
<p>[“1-&gt;2-&gt;5”, “1-&gt;3”]</p>
<h3 id="解法1：-DFS，-O（N）"><a href="#解法1：-DFS，-O（N）" class="headerlink" title="解法1： DFS， O（N）"></a>解法1： DFS， O（N）</h3><p>很标准的DFS的题目，要注意的是因为我们需要加入“-&gt;”， 所以写法上可以有两种办法。<br>一个是helper函数的起始string是“”， 那么每次加一个node的时候要判断是否str还是空，是的话不加，不是则加箭头。<br>另一个是一开始就赋值root-&gt;val， 这样每次碰到新node的时候一定需要加上”-&gt;”。写法上第二种办法更干净一些。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; binaryTreePaths(TreeNode* root) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</div><div class="line">        <span class="keyword">if</span> (!root) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        helper(root, to_string(root-&gt;val), res);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!root) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</div><div class="line">            res.push_back(s);</div><div class="line">            <span class="keyword">return</span>;           </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</div><div class="line">            helper(root-&gt;left, s + <span class="string">"-&gt;"</span> + to_string(root-&gt;left-&gt;val), res);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</div><div class="line">            helper(root-&gt;right, s + <span class="string">"-&gt;"</span> + to_string(root-&gt;right-&gt;val), res);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> DFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode解题: Lowest Common Ancestor of a Binary Tree (236)]]></title>
      <url>/2016/12/22/2016-12-22-leetcode-solution-Lowest-Common-Ancestor-of-a-Binary-Tree-236/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”</p>
<pre><code>    _______3______
   /              \
___5__          ___1__
</code></pre><p>   /      \        /      \<br>   6      _2       0       8<br>         /  \<br>         7   4<br>For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</p>
<p>Show Company Tags<br>Show Tags<br>Show Similar Problems</p>
<h3 id="解法1：-O（N）"><a href="#解法1：-O（N）" class="headerlink" title="解法1： O（N）"></a>解法1： O（N）</h3><p>这题和<a href="http://bigteemo.github.io/2016/12/14/leetcode-solution-Lowest-Common-Ancestor-of-a-Binary-Search-Tree-235/">Lowest Common Ancestor of a Binary Search Tree  (235)</a>的不同之处在于这里的条件比较松，只知道是一个binary tree。所以当root不是其中一个node的时候，需要同时计算left和right是否有存在的LCA。<br>那么递归的返回条件就是只要找到root和其中之一相等的时候，就返回当前的node。<br>这样就会出现种情况，<br>root 不是两个node的任何一个，</p>
<ol>
<li>LCA可以存在于left tree中</li>
<li>也可以存在于right tree中</li>
<li>也可以是当前的root（因为左右各含一个node）。<br>对于1，2两种情况，其中一个tree会返回空值<br>对于第三种情况，left和right的值都不同，以此就可以区分而得出我们想要的结果。</li>
</ol>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root == p || root == q) &#123;</div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</div><div class="line">        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> right;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (right == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> left;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == p || root == q) &#123;</div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</div><div class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</div><div class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> right;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (right == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> left;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Divide &amp; Conquer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Factorial Trailing Zeroes (172)]]></title>
      <url>/2016/12/21/2016-12-21-leetcode-solution-Factorial-Trailing-Zeroes-172/</url>
      <content type="html"><![CDATA[<p>Given an integer n, return the number of trailing zeroes in n!.</p>
<p>Note: Your solution should be in logarithmic time complexity.</p>
<h3 id="解法1：-O（N），-N-is-number-of-5"><a href="#解法1：-O（N），-N-is-number-of-5" class="headerlink" title="解法1： O（N）， N is number of 5"></a>解法1： O（N）， N is number of 5</h3><p>一道老题了， 主要就是有一个5就会对应一个trailing zero， 题目要求的就变成从1到n有多少个数含有5的因子。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (n &lt; <span class="number">5</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</div><div class="line">            count += n / <span class="number">5</span>;</div><div class="line">            n = n / <span class="number">5</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Palindrome Linked List (234)]]></title>
      <url>/2016/12/21/2016-12-21-leetcode-solution-Palindrome-Linked-List-234/</url>
      <content type="html"><![CDATA[<p>Given a singly linked list, determine if it is a palindrome.</p>
<p>Follow up:<br>Could you do it in O(n) time and O(1) space?</p>
<h3 id="解法1：-O（N）-Time-O（1）-Space"><a href="#解法1：-O（N）-Time-O（1）-Space" class="headerlink" title="解法1： O（N） Time + O（1） Space"></a>解法1： O（N） Time + O（1） Space</h3><p>基本思路就是从中间断开，然后把其中一段reverse，再同时遍历判断两个字列是否一致。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * struct ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode *next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</div><div class="line">    </div><div class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        ListNode* ptr = head;</div><div class="line">        <span class="keyword">while</span> (ptr) &#123;</div><div class="line">            ++count;</div><div class="line">            ptr = ptr-&gt;next;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        ptr = head;</div><div class="line">        ListNode* preMidPtr = preMid(ptr);</div><div class="line">        ListNode* right;</div><div class="line">        <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// even number</span></div><div class="line">            right = preMidPtr-&gt;next;</div><div class="line">            preMidPtr-&gt;next = <span class="literal">NULL</span>;</div><div class="line">            </div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            right = preMidPtr-&gt;next-&gt;next;</div><div class="line">            preMidPtr-&gt;next = <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        right = reverse(right);</div><div class="line">        <span class="keyword">while</span> (head &amp;&amp; right) &#123;</div><div class="line">            <span class="keyword">if</span> (head-&gt;val != right-&gt;val) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">            head = head-&gt;next;</div><div class="line">            right = right-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> head == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function">ListNode* <span class="title">preMid</span><span class="params">(ListNode* root)</span> </span>&#123;</div><div class="line">        ListNode* fast = root-&gt;next;</div><div class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</div><div class="line">            root = root-&gt;next;</div><div class="line">            fast = fast-&gt;next-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span> </span>&#123;</div><div class="line">        ListNode* prev = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">while</span> (head) &#123;</div><div class="line">            ListNode* temp = head-&gt;next;</div><div class="line">            head-&gt;next = prev;</div><div class="line">            prev = head;</div><div class="line">            head = temp;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> prev;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode解题: Count Complete Tree Nodes (222)]]></title>
      <url>/2016/12/21/2016-12-21-leetcode-solution-Count-Complete-Tree-Nodes-222/</url>
      <content type="html"><![CDATA[<p>Given a complete binary tree, count the number of nodes.</p>
<p>Definition of a complete binary tree from Wikipedia:<br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p>
<h3 id="解法1：-O-logN-logN）"><a href="#解法1：-O-logN-logN）" class="headerlink" title="解法1： O(logN * logN）"></a>解法1： O(logN * logN）</h3><p>这题参考了<a href="https://leetcode.com/problems/count-complete-tree-nodes/" target="_blank" rel="external">Discussion</a>的解法， 用遍历的方法的话，复杂度是O（N）， 但并没有用到complete BT的性质，显然最后的结果是TLE。<br>在巧妙的解法里，运用complete tree的一个性质是： 如果从一个root出发，最左面和最右面的高度一致的话，那么一定是一个complete tree，他的节点个数是pow(2, k) - 1, k是高度。<br>这个的运算的复杂度是O(logN).<br>如果高度不一致的话，那么可以对左右各做一次操作， 也就是一个递归操作。<br>复杂度分析<br>T（n) = T(n/2) + c<em>logN = T（n/4) + c</em>logN + c1<em>(logN - 1) = … = T(1) + c[logN + logN - 1 + logN - 2 + … + 1] =&gt; O(logN </em> logN)</p>
<p>logN*logN是比N好很多的，比如1024， logN = 10， N = 1024， 显然这个解法的复杂度好很多。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!root) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</div><div class="line">        TreeNode* toleft = root, *toright = root;</div><div class="line">        <span class="keyword">while</span> (toleft) &#123;++left; toleft = toleft-&gt;left;&#125;</div><div class="line">        <span class="keyword">while</span> (toright) &#123;++right; toright = toright-&gt;right;&#125;</div><div class="line">        <span class="keyword">if</span> (left == right) <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; left) - <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span> + countNodes(root-&gt;left) + countNodes(root-&gt;right);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Valid Palindrome (125)]]></title>
      <url>/2016/12/20/2016-12-20-leetcode-solution-Valid-Palindrome-125/</url>
      <content type="html"><![CDATA[<p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<p>For example,<br>“A man, a plan, a canal: Panama” is a palindrome.<br>“race a car” is not a palindrome.</p>
<p>Note:<br>Have you consider that the string might be empty? This is a good question to ask during an interview.</p>
<p>For the purpose of this problem, we define empty string as valid palindrome.</p>
<p>Show Company Tags<br>Show Tags<br>Show Similar Problems</p>
<h3 id="解法1：-Two-pointers-O-N"><a href="#解法1：-Two-pointers-O-N" class="headerlink" title="解法1： Two pointers, O(N)"></a>解法1： Two pointers, O(N)</h3><p>用双指针很简单。要注意的是要跳过非alphanumeric的数字，这里C++里面判断是否是alphanumeric的数字的时候是用的isalnum（x)。 转化为lowercase的时候用的是tolower（x)<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (s.empty()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = s.length() - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</div><div class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; !<span class="built_in">isalnum</span>(s[i])) &#123; ++i;&#125;</div><div class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; !<span class="built_in">isalnum</span>(s[j])) &#123; --j;&#125;</div><div class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[i]) != <span class="built_in">tolower</span>(s[j])) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    ++i;</div><div class="line">                    --j;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Two pointers </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Valid Parenthese (20)]]></title>
      <url>/2016/12/20/2016-12-20-leetcode-solution-Valid-Parenthese-20/</url>
      <content type="html"><![CDATA[<p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p>
<p>The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not.</p>
<h3 id="解法1：-Stack-O（N）-Space-O（N）-Time"><a href="#解法1：-Stack-O（N）-Space-O（N）-Time" class="headerlink" title="解法1： Stack O（N） Space + O（N） Time"></a>解法1： Stack O（N） Space + O（N） Time</h3><p>主要考察stack的用法，用一个stack存储所有的左括号，每当遇到右括号的时候就取stack中寻找是否是match的左括号。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (s.empty()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</div><div class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span> || c == <span class="string">'['</span> || c == <span class="string">'&#123;'</span>) &#123;</div><div class="line">                st.push(c);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (st.empty()) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">char</span> top = st.top();</div><div class="line">                    <span class="keyword">if</span> ((top == <span class="string">'('</span> &amp;&amp; c == <span class="string">')'</span>) || (top == <span class="string">'['</span> &amp;&amp; c == <span class="string">']'</span>) || (top == <span class="string">'&#123;'</span> &amp;&amp; c == <span class="string">'&#125;'</span>)) &#123;</div><div class="line">                        st.pop();</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> st.empty();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isEmpty()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: s.toCharArray()) &#123;</div><div class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span> || c == <span class="string">'&#123;'</span> || c == <span class="string">'['</span>) &#123;</div><div class="line">                stack.push(c);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">char</span> top = stack.peek();</div><div class="line">                <span class="keyword">if</span> (c == <span class="string">')'</span> &amp;&amp; top == <span class="string">'('</span>) &#123;</div><div class="line">                stack.pop();</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">']'</span> &amp;&amp; top == <span class="string">'['</span>) &#123;</div><div class="line">                    stack.pop();</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'&#125;'</span> &amp;&amp; top == <span class="string">'&#123;'</span>) &#123;</div><div class="line">                    stack.pop();</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> stack.isEmpty();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Validate Binary Search Tree (98)]]></title>
      <url>/2016/12/20/2016-12-20-leetcode-solution-Validate-Binary-Search-Tree-98/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.<br>Example 1:<br>    2<br>   / \<br>  1   3<br>Binary tree [2,1,3], return true.<br>Example 2:<br>    1<br>   / \<br>  2   3<br>Binary tree [1,2,3], return false.</p>
<h3 id="解法1：-DFS"><a href="#解法1：-DFS" class="headerlink" title="解法1： DFS"></a>解法1： DFS</h3><p>本题的思路在题意中已经给出来了。要validate一个BST，要满足的是left 和right都是valid BST,同时root的值要大于left的最大值，要小于right的最小值。这里就提示我们在进行遍历的时候要记录每一个子树的最大值和最小值。<br>用一个辅助结构struct来记录max，min和是否是validate tree。 从左至右判断是否满足BST的条件。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resultSet</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> maxVal;</div><div class="line">    <span class="keyword">int</span> minVal;</div><div class="line">    <span class="keyword">bool</span> isValid;</div><div class="line">    </div><div class="line">    resultSet (<span class="keyword">int</span> maxv, <span class="keyword">int</span> minv, <span class="keyword">bool</span> isv):maxVal(maxv),minVal(minv),isValid(isv)&#123;&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        resultSet temp = helper(root);</div><div class="line">        <span class="keyword">return</span> temp.isValid;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function">resultSet <span class="title">helper</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</div><div class="line">            <span class="keyword">return</span> resultSet(root-&gt;val, root-&gt;val, <span class="literal">true</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> maxVal = root-&gt;val;</div><div class="line">        <span class="keyword">int</span> minVal = root-&gt;val;</div><div class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</div><div class="line">            resultSet left = helper(root-&gt;left);</div><div class="line">            <span class="keyword">if</span> (!left.isValid || root-&gt;val &lt;= left.maxVal) &#123;</div><div class="line">                <span class="keyword">return</span> resultSet(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>);</div><div class="line">            &#125;</div><div class="line">            maxVal = max(maxVal, left.maxVal);</div><div class="line">            minVal = min(minVal, left.minVal);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</div><div class="line">            resultSet right = helper(root-&gt;right);</div><div class="line">            <span class="keyword">if</span> (!right.isValid || root-&gt;val &gt;= right.minVal) &#123;</div><div class="line">                <span class="keyword">return</span> resultSet(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>);</div><div class="line">            &#125;</div><div class="line">            maxVal = max(maxVal, right.maxVal);</div><div class="line">            minVal = min(minVal, right.minVal);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> resultSet(maxVal, minVal, <span class="literal">true</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> DFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Swap Nodes in Pairs (24)]]></title>
      <url>/2016/12/19/2016-12-19-leetcode-solution-Swap-Nodes-in-Pairs-24/</url>
      <content type="html"><![CDATA[<p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p>
<p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p>
<h3 id="解法1：-O-N-基本的LinkedList操作"><a href="#解法1：-O-N-基本的LinkedList操作" class="headerlink" title="解法1： O(N), 基本的LinkedList操作"></a>解法1： O(N), 基本的LinkedList操作</h3><p>调整后头节点不确定，用dummy node解决。然后就是很普通的node之间的对换。 1 -&gt; 2 -&gt; 3 -&gt; 4, 在换两个node之前，要记录剩下的list的头节点。 换好之后（假设两个node分别为first和second，那么就把first指向剩下的list的头节点)<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * struct ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode *next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> head;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        dummy-&gt;next = head;</div><div class="line">        </div><div class="line">        ListNode* ptr = dummy;</div><div class="line">        <span class="keyword">while</span> (ptr-&gt;next != <span class="literal">NULL</span> &amp;&amp; ptr-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</div><div class="line">            ListNode* first = ptr-&gt;next;</div><div class="line">            ListNode* second = first-&gt;next;</div><div class="line">            ListNode* remaining = second-&gt;next;</div><div class="line">            ptr-&gt;next = second;</div><div class="line">            second-&gt;next = first;</div><div class="line">            first-&gt;next = remaining;</div><div class="line">            ptr = first;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        ListNode* res = dummy-&gt;next;</div><div class="line">        <span class="keyword">delete</span> dummy;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Hamming Distance (461)]]></title>
      <url>/2016/12/19/2016-12-19-leetcode-solution-Hamming-Distance-461/</url>
      <content type="html"><![CDATA[<p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p>
<p>Given two integers x and y, calculate the Hamming distance.</p>
<p>Note:<br>0 ≤ x, y &lt; 231.</p>
<p>Example:</p>
<p>Input: x = 1, y = 4</p>
<p>Output: 2</p>
<p>Explanation:<br>1   (0 0 0 1)<br>4   (0 1 0 0)<br>       ↑   ↑</p>
<p>The above arrows point to positions where the corresponding bits are different.</p>
<h3 id="解法1：-O-M-M-is-the-number-of-bits-in-difference"><a href="#解法1：-O-M-M-is-the-number-of-bits-in-difference" class="headerlink" title="解法1： O(M), M is the number of bits in difference"></a>解法1： O(M), M is the number of bits in difference</h3><p>这题考察了两个基本操作，一个是XOR的消除操作。XOR两个数得出的数含有所有不一样bit，然后再统计set bit的个数就可以了。如果还记得在统计bit的题目里面的做法，用x &amp; (x - 1)消掉最高位的1直到x变为0为止。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = x ^ y; </div><div class="line">        <span class="keyword">return</span> numberOfBits(temp);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</div><div class="line">            ++count;</div><div class="line">            x = x &amp; (x - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode解题: Convert Sorted Array to Binary Search Tree (108)]]></title>
      <url>/2016/12/19/2016-12-19-leetcode-solution-Convert-Sorted-Array-to-Binary-Search-Tree-108/</url>
      <content type="html"><![CDATA[<p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<h3 id="解法1：-Recursion"><a href="#解法1：-Recursion" class="headerlink" title="解法1： Recursion"></a>解法1： Recursion</h3><p>很多Tree的问题都可以用Divide &amp; Conquer/递归的思想。这题也如此。要建立balanced tree，我们需要左边和右边的height尽可能相近。就考虑到选择中间作为root。之后就转化为把左array和右array转换的问题，这就是一个递归。</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums.empty()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (start == end) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(nums[start]);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> middle = start + (end - start) / <span class="number">2</span>;</div><div class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(nums[middle]);</div><div class="line">        TreeNode* left = helper(nums, start, middle - <span class="number">1</span>);</div><div class="line">        TreeNode* right = helper(nums, middle + <span class="number">1</span>, end);</div><div class="line">        root-&gt;left = left;</div><div class="line">        root-&gt;right = right;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Divide &amp; Conquer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Remove Duplicates from Sorted Array (26)]]></title>
      <url>/2016/12/18/2016-12-18-leetcode-solution-Remove-Duplicates-from-Sorted-Array-26/</url>
      <content type="html"><![CDATA[<p>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p>For example,<br>Given input array nums = [1,1,2],</p>
<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.</p>
<h3 id="解法1：Two-pointers"><a href="#解法1：Two-pointers" class="headerlink" title="解法1：Two pointers"></a>解法1：Two pointers</h3><p>思路和Remove elements一样，不一样的是two pointers指向的位置不同。这题由于是sorted，那么可以用一个指针指向插入的位置，只有碰到和前面不一样的数值的时候才更新他的值。<br>最后由于是返回count，所以要注意是把第一个指针的数值+1.<br>举例：1 2 3 3 4<br>当1，2，3 都不一样的时候，slow的指针往前进。当碰到第二个3的时候，slow不变，当碰到4时，把4赋值给第二个3，也就是当前slow的位置。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums.empty()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i] != nums[i <span class="number">-1</span>]) &#123;</div><div class="line">                nums[++slow] = nums[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> slow + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Two pointers </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Remove Element (27)]]></title>
      <url>/2016/12/18/2016-12-18-leetcode-solution-Remove-Element-27/</url>
      <content type="html"><![CDATA[<p>Given an array and a value, remove all instances of that value in place and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p>Example:<br>Given input array nums = [3,2,2,3], val = 3</p>
<p>Your function should return length = 2, with the first two elements of nums being 2.</p>
<p>Hint:</p>
<p>Try two pointers.<br>Did you use the property of “the order of elements can be changed”?<br>What happens when the elements to remove are rare?</p>
<h3 id="解法1：Two-pointers"><a href="#解法1：Two-pointers" class="headerlink" title="解法1：Two pointers"></a>解法1：Two pointers</h3><p>用two pointers，back记录需要remove的起始的位置。front不停的往后扫描，当扫到不要remove的时候则前进，如果扫到需要remove的就和back指向的数值交换，back向前-1<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums.empty()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> front = <span class="number">0</span>, back = nums.size() - <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (front &lt;= back) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[front] != val) &#123;</div><div class="line">                ++front;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">int</span> temp = nums[back];</div><div class="line">                nums[back] = nums[front];</div><div class="line">                nums[front] = temp;</div><div class="line">                --back;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> front;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Two pointers </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Plus One (66)]]></title>
      <url>/2016/12/18/2016-12-18-leetcode-solution-Plus-One-66/</url>
      <content type="html"><![CDATA[<p>Given a non-negative number represented as an array of digits, plus one to the number.</p>
<p>The digits are stored such that the most significant digit is at the head of the list.</p>
<h3 id="解法1：O-N"><a href="#解法1：O-N" class="headerlink" title="解法1：O(N)"></a>解法1：O(N)</h3><p>很基本的算carry，digit的方法</p>
<p>C++<br>要注意c++ insert的用法是insert(iterator, obj)， 如果是在头部插入，可以用insert(it.begin(), obj).<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</div><div class="line">        <span class="keyword">if</span> (digits.size() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> digits;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> n = digits.size();</div><div class="line">        carry = (digits[n - <span class="number">1</span>] + <span class="number">1</span>) / <span class="number">10</span>;</div><div class="line">        digits[n - <span class="number">1</span>] = (digits[n- <span class="number">1</span>] + <span class="number">1</span>) % <span class="number">10</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</div><div class="line">            <span class="keyword">int</span> temp = (digits[i] + carry) % <span class="number">10</span>;</div><div class="line">            carry = (digits[i] + carry) / <span class="number">10</span>;</div><div class="line">            digits[i] = temp;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</div><div class="line">            digits.insert(digits.begin(), carry);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> digits;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Power of Four (342)]]></title>
      <url>/2016/12/18/2016-12-18-leetcode-solution-Power-of-Four-342/</url>
      <content type="html"><![CDATA[<p>Given an integer (signed 32 bits), write a function to check whether it is a power of 4.</p>
<p>Example:<br>Given num = 16, return true. Given num = 5, return false.</p>
<p>Follow up: Could you solve it without loops/recursion?</p>
<h3 id="解法1：log换底"><a href="#解法1：log换底" class="headerlink" title="解法1：log换底"></a>解法1：log换底</h3><p>log4(x) == int, 运用log4(x) = log10(x)/log10(4)<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        <span class="keyword">double</span> temp = <span class="built_in">log10</span>(num) / <span class="built_in">log10</span>(<span class="number">4</span>);</div><div class="line">        <span class="keyword">return</span> temp == (<span class="keyword">int</span>) temp;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法2：power-of-two-math"><a href="#解法2：power-of-two-math" class="headerlink" title="解法2：power of two + math"></a>解法2：power of two + math</h3><p>如果是4的次方数，那么-1之后一定能被3整除。<br>要注意的是&amp;的优先级比==小，所以如果写成num &amp; (num - 1) == 0是不对的。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> num &gt; <span class="number">0</span> &amp;&amp; !(num &amp; (num - <span class="number">1</span>)) &amp;&amp; (num - <span class="number">1</span>) % <span class="number">3</span> == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Reorder List (143)]]></title>
      <url>/2016/12/18/2016-12-18-leetcode-solution-Reorder-List-143/</url>
      <content type="html"><![CDATA[<p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>You must do this in-place without altering the nodes’ values.</p>
<p>For example,<br>Given {1,2,3,4}, reorder it to {1,4,2,3}.</p>
<h3 id="解法1：Hashmap-two-pointers-O-N-Time-with-O-N-space"><a href="#解法1：Hashmap-two-pointers-O-N-Time-with-O-N-space" class="headerlink" title="解法1：Hashmap + two pointers O(N) Time with O(N) space"></a>解法1：Hashmap + two pointers O(N) Time with O(N) space</h3><p>用一个hashmap记录每一个node的位置，map的key是位置的坐标。然后用双指针重新把list按顺序连接起来。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * struct ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode *next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, ListNode*&gt; <span class="built_in">map</span>;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">            ListNode* cur = head;</div><div class="line">            head = head-&gt;next;</div><div class="line">            cur-&gt;next = <span class="literal">NULL</span>;</div><div class="line">            <span class="built_in">map</span>.insert(&#123;count, cur&#125;);</div><div class="line">            count++;</div><div class="line">        &#125;</div><div class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode* tail = dummy;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = count - <span class="number">1</span>; i &lt;= j; ++i, --j) &#123;</div><div class="line">            <span class="keyword">if</span> (i == j) &#123;</div><div class="line">                tail-&gt;next = <span class="built_in">map</span>[i];</div><div class="line">                tail = tail-&gt;next;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                tail-&gt;next = <span class="built_in">map</span>[i];</div><div class="line">                tail = tail-&gt;next;</div><div class="line">                tail-&gt;next = <span class="built_in">map</span>[j];</div><div class="line">                tail = tail-&gt;next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ListNode* res = dummy-&gt;next;</div><div class="line">        head = res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法2：-findMiddle-Reverse-O-N-Time-O-1-Space"><a href="#解法2：-findMiddle-Reverse-O-N-Time-O-1-Space" class="headerlink" title="解法2： findMiddle + Reverse O(N) Time + O(1) Space"></a>解法2： findMiddle + Reverse O(N) Time + O(1) Space</h3><p>本题也可以用linkedlist的常用算法解决。<br>第一步可以先找出list的中点，如果是偶数个如：1-&gt;2-&gt;3-4, 找出的是2，如果是奇数个：1-&gt;2-&gt;3-&gt;4-&gt;5, 找出的是3。<br>第二步：找出以后对后半部分进行reverse操作。<br>第三步：将右半部份merge到左半部分<br>这种解法不像第一种解法需要额外的存储空间。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * struct ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode *next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ListNode* preMiddle = findPreMiddle(head);</div><div class="line">        ListNode* right = preMiddle-&gt;next;</div><div class="line">        preMiddle-&gt;next = <span class="literal">NULL</span>;</div><div class="line">        right = reverse(right);</div><div class="line">        mergeToLeft(head, right);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">ListNode* <span class="title">findPreMiddle</span><span class="params">(ListNode* head)</span> </span>&#123;</div><div class="line">        ListNode* slow = head;</div><div class="line">        ListNode* fast = head-&gt;next;</div><div class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</div><div class="line">            slow = slow-&gt;next;</div><div class="line">            fast = fast-&gt;next-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> slow;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span> </span>&#123;</div><div class="line">        ListNode* prev = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">            ListNode* temp = head-&gt;next;</div><div class="line">            head-&gt;next = prev;</div><div class="line">            prev =head;</div><div class="line">            head = temp;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> prev;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeToLeft</span><span class="params">(ListNode* left, ListNode* right)</span> </span>&#123;</div><div class="line">        ListNode* curLeft;</div><div class="line">        ListNode* curRight;</div><div class="line">        <span class="keyword">while</span> (left &amp;&amp; right) &#123;</div><div class="line">            curLeft = left;</div><div class="line">            left = left-&gt;next;</div><div class="line">            curRight = right;</div><div class="line">            right = right-&gt;next;</div><div class="line">            curLeft-&gt;next = curRight;</div><div class="line">            curRight-&gt;next = left;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Implement Queue using Stacks (232)]]></title>
      <url>/2016/12/17/2016-12-17-leetcode-solution-Implement-Queue-using-Stacks-232/</url>
      <content type="html"><![CDATA[<p>Implement the following operations of a queue using stacks.</p>
<p>push(x) – Push element x to the back of queue.<br>pop() – Removes the element from in front of queue.<br>peek() – Get the front element.<br>empty() – Return whether the queue is empty.<br>Notes:<br>You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid.<br>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.<br>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</p>
<h3 id="解法1：Two-Queue"><a href="#解法1：Two-Queue" class="headerlink" title="解法1：Two Queue"></a>解法1：Two Queue</h3><p>stack和queue的区别是前者是FILO, 后者是FIFO， 如果用另外一个stack去反倒回来就得到了queue一样的效果。<br>实现起来，用一个buffer stack存储应该的顺序，peek和pop都应该从buffer中取，如果读取buffer的时候为空的话，则需要把数据从原stack移到buffer。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> &#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; mstack;</div><div class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; buffer;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Push element x to the back of queue.</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        mstack.push(x);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Removes the element from in front of queue.</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (buffer.empty()) &#123;</div><div class="line">            <span class="keyword">while</span> (!mstack.empty()) &#123;</div><div class="line">                buffer.push(mstack.top());</div><div class="line">                mstack.pop();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        buffer.pop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Get the front element.</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (buffer.empty()) &#123;</div><div class="line">             <span class="keyword">while</span> (!mstack.empty()) &#123;</div><div class="line">                buffer.push(mstack.top());</div><div class="line">                mstack.pop();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> buffer.top();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Return whether the queue is empty.</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mstack.empty() &amp;&amp; buffer.empty();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Balanced Binary Tree (110)]]></title>
      <url>/2016/12/17/2016-12-17-leetcode-solution-Balanced-Binary-Tree-110/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>按照定义，balanced是指left tree和right tree的max height的差值可以小于等于1，同时要满足left tree和right tree都是一个balanced tree。<br>用返回一个resultSet的办法返回多值，（balanced，maxHeight). 要注意的是返回的时候root的height需要是max(leftHeight, rightHeight) + 1<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resultSet</span> &#123;</span></div><div class="line">    <span class="keyword">bool</span> isBalanced;</div><div class="line">    <span class="keyword">int</span> maxHeight;</div><div class="line">    resultSet(<span class="keyword">bool</span> b, <span class="keyword">int</span> h): isBalanced(b), maxHeight(h) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line"></div><div class="line">        resultSet res = helper(root);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res.isBalanced;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">resultSet <span class="title">helper</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> resultSet(<span class="literal">true</span>, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</div><div class="line">            <span class="keyword">return</span> resultSet(<span class="literal">true</span>, <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        resultSet left = helper(root-&gt;left);</div><div class="line">        <span class="keyword">if</span> (!left.isBalanced) &#123;</div><div class="line">            <span class="keyword">return</span> resultSet(<span class="literal">false</span>, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        resultSet right = helper(root-&gt;right);</div><div class="line">        <span class="keyword">if</span> (!right.isBalanced) &#123;</div><div class="line">            <span class="keyword">return</span> resultSet(<span class="literal">false</span>, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> resultSet(<span class="built_in">abs</span>(left.maxHeight - right.maxHeight) &lt;= <span class="number">1</span>, max(left.maxHeight, right.maxHeight) + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Divide &amp; Conquer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Binary Tree Level Order Traversal (102)]]></title>
      <url>/2016/12/17/2016-12-17-leetcode-solution-Binary-Tree-Level-Order-Traversal-102/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>return its level order traversal as:<br>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p>
<h3 id="解法1：One-Queue"><a href="#解法1：One-Queue" class="headerlink" title="解法1：One Queue"></a>解法1：One Queue</h3><p>比较基础的BST算法，主要是掌握用一个queue和一个每层的计数器k来维护当前层的node个数<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</div><div class="line">        q.push(root);</div><div class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</div><div class="line">            <span class="keyword">int</span> k = q.size();</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</div><div class="line">                TreeNode* node = q.front();</div><div class="line">                q.pop();</div><div class="line">                level.push_back(node-&gt;val);</div><div class="line">                <span class="keyword">if</span> (node-&gt;left) &#123;</div><div class="line">                    q.push(node-&gt;left);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (node-&gt;right) &#123;</div><div class="line">                    q.push(node-&gt;right);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            res.push_back(level);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> BST </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Partition List (86)]]></title>
      <url>/2016/12/17/2016-12-17-leetcode-solution-Partition-List-86/</url>
      <content type="html"><![CDATA[<p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p>
<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p>For example,<br>Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,<br>return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.</p>
<h3 id="解法1：Dummy-Node-O-N-One-pass"><a href="#解法1：Dummy-Node-O-N-One-pass" class="headerlink" title="解法1：Dummy Node, O(N) One pass"></a>解法1：Dummy Node, O(N) One pass</h3><p>这题比array的partition容易一些，主要用两个dummy node记录两个list，一个小于x，一个大于等于x。用一个head指针维护现在遍历到的node。最后将两个dummy连在一起就可以了。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * struct ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode *next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line"></div><div class="line">        ListNode* left = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode* lefttail = left;</div><div class="line">        ListNode* right = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode* righttail = right;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">            ListNode* next = head-&gt;next;</div><div class="line">            head-&gt;next = <span class="literal">NULL</span>;</div><div class="line">            <span class="keyword">if</span> (head-&gt;val &lt; x) &#123;</div><div class="line">                lefttail-&gt;next = head;</div><div class="line">                lefttail = lefttail-&gt;next;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                righttail-&gt;next = head;</div><div class="line">                righttail = righttail-&gt;next;</div><div class="line">            &#125;</div><div class="line">            head = next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        lefttail-&gt;next = right-&gt;next;</div><div class="line">        ListNode* res = left-&gt;next;</div><div class="line">        <span class="keyword">delete</span> left;</div><div class="line">        <span class="keyword">delete</span> right;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Binary Tree Level Order Traversal II (107)]]></title>
      <url>/2016/12/16/2016-12-16-leetcode-solution-Binary-Tree-Level-Order-Traversal-II-107/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>return its bottom-up level order traversal as:<br>[<br>  [15,7],<br>  [9,20],<br>  [3]<br>]</p>
<h3 id="解法1：BST-Two-container"><a href="#解法1：BST-Two-container" class="headerlink" title="解法1：BST + Two container"></a>解法1：BST + Two container</h3><p>用按层遍历（one queue）的办法遍历得出每一层的vector，然后放入一个stack，最后按顺序读出vector中的值即可。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</div><div class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</div><div class="line"></div><div class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; temp;</div><div class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</div><div class="line">        q.push(root);</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</div><div class="line">            <span class="keyword">int</span> k = q.size();</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</div><div class="line">                TreeNode* node = q.front();</div><div class="line">                q.pop();</div><div class="line">                level.push_back(node-&gt;val);</div><div class="line">                <span class="keyword">if</span> (node-&gt;left) &#123;</div><div class="line">                    q.push(node-&gt;left);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (node-&gt;right) &#123;</div><div class="line">                    q.push(node-&gt;right);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            temp.push(level);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (!temp.empty()) &#123;</div><div class="line">            res.push_back(temp.top());</div><div class="line">            temp.pop();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> BST </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Symmetric Tree (101)]]></title>
      <url>/2016/12/16/2016-12-16-leetcode-solution-Symmetric-Tree-101/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree [1,2,2,3,4,4,3] is symmetric:</p>
<pre><code>1
</code></pre><p>   / \<br>  2   2<br> / \ / \<br>3  4 4  3<br>But the following [1,2,2,null,3,null,3] is not:<br>    1<br>   / \<br>  2   2<br>   \   \<br>   3    3</p>
<p>   Note:<br>   Bonus points if you could solve it both recursively and iteratively.</p>
<h3 id="解法1：Recursive"><a href="#解法1：Recursive" class="headerlink" title="解法1：Recursive"></a>解法1：Recursive</h3><p>主要还是分治的思想，对称的意思就是left = right，实际上我们要比较的是left tree 和right tree。<br>需要满足的条件是left.left = right.right &amp;&amp; left.right = right.left<br>然后不停的递归下去就可以了。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> mirror(root-&gt;left, root-&gt;right);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">mirror</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (left-&gt;val != right-&gt;val) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">bool</span> leftChild = mirror(left-&gt;left, right-&gt;right);</div><div class="line">        <span class="keyword">if</span> (!leftChild) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">bool</span> rightChild = mirror(left-&gt;right, right-&gt;left);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> rightChild;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法2：Iteratively"><a href="#解法2：Iteratively" class="headerlink" title="解法2：Iteratively"></a>解法2：Iteratively</h3><p>非递归一般需要用额外的数据结构，这里可以想到的是用queue，然后做一个BFS（按层遍历）。和比较是否是same tree很像，唯一不一样的是这里left需要从左往右，而right需要从右往左。<br>参考了<a href="http://bangbingsyb.blogspot.com/2014/11/leetcode-symmetric-tree.html" target="_blank" rel="external">喜唰唰</a>的解法。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">       <span class="built_in">queue</span>&lt;TreeNode*&gt; left, right;</div><div class="line">       left.push(root-&gt;left);</div><div class="line">       right.push(root-&gt;right);</div><div class="line">       <span class="keyword">while</span>(!left.empty() &amp;&amp; !right.empty()) &#123;</div><div class="line">           TreeNode* lchild = left.front();</div><div class="line">           TreeNode* rchild = right.front();</div><div class="line">           left.pop();</div><div class="line">           right.pop();</div><div class="line">           <span class="keyword">if</span> (!lchild &amp;&amp; !rchild) <span class="keyword">continue</span>;</div><div class="line">           <span class="keyword">if</span> (!lchild &amp;&amp; rchild) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">           <span class="keyword">if</span> (lchild &amp;&amp; !rchild) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">           <span class="keyword">if</span> (lchild-&gt;val != rchild-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">           left.push(lchild-&gt;left);</div><div class="line">           left.push(lchild-&gt;right);</div><div class="line">           right.push(rchild-&gt;right);</div><div class="line">           right.push(rchild-&gt;left);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (!left.empty() || !right.empty()) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">       &#125;</div><div class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> BST </tag>
            
            <tag> Divide &amp; Conquer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Insertion Sort List (147)]]></title>
      <url>/2016/12/16/2016-12-16-leetcode-solution-Insertion-Sort-List-147/</url>
      <content type="html"><![CDATA[<p>Sort a linked list using insertion sort.</p>
<h3 id="解法1：Dummy-Node-Insertion-Sort-O-N-2"><a href="#解法1：Dummy-Node-Insertion-Sort-O-N-2" class="headerlink" title="解法1：Dummy Node, Insertion Sort O(N^2)"></a>解法1：Dummy Node, Insertion Sort O(N^2)</h3><p>这题一开始想不太清楚，但知道应该用dummy node。实际上，dummy node可以作为一个空的list，用一个指针（head）来记录当前想要插入的node，每一个node在dummy指向的list中找到位置后插入。<br>这样想就比较清晰了。用到的指针有</p>
<ol>
<li>cur 记录当前插入的node的指针</li>
<li>p 用来遍历已经排序好的dummy指向的那个list</li>
<li>head 用来遍历原list直到end</li>
</ol>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * struct ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode *next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> head;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="comment">// For each node, attach to dummy linked list</span></div><div class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">            ListNode* cur = head;</div><div class="line">            head = head-&gt;next;</div><div class="line"></div><div class="line">            ListNode* p = dummy;</div><div class="line">            <span class="keyword">while</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;val &lt;= cur-&gt;val) &#123;</div><div class="line">                p = p-&gt;next;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            cur-&gt;next = p-&gt;next;</div><div class="line">            p-&gt;next = cur;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        head = dummy-&gt;next;</div><div class="line">        <span class="keyword">delete</span> dummy;</div><div class="line">        <span class="keyword">return</span> head;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Linked List Cycle (141)]]></title>
      <url>/2016/12/15/2016-12-15-leetcode-solution-Linked-List-Cycle-141/</url>
      <content type="html"><![CDATA[<p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
<h3 id="解法1：O-1-Space-O-N-Time-Two-pointers"><a href="#解法1：O-1-Space-O-N-Time-Two-pointers" class="headerlink" title="解法1：O(1) Space + O(N) Time, Two pointers"></a>解法1：O(1) Space + O(N) Time, Two pointers</h3><p>此题初看可以用hashtable来解决，用一个指针一边跑一边放入hashtable，如果跑到见过的node⑩则知道有cycle。<br>由于follow up中提到了不能用extra space，所以考虑经典的two pointers算法。快慢指针，一个走一步一个走两步，如果在走完之前相遇的话就有cycle。<br>要注意的是输入的判定，如果为空list的话直接返回false<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * struct ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode *next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        ListNode* slow = head;</div><div class="line">        ListNode* fast = head-&gt;next;</div><div class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</div><div class="line">            slow = slow-&gt;next;</div><div class="line">            fast = fast-&gt;next-&gt;next;</div><div class="line">            <span class="keyword">if</span> (slow == fast) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Two pointers </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Group Shifted Strings (249)]]></title>
      <url>/2016/12/15/2016-12-15-leetcode-solution-Group-Shifted-Strings-249/</url>
      <content type="html"><![CDATA[<p>Given a string, we can “shift” each of its letter to its successive letter, for example: “abc” -&gt; “bcd”. We can keep “shifting” which forms the sequence:</p>
<p>“abc” -&gt; “bcd” -&gt; … -&gt; “xyz”<br>Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence.</p>
<p>For example, given: [“abc”, “bcd”, “acef”, “xyz”, “az”, “ba”, “a”, “z”],<br>A solution is:</p>
<p>[<br>  [“abc”,”bcd”,”xyz”],<br>  [“az”,”ba”],<br>  [“acef”],<br>  [“a”,”z”]<br>]</p>
<h3 id="解法1：Hash-Function-Hash-Table"><a href="#解法1：Hash-Function-Hash-Table" class="headerlink" title="解法1：Hash Function, Hash Table"></a>解法1：Hash Function, Hash Table</h3><p>此题一看就是用hashtable的一道题，但难点在于什么是hashtable的key，换句话说，要构造出一个function，使得grouped string有相同的key。<br>思考一下可以得出，如果将每个字符转化为和第一个字符的距离，变可以得出一样的key。这里要注意的是，difference可以是正也可以是负，那么就需要加上25或者是26之后再对26取余来做。<br>C++<br>涉及到了几个C++的syntax：</p>
<ul>
<li>access map value：iterator-&gt;second, iterator-&gt;first</li>
<li>insert to the end of a vector: vector.push_back()<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupStrings(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strings) &#123;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="built_in">map</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> str: strings) &#123;</div><div class="line">            <span class="built_in">string</span> s = <span class="string">""</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i : str) &#123;</div><div class="line">                s += <span class="built_in">std</span>::to_string((i - str[<span class="number">0</span>] + <span class="number">26</span>) % <span class="number">26</span>) + <span class="string">" "</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.find(s) != <span class="built_in">map</span>.end()) &#123;</div><div class="line">                <span class="built_in">map</span>[s].push_back(str);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</div><div class="line">                v.push_back(str);</div><div class="line">                <span class="built_in">map</span>[s] = v;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="built_in">map</span>.begin(); i != <span class="built_in">map</span>.end(); ++i) &#123;</div><div class="line">            res.push_back(i-&gt;second);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Hash table </tag>
            
            <tag> Hash function </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Convert Sorted List to Binary Search Tree (109)]]></title>
      <url>/2016/12/15/2016-12-15-leetcode-solution-Convert-Sorted-List-to-Binary-Search-Tree-109/</url>
      <content type="html"><![CDATA[<p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<h3 id="解法1：Divide-and-Conquer"><a href="#解法1：Divide-and-Conquer" class="headerlink" title="解法1：Divide and Conquer"></a>解法1：Divide and Conquer</h3><p>按照题意是要构造一个balanced的BST,那么root一定是sorted list的中间的一个点。所以想到了linkedlist求中间点的算法。<br>如果中间点求到了，那么可以将原list分成左右两个子list，对于每一个子list做相应的操作，左面的list就是左子树，右面的list就是右子树。这是一种分治的思想<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * struct ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode *next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(head-&gt;val);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ListNode* preMiddle = findPreMiddle(head);</div><div class="line">        ListNode* right = preMiddle-&gt;next-&gt;next;</div><div class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(preMiddle-&gt;next-&gt;val);</div><div class="line"></div><div class="line">        <span class="comment">// break left and right</span></div><div class="line">        preMiddle-&gt;next-&gt;next = <span class="literal">NULL</span>;</div><div class="line">        preMiddle-&gt;next = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">        TreeNode* leftTree = sortedListToBST(head);</div><div class="line">        TreeNode* rightTree = sortedListToBST(right);</div><div class="line">        root-&gt;left = leftTree;</div><div class="line">        root-&gt;right = rightTree;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">ListNode* <span class="title">findPreMiddle</span><span class="params">(ListNode* head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> head;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ListNode* slow = head;</div><div class="line">        ListNode* fast = head-&gt;next;</div><div class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</div><div class="line">            slow = slow-&gt;next;</div><div class="line">            fast = fast-&gt;next-&gt;next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> slow;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Lowest Common Ancestor of a Binary Search Tree (235)]]></title>
      <url>/2016/12/14/2016-12-14-leetcode-solution-Lowest-Common-Ancestor-of-a-Binary-Search-Tree-235/</url>
      <content type="html"><![CDATA[<p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”</p>
<p><strong>___</strong>6<strong>__</strong><br>/              \<br><strong>_2</strong>          <strong>_8</strong><br>/      \        /      \<br>0      _4       7       9<br>  /  \<br>  3   5<br>For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</p>
<h3 id="解法1：Recursion"><a href="#解法1：Recursion" class="headerlink" title="解法1：Recursion"></a>解法1：Recursion</h3><p>这题有一个很重要的前提是这是一棵BST。并且隐含条件是一定存在对于给点的两个node的LCA。<br>那么考虑两种情况，假设两个node的大小一个比root大一个比root小，则node分属于左右子树，LCA只可能是root<br>如果两个node同属一边，则问题也等价于在左子树（假设node的val比root的小），套用递归的思想解决即可。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (root == p || root == q) &#123;</div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) &#123;</div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) &#123;</div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val) &#123;</div><div class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (root == p || root == q) &#123;</div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> ((root.val &lt; p.val &amp;&amp; root.val &gt; q.val) || (root.val &gt; p.val &amp;&amp; root.val &lt; q.val)) &#123;</div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</div><div class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Ugly Number (263)]]></title>
      <url>/2016/12/14/2016-12-14-leetcode-solution-Ugly-Number-263/</url>
      <content type="html"><![CDATA[<p>Write a program to check whether a given number is an ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.</p>
<p>Note that 1 is typically treated as an ugly number.</p>
<h3 id="解法1：暴力法"><a href="#解法1：暴力法" class="headerlink" title="解法1：暴力法"></a>解法1：暴力法</h3><p>按照题意，ugly number一定是1，2，3，5几个数的乘积。那么用number不停的去整除2，3，5，如果发现不能整除，则不是ugly，如果能整除则继续直到为1或者出现不能整除的数为止。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (num != <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (num %<span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">                num /= <span class="number">2</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num % <span class="number">3</span> == <span class="number">0</span>) &#123;</div><div class="line">                num /= <span class="number">3</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num % <span class="number">5</span> == <span class="number">0</span>) &#123;</div><div class="line">                num /= <span class="number">5</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Reverse Linked List II (92)]]></title>
      <url>/2016/12/14/2016-12-14-leetcode-solution-Reverse-Linked-List-II-92/</url>
      <content type="html"><![CDATA[<p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p>
<p>For example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,</p>
<p>return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL.</p>
<p>Note:<br>Given m, n satisfy the following condition:<br>1 ≤ m ≤ n ≤ length of list.</p>
<h3 id="解法1：Two-pointers-One-Pass-O-N"><a href="#解法1：Two-pointers-One-Pass-O-N" class="headerlink" title="解法1：Two pointers, One Pass O(N)"></a>解法1：Two pointers, One Pass O(N)</h3><p>题目要求只能走一遍，所以考虑用双指针。同时需要考虑到的是，等reverse结束，我们的head是不确定的，在这种情况下我们考虑使用dummy node，将dummy node指向head，最后不管其中怎么变化，我们一定是返回dummy.next<br>假设我们已经知道从node m 到node n需要reverse，那么reverse之后由于要并入原来的list，我们需要知道子list的head之前的那个node，以及子list的尾巴之后的那个node， 比如：<br>1-&gt;2-&gt;3-&gt;4-&gt;5, if m = 2, n = 4<br>那么我们需要记录指针位置1和指针位置5，当把2-&gt;3-&gt;4翻转过后把新的head和tail指向这两个节点就可以了。<br>实现上维护two pointers和一个计数器，当right pointer移动到子list的head的时候，left pointer就自然而然的指向了前面的那个node，把子list的head记录为newtail，因为当reverse之后他会变成tail。<br>然后开始reverse的过程，同时变更计数器，直到计数器等于n的值为止。这个时候我们就得到了新的head，记录下一个值便是我们要将newtail指向的位置。最后返回dummy.next<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * struct ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode *next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (m == n) &#123;</div><div class="line">            <span class="keyword">return</span> head;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        dummy-&gt;next = head;</div><div class="line">        ListNode* ptr0 = dummy;</div><div class="line"></div><div class="line">        ListNode* newhead = <span class="literal">NULL</span>;</div><div class="line">        ListNode* newtail = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (count &lt; m) &#123;</div><div class="line">            ptr0 = ptr0-&gt;next;</div><div class="line">            head = head-&gt;next;</div><div class="line">            ++count;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        newtail = head;</div><div class="line">        ListNode* prev = head;</div><div class="line">        head = head-&gt;next;</div><div class="line">        ++count;</div><div class="line">        <span class="keyword">while</span> (count &lt;= n) &#123;</div><div class="line">            ListNode* temp = head-&gt;next;</div><div class="line">            head-&gt;next = prev;</div><div class="line">            prev = head;</div><div class="line">            head = temp;</div><div class="line">            ++count;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        newhead = prev;</div><div class="line"></div><div class="line">        ptr0-&gt;next = newhead;</div><div class="line">        newtail-&gt;next = head;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> dummy-&gt;next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题 : Path Sum III (437)]]></title>
      <url>/2016/12/13/2016-12-13-leetcode-solution-Path-Sum-III-437/</url>
      <content type="html"><![CDATA[<p>You are given a binary tree in which each node contains an integer value.</p>
<p>Find the number of paths that sum to a given value.</p>
<p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p>
<p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p>
<p>Example:</p>
<p>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</p>
<pre><code>  10
 /  \
5   -3
</code></pre><p>   / \    \<br>  3   2   11<br> / \   \<br>3  -2   1</p>
<p>Return 3. The paths that sum to 8 are:</p>
<ol>
<li>5 -&gt; 3</li>
<li>5 -&gt; 2 -&gt; 1</li>
<li>-3 -&gt; 11</li>
</ol>
<h3 id="解法1：DFS-Recursion"><a href="#解法1：DFS-Recursion" class="headerlink" title="解法1：DFS / Recursion"></a>解法1：DFS / Recursion</h3><p>这题考察DFS的基本知识。因为考虑的是每一个从上到下的path，那么应该要想到要用DFS。<br>对于每一个节点，如果包括自己，则可以递归运算left 和right，而要match的数则变成了sum - val。<br>如果不包括自己，则直接运算left和right，最后将两个情况相加就是结果。<br>实际上这里就是用了一个preorder遍历，回想一下preorder的算法：<br>visit root;<br>visit left;<br>visit right;<br>这里也一样：<br>visit root =&gt; compute number of paths with root (dfs(root, sum))<br>visit left =&gt; compute number of  paths with left (pathSum(root-&gt;left, sum))<br>visit right =&gt; compute number of paths with right (pathSum(root-&gt;right, sum))</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> left = pathSum(root-&gt;left, sum);</div><div class="line">        <span class="keyword">int</span> right = pathSum(root-&gt;right, sum);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> dfs(root, sum) + left + right;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (root-&gt;val == sum) &#123;</div><div class="line">            res++;</div><div class="line">        &#125;</div><div class="line">        res += dfs(root-&gt;left, sum - root-&gt;val);</div><div class="line">        res += dfs(root-&gt;right, sum - root-&gt;val);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> left = pathSum(root.left, sum);</div><div class="line">        <span class="keyword">int</span> right = pathSum(root.right, sum);</div><div class="line"></div><div class="line">        <span class="comment">// Count the number of paths starting from the current root</span></div><div class="line">        <span class="keyword">int</span> startingFromThisRoot = dfs(root, sum);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> startingFromThisRoot + left + right;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</div><div class="line">        <span class="keyword">if</span> (root.val == sum) ++res;</div><div class="line"></div><div class="line">        res += dfs(root.left, sum - root.val);</div><div class="line">        res += dfs(root.right, sum - root.val);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> DFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Strobogrammatic Number (246)]]></title>
      <url>/2016/12/13/2016-12-13-leetcode-solution-Strobogrammatic-Number-246/</url>
      <content type="html"><![CDATA[<p>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).</p>
<p>Write a function to determine if a number is strobogrammatic. The number is represented as a string.</p>
<p>For example, the numbers “69”, “88”, and “818” are all strobogrammatic.</p>
<h3 id="解法1：HashMap-Two-pointers-O-N"><a href="#解法1：HashMap-Two-pointers-O-N" class="headerlink" title="解法1：HashMap, Two pointers, O(N)"></a>解法1：HashMap, Two pointers, O(N)</h3><p>题目的意思是一个数倒过来之后和原数一样，那么满足这种性质的单个的数只有0，1，6，8，9. 其中6和9只能搭配使用.<br>本题用一个hashmap来存储对应的关系可以使解法变得比较干净. 6-&gt;9, 9-&gt;6, 0，1，8 对应自己。用两个指针，从两边往中间扫描，只有经过映射后的数值相等的情况下颠倒才能保持原数。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isStrobogrammatic</span><span class="params">(<span class="built_in">string</span> num)</span> </span>&#123;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; <span class="built_in">map</span>;</div><div class="line">        <span class="built_in">map</span>[<span class="string">'0'</span>] = <span class="string">'0'</span>;</div><div class="line">        <span class="built_in">map</span>[<span class="string">'1'</span>] = <span class="string">'1'</span>;</div><div class="line">        <span class="built_in">map</span>[<span class="string">'6'</span>] = <span class="string">'9'</span>;</div><div class="line">        <span class="built_in">map</span>[<span class="string">'8'</span>] = <span class="string">'8'</span>;</div><div class="line">        <span class="built_in">map</span>[<span class="string">'9'</span>] = <span class="string">'6'</span>;</div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = num.length() - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[num[left]] != num[right]) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">            ++left;</div><div class="line">            --right;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Rotate List (61)]]></title>
      <url>/2016/12/13/2016-12-13-leetcode-solution-Rotate-List-61/</url>
      <content type="html"><![CDATA[<p>Given a list, rotate the list to the right by k places, where k is non-negative.</p>
<p>For example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,<br>return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.</p>
<h3 id="解法1：Two-pointers-O-N"><a href="#解法1：Two-pointers-O-N" class="headerlink" title="解法1：Two pointers, O(N)"></a>解法1：Two pointers, O(N)</h3><p>这题考的是Linkedlist的基本操作。可以容易看到只要把最后k个元素作为字串挪到list的头部即可。<br>实际操作可以维护两个指针，同时向右移动，让左指针指向新的头部，右指针指向衔接的地方。<br>要注意的操作就是k可能会大于linkedlist的长度，那么需要多一个取余操作。<br>还有对输入的数据范围也需要进行判断，NULL linkedlist直接返回，取余后为0的k也直接返回原list。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * struct ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode *next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> len = getLength(head);</div><div class="line">        k = k % len;</div><div class="line">        ListNode left = head;</div><div class="line">        ListNode right = head;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (count &lt; k) &#123;</div><div class="line">            right = right-&gt;next;</div><div class="line">            ++count;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (right-&gt;next != <span class="literal">NULL</span>) &#123;</div><div class="line">            left = left-&gt;next;</div><div class="line">            right = right-&gt;next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ListNode* res = left-&gt;next;</div><div class="line">        left-&gt;next = <span class="literal">NULL</span>;</div><div class="line">        right-&gt;next = head;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode* head)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">            ++count;</div><div class="line">            head = head-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode解题: happy number (202)]]></title>
      <url>/2016/12/12/2016-12-12-Leetcode-solution-happy-number-202/</url>
      <content type="html"><![CDATA[<p>Write an algorithm to determine if a number is “happy”.</p>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>
<p>Example: 19 is a happy number</p>
<p>12 + 92 = 82<br>82 + 22 = 68<br>62 + 82 = 100<br>12 + 02 + 02 = 1</p>
<h3 id="解法1：hashmap"><a href="#解法1：hashmap" class="headerlink" title="解法1：hashmap"></a>解法1：hashmap</h3><p>这里需要判断重复的情况，想到用hashmap来存储已经计算过的值。对每一个未访问过的数值，计算位数的平方和。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; <span class="built_in">map</span>;</div><div class="line">        <span class="keyword">while</span> (n != <span class="number">1</span>) &#123;</div><div class="line">            <span class="built_in">map</span>[n] = <span class="literal">true</span>;</div><div class="line">            <span class="keyword">int</span> temp = digitSquareSum(n);</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[temp]) &#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</div><div class="line">            n = temp;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">digitSquareSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> n;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">int</span> digit = n % <span class="number">10</span>;</div><div class="line">            sum += digit * digit;</div><div class="line">            n /= <span class="number">10</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法2：观察规律"><a href="#解法2：观察规律" class="headerlink" title="解法2：观察规律"></a>解法2：观察规律</h3><p>看到别人的解法里有这么一个巧妙的方法：可以试试几个会出现loop的数，最后都会出现4。结论是：所有最终会有4的都不是happy number，这样我们就可以把额外的空间要求去除了。<br>例子如下：<br>1^2 + 1^2 = 2<br>2^2 = 4<br>4^2 = 16<br>1^2 + 6^2 = 37<br>3^2 + 7^2 = 58<br>5^2 + 8^2 = 89<br>8^2 + 9^2 = 145<br>1^2 + 4^2 + 5^2 = 42<br>4^2 + 2^2 = 20<br>2^2 + 0^2 = 4</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; n != <span class="number">4</span>) &#123;</div><div class="line">            <span class="keyword">int</span> t = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span> (n) &#123;</div><div class="line">                t += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</div><div class="line">                n /= <span class="number">10</span>;</div><div class="line">            &#125;</div><div class="line">            n = t;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode解题: Power of Three (326)]]></title>
      <url>/2016/12/12/2016-12-12-Leetcode-Solution-Power-of-Three-326/</url>
      <content type="html"><![CDATA[<p>Given an integer, write a function to determine if it is a power of three.</p>
<p>Follow up:<br>Could you do it without using any loop / recursion?</p>
<h3 id="解法1：Loop"><a href="#解法1：Loop" class="headerlink" title="解法1：Loop"></a>解法1：Loop</h3><p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">while</span> ( n &gt;= <span class="number">3</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (n % <span class="number">3</span> != <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">            n  = n / <span class="number">3</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法2：Follow-up"><a href="#解法2：Follow-up" class="headerlink" title="解法2：Follow up"></a>解法2：Follow up</h3><p>如果一个数是3^x，那么以3为底数做log，结果一定是整数。运用log3(x) = log10(x) / log10(3)<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">      <span class="keyword">double</span> res = <span class="built_in">log10</span>(n) / <span class="built_in">log10</span>(<span class="number">3</span>);</div><div class="line">      <span class="keyword">return</span> (res - (<span class="keyword">int</span>)res) == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode解题: Add Two Numbers II (445)]]></title>
      <url>/2016/12/12/2016-12-12-Leetcode-Solution-Add-Two-Numbers-II-445/</url>
      <content type="html"><![CDATA[<p>You are given two linked lists representing two non-negative numbers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>Follow up:<br>What if you cannot modify the input lists? In other words, reversing the lists is not allowed.</p>
<p>Example:</p>
<p>Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 8 -&gt; 0 -&gt; 7</p>
<h3 id="解法1：Reverse-两数相加"><a href="#解法1：Reverse-两数相加" class="headerlink" title="解法1：Reverse + 两数相加"></a>解法1：Reverse + 两数相加</h3><p>因为list的头是最高位，我们要相加是从最低位开始加，所以如果能先反转的话比较容易做。分别reverse再求和，最后把结果list再reverse一下就可以了。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * struct ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode *next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> l2;</div><div class="line">        &#125;   </div><div class="line"></div><div class="line">        <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> l1;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        l1 = reverse(l1);</div><div class="line">        l2 = reverse(l2);</div><div class="line"></div><div class="line">        <span class="comment">// normal algorithm</span></div><div class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode* tail = dummy;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">int</span> temp = l1-&gt;val + l2-&gt;val + carry;</div><div class="line">            <span class="keyword">int</span> digit = temp % <span class="number">10</span>;</div><div class="line">            carry = temp / <span class="number">10</span>;</div><div class="line">            ListNode* node = <span class="keyword">new</span> ListNode(digit);</div><div class="line">            tail-&gt;next = node;</div><div class="line">            tail = tail-&gt;next;</div><div class="line">            l1 = l1-&gt;next;</div><div class="line">            l2 = l2-&gt;next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (l1 != <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">int</span> temp = l1-&gt;val + carry;</div><div class="line">            ListNode* node = <span class="keyword">new</span> ListNode(temp % <span class="number">10</span>);</div><div class="line">            carry = temp / <span class="number">10</span>;</div><div class="line">            tail-&gt;next = node;</div><div class="line">            tail = tail-&gt;next;</div><div class="line">            l1 = l1-&gt;next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (l2 != <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">int</span> temp = l2-&gt;val + carry;</div><div class="line">            ListNode* node = <span class="keyword">new</span> ListNode(temp % <span class="number">10</span>);</div><div class="line">            carry = temp / <span class="number">10</span>;</div><div class="line">            tail-&gt;next = node;</div><div class="line">            tail = tail-&gt;next;</div><div class="line">            l2 = l2-&gt;next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</div><div class="line">            ListNode* node = <span class="keyword">new</span> ListNode(carry);</div><div class="line">            tail-&gt;next = node;</div><div class="line">            tail = tail-&gt;next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// reverse back</span></div><div class="line">        ListNode* res = reverse(dummy-&gt;next);</div><div class="line">        <span class="keyword">delete</span> dummy;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span> </span>&#123;</div><div class="line">        ListNode* prev = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">            ListNode* temp = head-&gt;next;</div><div class="line">            head-&gt;next = prev;</div><div class="line">            prev = head;</div><div class="line">            head = temp;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> prev;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法2：-Follow-up-O-N-Time-and-Space"><a href="#解法2：-Follow-up-O-N-Time-and-Space" class="headerlink" title="解法2： Follow up O(N) Time and Space"></a>解法2： Follow up O(N) Time and Space</h3><p>从list的最后加，如果不能反转，需要想到有一种数据结构是可以从后往前存储的，那就是stack。<br>用两个stack保存每一个队列的node，然后往回加。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * struct ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode *next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; left;</div><div class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; right;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (l1 != <span class="literal">NULL</span>) &#123;</div><div class="line">            left.push(l1);</div><div class="line">            l1 = l1-&gt;next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (l2 != <span class="literal">NULL</span>) &#123;</div><div class="line">            right.push(l2);</div><div class="line">            l2 = l2-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</div><div class="line"></div><div class="line">        ListNode* res = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">while</span> (!left.empty() &amp;&amp; !right.empty()) &#123;</div><div class="line">            ListNode* leftnode = left.top();</div><div class="line">            ListNode* rightnode = right.top();</div><div class="line">            <span class="keyword">int</span> temp = leftnode-&gt;val + rightnode-&gt;val + carry;</div><div class="line">            <span class="keyword">int</span> digit = temp % <span class="number">10</span>;</div><div class="line">            carry = temp / <span class="number">10</span>;</div><div class="line">            ListNode* node = <span class="keyword">new</span> ListNode(digit);</div><div class="line">            node-&gt;next = res;</div><div class="line">            res = node;</div><div class="line">            left.pop();</div><div class="line">            right.pop();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (!left.empty()) &#123;</div><div class="line">            ListNode* leftnode = left.top();</div><div class="line">            <span class="keyword">int</span> temp = leftnode-&gt;val + carry;</div><div class="line">            <span class="keyword">int</span> digit = temp % <span class="number">10</span>;</div><div class="line">            carry = temp / <span class="number">10</span>;</div><div class="line">            ListNode* node = <span class="keyword">new</span> ListNode(digit);</div><div class="line">            node-&gt;next = res;</div><div class="line">            res = node;</div><div class="line">            left.pop();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (!right.empty()) &#123;</div><div class="line">            ListNode* rightnode = right.top();</div><div class="line">            <span class="keyword">int</span> temp = rightnode-&gt;val + carry;</div><div class="line">            <span class="keyword">int</span> digit = temp % <span class="number">10</span>;</div><div class="line">            carry = temp / <span class="number">10</span>;</div><div class="line">            ListNode* node = <span class="keyword">new</span> ListNode(digit);</div><div class="line">            node-&gt;next = res;</div><div class="line">            res = node;</div><div class="line">            right.pop();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</div><div class="line">            ListNode* node = <span class="keyword">new</span> ListNode(carry);</div><div class="line">            node-&gt;next = res;</div><div class="line">            res = node;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Remove Duplicates from Sorted List (83)]]></title>
      <url>/2016/12/06/2016-12-06-leetcode-solution-Remove-Duplicates-from-Sorted-List-83/</url>
      <content type="html"><![CDATA[<p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p>For example,<br>Given 1-&gt;1-&gt;2, return 1-&gt;2.<br>Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.</p>
<p>Hide Tags</p>
<h3 id="解法1：Two-pointers-O-N"><a href="#解法1：Two-pointers-O-N" class="headerlink" title="解法1：Two pointers O(N)"></a>解法1：Two pointers O(N)</h3><p>用双指针，比较两node的值，如果相等，则前面的指针跳过下一个node（删除后一个node）。如果不相等，则两个指针同时向后移动直到尾部。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * struct ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode *next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> head;</div><div class="line">        &#125;</div><div class="line">        ListNode* res = head;</div><div class="line">        ListNode* ptr = head-&gt;next;</div><div class="line">        <span class="keyword">while</span> (ptr != <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (head-&gt;val == ptr-&gt;val) &#123;</div><div class="line">                ListNode* temp = ptr;</div><div class="line">                head-&gt;next = ptr-&gt;next;</div><div class="line">                <span class="keyword">delete</span> temp;</div><div class="line">                ptr = head-&gt;next;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                head = head-&gt;next;</div><div class="line">                ptr = ptr-&gt;next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> 基础算法 </tag>
            
            <tag> Linkedlist </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Merge Two Sorted List (21)]]></title>
      <url>/2016/12/06/2016-12-06-leetcode-solution-Merge-Two-Sorted-List-21/</url>
      <content type="html"><![CDATA[<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<h3 id="解法1：Dummy-Node-O-N-M"><a href="#解法1：Dummy-Node-O-N-M" class="headerlink" title="解法1：Dummy Node O(N + M)"></a>解法1：Dummy Node O(N + M)</h3><p>对于head不明确的linkedlist的题目，都考虑建立Dummy Node，然后返回Dummy-&gt;next的办法解决。<br>C++<br>用C++注意在最后需要delete掉dummy防止memory leak<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * struct ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode *next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</div><div class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode* tail = dummy;</div><div class="line">        <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;</div><div class="line">                tail-&gt;next = l1;</div><div class="line">                l1 = l1-&gt;next;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                tail-&gt;next = l2;</div><div class="line">                l2 = l2-&gt;next;</div><div class="line">            &#125;</div><div class="line">            tail = tail-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (l1 != <span class="literal">NULL</span>) &#123;</div><div class="line">            tail-&gt;next = l1;</div><div class="line">            l1 = l1-&gt;next;</div><div class="line">            tail = tail-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (l2 != <span class="literal">NULL</span>) &#123;</div><div class="line">            tail-&gt;next = l2;</div><div class="line">            l2 = l2-&gt;next;</div><div class="line">            tail = tail-&gt;next;</div><div class="line">        &#125;</div><div class="line">        ListNode* res = dummy-&gt;next;</div><div class="line">        <span class="keyword">delete</span> dummy;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> 基础算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Repeated Substring Pattern (459)]]></title>
      <url>/2016/12/06/2016-12-06-leetcode-solution-Repeated-Substring-Pattern-459/</url>
      <content type="html"><![CDATA[<p>Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.</p>
<p>Example 1:<br>Input: “abab”</p>
<p>Output: True</p>
<p>Explanation: It’s the substring “ab” twice.<br>Example 2:<br>Input: “aba”</p>
<p>Output: False<br>Example 3:<br>Input: “abcabcabcabc”</p>
<p>Output: True</p>
<p>Explanation: It’s the substring “abc” four times. (And the substring “abcabc” twice.)</p>
<h3 id="解法1：O-k-N-k是n的约数个数，n是字符串的长度"><a href="#解法1：O-k-N-k是n的约数个数，n是字符串的长度" class="headerlink" title="解法1：O(k * N), k是n的约数个数，n是字符串的长度"></a>解法1：O(k * N), k是n的约数个数，n是字符串的长度</h3><p>由于要分成相同的几个字串相连，那么字串的长度一定是原字符串的一个约数。这种情况下，约数的个数是有限制的，1 到 n / 2。<br>暴力解法，从n/2到1一个一个试，然后拼接出原字符长度比较。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (str.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">int</span> n = str.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) &#123;</div><div class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</div><div class="line">                <span class="built_in">string</span> sub = str.substr(<span class="number">0</span>, i);</div><div class="line">                <span class="built_in">string</span> copy = <span class="string">""</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (n / i); ++j) &#123;</div><div class="line">                    copy += sub;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (str.compare(copy) == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法2：-KMP-with-O-N-Time"><a href="#解法2：-KMP-with-O-N-Time" class="headerlink" title="解法2： KMP with O(N) Time"></a>解法2： KMP with O(N) Time</h3><p>本题还有KMP的解法，显然不是我想出来的。先把网上看到的解释贴在这里。<br>用到的关于<a href="http://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="external">KMP</a>的算法的详细说明。<br>深深的怀疑面试会期望给出这个答案。。<br>还有是关于本题的<a href="http://www.cnblogs.com/grandyang/p/6087347.html" target="_blank" rel="external">解释</a></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> KMP </tag>
            
            <tag> Unfinished </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Number of Segments in a String (434)]]></title>
      <url>/2016/12/06/2016-12-06-leetcode-solution-Number-of-Segments-in-a-String-434/</url>
      <content type="html"><![CDATA[<p>Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters.</p>
<p>Please note that the string does not contain any non-printable characters.</p>
<p>Example:</p>
<p>Input: “Hello, my name is John”<br>Output: 5</p>
<h3 id="解法1：O-N"><a href="#解法1：O-N" class="headerlink" title="解法1：O(N)"></a>解法1：O(N)</h3><p>按每一个segment的开头来判断一个segment的开始。</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSegments</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (s[i] != <span class="string">' '</span> &amp;&amp; (i == <span class="number">0</span> || s[i - <span class="number">1</span>] == <span class="string">' '</span>)) &#123;</div><div class="line">                ++res;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Number of Boomerangs (447)]]></title>
      <url>/2016/12/04/2016-12-04-leetcode-solution-Number-of-Boomerangs-447/</url>
      <content type="html"><![CDATA[<p>Given n points in the plane that are all pairwise distinct, a “boomerang” is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).</p>
<p>Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive).</p>
<p>Example:<br>Input:<br>[[0,0],[1,0],[2,0]]</p>
<p>Output:<br>2</p>
<p>Explanation:<br>The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]</p>
<h3 id="解法1：O-N-2"><a href="#解法1：O-N-2" class="headerlink" title="解法1：O(N^2)"></a>解法1：O(N^2)</h3><p>排列组合的题。假设有a,b,c。如果bc和a的距离相等，那么可以产生abc或者acb两种排列。如果是bcd和a的距离相等，那么可以产生6种排列。对于有n个数和a相等的情况，总共的个数是n*(n-1)。<br>那么问题就转化为，对于每一个pair作为a，计算每一种距离的pair的个数，然后再把总和相加就是答案。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfBoomerangs</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (points.size() &lt; <span class="number">3</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size(); ++i) &#123;</div><div class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; points.size(); ++j) &#123;</div><div class="line">                <span class="keyword">if</span> (i == j) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">int</span> x = points[i].first - points[j].first;</div><div class="line">                <span class="keyword">int</span> y = points[i].second - points[j].second;</div><div class="line">                ++<span class="built_in">map</span>[x * x + y * y];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> iter = <span class="built_in">map</span>.begin(); iter != <span class="built_in">map</span>.end(); ++iter) &#123;</div><div class="line">                res += iter-&gt;second * (iter-&gt;second - <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfBoomerangs</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (points == <span class="keyword">null</span> || points.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (points[<span class="number">0</span>] == <span class="keyword">null</span> || points[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="comment">// Do the calculation</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</div><div class="line">            HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();    <span class="comment">// record the count of each distance between two points</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; points.length; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</div><div class="line">                <span class="keyword">int</span> x = points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>];</div><div class="line">                <span class="keyword">int</span> y = points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>];</div><div class="line">                <span class="keyword">int</span> dist = x * x + y * y;</div><div class="line">                map.put(dist, map.getOrDefault(dist, <span class="number">0</span>) + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> key : map.keySet()) &#123;</div><div class="line">                res += map.get(key) * (map.get(key) - <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Roman to Integer (13)]]></title>
      <url>/2016/12/04/2016-12-04-leetcode-solution-Roman-to-Integer-13/</url>
      <content type="html"><![CDATA[<p>Given a roman numeral, convert it to an integer.<br>Input is guaranteed to be within the range from 1 to 3999.</p>
<h3 id="解法1：O-N-Time"><a href="#解法1：O-N-Time" class="headerlink" title="解法1：O(N) Time"></a>解法1：O(N) Time</h3><p>Roman to Integer 是较容易的。需要记忆的是几个关键的Roman字母和数值的对应关系。<br>从后往前扫描，如果前面的数值比后面的数值小，则需要减去，否则加上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">| I | V | X  | L | C | D | M  |</div><div class="line">|---|---|----|---|---|---|--- |</div><div class="line">| 1 | 5 | 10 |50 |100|500|1000|</div></pre></td></tr></table></figure></p>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">  public:</div><div class="line">  int romanToInt(string s) &#123;</div><div class="line">      if (s.empty()) &#123;</div><div class="line">          return 0;</div><div class="line">      &#125;</div><div class="line">      int res = 0;</div><div class="line">      res += romans[toupper(s[s.size() - 1])];</div><div class="line">      for (int i = s.size() - 2; i &gt;= 0; --i) &#123;</div><div class="line">          if (romans[toupper(s[i])] &lt; romans[toupper(s[i + 1])]) &#123;</div><div class="line">              res -= romans[toupper(s[i])];</div><div class="line">          &#125; else &#123;</div><div class="line">              res += romans[toupper(s[i])];</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      return res;</div><div class="line">  &#125;</div><div class="line">  private:</div><div class="line">    unordered_map&lt;char, int&gt; romans &#123;&#123;&apos;I&apos;,1&#125;,&#123;&apos;V&apos;,5&#125;,&#123;&apos;X&apos;,10&#125;, &#123;&apos;L&apos;,50&#125;, &#123;&apos;C&apos;, 100&#125;, &#123;&apos;D&apos;,500&#125;, &#123;&apos;M&apos;,1000&#125;&#125;;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Number of 1 Bits (191)]]></title>
      <url>/2016/12/04/2016-12-04-leetcode-solution-Number-of-1-Bits-191/</url>
      <content type="html"><![CDATA[<p>Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).</p>
<p>For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3.</p>
<h3 id="解法1：O-M-M-is-number-of-total-set-bits"><a href="#解法1：O-M-M-is-number-of-total-set-bits" class="headerlink" title="解法1：O(M) M is number of total set bits"></a>解法1：O(M) M is number of total set bits</h3><p>运用n &amp; (n -1)消掉最高位的set bit的思想，可以不停重复这个操作直到n变为0，<br>这样的复杂度可以减少为所有1的个数<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</div><div class="line">            ++count;</div><div class="line">            n = n &amp; (n - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="解法2：O-N-N-is-number-of-total-bits"><a href="#解法2：O-N-N-is-number-of-total-bits" class="headerlink" title="解法2：O(N) N is number of total bits"></a>解法2：O(N) N is number of total bits</h3><p>用右移的方法来判断每一位是否是1直到n变为0<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</div><div class="line">            res += n &amp; <span class="number">1</span>;</div><div class="line">            n =  n &gt;&gt; <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Bit Manipulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Add Strings (415)]]></title>
      <url>/2016/12/04/2016-12-04-leetcode-solution-Add-Strings-415/</url>
      <content type="html"><![CDATA[<p>Given two non-negative numbers num1 and num2 represented as string, return the sum of num1 and num2.</p>
<p>Note:</p>
<p>The length of both num1 and num2 is &lt; 5100.<br>Both num1 and num2 contains only digits 0-9.<br>Both num1 and num2 does not contain any leading zero.<br>You must not use any built-in BigInteger library or convert the inputs to integer directly.<br>Show Company Tags<br>Show Tags<br>Show Similar Problems</p>
<h3 id="解法1：Two-pointers-O-N-M-Time"><a href="#解法1：Two-pointers-O-N-M-Time" class="headerlink" title="解法1：Two pointers, O(N + M) Time"></a>解法1：Two pointers, O(N + M) Time</h3><p>经典的两数相加问题，主要的考察就是每一位上怎么计算digit和carry。digit = (temp + carry) % 10, carry = (temp + carry) / 10;<br>容易忘记的几个点：</p>
<ol>
<li>如果两个string的长度不相等，最后要遍历剩下较长的string</li>
<li>最后要判断carry是否为0，如果不是，要在string的最前面加上carry的值</li>
</ol>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><p>C++ 里的几个用法：</p>
<ul>
<li>char&amp; to int: 只能用c - ‘0’这种办法</li>
<li>int to string: 在c++ 11里有std::to_string 的函数，用法为std::to_string(string&amp; s)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (num1.empty()) &#123;</div><div class="line">            <span class="keyword">return</span> num2;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (num2.empty()) &#123;</div><div class="line">            <span class="keyword">return</span> num1;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</div><div class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> i, j;</div><div class="line">        <span class="keyword">for</span> (i = num1.size() - <span class="number">1</span>, j = num2.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; --i, --j) &#123;</div><div class="line">            <span class="keyword">int</span> temp = num1[i] - <span class="string">'0'</span> + num2[j] - <span class="string">'0'</span>;</div><div class="line">            <span class="keyword">int</span> digit = (temp + carry) % <span class="number">10</span>;</div><div class="line">            carry = (temp + carry) / <span class="number">10</span>;</div><div class="line">            res = to_string(digit) + res;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; --i) &#123;</div><div class="line">            <span class="keyword">int</span> temp = num1[i] - <span class="string">'0'</span>;</div><div class="line">            <span class="keyword">int</span> digit = (temp + carry) % <span class="number">10</span>;</div><div class="line">            carry = (temp + carry) / <span class="number">10</span>;</div><div class="line">            res = to_string(digit) + res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j) &#123;</div><div class="line">            <span class="keyword">int</span> temp = num2[j]  - <span class="string">'0'</span>;</div><div class="line">            <span class="keyword">int</span> digit = (temp + carry) % <span class="number">10</span>;</div><div class="line">            carry = (temp + carry) / <span class="number">10</span>;</div><div class="line">            res = to_string(digit) + res;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</div><div class="line">            res = to_string(carry) + res;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Binary Watch (401)]]></title>
      <url>/2016/12/04/2016-12-04-leetcode-solution-Binary-Watch-401/</url>
      <content type="html"><![CDATA[<p>A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).</p>
<p>Each LED represents a zero or one, with the least significant bit on the right.</p>
<p>For example, the above binary watch reads “3:25”.</p>
<p>Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.</p>
<p>Example:</p>
<p>Input: n = 1<br>Return: [“1:00”, “2:00”, “4:00”, “8:00”, “0:01”, “0:02”, “0:04”, “0:08”, “0:16”, “0:32”]<br>Note:<br>The order of output does not matter.<br>The hour must not contain a leading zero, for example “01:00” is not valid, it should be “1:00”.<br>The minute must be consist of two digits and may contain a leading zero, for example “10:2” is not valid, it should be “10:02”.</p>
<h3 id="解法1：Backtracking-Recursion"><a href="#解法1：Backtracking-Recursion" class="headerlink" title="解法1：Backtracking/Recursion"></a>解法1：Backtracking/Recursion</h3><p>好久没有写backtracking的题目了,搞了好久才搞出来。code也不一定简略但好歹是过了OA。<br>基本思路就是建立两个vector存储可能的时针值和分针值，然后记录已经用过的时针值和分针值。<br>要注意的是要去重，所以我用了一个unordered_set来记录当前所有的答案，如果有重复的则不插入。<br>另外要判断时针和分针的有效性。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; readBinaryWatch(<span class="keyword">int</span> num) &#123;</div><div class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &#123;<span class="string">"0:00"</span> &#125;;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; hour_used(hours.size(), <span class="literal">false</span>);</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; minute_used(minutes.size(), <span class="literal">false</span>);</div><div class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; resSet;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</div><div class="line">        helper(num, <span class="number">0</span>, <span class="number">0</span>, hour_used, minute_used, resSet);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter = resSet.begin(); iter != resSet.end(); ++iter) &#123;</div><div class="line">            res.emplace_back(*iter);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">std</span>::sort(res.begin(), res.end());</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> hour, <span class="keyword">int</span> minute, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; hour_used, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; minute_used, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span> </span>&#123;</div><div class="line">        <span class="comment">// Termination condition</span></div><div class="line">        <span class="keyword">if</span> (hour &gt; <span class="number">11</span> || minute &gt; <span class="number">59</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">string</span> s;</div><div class="line">            <span class="keyword">if</span> (minute &lt; <span class="number">10</span>) &#123;</div><div class="line">                s = to_string(hour) + <span class="string">":0"</span> + to_string(minute);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                s = to_string(hour) + <span class="string">":"</span> + to_string(minute);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (res.find(s) == res.end()) &#123;</div><div class="line">                res.emplace(s);    </div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hours.size(); ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (!hour_used[i]) &#123;</div><div class="line">                hour_used[i] = <span class="literal">true</span>;</div><div class="line">                helper(num - <span class="number">1</span>, hour + hours[i], minute, hour_used, minute_used, res);</div><div class="line">                hour_used[i] = <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minutes.size(); ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (!minute_used[i]) &#123;</div><div class="line">                minute_used[i] = <span class="literal">true</span>;</div><div class="line">                helper(num <span class="number">-1</span>, hour, minute + minutes[i], hour_used, minute_used, res);    </div><div class="line">                minute_used[i] = <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hours &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>&#125;;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minutes &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>&#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Backtracking </tag>
            
            <tag> DFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Power of Two (231)]]></title>
      <url>/2016/12/03/2016-12-03-leetcode-solution-Power-of-Two-231/</url>
      <content type="html"><![CDATA[<p>Given an integer, write a function to determine if it is a power of two.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>经典的算法，如果是pot，那么只有最高位为1，如果将此数减1之后再和原来的数取AND，结果一定为0.<br>要注意的是要规避：1. 负数 2. 0<br>这两种情况都不是power of two<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (n &amp; ( n - <span class="number">1</span>)) == <span class="number">0</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Reverse Linked List (206)]]></title>
      <url>/2016/12/03/2016-12-03-leetcode-solution-Reverse-Linked-List-206/</url>
      <content type="html"><![CDATA[<p>Reverse a singly linked list.<br>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<h3 id="解法1：Iteratively"><a href="#解法1：Iteratively" class="headerlink" title="解法1：Iteratively"></a>解法1：Iteratively</h3><p>经典的答案，没啥好说的。要背下来。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * struct ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode *next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</div><div class="line">        ListNode* ptr = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">            ListNode* temp = head-&gt;next;</div><div class="line">            head-&gt;next = ptr;</div><div class="line">            ptr = head;</div><div class="line">            head = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ptr;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法2：-Recursively"><a href="#解法2：-Recursively" class="headerlink" title="解法2： Recursively"></a>解法2： Recursively</h3><p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> head;</div><div class="line">        &#125;</div><div class="line">        ListNode* newhead = reverseList(head-&gt;next);</div><div class="line">        head-&gt;next-&gt;next = head;</div><div class="line">        head-&gt;next = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">return</span> newhead;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> 基础算法 </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Intersection of Two Arrays II (350)]]></title>
      <url>/2016/12/03/2016-12-03-leetcode-solution-Intersection-of-Two-Arrays-II-350/</url>
      <content type="html"><![CDATA[<p>Given two arrays, write a function to compute their intersection.</p>
<p>Example:<br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].</p>
<p>Note:<br>Each element in the result should appear as many times as it shows in both arrays.<br>The result can be in any order.<br>Follow up:<br>What if the given array is already sorted? How would you optimize your algorithm?<br>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?<br>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</p>
<h3 id="解法1：HashTable-O-N-Space-O-N-M-Time"><a href="#解法1：HashTable-O-N-Space-O-N-M-Time" class="headerlink" title="解法1：HashTable O(N) Space + O(N + M) Time"></a>解法1：HashTable O(N) Space + O(N + M) Time</h3><p>将其中一个构建hashtable，记录每个数字出现的次数。扫描第二个数组，每当找到一样的次数大于0的数字则加入res，加入结束以后需要将hashtable中出现次数-1<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums1) &#123;</div><div class="line">            ++<span class="built_in">map</span>[num];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums2) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[num] &gt; <span class="number">0</span>) &#123;</div><div class="line">                res.emplace_back(num);</div><div class="line">                --<span class="built_in">map</span>[num];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="Follow-up："><a href="#Follow-up：" class="headerlink" title="Follow up："></a>Follow up：</h3><p>如果是已经排序了的数组，那么不需要用hashtable，可以用two pointers解决。简化到了O(N + M) TIME + O(1) Space<br>对于follow up的回答：这个<a href="http://buttercola.blogspot.com/2016/06/leetcode-intersection-of-two-arrays-ii.html" target="_blank" rel="external">blog</a>给了挺好的答案。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line">pubic：</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</div><div class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">      <span class="keyword">int</span> ptr1 =<span class="number">0</span>, ptr2 = <span class="number">0</span>;</div><div class="line">      <span class="keyword">while</span> (ptr1 &lt; nums1.size() &amp;&amp; ptr2 &lt; nums2.size()) &#123;</div><div class="line">        <span class="keyword">if</span> (nums1[ptr1] &lt; nums2[ptr2]) &#123;</div><div class="line">          ++ptr1;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[ptr1] &gt; nums2[ptr2]) &#123;</div><div class="line">          ++ptr2;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        res.emplace_back(nums1[ptr1]);</div><div class="line">        ++ptr1;</div><div class="line">        ++ptr2;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Contains Duplicate (217)]]></title>
      <url>/2016/12/03/2016-12-03-leetcode-solution-Contains-Duplicate-217/</url>
      <content type="html"><![CDATA[<p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<h3 id="解法1：Hashtable"><a href="#解法1：Hashtable" class="headerlink" title="解法1：Hashtable"></a>解法1：Hashtable</h3><p>很直观的用Hashtable的题，对每一个int记录出现的次数，一但出现多余1则返回true。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</div><div class="line">            ++<span class="built_in">map</span>[num];</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[num] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Longest Palindrome (409)]]></title>
      <url>/2016/12/03/2016-12-03-leetcode-solution-Longest-Palindrome-409/</url>
      <content type="html"><![CDATA[<p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.</p>
<p>This is case sensitive, for example “Aa” is not considered a palindrome here.</p>
<p>Note:<br>Assume the length of given string will not exceed 1,010.</p>
<p>Example:</p>
<p>Input:<br>“abccccdd”</p>
<p>Output:<br>7</p>
<p>Explanation:<br>One longest palindrome that can be built is “dccaccd”, whose length is 7.</p>
<h3 id="解法1：Hashtable"><a href="#解法1：Hashtable" class="headerlink" title="解法1：Hashtable"></a>解法1：Hashtable</h3><p>统计每个字母的出现次数：<br>  若字母出现偶数次，则直接累加至最终结果<br>  若字母出现奇数次，则将其值-1之后累加至最终结果<br>  若存在出现奇数次的字母，将最终结果+1<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: s) &#123;</div><div class="line">            ++<span class="built_in">map</span>[c];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> maxOdd = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> oddSum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter = <span class="built_in">map</span>.begin(); iter != <span class="built_in">map</span>.end(); ++iter) &#123;</div><div class="line">            <span class="keyword">if</span> (iter-&gt;second % <span class="number">2</span> == <span class="number">0</span>) res+= iter-&gt;second;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                maxOdd = max(iter-&gt;second, maxOdd);</div><div class="line">                oddSum += iter-&gt;second - <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (maxOdd &gt; <span class="number">0</span>) &#123;</div><div class="line">            oddSum++;</div><div class="line">        &#125;</div><div class="line">        res += oddSum;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : s.toCharArray()) &#123;</div><div class="line">            map.put(ch, map.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">                <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">boolean</span> oddFlag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> key : map.keySet()) &#123;</div><div class="line">            <span class="keyword">if</span> (map.get(key) % <span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">                res += map.get(key);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                res += map.get(key) - <span class="number">1</span>;</div><div class="line">                oddFlag = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> oddFlag ? res + <span class="number">1</span> : res;        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Majority Element (169)]]></title>
      <url>/2016/11/30/2016-11-30-leetcode-solution-Majority-Element-169/</url>
      <content type="html"><![CDATA[<p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<h3 id="解法1：抵消的思路，O-N-Time-O-1-Space"><a href="#解法1：抵消的思路，O-N-Time-O-1-Space" class="headerlink" title="解法1：抵消的思路，O(N) Time + O(1) Space"></a>解法1：抵消的思路，O(N) Time + O(1) Space</h3><p>运用抵消的思路，如果有多余半数的一个数字，那么如果我们俩俩抵消不一样的数字，最后剩下来的一定是最多的那个数字。<br>抵消的实现用一个计数器，当两个数字不一样的时候，计数器减少1，如果归0了则更改被选答案到当前选定的数字。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> count = <span class="number">1</span>; <span class="keyword">int</span> result = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</div><div class="line">            <span class="keyword">if</span> (num == result) ++count;</div><div class="line">            <span class="keyword">else</span> count--;</div><div class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">                result = num;</div><div class="line">                ++count;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法2：排序-O-NlogN"><a href="#解法2：排序-O-NlogN" class="headerlink" title="解法2：排序 O(NlogN)"></a>解法2：排序 O(NlogN)</h3><p>因为多数元素个数超过半数，那么排序之后，当中的元素一定是最多的元素。<br>这个方法也能过OA<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="built_in">std</span>::sort(nums.begin(), nums.end());</div><div class="line"></div><div class="line">        <span class="keyword">return</span> nums[nums.size() / <span class="number">2</span>];</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> 抵消 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Valid Anagram (242)]]></title>
      <url>/2016/11/30/2016-11-30-leetcode-solution-Valid-Anagram-242/</url>
      <content type="html"><![CDATA[<p>Given two strings s and t, write a function to determine if t is an anagram of s.</p>
<p>For example,<br>s = “anagram”, t = “nagaram”, return true.<br>s = “rat”, t = “car”, return false.</p>
<p>Note:<br>You may assume the string contains only lowercase alphabets.</p>
<p>Follow up:<br>What if the inputs contain unicode characters? How would you adapt your solution to such case?</p>
<h3 id="解法1：Sort-O-NlogN"><a href="#解法1：Sort-O-NlogN" class="headerlink" title="解法1：Sort O(NlogN)"></a>解法1：Sort O(NlogN)</h3><p>先排序，然后看排过序的两个string是否一致。</p>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><p>主要是掌握一下两个c++里的用法:<br>一个是对于字符串的排序。<br>  std::sort(s.begin(), s.end())<br>另一个是比较两个字符串用s1.compare(s2)的形式，当两个字符串相等时，返回0<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</div><div class="line">        <span class="built_in">std</span>::sort(s.begin(), s.end());</div><div class="line">        <span class="built_in">std</span>::sort(t.begin(), t.end());</div><div class="line"></div><div class="line">        <span class="keyword">return</span> s.compare(t) == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法2：Hashtable-O-N-time-O-N-Space"><a href="#解法2：Hashtable-O-N-time-O-N-Space" class="headerlink" title="解法2：Hashtable O(N) time + O(N) Space"></a>解法2：Hashtable O(N) time + O(N) Space</h3><p>统计其中一个字符串每个字符出现的次数，然后扫描另一个字符串来判断是否一致。<br>如果都是a-z的小写字母，那就只需要一个大小为26的数组记录就可，如果出现了unicode，那么还是必须要用hashtable来解决。</p>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</div><div class="line">            ++<span class="built_in">map</span>[c];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: t) &#123;</div><div class="line">            --<span class="built_in">map</span>[c];</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[c] &lt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// check if there's remaining</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter = <span class="built_in">map</span>.begin(); iter != <span class="built_in">map</span>.end(); ++iter) &#123;</div><div class="line">            <span class="keyword">if</span> (iter-&gt;second != <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="Follw-up"><a href="#Follw-up" class="headerlink" title="Follw up"></a>Follw up</h3><p>见解法2的讨论，主要是针对用hashtable这一种用法的follow up。</p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: First Unique Character in a String (387)]]></title>
      <url>/2016/11/29/2016-11-29-leetcode-solution-First-Unique-Character-in-a-String-387/</url>
      <content type="html"><![CDATA[<p>Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.</p>
<p>Examples:</p>
<p>s = “leetcode”<br>return 0.</p>
<p>s = “loveleetcode”,<br>return 2.<br>Note: You may assume the string contain only lowercase letters.</p>
<h3 id="解法1：HashTable"><a href="#解法1：HashTable" class="headerlink" title="解法1：HashTable"></a>解法1：HashTable</h3><p>思路是将字符串建立hashtable，其中存的是每一个字符出现的位置，如果出现超过1次则位置设置为-1，然后遍历hashtable找出最小的非-1的即可。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.find(s[i]) != <span class="built_in">map</span>.end()) &#123;</div><div class="line">                <span class="built_in">map</span>[s[i]] = <span class="number">-1</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="built_in">map</span>[s[i]] = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> res = s.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter = <span class="built_in">map</span>.begin(); iter != <span class="built_in">map</span>.end(); ++iter) &#123;</div><div class="line">            <span class="keyword">if</span> (iter-&gt;second !=<span class="number">-1</span>) &#123;</div><div class="line">                res = min(res, iter-&gt;second);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (res == s.size()) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法2：HashTable"><a href="#解法2：HashTable" class="headerlink" title="解法2：HashTable"></a>解法2：HashTable</h3><p>上面的思路有点繁复，如果hashtable中存入每一个字符出现的次数，那么只需要重新扫描一遍字符串，找到第一个次数为1的就是所求的答案。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</div><div class="line">            ++<span class="built_in">map</span>[c];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[s[i]] == <span class="number">1</span>) &#123;</div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> HashTable </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Excel Sheet Column Number (171)]]></title>
      <url>/2016/11/29/2016-11-29-leetcode-solution-Excel-Sheet-Column-Number-171/</url>
      <content type="html"><![CDATA[<p>Related to question Excel Sheet Column Title</p>
<p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>
<p>For example:</p>
<pre><code>A -&gt; 1
B -&gt; 2
C -&gt; 3
...
Z -&gt; 26
AA -&gt; 27
AB -&gt; 28
</code></pre><h3 id="解法1：O-N-26进制到10进制转换"><a href="#解法1：O-N-26进制到10进制转换" class="headerlink" title="解法1：O(N) 26进制到10进制转换"></a>解法1：O(N) 26进制到10进制转换</h3><p>26进制转换为10进制的算法。关键的一句就是res = res * 26 + (s[i] - ‘A’ + 1), 从高位向低位运算。往下一位时要把之前的结果乘以26。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</div><div class="line">            res = res * <span class="number">26</span> + (s[i] - <span class="string">'A'</span> + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Meeting Rooms (252)]]></title>
      <url>/2016/11/29/2016-11-29-leetcode-solution-Meeting-Rooms-252/</url>
      <content type="html"><![CDATA[<p>Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],…] (si &lt; ei), determine if a person could attend all meetings.</p>
<p>For example,<br>Given [[0, 30],[5, 10],[15, 20]],<br>return false.</p>
<h3 id="解法1：O-NlogN-Time"><a href="#解法1：O-NlogN-Time" class="headerlink" title="解法1：O(NlogN) Time"></a>解法1：O(NlogN) Time</h3><p>考察的是对custom class排序的能力，我们只需要用标准的库函数，用上自己定义的比较函数就可以了。比较的时候后一个meeting的开始时间不能早于前一个会议的结束时间。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for an interval.</span></div><div class="line"><span class="comment"> * struct Interval &#123;</span></div><div class="line"><span class="comment"> *     int start;</span></div><div class="line"><span class="comment"> *     int end;</span></div><div class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></div><div class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(Interval left, Interval right)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> left.start &lt; right.start;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canAttendMeetings</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</div><div class="line">        <span class="built_in">std</span>::sort(intervals.begin(), intervals.end(), compare);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</div><div class="line">            <span class="keyword">if</span> (intervals[i].start &lt; intervals[i - <span class="number">1</span>].end) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Sort </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Same Tree (100)]]></title>
      <url>/2016/11/28/2016-11-28-leetcode-solution-Same-Tree-100/</url>
      <content type="html"><![CDATA[<p>Given two binary trees, write a function to check if they are equal or not.</p>
<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>
<h3 id="解法1：递归-分治"><a href="#解法1：递归-分治" class="headerlink" title="解法1：递归 / 分治"></a>解法1：递归 / 分治</h3><p>经典的二叉树的问题，用递归很容易解决。两个树相等首先是root的值要一样，然后左子树相等，右子树相等。终结条件是如果值不一样或者有一个root为空另一个不是空则结构不同。</p>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (p-&gt; val != q-&gt;val) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">bool</span> left = isSameTree(p-&gt;left, q-&gt;left);</div><div class="line">        <span class="keyword">if</span> (!left) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">bool</span> right = isSameTree(p-&gt;right, q-&gt;right);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> right;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> Recursion </tag>
            
            <tag> C++ </tag>
            
            <tag> Binary Tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Delete Node in a Linked List (237)]]></title>
      <url>/2016/11/28/2016-11-28-leetcode-solution-Delete-Node-in-a-Linked-List-237/</url>
      <content type="html"><![CDATA[<p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function.</p>
<h3 id="解法1：O-1-Time"><a href="#解法1：O-1-Time" class="headerlink" title="解法1：O(1) Time"></a>解法1：O(1) Time</h3><p>由于只给了当前node的指针，那么没办法得到前面一个节点的信息。只能换种思考方式。我们可以将下一个节点的数值拷贝过来然后删除下一个节点就可以。</p>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><p>要注意的是要删除下一个节点指针对应的object，否则会造成leak<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * struct ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode *next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span> || node-&gt; next == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        node-&gt;val = node-&gt;next-&gt;val;</div><div class="line">        ListNode* p = node-&gt;next;</div><div class="line">        node-&gt;next = node-&gt;next-&gt;next;</div><div class="line">        <span class="keyword">delete</span> p;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Intersection of two arrays (349)]]></title>
      <url>/2016/11/28/2016-11-28-leetcode-solution-Intersection-of-two-arrays-349/</url>
      <content type="html"><![CDATA[<p>Given two arrays, write a function to compute their intersection.</p>
<p>Example:<br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].</p>
<p>Note:<br>Each element in the result must be unique.<br>The result can be in any order.</p>
<h3 id="解法1：Sort-Two-pointers-O-NlogN-Time-O-1-Space"><a href="#解法1：Sort-Two-pointers-O-NlogN-Time-O-1-Space" class="headerlink" title="解法1：Sort + Two pointers O(NlogN) Time + O(1) Space"></a>解法1：Sort + Two pointers O(NlogN) Time + O(1) Space</h3><p>先考虑将两个数组排序，然后只需要维护两个指针，对于一样的数值就放入返回数组中。同时要考虑去重的情况。这点上<a href="http://www.jiuzhang.com/solutions/intersection-of-two-arrays/" target="_blank" rel="external">九章的答案</a>做的比我更简洁。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</div><div class="line">        <span class="built_in">std</span>::sort(nums1.begin(), nums1.end());</div><div class="line">        <span class="built_in">std</span>::sort(nums2.begin(), nums2.end());</div><div class="line">        <span class="keyword">int</span> ptr1 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> ptr2 = <span class="number">0</span>;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">        <span class="keyword">while</span> (ptr1 &lt; nums1.size() &amp;&amp; ptr2 &lt; nums2.size()) &#123;</div><div class="line">            <span class="keyword">while</span> (ptr1 &gt; <span class="number">0</span> &amp;&amp; ptr1 &lt; nums1.size() &amp;&amp; nums1[ptr1] == nums1[ptr1<span class="number">-1</span>]) ++ptr1;</div><div class="line">            <span class="keyword">while</span> (ptr2 &gt; <span class="number">0</span> &amp;&amp; ptr2 &lt; nums2.size() &amp;&amp; nums2[ptr2] == nums2[ptr2 - <span class="number">1</span>]) ++ptr2;</div><div class="line">            <span class="keyword">if</span> (ptr1 == nums1.size()) <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">if</span> (ptr2 == nums2.size()) <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">if</span> (nums1[ptr1] &lt; nums2[ptr2]) &#123;</div><div class="line">                ++ptr1;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[ptr1] &gt; nums2[ptr2]) &#123;</div><div class="line">                ++ptr2;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                res.emplace_back(nums1[ptr1]);</div><div class="line">                ++ptr1;</div><div class="line">                ++ptr2;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="解法2：-HashTable-O-N-Time-O-N-Space"><a href="#解法2：-HashTable-O-N-Time-O-N-Space" class="headerlink" title="解法2： HashTable O(N) Time + O(N) Space"></a>解法2： HashTable O(N) Time + O(N) Space</h3><p>先扫描第一个数组，建立hashtable，然后扫描第二个数组，同时维持一个结果的hashtable用来去重。<br>C++<br>用到了unordered_map’s iterate method.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; <span class="built_in">map</span>; <span class="comment">// define a map</span></div><div class="line"><span class="built_in">map</span>.begin() 和 <span class="built_in">map</span>.end() <span class="keyword">return</span> iterator of the <span class="built_in">map</span>, can be used like</div><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> a = <span class="built_in">map</span>.begin(); a!= <span class="built_in">map</span>.end(); a++) &#123;&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; <span class="built_in">map</span>;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; res;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums1) &#123;</div><div class="line">            <span class="built_in">map</span>[num] = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums2) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[num] &amp;&amp; !res[num])</div><div class="line">                res[num] = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// iterate over map</span></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res_vector;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iterator = res.begin(); iterator != res.end(); iterator++) &#123;</div><div class="line">            <span class="keyword">if</span> (iterator-&gt;second) &#123;</div><div class="line">                res_vector.emplace_back(iterator-&gt;first);</div><div class="line">            &#125;</div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> res_vector;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> Two pointers </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Sum of Left Leaves (404)]]></title>
      <url>/2016/11/27/2016-11-27-leetcode-solution-Sum-of-Left-Leaves-404/</url>
      <content type="html"><![CDATA[<p>Find the sum of all left leaves in a given binary tree.</p>
<p>Example:</p>
<pre><code>3
</code></pre><p>   / \<br>  9  20<br>    /  \<br>   15   7</p>
<p>There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.</p>
<h3 id="解法1：Recursion-O-N-Time"><a href="#解法1：Recursion-O-N-Time" class="headerlink" title="解法1：Recursion O(N) Time"></a>解法1：Recursion O(N) Time</h3><p>二叉树很自然的想到用递归的办法解决。这里的难点是要记录每一个节点是否为Left child/right child，为此我们需要有一个helper函数来记录。根据OA的结果，root是算作非左子树的。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> helper(root, <span class="literal">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">bool</span> isleft)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> isleft? root-&gt;val: <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> left = helper(root-&gt;left, <span class="literal">true</span>);</div><div class="line">        <span class="keyword">int</span> right = helper(root-&gt;right, <span class="literal">false</span>);</div><div class="line">        <span class="keyword">return</span> left + right;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Ransom Note (383)]]></title>
      <url>/2016/11/27/2016-11-27-leetcode-solution-Ransom-Note-383/</url>
      <content type="html"><![CDATA[<p>Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.</p>
<p>Each letter in the magazine string can only be used once in your ransom note.</p>
<p>Note:<br>You may assume that both strings contain only lowercase letters.</p>
<p>canConstruct(“a”, “b”) -&gt; false<br>canConstruct(“aa”, “ab”) -&gt; false<br>canConstruct(“aa”, “aab”) -&gt; true</p>
<h3 id="解法1：O-N-M-Time-with-O-M-Space"><a href="#解法1：O-N-M-Time-with-O-M-Space" class="headerlink" title="解法1：O(N + M) Time with O(M) Space"></a>解法1：O(N + M) Time with O(M) Space</h3><p>经典的用hashtable解决的字母问题，把magazine先hash算出每一个字母出现的次数，然后对ransomNote扫描碰到见过的字母则次数-1，直到所对应的字母的次数小于0（false）或者是可以扫描完所有的ransomNote的字母。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(<span class="built_in">string</span> ransomNote, <span class="built_in">string</span> magazine)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">map</span> (<span class="number">26</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; magazine.size(); ++i) &#123;</div><div class="line">            ++<span class="built_in">map</span>[magazine[i] - <span class="string">'a'</span>];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ransomNote.size(); ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[ransomNote[i] - <span class="string">'a'</span>] &lt;= <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                --<span class="built_in">map</span>[ransomNote[i] - <span class="string">'a'</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>C++ with std::unordered_map<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(<span class="built_in">string</span> ransomNote, <span class="built_in">string</span> magazine)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; magazine.size(); ++i) &#123;</div><div class="line">            <span class="built_in">map</span>[magazine[i]]++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ransomNote.size(); ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[ransomNote[i]] == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                --<span class="built_in">map</span>[ransomNote[i]];</div><div class="line">            &#125;           </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Minimum Moves to Equal Array Elements (453)]]></title>
      <url>/2016/11/27/2016-11-27-leetcode-solution-Minimum-Moves-to-Equal-Array-Elements-453/</url>
      <content type="html"><![CDATA[<p>Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.</p>
<p>Example:</p>
<p>Input:<br>[1,2,3]</p>
<p>Output:<br>3</p>
<p>Explanation:<br>Only three moves are needed (remember each move increments two elements):</p>
<p>[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]</p>
<h3 id="解法1：O-N"><a href="#解法1：O-N" class="headerlink" title="解法1：O(N)"></a>解法1：O(N)</h3><p>本题巧妙的办法是要想到等价的操作，将n-1个元素都+1等价于将1个元素-1，在选择+1的时候我们都是避开最大的元素，那么-1的时候就要选择最大的元素。那么问题就转化为了将元素全部转化为最小元素，需要多少步，每步减少一个元素的值。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> minNum = INT_MAX;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (num : nums) minNum = min(minNum, num);</div><div class="line">        <span class="keyword">for</span> (num: nums) count += (num - minNum);</div><div class="line">        <span class="keyword">return</span> count;        </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Assign Cookies (455)]]></title>
      <url>/2016/11/27/2016-11-27-leetcode-solution-Assign-Cookies-455/</url>
      <content type="html"><![CDATA[<p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &gt;= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.</p>
<p>Note:<br>You may assume the greed factor is always positive.<br>You cannot assign more than one cookie to one child.</p>
<p>Example 1:<br>Input: [1,2,3], [1,1]</p>
<p>Output: 1</p>
<p>Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.<br>And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.<br>You need to output 1.<br>Example 2:<br>Input: [1,2], [1,2,3]</p>
<p>Output: 2</p>
<p>Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.<br>You have 3 cookies and their sizes are big enough to gratify all of the children,<br>You need to output 2.</p>
<h3 id="解法1：O-nlogn-mlogm-贪心"><a href="#解法1：O-nlogn-mlogm-贪心" class="headerlink" title="解法1：O(nlogn + mlogm) 贪心"></a>解法1：O(nlogn + mlogm) 贪心</h3><p>如果两个array g和s都是从小到大排序的，那么基本思路就是把满足条件当中最小的一个cookie给孩子，然后再从剩下的cookie中挑选满足条件的最小的cookie给下一个孩子。这似乎就是一种贪心的思路。<br>排序需要花费O(NlogN)的时间，两个数组分别排序。<br>排序之后，维护两个指针分别在两个数组。遍历孩子的数组，直到cookie的数组已选完。用到线性的时间。所以整体的复杂度还是O(nlogn)的量级。<br>C++<br>用到了std::sort(vector.begin(), vector.end())<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</div><div class="line">        <span class="comment">// sort two vectors</span></div><div class="line">        <span class="built_in">std</span>::sort(g.begin(), g.end());</div><div class="line">        <span class="built_in">std</span>::sort(s.begin(), s.end());</div><div class="line"></div><div class="line">        <span class="keyword">int</span> gPtr = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> sPtr = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (; gPtr &lt; g.size() &amp;&amp; sPtr &lt; s.size(); ++gPtr) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">while</span> (sPtr &lt; s.size() &amp;&amp; s[sPtr] &lt; g[gPtr]) ++sPtr;</div><div class="line">            <span class="keyword">if</span> (sPtr == s.size()) <span class="keyword">break</span>;</div><div class="line">            ++num;</div><div class="line">            ++sPtr;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> num;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Island Perimeter (463)]]></title>
      <url>/2016/11/27/2016-11-27-leetcode-solution-Island-Perimeter-463/</url>
      <content type="html"><![CDATA[<p>You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island.</p>
<p>Example:<br>[[0,1,0,0],<br> [1,1,1,0],<br> [0,1,0,0],<br> [1,1,0,0]]</p>
<p>Answer: 16<br>Explanation: The perimeter is the 16 yellow stripes in the image below:</p>
<h3 id="解法1：O-N-2-Time"><a href="#解法1：O-N-2-Time" class="headerlink" title="解法1：O(N^2) Time"></a>解法1：O(N^2) Time</h3><p>一开始观察可以注意到边界上的岛屿需要特殊处理，每一个边界周长都有效。对于每一个岛屿，要判断每一条边界是否有效，如果是在grid的边界上则直接有效，否贼考虑是否上下左右为0，如果是则为有效边界。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> perimeter = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> row = grid.size();</div><div class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j) &#123;</div><div class="line">                <span class="comment">// check left boundary</span></div><div class="line">                <span class="keyword">if</span> (grid[i][j] != <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span>) ++perimeter;</div><div class="line">                    <span class="keyword">if</span> (j == col - <span class="number">1</span>) ++perimeter;</div><div class="line">                    <span class="keyword">if</span> (j != <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="number">0</span>) ++perimeter;</div><div class="line">                    <span class="keyword">if</span> (j != col - <span class="number">1</span> &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="number">0</span>) ++perimeter;</div><div class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span>) ++perimeter;</div><div class="line">                    <span class="keyword">if</span> (i == row - <span class="number">1</span>) ++perimeter;</div><div class="line">                    <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="number">0</span>) ++perimeter;</div><div class="line">                    <span class="keyword">if</span> (i != row - <span class="number">1</span> &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="number">0</span>) ++perimeter;</div><div class="line">                &#125;                </div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> perimeter;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[backup hexo blog]]></title>
      <url>/2016/11/13/2016-11-13-backup-hexo-blog/</url>
      <content type="html"><![CDATA[<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Move Zeros (283)]]></title>
      <url>/2016/11/08/2016-11-08-leetcode-solution-Move-Zeros-283/</url>
      <content type="html"><![CDATA[<p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p>
<p>Note:<br>You must do this in-place without making a copy of the array.<br>Minimize the total number of operations.</p>
<h3 id="解法1：双指针-O-N-time-with-O-1-space"><a href="#解法1：双指针-O-N-time-with-O-1-space" class="headerlink" title="解法1：双指针 O(N) time with O(1) space"></a>解法1：双指针 O(N) time with O(1) space</h3><p>这题的思路很像Quick Sort里partition的思路，需要用到两个指针。一个指针用来traverse，另一个用来记录下一个非0的元素需要插入的位置。<br>C++中有一个swap function，可以交换两个reference的值。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i]) &#123;</div><div class="line">                swap(nums[i], nums[j++]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">int</span> temp = nums[i];</div><div class="line">                nums[i] = nums[j];</div><div class="line">                nums[j++] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode解题: Invert Binary Tree (226)]]></title>
      <url>/2016/11/07/2016-11-07-Leetcode-solution-Invert-Binary-Tree-226/</url>
      <content type="html"><![CDATA[<p>invert a binary tree.</p>
<pre><code>4
</code></pre><p>   /   \<br>  2     7<br> / \   / \<br>1   3 6   9<br>to<br>     4<br>   /   \<br>  7     2<br> / \   / \<br>9   6 3   1</p>
<h3 id="解法1：Recursion-Divide-amp-Conquer-O-N-time"><a href="#解法1：Recursion-Divide-amp-Conquer-O-N-time" class="headerlink" title="解法1：Recursion, Divide &amp; Conquer, O(N) time"></a>解法1：Recursion, Divide &amp; Conquer, O(N) time</h3><p>很典型的一个Divide &amp; Conquer题目，用递归的办法很简单。先对左子树invert，然后对右子树invert,最后交换左右子树即可。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        invertTree(root-&gt;left);</div><div class="line">        invertTree(root-&gt;right);</div><div class="line">        TreeNode* temp = root-&gt;left;</div><div class="line">        root-&gt;left = root-&gt;right;</div><div class="line">        root-&gt;right = temp;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</div><div class="line">        invertTree(root.left);</div><div class="line">        invertTree(root.right);</div><div class="line">        TreeNode temp = root.right;</div><div class="line">        root.right = root.left;</div><div class="line">        root.left = temp;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Find the Difference (389)]]></title>
      <url>/2016/11/07/2016-11-07-leetcode-solution-Find-the-Difference-389/</url>
      <content type="html"><![CDATA[<p>Given two strings s and t which consist of only lowercase letters.</p>
<p>String t is generated by random shuffling string s and then add one more letter at a random position.</p>
<p>Find the letter that was added in t.</p>
<p>Example:</p>
<p>Input:<br>s = “abcd”<br>t = “abcde”</p>
<p>Output:<br>e</p>
<p>Explanation:<br>‘e’ is the letter that was added.</p>
<h3 id="解法1：O-N-Time-Complexity-with-O-1-Space"><a href="#解法1：O-N-Time-Complexity-with-O-1-Space" class="headerlink" title="解法1：O(N) Time Complexity with O(1) Space"></a>解法1：O(N) Time Complexity with O(1) Space</h3><p>用Hash的思路，对短字符串建立Hash索引，然后长字符串里面每一个字符减一，最后如果发现出现负数次数的字符时则一定是多出来的那个字符。<br>C++ 中注意unordered_map的用法，unordered_map::operator[] 对于不存在的元素会进行插入操作并初始化对应的map数值。<br>Java取字符串中的字符的method是s.charAt(i)<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; strmap;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: s) ++strmap[c];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: t) &#123;</div><div class="line">            --strmap[c];</div><div class="line">            <span class="keyword">if</span> (strmap[c] &lt; <span class="number">0</span>) <span class="keyword">return</span> c;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(String s, String t)</span> </span>&#123;</div><div class="line">       <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</div><div class="line">           map[s.charAt(i) - <span class="string">'a'</span>]++;</div><div class="line">           map[t.charAt(i) - <span class="string">'a'</span>]--;</div><div class="line">       &#125;</div><div class="line">       map[t.charAt(t.length() - <span class="number">1</span>) - <span class="string">'a'</span>]--;</div><div class="line">       <span class="keyword">char</span> res = <span class="string">'a'</span>;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</div><div class="line">           <span class="keyword">if</span> (map[i] &lt; <span class="number">0</span>) &#123;</div><div class="line">               res += i;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法2：O-N-Time-Complexity-with-O-1-Space"><a href="#解法2：O-N-Time-Complexity-with-O-1-Space" class="headerlink" title="解法2：O(N) Time Complexity with O(1) Space"></a>解法2：O(N) Time Complexity with O(1) Space</h3><p>找不同的题目可以尝试用抵消的思路。一个抵消的工具就是XOR，如果对每一个字符进行异或操作，由于相同的元素抵消，剩下的一定是不相同的那一个。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</div><div class="line">       <span class="keyword">char</span> res = <span class="number">0</span>;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">char</span> c: s) res ^= c;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">char</span> c: s) res ^= c;</div><div class="line">       <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Shortest Word Distance (243)]]></title>
      <url>/2016/11/07/2016-11-07-leetcode-solution-Shortest-Word-Distance-243/</url>
      <content type="html"><![CDATA[<p>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p>
<p>For example,<br>Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”].</p>
<p>Given word1 = “coding”, word2 = “practice”, return 3.<br>Given word1 = “makes”, word2 = “coding”, return 1.</p>
<p>Note:<br>You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.</p>
<h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>思路就是维护两个指针，一个记录上一次出现的word1的位置，另一个记录word2的位置。每次发现一个新位置的时候计算一下当前的距离并且更新最短距离。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> iter1 = <span class="number">-1</span>, iter2 = <span class="number">-1</span>;</div><div class="line">        <span class="keyword">int</span> res = words.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.size(); i++) &#123;</div><div class="line">            <span class="keyword">if</span> (words[i] == word1) &#123;</div><div class="line">                iter1 = i;</div><div class="line">                <span class="keyword">if</span> (iter2 != <span class="number">-1</span>) &#123;</div><div class="line">                    res = <span class="built_in">std</span>::min(res, iter1 - iter2);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (words[i] == word2) &#123;</div><div class="line">                iter2 = i;</div><div class="line">                <span class="keyword">if</span> (iter1 != <span class="number">-1</span>) &#123;</div><div class="line">                    res = <span class="built_in">std</span>::min(res, iter2 - iter1);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(String[] words, String word1, String word2)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (words.length &lt; <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> first = -<span class="number">1</span>, second = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (words[i].equals(word1)) &#123;</div><div class="line">                first = i;</div><div class="line">                <span class="keyword">if</span> (second != -<span class="number">1</span>) &#123;</div><div class="line">                    res = Math.min(res, Math.abs(second - first));</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (words[i].equals(word2)) &#123;</div><div class="line">                second = i;</div><div class="line">                <span class="keyword">if</span> (first != -<span class="number">1</span>) &#123;</div><div class="line">                    res = Math.min(res, Math.abs(second - first));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Connect to remote MySQL server]]></title>
      <url>/2016/11/05/2016-11-05-Connect-to-remote-MySQL-server/</url>
      <content type="html"><![CDATA[<p>家里有两台台式机，一台干脆专门用来下data，配置了一下MySQL,从另一台电脑上成功连接，把大概的步骤记录一下。</p>
<ul>
<li><p>打开 3306 端口<br>….MySQL的默认端口是3306,需要配置firewall来开放端口，如果是Windows机可以参考<a href="http://www.thewindowsclub.com/block-open-port-windows-8-firewall" target="_blank" rel="external">这篇文章</a>。</p>
</li>
<li><p>建立远程连接的用户<br>…. 添加用户</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'myuser'</span>@<span class="string">'localhost'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'mypass'</span>;</div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'myuser'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'mypass'</span>;</div></pre></td></tr></table></figure>
<p>….设定用户的权限</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GRANT</span> ALL <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'myuser'</span>@<span class="string">'localhost'</span>;</div><div class="line"><span class="keyword">GRANT</span> ALL <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'myuser'</span>@<span class="string">'%'</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>连接</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -u USERNAME -h HOST_IP -p</div></pre></td></tr></table></figure>
</li>
<li><p>基本操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// <span class="keyword">Show</span> all <span class="keyword">databases</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">database</span>;</div><div class="line">// Switch to a table</div><div class="line"><span class="keyword">use</span> DATABASE_NAMME;</div><div class="line">// <span class="keyword">Show</span> all <span class="keyword">tables</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>Reference：<br><a href="http://stackoverflow.com/questions/16287559/mysql-adding-user-for-remote-access" target="_blank" rel="external">http://stackoverflow.com/questions/16287559/mysql-adding-user-for-remote-access</a><br><a href="http://stackoverflow.com/questions/15872543/access-remote-database-from-command-line" target="_blank" rel="external">http://stackoverflow.com/questions/15872543/access-remote-database-from-command-line</a></p>
]]></content>
      
        <categories>
            
            <category> 技术总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Maximum Depth of Binary Tree (104)]]></title>
      <url>/2016/10/02/2016-10-02-leetcode-solution-Maximum-Depth-of-Binary-Tree-104/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<h3 id="解法1：Recursion-with-O-N-time"><a href="#解法1：Recursion-with-O-N-time" class="headerlink" title="解法1：Recursion with O(N) time"></a>解法1：Recursion with O(N) time</h3><p>Divide and Conquer, 递归的思路，空Node的depth为0，任意一个Node的depth为左面和右面的最大的depth+1, i.e. maxDepth(i) = Max(maxDepth(left), maxDepth(right)) + 1<br>注意C++中空值是NULL, java是null<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class="number">1</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法2-Non-recursion"><a href="#解法2-Non-recursion" class="headerlink" title="解法2: Non-recursion"></a>解法2: Non-recursion</h3><p>我们只需要修改一个非递归的树的遍历算法就可以了，<a href="http://articles.leetcode.com/maximum-height-of-binary-tree" target="_blank" rel="external">这篇文章</a>详细讲了思路</p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> Recursion </tag>
            
            <tag> C++ </tag>
            
            <tag> Divide and Conquer </tag>
            
            <tag> Tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Single Number (136)]]></title>
      <url>/2016/10/02/2016-10-02-leetcode-solution-Single-Number-136/</url>
      <content type="html"><![CDATA[<p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<p>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<h3 id="解法1：O-N-time-with-O-1-space-N-is-the-number-of-elements"><a href="#解法1：O-N-time-with-O-1-space-N-is-the-number-of-elements" class="headerlink" title="解法1：O(N) time with O(1) space, N is the number of elements"></a>解法1：O(N) time with O(1) space, N is the number of elements</h3><p>运用XOR是一个抵消运算符，A XOR A 出来是一个0，所以对所有的数字做XOR之后重复的都消掉了，只剩下单独的一个。C++中vector的method是vector.size(),和java中array的array.length注意区分。</p>
<p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> result = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</div><div class="line">            result ^= nums[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> result = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            result ^= nums[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> XOR </tag>
            
            <tag> Bit Manipulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Sum of Two Integers (371)]]></title>
      <url>/2016/10/02/2016-10-02-leetcode-solution-Sum-of-Two-Integers-371/</url>
      <content type="html"><![CDATA[<p>Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.</p>
<p>Example:<br>Given a = 1 and b = 2, return 3.</p>
<h3 id="解法1：Iteration"><a href="#解法1：Iteration" class="headerlink" title="解法1：Iteration"></a>解法1：Iteration</h3><p>XOR是一个不带进位的加法运算，进位的信息可以通过AND（与运算）再左移获得。可以有Recursion和Iteration两种写法<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">int</span> c = a ^ b;</div><div class="line">            <span class="keyword">int</span> carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;</div><div class="line">            a = c;</div><div class="line">            b = carry;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> a;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法2：Recursion"><a href="#解法2：Recursion" class="headerlink" title="解法2：Recursion"></a>解法2：Recursion</h3><p>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> a; <span class="comment">// stop condition</span></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">int</span> c = a ^ b;</div><div class="line">      <span class="keyword">int</span> carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;</div><div class="line">      <span class="keyword">return</span> getSum(c, carry);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> C++ </tag>
            
            <tag> Bit Manipulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Flip Game (293)]]></title>
      <url>/2016/10/02/2016-10-02-leetcode-solution-Flip-Game-293/</url>
      <content type="html"><![CDATA[<p>You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two consecutive “++” into “–”. The game ends when a person can no longer make a move and therefore the other person will be the winner.</p>
<p>Write a function to compute all possible states of the string after one valid move.</p>
<p>For example, given s = “++++”, after one move, it may become one of the following states:</p>
<p>[<br>  “–++”,<br>  “+–+”,<br>  “++–”<br>]<br>If there is no valid move, return an empty list [].</p>
<h3 id="解法1：DP-with-O-N-time-N-number-of-characters"><a href="#解法1：DP-with-O-N-time-N-number-of-characters" class="headerlink" title="解法1：DP with O(N) time, N = number of characters"></a>解法1：DP with O(N) time, N = number of characters</h3><p>按顺序一个个查看是否连续的两个字符是’+’， 如果是则换，如果不是继续<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generatePossibleNextMoves(<span class="built_in">string</span> s) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</div><div class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'+'</span> &amp;&amp; s[i+<span class="number">1</span>] == <span class="string">'+'</span>) &#123;</div><div class="line">                <span class="built_in">string</span> temp = s.substr(<span class="number">0</span>); <span class="comment">// or just string temp = s;</span></div><div class="line">                temp[i] = <span class="string">'-'</span>;</div><div class="line">                temp[i + <span class="number">1</span>] = <span class="string">'-'</span>;</div><div class="line">                result.push_back(temp);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generatePossibleNextMoves</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'+'</span> &amp;&amp; s.charAt(i + <span class="number">1</span>) == <span class="string">'+'</span>) &#123;</div><div class="line">                StringBuffer temp = <span class="keyword">new</span> StringBuffer(s);</div><div class="line">                temp.setCharAt(i, <span class="string">'-'</span>);</div><div class="line">                temp.setCharAt(i + <span class="number">1</span>, <span class="string">'-'</span>);</div><div class="line">                result.add(temp.toString());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Palindrome Permutation (266)]]></title>
      <url>/2016/10/02/2016-10-02-leetcode-solution-Palindrome-Permutation-266/</url>
      <content type="html"><![CDATA[<p>Given a string, determine if a permutation of the string could form a palindrome.</p>
<p>For example,<br>“code” -&gt; False, “aab” -&gt; True, “carerac” -&gt; True.</p>
<h3 id="解法1：DP-with-O-N-time-N-number-of-characters"><a href="#解法1：DP-with-O-N-time-N-number-of-characters" class="headerlink" title="解法1：DP with O(N) time, N = number of characters"></a>解法1：DP with O(N) time, N = number of characters</h3><p>Palindrome分为even和odd两种情况，在even的时候，一定是每一个字母都出现偶数次。在odd的时候，有且仅有一个字母可出现奇数次。那么就可以统计每一个字母出现的次数，如果出现奇数次的字母的个数大于1，那么一定不能组成一个Palindrome，反之则可以。统计的时候需要一个HashMap来记录每一个字母的个数。<br>C++<br><figure class="highlight plain"><figcaption><span>lang: cpp</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool canPermutePalindrome(string s) &#123;</div><div class="line">        map&lt;char, int&gt; hmap;</div><div class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</div><div class="line">            if (hmap.count(s[i]) == 0) &#123;</div><div class="line">                // not exist</div><div class="line">                hmap.insert(std::pair&lt;char, int&gt;(s[i], 1));</div><div class="line">            &#125; else &#123;</div><div class="line">                hmap[s[i]]++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // Iterate over map keys</div><div class="line">        map&lt;char, int&gt;::iterator iter = hmap.begin();</div><div class="line">        map&lt;char, int&gt;::iterator iter_end = hmap.end();</div><div class="line">        int odd = 0;</div><div class="line">        while (iter != iter_end) &#123;</div><div class="line">            if (iter-&gt;second % 2 != 0) &#123;</div><div class="line">                odd++;</div><div class="line">            &#125;</div><div class="line">            ++iter;</div><div class="line">        &#125;</div><div class="line">        return odd &lt; 2;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public boolean canPermutePalindrome(String s) &#123;</div><div class="line">        if (s == null || s.length() == 0) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int size = s.length();</div><div class="line">        Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();</div><div class="line">        for (int i = 0; i &lt; size; i++) &#123;</div><div class="line">            if (map.containsKey(s.charAt(i))) &#123;</div><div class="line">                map.put(s.charAt(i), map.get(s.charAt(i)) + 1);</div><div class="line">            &#125; else &#123;</div><div class="line">                map.put(s.charAt(i), 1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Check for odd number</div><div class="line">        int odd = 0;</div><div class="line">        for (Character ch : map.keySet()) &#123;</div><div class="line">            if (map.get(ch) % 2 != 0) &#123;</div><div class="line">                odd++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return odd &lt; 2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> HashMap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Nim Game (292)]]></title>
      <url>/2016/10/01/2016-10-01-leetcode-solution-Nim-Game-292/</url>
      <content type="html"><![CDATA[<p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p>
<p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p>
<p>For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.</p>
<h3 id="解法1：DP-with-O-N-time-N-is-the-number-of-input-Runtime-Error"><a href="#解法1：DP-with-O-N-time-N-is-the-number-of-input-Runtime-Error" class="headerlink" title="解法1：DP with O(N) time, N is the number of input, Runtime Error"></a>解法1：DP with O(N) time, N is the number of input, Runtime Error</h3><p>思路就是去试几个不同的数，找出规律。自然的首先想到的是DP的算法，比如输入4，那么无论如何不能达到。如果是5，那么只要1可以，那么5就可以。似乎只需要看前面差4个数的结果。x[i] = x[i - 4]，但是当数据变大的时候会出现Runtime error。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">bool</span> x[n + <span class="number">1</span>];</div><div class="line">      x[<span class="number">0</span>] = <span class="literal">false</span>; x[<span class="number">1</span>] = <span class="literal">true</span>; x[<span class="number">2</span>] = <span class="literal">true</span>; x[<span class="number">3</span>] = <span class="literal">true</span>;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++) &#123;</div><div class="line">          x[i] = x[i - <span class="number">4</span>];</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> x[n];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法2：O-1-Time-with-Math"><a href="#解法2：O-1-Time-with-Math" class="headerlink" title="解法2：O(1) Time with Math"></a>解法2：O(1) Time with Math</h3><p>1,2,3 可以，4 false， 5，6，7 true, 8 false. 得出的结论是能除4的就不能赢。<br>C++<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> n % <span class="number">4</span> != <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> C++ </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Moving Average from Data Stream (346)]]></title>
      <url>/2016/10/01/2016-10-01-leetcode-solution-Moving-Average-from-Data-Stream-346/</url>
      <content type="html"><![CDATA[<p>Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.</p>
<p>For example,<br>MovingAverage m = new MovingAverage(3);<br>m.next(1) = 1<br>m.next(10) = (1 + 10) / 2<br>m.next(3) = (1 + 10 + 3) / 3<br>m.next(5) = (10 + 3 + 5) / 3</p>
<h3 id="解法1：O-1-Computation-and-O-N-space"><a href="#解法1：O-1-Computation-and-O-N-space" class="headerlink" title="解法1：O(1) Computation and O(N) space"></a>解法1：O(1) Computation and O(N) space</h3><p>需要考虑每次计算运用上次的结果，由于平均值是Sum / Size, 如果维护average的值的话不方便重复利用已经计算过的值，所以我们可以考虑维护一个当前的Sum. 最后需要计算average的时候就把sum除以当前的数字个数。</p>
<p>数据结构： 考虑使用queue<int>, 用到的操作是queue.front(), queue.pop() 和queue.push(item)</int></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//C++</span></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MovingAverage</span> &#123;</span></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">      <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; data;</div><div class="line">      <span class="keyword">int</span> sum;</div><div class="line">      <span class="keyword">int</span> msize;</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">      MovingAverage(<span class="keyword">int</span> size) &#123;</div><div class="line">          msize = size;</div><div class="line">          sum = <span class="number">0</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">double</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">          <span class="keyword">if</span> (data.size() == msize) &#123;</div><div class="line">              sum -= data.front();</div><div class="line">              data.pop();</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          data.push(val);</div><div class="line">          sum += val;</div><div class="line"></div><div class="line">          <span class="keyword">return</span> (<span class="keyword">double</span>)sum / data.size();      </div><div class="line">      &#125;</div><div class="line">  &#125;;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Nested List Weight Sum (339)]]></title>
      <url>/2016/09/17/2016-09-17-leetcode-solution-Nested-List-Weight-Sum-339/</url>
      <content type="html"><![CDATA[<p>Given a nested list of integers, return the sum of all integers in the list weighted by their depth.</p>
<p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p>
<p>Example 1:<br>Given the list [[1,1],2,[1,1]], return 10. (four 1’s at depth 2, one 2 at depth 1)</p>
<p>Example 2:<br>Given the list [1,[4,[6]]], return 27. (one 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4<em>2 + 6</em>3 = 27)</p>
<h3 id="解法1：Recursion-with-O-N-time-N-is-number-of-total-elements"><a href="#解法1：Recursion-with-O-N-time-N-is-number-of-total-elements" class="headerlink" title="解法1：Recursion with O(N) time, N is number of total elements"></a>解法1：Recursion with O(N) time, N is number of total elements</h3><p>看到Nested，从构造上来说和递归的思路很一致。想到递归时每一次调用递归函数需要记录下当前的level。<br>整体的思路是对每一个element, 如果是Integer的话，当前的结果应该是数值 * level, 然后继续，如果是Nested List，那么level + 1, 然后继续递归。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depthSum</span><span class="params">(<span class="built_in">vector</span>&lt;NestedInteger&gt;&amp; nestedList)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> depthSumHelper(nestedList, <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depthSumHelper</span><span class="params">(<span class="built_in">vector</span>&lt;NestedInteger&gt;&amp; nestedList, <span class="keyword">int</span> depth)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nestedList.size(); i++) &#123;</div><div class="line">            <span class="keyword">if</span> (nestedList[i].isInteger()) &#123;</div><div class="line">                sum += nestedList[i].getInteger() * depth;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                sum += depthSumHelper(nestedList[i].getList(), depth + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Recursion </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Coin Change (322)]]></title>
      <url>/2016/07/20/2016-07-20-leetcode-solution-Coin-Change-322/</url>
      <content type="html"><![CDATA[<p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p>
<p>Example 1:<br>coins = [1, 2, 5], amount = 11<br>return 3 (11 = 5 + 5 + 1)</p>
<p>Example 2:<br>coins = [2], amount = 3<br>return -1.</p>
<p>Note:<br>You may assume that you have an infinite number of each kind of coin.</p>
<h3 id="解法1：-找规律-Memorization-One-pass-O-N-Time"><a href="#解法1：-找规律-Memorization-One-pass-O-N-Time" class="headerlink" title="解法1： 找规律 + Memorization, One pass O(N) Time"></a>解法1： 找规律 + Memorization, One pass O(N) Time</h3><p>这题需要多写几个数出来找一下规律:<br>如果我们把0到15的二进制表达式写出来，并且把对应的set bit的个数写出来，我们可以得到如下：</p>
<h2 id="0-0000-0"><a href="#0-0000-0" class="headerlink" title="0    0000    0"></a>0    0000    0</h2><h2 id="1-0001-1"><a href="#1-0001-1" class="headerlink" title="1    0001    1"></a>1    0001    1</h2><p>2    0010    1</p>
<h2 id="3-0011-2"><a href="#3-0011-2" class="headerlink" title="3    0011    2"></a>3    0011    2</h2><p>4    0100    1<br>5    0101    2<br>6    0110    2</p>
<h2 id="7-0111-3"><a href="#7-0111-3" class="headerlink" title="7    0111    3"></a>7    0111    3</h2><p>8    1000    1<br>9    1001    2<br>10   1010    2<br>11   1011    3<br>12   1100    2<br>13   1101    3<br>14   1110    3<br>15   1111    4</p>
<p>观察后联系hint,发现偶数X的bit数是X/2的bit数，奇数X的bit数是X/2的bit数+1，于是可以得到一个O(N)的算法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</div><div class="line"></div><div class="line">   <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</div><div class="line">   <span class="comment">// dp[0] is 0</span></div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">            dp[i] = dp[i / <span class="number">2</span>];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            dp[i] = dp[i / <span class="number">2</span>] + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> dp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Dynamic programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: counting bits (338)]]></title>
      <url>/2016/07/20/2016-07-20-leetcode-solution-counting-bits-338/</url>
      <content type="html"><![CDATA[<p>Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.</p>
<p>Example:<br>For num = 5 you should return [0,1,1,2,1,2].</p>
<p>Follow up:</p>
<p>It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?<br>Space complexity should be O(n).<br>Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.<br>Hint:</p>
<p>You should make use of what you have produced already.<br>Divide the numbers in ranges like [2-3], [4-7], [8-15] and so on. And try to generate new range from previous.<br>Or does the odd/even status of the number help you in calculating the number of 1s?</p>
<h3 id="解法1：-找规律-Memorization-One-pass-O-N-Time"><a href="#解法1：-找规律-Memorization-One-pass-O-N-Time" class="headerlink" title="解法1： 找规律 + Memorization, One pass O(N) Time"></a>解法1： 找规律 + Memorization, One pass O(N) Time</h3><p>这题需要多写几个数出来找一下规律:<br>如果我们把0到15的二进制表达式写出来，并且把对应的set bit的个数写出来，我们可以得到如下：</p>
<h2 id="0-0000-0"><a href="#0-0000-0" class="headerlink" title="0    0000    0"></a>0    0000    0</h2><h2 id="1-0001-1"><a href="#1-0001-1" class="headerlink" title="1    0001    1"></a>1    0001    1</h2><p>2    0010    1</p>
<h2 id="3-0011-2"><a href="#3-0011-2" class="headerlink" title="3    0011    2"></a>3    0011    2</h2><p>4    0100    1<br>5    0101    2<br>6    0110    2</p>
<h2 id="7-0111-3"><a href="#7-0111-3" class="headerlink" title="7    0111    3"></a>7    0111    3</h2><p>8    1000    1<br>9    1001    2<br>10   1010    2<br>11   1011    3<br>12   1100    2<br>13   1101    3<br>14   1110    3<br>15   1111    4</p>
<p>观察后联系hint,发现偶数X的bit数是X/2的bit数，奇数X的bit数是X/2的bit数+1，于是可以得到一个O(N)的算法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</div><div class="line">   </div><div class="line">   <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</div><div class="line">   <span class="comment">// dp[0] is 0</span></div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">            dp[i] = dp[i / <span class="number">2</span>];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            dp[i] = dp[i / <span class="number">2</span>] + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法2：-找规律-Memorization-One-pass-O-N-Time"><a href="#解法2：-找规律-Memorization-One-pass-O-N-Time" class="headerlink" title="解法2： 找规律 + Memorization, One pass O(N) Time"></a>解法2： 找规律 + Memorization, One pass O(N) Time</h3><p>另一种规律，我们使用i &amp; (i - 1) 来看对应的结果。</p>
<h2 id="0-0000-0-N-A"><a href="#0-0000-0-N-A" class="headerlink" title="0    0000    0    N/A"></a>0    0000    0    N/A</h2><h2 id="1-0001-1-0000"><a href="#1-0001-1-0000" class="headerlink" title="1    0001    1    0000"></a>1    0001    1    0000</h2><p>2    0010    1    0000</p>
<h2 id="3-0011-2-0010"><a href="#3-0011-2-0010" class="headerlink" title="3    0011    2    0010"></a>3    0011    2    0010</h2><p>4    0100    1    0000<br>5    0101    2    0100<br>6    0110    2    0100</p>
<h2 id="7-0111-3-0110"><a href="#7-0111-3-0110" class="headerlink" title="7    0111    3    0110"></a>7    0111    3    0110</h2><p>8    1000    1    0000<br>9    1001    2    1000<br>10   1010    2    1000<br>11   1011    3    1010<br>12   1100    2    1000<br>13   1101    3    1100<br>14   1110    3    1100<br>15   1111    4    1110</p>
<p>更加简化的一个规律是dp[i] = dp[i &amp; (i - 1)] + 1, 比如15, 15 &amp; 14 = ‘1110’， ’1110‘的bits是3，所以15的bits是4<br>那么就可以得到如下的程序。这个程序更简短。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</div><div class="line">   </div><div class="line">   <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</div><div class="line">   <span class="comment">// dp[0] is 0</span></div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</div><div class="line">        dp[i] = dp[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Dynamic programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Perfect Squares (279)]]></title>
      <url>/2016/07/20/2016-07-20-leetcode-solution-Perfect-Squares-279/</url>
      <content type="html"><![CDATA[<p>Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, …) which sum to n.<br>For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.</p>
<h3 id="解法1：DP-O-N-2-with-O-N-空间"><a href="#解法1：DP-O-N-2-with-O-N-空间" class="headerlink" title="解法1：DP O(N^2) with O(N) 空间"></a>解法1：DP O(N^2) with O(N) 空间</h3><p>如果用暴力的方法想：对于一个数字N，我们可以从1开始试， 因为1是一个perfect square,那么求出N - 1的解，假设为X，则N的解就是X+1<br>我们从1开始尝试所有可能的组合，然后求出了一系列的解之后挑选最小的值。但这样做的话复杂率特别高，应该是指数级的<br>实际上可以发现，这里有很多overlapping的问题，比如我们求12的最小值，那么如果第一个选择的值是4，则剩下的为8.<br>当我们在前面选择第一个值为2时，子问题变为寻找10 - 2 = 10的最小值，而当我们求10的最小值的时候可能已经求过了8的最小平方数。<br>所以我们可以想到用dp/memorization的方法去解决这个问题。</p>
<ol>
<li>建立dp数组dp[N], N是要求的数字，dp数组中存储的是对应的这个数字n，他的最小平方和数。</li>
<li>初始化,将所有perfect square的数字都设为1</li>
<li>对于非perfect square的数字，dp[i] = Min(dp[j] + dp[i - j], j = 1 … i / 2),也就是说,dp[12] = Min of (dp[1] + dp[11], dp[2] + dp[10], …)<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> ) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i*i &lt;= n; i++) &#123;</div><div class="line">        dp[i*i] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (dp[i] != <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">int</span> res = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i/<span class="number">2</span>; j++) &#123;</div><div class="line">                <span class="keyword">int</span> temp = dp[j] + dp[i - j];</div><div class="line">                res = Math.min(temp, res);</div><div class="line">            &#125;</div><div class="line">            dp[i] = res;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dp[n];</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Dynamic programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Minimum Path Sum (64)]]></title>
      <url>/2016/07/20/2016-07-20-leetcode-solution-Minimum-Path-Sum-64/</url>
      <content type="html"><![CDATA[<p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.<br>Note: You can only move either down or right at any point in time.</p>
<h3 id="解法1：DP-O-N-2-with-O-N-空间"><a href="#解法1：DP-O-N-2-with-O-N-空间" class="headerlink" title="解法1：DP O(N^2) with O(N) 空间"></a>解法1：DP O(N^2) with O(N) 空间</h3><p>也是很直接的dp, dp[i][j]表示的是到(i,j)点的最小路径和。dp[i][j] = Min(dp[i - 1][j], dp[i][j -1]) + A[i][j]<br>最后的结果便是dp[n - 1][m - 1], 用滚动数组节省内存空间<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> nrow = grid.length;</div><div class="line">    <span class="keyword">int</span> ncol = grid[<span class="number">0</span>].length;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[ncol];</div><div class="line">    dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">    </div><div class="line">    <span class="comment">// Initialize the dp array</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; ncol; j++) &#123;</div><div class="line">        dp[j] = dp[j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =  <span class="number">1</span>; i &lt; nrow; i++) &#123;</div><div class="line">        dp[<span class="number">0</span>] += grid[i][<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; ncol; j++) &#123;</div><div class="line">            dp[j] = Math.min(dp[j], dp[j - <span class="number">1</span>]) + grid[i][j];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dp[ncol - <span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Dynamic programming </tag>
            
            <tag> 滚动数组 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Unique Paths II (63)]]></title>
      <url>/2016/07/20/2016-07-20-leetcode-solution-Unique-Paths-II-63/</url>
      <content type="html"><![CDATA[<p>Follow up for “Unique Paths”:</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<p>An obstacle and empty space is marked as 1 and 0 respectively in the grid.</p>
<p>For example,<br>There is one obstacle in the middle of a 3x3 grid as illustrated below.</p>
<p>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>The total number of unique paths is 2.</p>
<p>Note: m and n will be at most 100.</p>
<h3 id="解法1：DP-O-N-2-with-O-N-空间"><a href="#解法1：DP-O-N-2-with-O-N-空间" class="headerlink" title="解法1：DP O(N^2) with O(N) 空间"></a>解法1：DP O(N^2) with O(N) 空间</h3><p>是<a href="http://bigteemo.github.io/2016/07/20/leetcode-solution-Unique-Paths-62/">Unique Path</a>的扩展，唯一区别是对于任意一个格子，要先判断是否为1，如果是1则有障碍物，在这种情况下，则到达这个<br>点的办法为0。其他地方的计算还是依照dp[i][j] = dp[i -1][j] + dp[i][j - 1]，这里同样用了滚动数组节省空间。<br>这题的坑是在： <strong>一开始初始化数组的时候，对[0][i]的判断取决于[i][i - 1] 和那个格子是否有障碍物两个条件。不能仅根据当个格子来判断</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (obstacleGrid == <span class="keyword">null</span> || obstacleGrid.length == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> nrow = obstacleGrid.length;</div><div class="line">    <span class="keyword">int</span> ncol = obstacleGrid[<span class="number">0</span>].length;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[ncol];</div><div class="line">    dp[<span class="number">0</span>] = obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; ncol; j++) &#123;</div><div class="line">        dp[j] = obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>?dp[j - <span class="number">1</span>]: <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nrow; i++) &#123;</div><div class="line">        dp[<span class="number">0</span>] = obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>?dp[<span class="number">0</span>] : <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; ncol; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>) &#123;</div><div class="line">                dp[j] += dp[j - <span class="number">1</span>];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                dp[j] = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dp[ncol - <span class="number">1</span>];    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Dynamic programming </tag>
            
            <tag> 滚动数组 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Unique Paths (62)]]></title>
      <url>/2016/07/20/2016-07-20-leetcode-solution-Unique-Paths-62/</url>
      <content type="html"><![CDATA[<p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<p>Note: m and n will be at most 100.</p>
<h3 id="解法1：DP-O-N-2-with-O-N-2-空间"><a href="#解法1：DP-O-N-2-with-O-N-2-空间" class="headerlink" title="解法1：DP O(N^2) with O(N^2) 空间"></a>解法1：DP O(N^2) with O(N^2) 空间</h3><p>很直接的2维dp问题，对于任意一个点i,j,到达它的办法可以从上面过来，也可以从左面过来。<br>所以总的办法数是dp[i][j] = dp[i - ][j] + dp[i][j -1]<br>结果就是dp[m - 1][n - 1]</p>
<p>Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (m == <span class="number">1</span> || n == <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</div><div class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</div><div class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</div><div class="line">            dp[i][j] = dp[i -<span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法2：DP-O-N-2-with-O-N-空间"><a href="#解法2：DP-O-N-2-with-O-N-空间" class="headerlink" title="解法2：DP O(N^2) with O(N) 空间"></a>解法2：DP O(N^2) with O(N) 空间</h3><p>和<a href="http://bigteemo.github.io/2016/07/20/leetcode-solution-Triangle-120/">triangle</a>相类似的思路，dp的过程是自上而下自左而右，那么可以用滚动数组来减少内存的使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (m == <span class="number">1</span> || n == <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</div><div class="line">        dp[j] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</div><div class="line">            dp[j] += dp[j - <span class="number">1</span>]; <span class="comment">// dp[j] initially stores the previous row's calculation</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Dynamic programming </tag>
            
            <tag> 滚动数组 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Triangle (120)]]></title>
      <url>/2016/07/20/2016-07-20-leetcode-solution-Triangle-120/</url>
      <content type="html"><![CDATA[<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>
<p>For example, given the following triangle<br>[<br>     [2],<br>    [3,4],<br>   [6,5,7],<br>  [4,1,8,3]<br>]<br>The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</p>
<p>Note:<br>Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</p>
<h3 id="解法1：DP-O-N-2-with-O-N-2-空间"><a href="#解法1：DP-O-N-2-with-O-N-2-空间" class="headerlink" title="解法1：DP O(N^2) with O(N^2) 空间"></a>解法1：DP O(N^2) with O(N^2) 空间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List(List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (triangle == <span class="keyword">null</span> || triangle.size() == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> n = triangle.size();    <span class="comment">// number of rows</span></div><div class="line">    </div><div class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] temp : dp) &#123;</div><div class="line">        Arrays.fill(temp, Integer.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</div><div class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + triangle.get(i).get(<span class="number">0</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;=i; j++) &#123;</div><div class="line">            dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + triangle.get(i).get(j);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">        res = Math.min(res, dp[n - <span class="number">1</span>][i]);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="解法2：DP-O-N-2-with-O-N-空间"><a href="#解法2：DP-O-N-2-with-O-N-空间" class="headerlink" title="解法2：DP O(N^2) with O(N) 空间"></a>解法2：DP O(N^2) with O(N) 空间</h3><p>观察上面的解法可以看到，我们的2维数组实际上只用到了上一行的信息，由此我们可以对内存做一个小优化而达到O(N)的空间。<br>我们只保留上一行的每一个位置的最小值，需要一个大小为N的数组，N是总的行数，然后在计算中只要反复更新这个数组。<br>也就是说dp[i] = Math.min(dp[i - 1], dp[i]) + A[j][i] j是现在计算到的行数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (triangle == <span class="keyword">null</span> || triangle.size() == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> n = triangle.size();    <span class="comment">// number of rows</span></div><div class="line">    </div><div class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">    </div><div class="line">    Arrays.fill(dp, Integer.MAX_VALUE);</div><div class="line">    dp[<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</div><div class="line">        <span class="comment">// i is the current row number</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</div><div class="line">            <span class="comment">// 这里比较容易出错，j要从后往前更新，因为下一行的计算用到了上一行的[i - 1] 和[i]，</span></div><div class="line">            <span class="comment">// 需要先更新后面的才不会override前面的数据</span></div><div class="line">            <span class="comment">// 同时下标使用的是j以此来模拟不同column的计算</span></div><div class="line">            dp[j] = Math.min(dp[j - <span class="number">1</span>], dp[j]) + triangle.get(i).get(j);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">        res = Math.min(res, dp[i]);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Dynamic programming </tag>
            
            <tag> 滚动数组 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Decode Ways (91)]]></title>
      <url>/2016/07/20/2016-07-20-leetcode-solution-decode-ways-91/</url>
      <content type="html"><![CDATA[<p>A message containing letters from A-Z is being encoded to numbers using the following mapping:</p>
<p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>Given an encoded message containing digits, determine the total number of ways to decode it.</p>
<p>For example,<br>Given encoded message “12”, it could be decoded as “AB” (1 2) or “L” (12).</p>
<p>The number of ways decoding “12” is 2.</p>
<h3 id="解法1：DP-O-N-with-O-1-空间"><a href="#解法1：DP-O-N-with-O-1-空间" class="headerlink" title="解法1：DP O(N) with O(1) 空间"></a>解法1：DP O(N) with O(1) 空间</h3><p>典型DP, dp数组表示前i个数字的# of decode ways. 那么对于dp[i], 他存在decode的办法有两种：</p>
<ol>
<li>单独一个数字decode, 这种情况实际是dp[i -1]</li>
<li>和嵌挤一个数字拼成一个10 ~ 26 的数字decode, 这种情况的办法是dp[i - 2]<br>但是要注意的是对于每一种可能的decode办法，有corner case需要考虑：</li>
<li>如果第i个数是0，那么只可能是dp[i - 2],并且要检查i - 1 和i拼成的数是否在10 ~ 26范围内, 比如120只可能是[1, 20]的分割</li>
<li>检查数是否在10 ~ 26范围内</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">	</div><div class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// empty string has no way of decoding</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</div><div class="line">    </div><div class="line">    dp[<span class="number">0</span>] = s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>?<span class="number">0</span>: <span class="number">1</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</div><div class="line">        <span class="keyword">if</span> (s.charAt(i) != <span class="string">'0'</span>) &#123;</div><div class="line">            dp[i] = dp[i - <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> temp = Integer.parseInt(s.substring(i - <span class="number">1</span>, i + <span class="number">1</span>));</div><div class="line">        <span class="keyword">if</span> (temp &gt;= <span class="number">10</span> &amp;&amp; temp &lt;= <span class="number">26</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</div><div class="line">                dp[i] += <span class="number">1</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                dp[i] += dp[i - <span class="number">2</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (dp[i] == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[s.length() - <span class="number">1</span>];    </div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Dynamic programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[量化金融面试知识点: Market Risk]]></title>
      <url>/2016/07/16/2016-07-16-Quant-Finance-Prep-market-risk/</url>
      <content type="html"><![CDATA[<p>问题来源于一份<a href="http://news.efinancialcareers.com/uk-en/212161/the-50-market-risk-interview-questions-you-need-to-anticipate" target="_blank" rel="external">Top 50 Questions related to Market Risk</a>. 试着回答了一部分问题，希望对准备面试有所帮助。</p>
<h3 id="Risk-Measures"><a href="#Risk-Measures" class="headerlink" title="Risk Measures"></a>Risk Measures</h3><ol>
<li><p>How would you calculate Value at Risk (VaR)?</p>
<p>There are three methods to calculate VaR.</p>
<ol>
<li><p>Delta-Normal Method (Parametric Method)</p>
<ul>
<li>Assume the distribution of underlying asset returns. </li>
<li>Go back on time for over N years and collect asset returns’ data.</li>
<li>Fit the data into the assumed distribution and calculate the VaR as the Xth percentile.</li>
<li>For example, a one-day 5% VaR is just the 5th percentile of the underlying return’s distribution.</li>
</ul>
</li>
<li><p>Historical-Simulation Method</p>
<ul>
<li>Assume historical path will be a guidence of what will happen in the future</li>
<li>Go back on time for over N years and collect portfolio’s data (close price).<ul>
<li>Each historical period is considered a scenario</li>
</ul>
</li>
<li>Given current portfolio’s value, forecast the next period’s value based on each scenario</li>
<li>Once portfolio’s value is calculated for each period, calculate the sample Nth percentile as the VaR</li>
</ul>
</li>
<li><p>Monte-Carlo Method</p>
<ul>
<li>Assume a stochastic process for each market variable (distribution and parameters)<ul>
<li>parameters can be estimated from historical data</li>
</ul>
</li>
<li>Simulate the data path for all variables of interest</li>
<li>Revalue the portfolio by the new market variables and calculate the value difference</li>
<li><p>Calculate the Nth percentile as the VaR value.</p>
</li>
<li><p>For example, we can assume all market variables changes are generated from a multivariate normal distribution</p>
</li>
<li>Then each step will involve generating data from the multivariate distribution and revalue the portfolio based on that</li>
</ul>
</li>
</ol>
</li>
<li><p>What’s wrong with VaR as a measurement of risk?</p>
<ul>
<li>It does not describe the loss on the left tail. When the return distribution is far from a normal distribution, it does not face real risk<ul>
<li>Example: short CDS of a 3% default rate with 0 recovery rate bond, 95% VaR is 0 (which doesn’t reflect the risk at all)</li>
</ul>
</li>
<li>It is not a coherent measure and is not sub-additive. <ul>
<li>It means when we combine two positions, we do not always have VaR(C) &lt;= VaR(A) + VaR(B)</li>
<li>Example: two short CDS positions with 3% default rate and 0 recovery rate bond:<br>  one of the bond default rate is 1 - (1 - 3%)*(1 - 3%) = 5.9%, so VaR(C) &gt; Var(A) + VaR(B)<br>  This contradicts the idea that diversification reduces risks.</li>
</ul>
</li>
</ul>
</li>
<li><p>What is non-Linear VaR? How would you calculate it?<br> Non-linear VaR reflects that the portfolio contains nonlinear derivatives which the payoff or the response to the risk factor is non-linear.<br> It is often calculate by using the monte carlo simulation of pricing model.</p>
</li>
<li><p>What is the parametric method of calculating VaR? What are its advantages?<br> The parametric method is the delta-normal method described in Q1.<br> The advantage is it is simple to calculate. It just need to estimate the joint distribution and<br> calculate the portfolio return’s distribution using either linear or nonlinear model.</p>
<ul>
<li>Non-linear model is called: Cornish-Fisher expansion (P448 on John Hull)</li>
</ul>
</li>
<li><p>What is the historical method of calculating VaR? What are its advantages?<br> Second Method described in Q1.<br> Advantage is it is a nonparametric method and the historical data determines the joint probability distribution of market variables.</p>
</li>
<li><p>Why would you calculate VaR using Monte Carlo simulations?<br> If the portfolio is consisting nonlinear derivatives, such as options, the return profile of the portfolio is non symmetric.<br> VaR is very sensitive to the left tail of the distribution so in this case we need to use monte carlo simulation to better model the nonlinear characterics.</p>
</li>
<li><p>What are the challenges in calculating VaR for a mixed portfolio?<br> Nonlinearity? [NOT finished yet]</p>
</li>
<li><p>What’s GVAR? How can you calculate it?<br> GVAR = Global vector autoregression Model</p>
</li>
<li><p>What is the one-day VaR of a $50m portfolio with a daily standard deviation of 2% at a 95% confidence level? What is the annualized VaR?</p>
<ul>
<li>One day VaR = 50m * 0.02 * 1.96 ~= 2m</li>
<li>Annualized VaR = sqrt(252) * 2m = 16 * 2m = 32m</li>
</ul>
</li>
<li><p>What do you know about extreme value theory?</p>
<ul>
<li>A framework to study the tail behavior of a distribution</li>
<li><a href="https://en.wikipedia.org/wiki/Extreme_value_theory" target="_blank" rel="external">https://en.wikipedia.org/wiki/Extreme_value_theory</a></li>
</ul>
</li>
<li><p>What is Expected Shortfall? How is it calculated? Why is it considered better than VaR? What are the disadvantages?</p>
<ul>
<li>Expected shortfall is also called conditional value at risk</li>
<li>It measures the expected loss under a certain amount.</li>
<li>It can be calculated by a list of scenarios. <ul>
<li>Each scenarios has the probability of occurrence and the return</li>
<li>Given a threshold, calculate the probablity of each scenario that happen with odds less than the threshold</li>
<li>Cacluate the expected (averaged) loss.</li>
</ul>
</li>
<li>Advantage： <ol>
<li>It is a coherent measure and a more complete measure of downside risk<ul>
<li>Reflect the sknewness (asymmetry) and kurtosis (fat tail)</li>
</ul>
</li>
</ol>
</li>
<li>Disadvantage: <ol>
<li>It treats a large probability of small loss as equivalent to a small probability of large loss</li>
<li>Difficult to forecast</li>
</ol>
</li>
</ul>
</li>
<li><p>What is incremental default risk?<br>Default risk incremental to what is calculated through the Value-at-risk model,<br>which often does not adequately capture the risk associated with illiquid products.</p>
</li>
</ol>
<h3 id="Yield-Curve"><a href="#Yield-Curve" class="headerlink" title="Yield Curve"></a>Yield Curve</h3><ol>
<li><p>What are the uses of the yield curve?<br>Yield curve depicts the relationship between bond yield and its maturities. It is used to:</p>
<ol>
<li>Forecasting interest rate</li>
<li>Pricing bond</li>
<li>Create strategies to boost total returns</li>
</ol>
</li>
<li><p>What’s the riskiest part of the yield curve?<br>The riskiest part is either a flattening or steepening of the yield curve.<br>It reflects yield changing among comparable bonds with different maturities.</p>
</li>
<li><p>What does it mean for risk when the yield curve is inverted?<br>When the yield curve is inverted, it is often viewed as an pending economic recession.<br>In this case, people tend to have negative view in long term so the price of long term bond is bidding up.</p>
</li>
<li><p>What is the discount factor? How would you calculate it?<br>Discount factor is the present value of a unit of currency delivered at a future time T.</p>
</li>
<li><p>What is convexity? How would you calculate it? Why is it important?<br>Convexity is the second derivatives of bond price relative to the interest rate.<br>Convexity measures the curvature of price-yield curve. It is a key aspect when measure interest rate risk.</p>
</li>
<li><p>What’s the relationship between coupon rate and convexity?<br>convexity decrease as coupon rate increase.<br>Zero-coupon bond have the highest convexity compared to other bond with the same duration and yield to maturity.</p>
</li>
<li><p>What’s the meaning of duration? Is it constant for all yields?<br>Duration is the sentivity of bond price relative to interest rate. (First derivative)<br>It is not constant for all yield since price-yield curve has curvature.</p>
</li>
<li><p>What’s the meaning of partial duration?<br>It’s also called key rate duration. It measures the bond price change relative to a set of rates with specific maturities.<br>It does not assume parallel shift in yield curve.</p>
</li>
<li><p>What are the limits of duration as a risk measure?<br>It assumes the parallel shift in yield curve and it ignores the curvature.</p>
</li>
<li><p>How would you decide which discount curve to use to value future cash flows from interest rate swaps?</p>
</li>
</ol>
<p>Questions on quantitative concepts:</p>
<ol>
<li><p>Can you explain the assumptions behind Black Scholes?</p>
</li>
<li><p>What’s a volatility smile? Why does it occur? What are the implications for Black Scholes?</p>
</li>
<li><p>What are the Greeks?</p>
</li>
<li><p>How are the main Greeks derived?</p>
</li>
<li><p>What do you know about jump processes?</p>
</li>
<li><p>Should you use implied standard deviation or historical deviation to forecast volatility? Explain your choice.</p>
</li>
</ol>
<h3 id="Hedging"><a href="#Hedging" class="headerlink" title="Hedging"></a>Hedging</h3><ol>
<li><p>What is delta hedging?</p>
</li>
<li><p>How would you hedge against a particular equity/bond under current market conditions?</p>
</li>
<li><p>When can hedging an options position mean that you take on more risk?</p>
</li>
<li><p>An option is at the money. How many shares of stock should you hold to hedge it?</p>
</li>
</ol>
<p>Questions on particular products:</p>
<ol>
<li><p>What is interest rate risk?<br>The effect on your portfolio value when interest rate changes.</p>
</li>
<li><p>What is reinvestment risk?<br>If you have cash flow generated from your portfolio and the market interest rate is changing, you have the reinvestment risk.<br>That means you may have to reinvest your proceedings at a lower/higher market preceding rate.</p>
</li>
<li><p>How do interest rate risk and reinvestment risk interact?<br>Reinvestment risk is more likely when interest rates are declining.<br>Reinvestment risk affects the yield-to-maturity of a bond,<br>which is calculated on the premise that all future coupon payments will be reinvested at the interest rate in effect when the bond was first purchased.</p>
</li>
<li><p>Which bond has the greatest associated interest rate risk? A five year zero coupon bond? Or a five year bond that pays coupons?<br>zero coupon bond has the highest duration and thus has the greatest interest rate risk.</p>
</li>
<li><p>Which is more volatile, a 20-year zero coupon bond or a 20-year 4.5% coupon bond?<br>20-year zero coupon bond.</p>
</li>
<li><p>What are the risks inherent in an interest rate swap?</p>
</li>
</ol>
<h3 id="Regulation"><a href="#Regulation" class="headerlink" title="Regulation"></a>Regulation</h3><ol>
<li><p>How has Basel III changed the treatment of market risk?</p>
</li>
<li><p>What the implications of Basel IIIs new trading book rules for market risk professionals?</p>
</li>
<li><p>How could the Basel III treatment of trading books be improved?</p>
</li>
<li><p>How will trading businesses change as a result of Basel III capital rules for banks’ trading books?</p>
</li>
<li><p>What are the key requirements of the Basel stress testing framework? Are they sufficiently stringent?</p>
</li>
<li><p>Which extreme events should stress tests be taking into consideration now?</p>
</li>
<li><p>Why is Basel II blamed for precipitating the 2008 financial crisis?</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 量化分析知识点 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Risk </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在Hexo中用mathjax渲染数学公式]]></title>
      <url>/2016/07/16/2016-07-16-maupassant-hexo-with-mathjax/</url>
      <content type="html"><![CDATA[<p>折腾了一晚上，还是没有搞定，研究了一下似乎是我用的theme: maupassant-hexo 暂时不支持mathjax.<br>搜索了一圈发现<a href="http://t.tiany.me/2015/12/08/hexo-config/" target="_blank" rel="external">这篇文章</a>有解决办法，并且指出了一个人<a href="https://github.com/tiany/maupassant-hexo/commit/fd8319fbf9a5f0936ad3348132e41d5c2d5a8215" target="_blank" rel="external">fork</a>了maupassant-hexo并对它加入了支持。暂时还没有尝试，先记录下来。</p>
]]></content>
      
        <categories>
            
            <category> 技术总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Mathjax </tag>
            
            <tag> Maupassant </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[量化金融面试知识点: 线性回归(Linear Regression)]]></title>
      <url>/2016/07/16/2016-07-16-Quant-Finance-Prep-Regression/</url>
      <content type="html"><![CDATA[<p>现在公式暂时还不能正常显示，由于是这个<a href="https://github.com/akfish/hexo-inject/issues/1" target="_blank" rel="external">issue</a><br>等作者修好了我再来更新吧</p>
<h2 id="Assumptions"><a href="#Assumptions" class="headerlink" title="Assumptions"></a>Assumptions</h2><ul>
<li>linearity of the conditional probability</li>
<li>Strict exogeneity: Erros are uncorrelated with indepedent variables (X)<ul>
<li>If violated, it is called endogeneity</li>
</ul>
</li>
<li>No multicollinearity: All regressor variables are linearly independent</li>
<li>Variance of erros should be constant: it is called homoscedasticity.<ul>
<li>If violated, it is called heteroscedasticity</li>
</ul>
</li>
<li>Errors have No serial correlation/autocorrelation</li>
<li>Errors are normally distributed </li>
<li>Errors are independent and identically distributed</li>
</ul>
<h2 id="Estimation-Model"><a href="#Estimation-Model" class="headerlink" title="Estimation Model"></a>Estimation Model</h2><ul>
<li>coefficients: $$\beta = (X^TX)^(-1)(X^TY)$$</li>
<li>variance of coefficients: Var(\beta|X) = ^(\sigma<em>err^2)/</em>((n - 1)s_x^2)<ul>
<li>More variance in the noise means \beta is more variable</li>
<li>Larger sample variance means smaller variance of coefficients. It is because it’s much easier to estimate the coefficients</li>
<li>Higher sampling frequency reduce variance</li>
</ul>
</li>
</ul>
<h2 id="Variance-Sum-of-Squares-and-R-2"><a href="#Variance-Sum-of-Squares-and-R-2" class="headerlink" title="Variance, Sum of Squares and R^2"></a>Variance, Sum of Squares and R^2</h2><ul>
<li><p>TSS: total sum of squares<br>TSS = SUM of (Y_i - \overline{Y})^2<br>It is the total variance in oberserved dependent variable</p>
</li>
<li><p>Regression SS:<br>RSS = SUM of (Y_fit - \overline{Y})^2<br>total variance in fitted observed dependent variables</p>
</li>
<li><p>Residual error SS:<br>RESS = SUM of (Y_i - Y_fit)^2</p>
</li>
<li><p>R^2<br>R^2 = 1 - ^(RESS/_TSS)<br>R^2 is the sample covariance between Y and Y_fit</p>
<ul>
<li>Special case: Single X variable<br>R^2 measures the sample covariance between Y and X</li>
</ul>
</li>
<li><p>Adjusted R^2<br>R^2 increases with number of parameters<br>Adjusted R^2 is adjusted by the degree of freedom<br>adj-R^2 = 1 - ^RSS<em>(n - p - 1)^(-1)/_(TSS</em>(n - 1)^(-1))</p>
</li>
<li><p>Durbin-Watson Test<br>Test if there is serial correlation in residuals/autocorrelation<br>If the p-value from the test is low, it indicates they are probably autocorrelation in noise</p>
</li>
<li><p>ACF<br>ACF graph is used to look for potential serial correlation at a number of lags</p>
</li>
</ul>
<h2 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h2><ul>
<li><p>Test if multiple coefficients are significant (not zero)<br>F-test</p>
<ul>
<li>This can be used to compare two models that one of the model has a subset of variables</li>
</ul>
</li>
<li><p>Model Selection Criteria</p>
<ul>
<li>AIC &amp; BIC<br>The smaller the error variance, the smaller AIC/BIC but it is penalized by number of variables</li>
<li>R^2</li>
</ul>
</li>
<li><p>Variance inflation factor (VIF)</p>
<ul>
<li>Measures how much the variance increases by including other predictor variables (test for multicollinearity)</li>
<li>Calculate by runnning regression of X_j on X_1 … X<em>n<br>and get R^2: VIF = ^1/</em>(1 - R^2)</li>
</ul>
</li>
</ul>
<h2 id="Violation-of-Assumptions"><a href="#Violation-of-Assumptions" class="headerlink" title="Violation of Assumptions"></a>Violation of Assumptions</h2><ul>
<li>Multicollinearity<br>If two or more variables are strongly correlated, it brings in multicollinearity problem<ul>
<li>the standard error of coefficients increases</li>
<li>It’s harder to seperate effects for correlated variables</li>
<li>Estimated coefficients are highly sensitive to whether the correlated variables exists</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 量化分析知识点 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Statistics </tag>
            
            <tag> Regression </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Edit Distance (72)]]></title>
      <url>/2016/07/13/2016-07-13-leetcode-solution-edit-distance-72/</url>
      <content type="html"><![CDATA[<p>Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)</p>
<p>You have the following 3 operations permitted on a word:</p>
<p>a) Insert a character<br>b) Delete a character<br>c) Replace a character</p>
<h3 id="解法：DP-with-O-N-2-Time-and-O-N-2-Space"><a href="#解法：DP-with-O-N-2-Time-and-O-N-2-Space" class="headerlink" title="解法：DP with O(N^2) Time and O(N^2) Space"></a>解法：DP with O(N^2) Time and O(N^2) Space</h3><p>双字符串统计min的问题，容易想到用DP解决。<br>假设dp[i][j] 表示前i个字符和前j个字符的子串，convert substr1 to substr2的minimum steps.<br>那么对于初始条件我们容易得到：</p>
<ul>
<li>dp[0][j] = j</li>
<li>dp[i][0] = i<br>这里表示的是，如果其中一个是空字符，那么你要么插入j个字符或者删除j个字符，任何一种情况都是j个操作<br>当考虑状态方程的时候，要考虑i和j两位置上的字符是否相等，分两种情况:<br>1 charAt(i) == charAt(j)<br>  当最后比较的字符相同时，有三种情况/操作可能出现<br>  1 可能最小值来自于i - 1和j - 1的匹配，<br>  2 或者是i - 1转为j的匹配，那么就要加上1表示从i字符串删除一位变为i - 1字符串的操作。<br>  3 也可能是把i匹配为j - 1的字符串，然后最后加上第j个字符(insert操作）<br>  dp[i][j] = Min(dp[i - 1][j - 1], dp[i - 1][j] + 1, dp[i][j - 1] + 1)</li>
</ul>
<p>2 charAt(i) != charAt(j)<br>    相类似于上面一种情况，唯一不同的是，dp[i - 1][j - 1]要加上1表示把第i位转化为第j位的操作<br>    dp[i][j] = Min(dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1, dp[i][j - 1] + 1）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</div><div class="line">		</div><div class="line">	<span class="comment">// input validation</span></div><div class="line">	<span class="keyword">if</span> (word1 == <span class="keyword">null</span> &amp;&amp; word2 == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (word1 == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">return</span> word2.length();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (word2 == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">return</span> word1.length();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">// DP</span></div><div class="line">	</div><div class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];</div><div class="line">	</div><div class="line">	<span class="comment">// initialize</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= word1.length(); i++) &#123;</div><div class="line">		dp[i][<span class="number">0</span>] = i;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= word2.length(); j++) &#123;</div><div class="line">		dp[<span class="number">0</span>][j] = j;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= word1.length(); i++) &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= word2.length(); j++) &#123;</div><div class="line">			<span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</div><div class="line">				<span class="comment">// make sure you get the index right, since we added 1 to the array, we need to subtract 1 </span></div><div class="line">				<span class="comment">// to get the index positions</span></div><div class="line">				dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>, Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> dp[word1.length()][word2.length()];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Dynamic programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Unique Binary Search Trees (96)]]></title>
      <url>/2016/07/13/2016-07-13-leetcode-solution-unique-binary-search-trees/</url>
      <content type="html"><![CDATA[<p>Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?</p>
<p>For example,<br>Given n = 3, there are a total of 5 unique BST’s.</p>
<h3 id="解法：DP-with-O-N-2-time-and-O-N-space"><a href="#解法：DP-with-O-N-2-time-and-O-N-space" class="headerlink" title="解法：DP with O(N^2) time and O(N) space"></a>解法：DP with O(N^2) time and O(N) space</h3><p>通常count的问题也可以考虑用dp的方法求解。由于是binary search trees,那么首先要搞清楚的是binary search tree的结构：<br>    1 root左边的所有节点一定比root小<br>    2 root右边的所有节点一定比root大<br>如果我们有N个数字可以选择，那么如果选择了一个i为root,则1 ~ （i -1)都必须在左子数，(i + 1) ~ N 都必须在右子数<br>具体每一个子数有多少unique的排列则完全取决于node的个数。<br>那么我们可以用memorization的思想，从1个node开始，存下每个node可能的排列个数，然后对每一个可能作为root的计算相应的子数的个数。对应的算法为O(N^2)的Time complexity<br>举例，如果N = 3<br>那么可以成为root的有1，2，3三个数<br>当1作为root的时候，由于他是最小值，则剩下的2个数只能排放右边，故排列数为num(2)<br>当2作为root的时候，比他小的数有一个，比他大的数有1个，分列左右两边，故排列数为num(1) * num(1)<br>当3作为root的时候，同理1，他是最大值，排列数为num(1) * num(1)<br>所以总的排列数是每个情况的相加,只要知道了num(1)和num(2)就可以求出num(3)</p>
<p>同时，这个问题也是Catalan Number的一个应用，具体可以看<a href="https://en.wikipedia.org/wiki/Catalan_number#Applications_in_combinatorics" target="_blank" rel="external">Wiki</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// If no nodes, then just an empty tree, so 1</span></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</div><div class="line">	dp[<span class="number">0</span>] = <span class="number">1</span>;	<span class="comment">// empty tree</span></div><div class="line">	dp[<span class="number">1</span>] = <span class="number">1</span>;	<span class="comment">// single node tree</span></div><div class="line">	</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</div><div class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</div><div class="line">			<span class="keyword">int</span> left = j - <span class="number">1</span>;	<span class="comment">// number of left node</span></div><div class="line">			<span class="keyword">int</span> right = i -  j;	<span class="comment">// number of right node</span></div><div class="line">			sum += dp[left] * dp[right];	<span class="comment">// multiply </span></div><div class="line">		&#125;</div><div class="line">		dp[i] = sum;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> dp[n];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Dynamic programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Maximum Product Subarray (152)]]></title>
      <url>/2016/07/13/2016-07-13-leetcode-solution-Maximum-Product-Subarray-152/</url>
      <content type="html"><![CDATA[<p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>For example, given the array [2,3,-2,4],<br>the contiguous subarray [2,3] has the largest product = 6.</p>
<h3 id="解法：DP-with-O-N-time-and-O-1-space"><a href="#解法：DP-with-O-N-time-and-O-1-space" class="headerlink" title="解法：DP with O(N) time and O(1) space"></a>解法：DP with O(N) time and O(1) space</h3><p>由于有负数的存在，有可能负负得正的情况出现，所以需要维护当前的最大值和最小值。最大值是max(A[i], min <em> A[i], max </em> A[i])<br>同时对每一个新元素要update最大值和最小值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">int</span> min = nums[<span class="number">0</span>];</div><div class="line">	<span class="keyword">int</span> max = nums[<span class="number">0</span>];</div><div class="line">	<span class="keyword">int</span> res = nums[<span class="number">0</span>];</div><div class="line">	</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</div><div class="line">		<span class="keyword">int</span> current_max = Math.max(max * nums[i], Math.max(min * nums[i], nums[i]));	</div><div class="line">		<span class="keyword">int</span> current_min = Math.min(max * nums[i], Math.max(min * nums[i], nums[i]));</div><div class="line">		res = Math.max(res, current_max);</div><div class="line">		<span class="comment">// 要注意的是max和min需要同时update,不能先update一个再update另一个，因为计算max和min的公式中用到了对方</span></div><div class="line">		max = current_max;</div><div class="line">		min = current_min;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Dynamic programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Range Sum Query - immutable (303)]]></title>
      <url>/2016/07/13/2016-07-13-leetcode-solution-range-sum-query-immutable/</url>
      <content type="html"><![CDATA[<p>Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.</p>
<p>Example:<br>Given nums = [-2, 0, 3, -5, 2, -1]</p>
<p>sumRange(0, 2) -&gt; 1<br>sumRange(2, 5) -&gt; -1<br>sumRange(0, 5) -&gt; -3<br>Note:<br>You may assume that the array does not change.<br>There are many calls to sumRange function.</p>
<h3 id="解法-Memorization-DP-with-O-1-time-and-O-N-space"><a href="#解法-Memorization-DP-with-O-1-time-and-O-N-space" class="headerlink" title="解法: Memorization/DP with O(1) time and O(N) space"></a>解法: Memorization/DP with O(1) time and O(N) space</h3><p>就是Subarray类题目的变形，求subarray sum首先要想到前缀和数组。维护一个cumulative sum,然后每次计算i到j的和的时候就是sum[j] - sum[i-1],花费时间是O(1)要注意的是下边界越界的处理。<br>dp[i] = (k - 1) * (dp[i -1] + dp[i - 2])<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">int</span>[] cumsum  = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">       <span class="comment">// calculate the cumulative sum O(N)</span></div><div class="line">	   </div><div class="line">	   <span class="comment">// exception handling</span></div><div class="line">	   <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	   cumsum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">	   cumsum[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">	   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</div><div class="line">			cumsum[i] = cumsum[i - <span class="number">1</span>] + nums[i];</div><div class="line">		&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">        <span class="comment">// Array access: O(1)</span></div><div class="line">		<span class="keyword">if</span> (cumsum == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> cumsum[j];</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> cumsum[j] - cumsum[i - <span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Your NumArray object will be instantiated and called as such:</span></div><div class="line"><span class="comment">// NumArray numArray = new NumArray(nums);</span></div><div class="line"><span class="comment">// numArray.sumRange(0, 1);</span></div><div class="line"><span class="comment">// numArray.sumRange(1, 2);</span></div><div class="line">	</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Dynamic programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Paint Fence (276)]]></title>
      <url>/2016/07/13/2016-07-13-leetcode-solution-Paint-Fence-276/</url>
      <content type="html"><![CDATA[<p>There is a fence with n posts, each post can be painted with one of the k colors.<br>You have to paint all the posts such that no more than two adjacent fence posts have the same color.<br>Return the total number of ways you can paint the fence.</p>
<h3 id="解法1-DP-with-O-N-time-and-O-1-space"><a href="#解法1-DP-with-O-N-time-and-O-1-space" class="headerlink" title="解法1: DP with O(N) time and O(1) space"></a>解法1: DP with O(N) time and O(1) space</h3><p>经典DP, dp[i]表示第i根柱子可能paint的方法数量。考虑三根柱子，如果第i根柱子和第i - 1根一样，那么一定和第i-2根不一样，所以这种情况有k - 1个颜色可选。同理，如果i和第i -2根一样，<br>那必然和第i - 1根不一样，也是k - 1种颜色可选。<br>dp[i] = (k - 1) * (dp[i -1] + dp[i - 2])</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// If no fence exists, there is no way to paint it.</span></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">// Corner case </span></div><div class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</div><div class="line">		<span class="keyword">return</span> k;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;k, k * k, k * k&#125;; <span class="comment">// initial value of dp[2] is set to be equal to dp[1]. </span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</div><div class="line">		dp[<span class="number">2</span>] = (k - <span class="number">1</span>) * (dp[<span class="number">0</span>] + dp[<span class="number">1</span>]);</div><div class="line">		dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</div><div class="line">		dp[<span class="number">1</span>] = dp[<span class="number">2</span>];</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> dp[<span class="number">2</span>];</div><div class="line">        </div><div class="line">&#125;</div><div class="line">	</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Dynamic programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: House Robber(198)]]></title>
      <url>/2016/07/13/2016-07-13-leetcode-solution-house-robber/</url>
      <content type="html"><![CDATA[<p>You are a professional robber planning to rob houses along a street.<br>Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<h3 id="解法1-DP-with-O-N-time-and-O-N-space"><a href="#解法1-DP-with-O-N-time-and-O-N-space" class="headerlink" title="解法1: DP with O(N) time and O(N) space"></a>解法1: DP with O(N) time and O(N) space</h3><p>应该考虑到是经典的DP问题，要求一个最大的解。那么首先dp数组的含义是dp[i]代表前i个房子能取得的最大值，<br>考虑第i个房子，如果抢第i个房子，那么第i-1个房子一定不能取，所以最大的值是dp[i - 2] + A[i]<br>如果不抢第i个房子，那么最大的值就是前一个房子能取得的最大值，状态方程dp[i] = max(dp[i - 1], dp[i - 2] + A[i])。<br>这种考虑第i个数字取或者不取得思路在其他dp问题中也经常见到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</div><div class="line">		<span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">// initialize</span></div><div class="line">	<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">	dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">	dp[<span class="number">1</span>] = Math.max(dp[<span class="number">0</span>], nums[<span class="number">1</span>]);</div><div class="line">	</div><div class="line">	<span class="comment">// dp transition</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++) &#123;</div><div class="line">		dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="解法1优化-DP-with-O-N-time-and-O-1-space"><a href="#解法1优化-DP-with-O-N-time-and-O-1-space" class="headerlink" title="解法1优化: DP with O(N) time and O(1) space"></a>解法1优化: DP with O(N) time and O(1) space</h3><p>实际上观察状态方程可以发现，我们只需要记录dp[i - 2], dp[i -1]两个数值，所以可以维护一个数组{A,B,C},前两个数字作为buffer，不停更新三个数字。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</div><div class="line">		<span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">// initialize</span></div><div class="line">	<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[<span class="number">0</span>], Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]), Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])&#125;;</div><div class="line">	</div><div class="line">	<span class="comment">// dp transition</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++) &#123;</div><div class="line">		dp[<span class="number">2</span>] = Math.max(dp[<span class="number">1</span>], dp[<span class="number">0</span>] + nums[i]);</div><div class="line">		dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</div><div class="line">		dp[<span class="number">1</span>] = dp[<span class="number">2</span>];</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> dp[<span class="number">2</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Dynamic programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Best time to buy and sell stock IV (188)]]></title>
      <url>/2016/07/08/2016-07-08-leetcode-note-Best-time-to-buy-and-sell-stock-IV/</url>
      <content type="html"><![CDATA[<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most k transactions.</p>
<p>Note:<br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法:"></a>解法:</h3><p>比较难想清楚的一题。<br>需要用到两个dp matrix, 一个叫local, 一个叫global<br>local[i][j] 表示的是前i天做j次操作，最后一次sell正好是i天时的最大利润<br>global[i][j]表示的是前i天做j次操作，最大的利润<br>那么答案就是global[N][k]<br>local的递推关系是：<br>local[i][j]可以是i-1天已经完成了j次交易，那么只要把最后一天的交易顺延，就得到了i天完成j次交易。另外一个可能是到i - 1天完成了j - 1次交易，那么只要再加上新加的一天的交易即可。<br>global的递推关系是：<br>global[i][j]是要么新一天的local maxi, 或者是前一天的global max<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> n = prices.length;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (k &gt; n) &#123;</div><div class="line">            <span class="keyword">return</span> maxProfit_naive(prices);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[][] global = <span class="keyword">new</span> <span class="keyword">int</span>[n][k + <span class="number">1</span>];</div><div class="line">        <span class="keyword">int</span>[][] local = <span class="keyword">new</span> <span class="keyword">int</span>[n][k + <span class="number">1</span>];</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</div><div class="line">            <span class="keyword">int</span> diff = prices[i] - prices[i - <span class="number">1</span>];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</div><div class="line">                local[i][j] = Math.max(global[i - <span class="number">1</span>][j - <span class="number">1</span>] + diff, local[i - <span class="number">1</span>][j] + diff);</div><div class="line">                global[i][j] = Math.max(local[i][j], global[i -<span class="number">1</span>][j]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> global[n - <span class="number">1</span>][k];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxProfit_naive</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</div><div class="line">                sum += prices[i] - prices[i - <span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Dynamic programming </tag>
            
            <tag> Java </tag>
            
            <tag> 局部最优和全局最优 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: best time to buy and sell stock III (123)]]></title>
      <url>/2016/07/08/2016-07-08-leetcode-note-best-time-to-buy-and-sell-stock-III/</url>
      <content type="html"><![CDATA[<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p>
<p>Note:<br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<h3 id="解法1：-Divide-amp-Conquer-O-N-2-Time-O-N-Space"><a href="#解法1：-Divide-amp-Conquer-O-N-2-Time-O-N-Space" class="headerlink" title="解法1： Divide &amp; Conquer O(N^2) Time + O(N) Space"></a>解法1： Divide &amp; Conquer O(N^2) Time + O(N) Space</h3><p>思路是利用I的解题方法，对于一个(i,j)范围的数组，可以用O(N)的时间和O(1)的空间算出最大的利润<br>那么可以将原数组分割为(0,i) + (i,length - 1)的两个数组，分别计算每个范围内的最大利润再相加。<br>一共有N种分割方法，所以总的时间复杂度是O(N^2)<br>这个解法lintcode可以AC,leetcode会TLE，所以需要改进这个解法，最好的是O(N) Time<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</div><div class="line">		<span class="keyword">int</span> left = maxSingleTransition(prices, <span class="number">0</span>, i);</div><div class="line">		<span class="keyword">int</span> right = maxSingleTransition(prices, i, prices.length - <span class="number">1</span>);</div><div class="line">		<span class="keyword">int</span> sum = left + right;</div><div class="line">		res = Math.max(res, sum);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxSingleTransition</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">int</span> min = prices[start];</div><div class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</div><div class="line">		res = Math.max(res, prices[i] - min);</div><div class="line">		min = Math.min(min, prices[i]);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法2：两次DP，O-N-Time-O-N-Space"><a href="#解法2：两次DP，O-N-Time-O-N-Space" class="headerlink" title="解法2：两次DP，O(N) Time + O(N) Space"></a>解法2：两次DP，O(N) Time + O(N) Space</h3><p>思路还是类似于第一种解法，但是做了优化。计算(0,i)的时候实际可以运用(0,i-1)的结果。同样，计算(i,length - 1)的时候可以<br>运用(i+1,length - 1)的结果。这就引出了用两个dp数组先记录下每一个区间的最大收益，然后再扫描一遍得到左右两个区间和的最大值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</div><div class="line">	<span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</div><div class="line">	</div><div class="line">	<span class="comment">// Scan from left</span></div><div class="line">	<span class="keyword">int</span> min = prices[<span class="number">0</span>];</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</div><div class="line">		left[i] = Math.max(left[i - <span class="number">1</span>], prices[i] - min);</div><div class="line">		min = Math.min(min, prices[i]);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">// Scan from right</span></div><div class="line">	<span class="keyword">int</span> max = prices[prices.length - <span class="number">1</span>];</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = prices.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">		right[i] = Math.max(right[i + <span class="number">1</span>], max - prices[i]);</div><div class="line">		max = Math.max(max, prices[i]);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">// search for the largest sum</span></div><div class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</div><div class="line">		res = Math.max(res, left[i] + right[i]);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Dynamic programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Best time to buy and sell stock II （122）]]></title>
      <url>/2016/07/08/2016-07-08-leetcode-note-best-time-to-buy-and-sell-stock-II/</url>
      <content type="html"><![CDATA[<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like<br>(ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time<br>(ie, you must sell the stock before you buy again).</p>
<h3 id="解法1：O-N"><a href="#解法1：O-N" class="headerlink" title="解法1：O(N)"></a>解法1：O(N)</h3><p>既然是可以交易任意多次，只要price[i] &gt; price[i - 1]我们就认为是一次合格的交易，<br>那么最大的profit一定是所有positive profit的和。只要扫描一遍求出所有正差值的和即为答案<br>这是一种greedy的思路。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">int</span> profit = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</div><div class="line">		<span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</div><div class="line">			profit += prices[i] - prices[i - <span class="number">1</span>];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> profit;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Best Time to Buy and Sell Stock （121)]]></title>
      <url>/2016/07/07/2016-07-07-leetcode-solution-Best-Time-to-Buy-and-Sell-Stock/</url>
      <content type="html"><![CDATA[<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>Example 1:<br>Input: [7, 1, 5, 3, 6, 4]<br>Output: 5</p>
<p>max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)<br>Example 2:<br>Input: [7, 6, 4, 3, 1]<br>Output: 0</p>
<p>In this case, no transaction is done, i.e. max profit = 0.</p>
<h3 id="解法1：DP-with-O-N-空间"><a href="#解法1：DP-with-O-N-空间" class="headerlink" title="解法1：DP with O(N) 空间"></a>解法1：DP with O(N) 空间</h3><p>从左往右维护一个最小的price,那么转换方程就可以写成dp[i] = Math.max(dp[i - 1], price[i] - min),<br>其中dp[i]表示的是前i个数中如果只能交易一次的最大利润，不一定要以i结尾。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">int</span>[] profit = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</div><div class="line">	<span class="keyword">int</span> min = prices[<span class="number">0</span>];</div><div class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</div><div class="line">		profit[i] = Math.max(profit[i - <span class="number">1</span>], prices[i] - min);</div><div class="line">		min = Math.min(min, prices[i]);</div><div class="line">		res = Math.max(res, profit[i]);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法2：DP-with-O-1-空间"><a href="#解法2：DP-with-O-1-空间" class="headerlink" title="解法2：DP with O(1) 空间"></a>解法2：DP with O(1) 空间</h3><p>从左往右维护当前的最小值，并且计算每一个累积和和最小值的差，取最大的作为结果.<br>这题用DP的思路是dp[i] = max(dp[i - 1], A[i] - min)， 所以就是也要维护一个min，实际上并不需要维护dp数组，只要不停更新min就可以了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">int</span> minPrice = prices[<span class="number">0</span>]; </div><div class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</div><div class="line">		res = Math.max(prices[i] - minPrice, res);</div><div class="line">		minPrice = Math.min(minPrice, prices[i]);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Dynamic programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode解题: Maximum Subarray (53)]]></title>
      <url>/2016/07/07/2016-07-07-leetcode-solution-Maximum-Subarray/</url>
      <content type="html"><![CDATA[<p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array [−2,1,−3,4,−1,2,1,−5,4],<br>the contiguous subarray [4,−1,2,1] has the largest sum = 6.<br><a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="external">Practice</a></p>
<h3 id="解法1：DP-with-O-N-空间"><a href="#解法1：DP-with-O-N-空间" class="headerlink" title="解法1：DP with O(N) 空间"></a>解法1：DP with O(N) 空间</h3><p>用经典的DP思想可以解决，dp数组存的是以i结尾的前i个数字的max subarray，那么可以得到这样的递推关系<br>dp[i] = Max(dp[i - 1] + A[i], A[i])<br>意思就是说以i结尾的最大的子数组和要么是自己，要么是前一个子数组和加上自己。可以写出如下的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">	dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">	<span class="keyword">int</span> max = dp[<span class="number">0</span>];</div><div class="line">	</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</div><div class="line">		dp[i] = Math.max(nums[i], dp[i - <span class="number">1</span>] + nums[i]);</div><div class="line">		max = Math.max(dp[i], max);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> max;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法1优化-DP-with-O-1-空间"><a href="#解法1优化-DP-with-O-1-空间" class="headerlink" title="解法1优化: DP with O(1) 空间"></a>解法1优化: DP with O(1) 空间</h3><p>观察上面的解法可以发现，实际上我们不需要维护一个数组来记录每一个点的最大和。<br>我们可以只维护一个变量sum,来记录从0到i的和。如果sum一旦小于0，那么对下一个dp数值的计算一定用不上sum,所以此时可以设置为0. 代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">		sum += nums[i];</div><div class="line">		max = Math.max(sum, max);</div><div class="line">		<span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</div><div class="line">			sum = <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">	<span class="keyword">return</span> max;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法2-前缀和数组的思路，O-N-time-O-1-space"><a href="#解法2-前缀和数组的思路，O-N-time-O-1-space" class="headerlink" title="解法2: 前缀和数组的思路，O(N) time + O(1) space"></a>解法2: 前缀和数组的思路，O(N) time + O(1) space</h3><p>基本思想是：如果把数组中每一个元素都加起来，我们可以得到一个累积的和，那么这个问题实际上就变成了<br>best time to buy and sell stock I的问题，从左至右寻找最小的mininum sum,然后将当前的sum和minSum相减再和全局的最大值比较得出结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">int</span> min = <span class="number">0</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">int</span> profit = nums[<span class="number">0</span>];</div><div class="line">	</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">		profit = Math.max(sum + nums[i] - min, profit);</div><div class="line">		sum += nums[i];</div><div class="line">		min = Math.min(sum, min);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> profit;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="解法3：用Divide-amp-Conquer思想：O-NlogN"><a href="#解法3：用Divide-amp-Conquer思想：O-NlogN" class="headerlink" title="解法3：用Divide &amp; Conquer思想：O(NlogN)"></a>解法3：用Divide &amp; Conquer思想：O(NlogN)</h3><p>具体的思路是把原来的array一分为二，那么最大的子数组和一定是在1.左面的数组，2.右面的数组，3.跨越左面和右面的数组<br>左面和右面用递归的方式计算。跨越中点的数组一定包含mid point,往右面扫描找出最大的，往左面扫描找出最大的，最后比较三个数得出结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (left &gt;= right) &#123;</div><div class="line">		<span class="keyword">return</span> A[left];</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">// Divide into left and right array</span></div><div class="line">	<span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</div><div class="line">	<span class="keyword">int</span> lmax = helper(A, left, mid - <span class="number">1</span>);</div><div class="line">	<span class="keyword">int</span> rmax = helper(A, mid + <span class="number">1</span>, right);</div><div class="line">	</div><div class="line">	<span class="comment">// Merge and Conquer</span></div><div class="line">	<span class="keyword">int</span> mmax = A[mid];</div><div class="line">	<span class="keyword">int</span> temp = mmax;</div><div class="line">	<span class="comment">// Scan to left</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = mid - <span class="number">1</span>; i &gt;= left; i--) &#123;</div><div class="line">		temp += A[i];</div><div class="line">		mmax = Math.max(mmax, temp);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">// Scan to right</span></div><div class="line">	temp = mmax;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= right; i++) &#123;</div><div class="line">		temp += A[i];</div><div class="line">		mmax = Math.max(mmax, temp);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> Math.max(mmax, Math.max(lmax, rmax));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 刷题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Dynamic programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用Hexo搭blog系统]]></title>
      <url>/2016/04/11/2016-04-11-Blogging-with-Hexo/</url>
      <content type="html"><![CDATA[<p>在看一个技术博客的时候无意间发现了博主使用的这个开源项目<strong>Hexo</strong>，它是一个基于Node.js的快速搭建blog的框架。<br>觉得很好就拿来搭了现在的这个大提摩，搭建这个Hexo需要的步骤非常简单。</p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>安装Hexo之前需要确保已经安装了Node.js和Git。安装Hexo时就可以按照官网执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo-cli</div></pre></td></tr></table></figure></p>
<h3 id="Deployer"><a href="#Deployer" class="headerlink" title="Deployer"></a>Deployer</h3><p>如果部署到github需要一个deployer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>
<h3 id="大道至简的Theme"><a href="#大道至简的Theme" class="headerlink" title="大道至简的Theme"></a>大道至简的Theme</h3><p>我用的这个主题是一个博主fork过来专门用于Hexo的，个人觉得简单干净大气。安装也很简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant</div><div class="line">$ npm install hexo-renderer-jade --save</div><div class="line">$ npm install hexo-renderer-sass --save</div></pre></td></tr></table></figure><br>要注意的是这个安装方法中jade已经改名成pug了，不过对我们使用这个theme好像问题也不大。</p>
<p>其他反面，等慢慢体验多了有什么想记一笔的再写上来。</p>
<h3 id="写博客和发布"><a href="#写博客和发布" class="headerlink" title="写博客和发布"></a>写博客和发布</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new post &quot;post-name&quot;</div></pre></td></tr></table></figure>
<h4 id="编辑分类-category"><a href="#编辑分类-category" class="headerlink" title="编辑分类(category)"></a>编辑分类(category)</h4><p>直接打开post文件，按照如下的格式修改即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: 显示的post的名字</div><div class="line">date: 2016-04-11 14:12:26</div><div class="line">category:</div><div class="line">- 技术总结</div><div class="line">- 在这里列举分类</div><div class="line">tags:</div><div class="line">- Hexo</div><div class="line">- 用这个方法加入tags</div><div class="line">---</div></pre></td></tr></table></figure></p>
<h4 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo generate --deploy</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 技术总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小提摩的大理想]]></title>
      <url>/2016/04/11/2016-04-11-My-first-blog/</url>
      <content type="html"><![CDATA[<p>总是感觉自己想学的和已经学得东西都很多，却零零散散，开了这个blog，想整理一些自己的资料。在这里我会总结或者分享一些技术相关的文章，工作学习生活体会，还有投资理财，量化交易的心得等等。不务正业的时候也会分享一些自家的深夜料理，以小餐日料和中国家常菜为主，偶尔会有黑暗料理乱入。</p>
]]></content>
      
        
    </entry>
    
  
  
</search>
